<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN">
<front>
<journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, USA</publisher-loc></publisher></journal-meta>
<article-meta><article-id pub-id-type="publisher-id">09-PLCB-RA-0181R3</article-id><article-id pub-id-type="doi">10.1371/journal.pcbi.1000502</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline"><subject>Computational Biology</subject><subject>Computational Biology/Genomics</subject><subject>Genetics and Genomics/Bioinformatics</subject></subj-group></article-categories><title-group><article-title>Fast Mapping of Short Sequences with Mismatches, Insertions and Deletions Using Index Structures</article-title><alt-title alt-title-type="running-head">Short Read Mapping with Gaps</alt-title></title-group><contrib-group>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Hoffmann</surname><given-names>Steve</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Otto</surname><given-names>Christian</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Kurtz</surname><given-names>Stefan</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Sharma</surname><given-names>Cynthia M.</given-names></name><xref ref-type="aff" rid="aff4"><sup>4</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Khaitovich</surname><given-names>Philipp</given-names></name><xref ref-type="aff" rid="aff9"><sup>9</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Vogel</surname><given-names>Jörg</given-names></name><xref ref-type="aff" rid="aff4"><sup>4</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Stadler</surname><given-names>Peter F.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff5"><sup>5</sup></xref><xref ref-type="aff" rid="aff6"><sup>6</sup></xref><xref ref-type="aff" rid="aff7"><sup>7</sup></xref><xref ref-type="aff" rid="aff8"><sup>8</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Hackermüller</surname><given-names>Jörg</given-names></name><xref ref-type="aff" rid="aff5"><sup>5</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib>
</contrib-group><aff id="aff1"><label>1</label><addr-line>Bioinformatics Group, Department of Computer Science, University of Leipzig, Leipzig, Germany</addr-line>       </aff><aff id="aff2"><label>2</label><addr-line>Interdisciplinary Center for Bioinformatics, University of Leipzig, Leipzig, Germany</addr-line>       </aff><aff id="aff3"><label>3</label><addr-line>Center for Bioinformatics, University of Hamburg, Hamburg, Germany</addr-line>       </aff><aff id="aff4"><label>4</label><addr-line>Max Planck Institute for Infection Biology, Berlin, Germany</addr-line>       </aff><aff id="aff5"><label>5</label><addr-line>RNomics Group, Fraunhofer Institute for Cell Therapy and Immunology IZI, Leipzig, Germany</addr-line>       </aff><aff id="aff6"><label>6</label><addr-line>Santa Fe Institute, Santa Fe, New Mexico, United States of America</addr-line>       </aff><aff id="aff7"><label>7</label><addr-line>Department of Theoretical Chemistry, University of Vienna, Vienna, Austria</addr-line>       </aff><aff id="aff8"><label>8</label><addr-line>Max-Planck-Institute for Mathematics in Sciences, Leipzig, Germany</addr-line>       </aff><aff id="aff9"><label>9</label><addr-line>Comparative Biology Group, Partner-Institute for Computational Biology, Shanghai, China</addr-line>       </aff><contrib-group>
<contrib contrib-type="editor" xlink:type="simple"><name name-style="western"><surname>Searls</surname><given-names>David B.</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/></contrib>
</contrib-group><aff id="edit1">Philadelphia, United States of America</aff><author-notes>
<corresp id="cor1">* E-mail: <email xlink:type="simple">joerg.hackermueller@izi.fraunhofer.de</email></corresp>
<fn fn-type="con"><p>Conceived and designed the experiments: SH SK PK JV PFS JH. Performed the experiments: SH CO CMS. Analyzed the data: SH CO CMS PK PFS JH. Contributed reagents/materials/analysis tools: SH SK PK JV PFS. Wrote the paper: SH.</p></fn>
<fn fn-type="conflict"><p>The authors have declared that no competing interests exist.</p></fn></author-notes><pub-date pub-type="collection"><month>9</month><year>2009</year></pub-date><pub-date pub-type="epub"><day>11</day><month>9</month><year>2009</year></pub-date><volume>5</volume><issue>9</issue><elocation-id>e1000502</elocation-id><history>
<date date-type="received"><day>19</day><month>2</month><year>2009</year></date>
<date date-type="accepted"><day>7</day><month>8</month><year>2009</year></date>
</history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2009</copyright-year><copyright-holder>Hoffmann et al</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract>
<p>With few exceptions, current methods for short read mapping make use of simple seed heuristics to speed up the search. Most of the underlying matching models neglect the necessity to allow not only mismatches, but also insertions and deletions. Current evaluations indicate, however, that very different error models apply to the novel high-throughput sequencing methods. While the most frequent error-type in Illumina reads are mismatches, reads produced by 454's GS FLX predominantly contain insertions and deletions (indels). Even though 454 sequencers are able to produce longer reads, the method is frequently applied to small RNA (miRNA and siRNA) sequencing. Fast and accurate matching in particular of short reads with diverse errors is therefore a pressing practical problem. We introduce a matching model for short reads that can, besides mismatches, also cope with indels. It addresses different error models. For example, it can handle the problem of leading and trailing contaminations caused by primers and poly-A tails in transcriptomics or the length-dependent increase of error rates. In these contexts, it thus simplifies the tedious and error-prone trimming step. For efficient searches, our method utilizes index structures in the form of enhanced suffix arrays. In a comparison with current methods for short read mapping, the presented approach shows significantly increased performance not only for 454 reads, but also for Illumina reads. Our approach is implemented in the software <monospace>segemehl</monospace> available at <ext-link ext-link-type="uri" xlink:href="http://www.bioinf.uni-leipzig.de/Software/segemehl/" xlink:type="simple">http://www.bioinf.uni-leipzig.de/Software/segemehl/</ext-link>.</p>
</abstract><abstract abstract-type="summary"><title>Author Summary</title>
<p>The successful mapping of high-throughput sequencing (HTS) reads to reference genomes largely depends on the accuracy of both the sequencing technologies and reference genomes. Current mapping algorithms focus on mapping with mismatches but largely neglect insertions and deletions—regardless of whether they are caused by sequencing errors or genomic variation. Furthermore, trailing contaminations by primers and declining read qualities can be cumbersome for programs that allow a maximum number of mismatches. We have developed and implemented a new approach for short read mapping that, in a first step, computes exact matches of the read and the reference genome. The exact matches are then modified by a limited number of mismatches, insertions and deletions. From the set of exact and inexact matches, we select those with minimum score-based E-values. This gives a set of regions in the reference genome which is aligned to the read using Myers bitvector algorithm <xref ref-type="bibr" rid="pcbi.1000502-Myers1">[1]</xref>. Our method utilizes enhanced suffix arrays <xref ref-type="bibr" rid="pcbi.1000502-Abouelhoda1">[2]</xref> to quickly find the exact and inexact matches. It maps more reads and achieves higher recall rates than previous methods. This consistently holds for reads produced by 454 as well as Illumina sequencing technologies.</p>
</abstract><funding-group><funding-statement>This work has been supported in part by the European Framework Program 6 Project SYNLET (EC contract number 043312), a formel.1 grant by the Medical Faculty, University of Leipzig (<ext-link ext-link-type="uri" xlink:href="http://www.med.uni-leipzig.de" xlink:type="simple">http://www.med.uni-leipzig.de</ext-link>), and the Leipzig Interdisciplinary Research Cluster of Genetic Factors, Clinical Phenotypes and Environment (LIFE) funded by the State of Saxony (<ext-link ext-link-type="uri" xlink:href="http://www.life.uni-leipzig.de" xlink:type="simple">http://www.life.uni-leipzig.de</ext-link>). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts><page-count count="10"/></counts></article-meta>
</front>
<body><sec id="s1">
<title>Introduction</title>
<p>Since the 454 pyrosequencing technology <xref ref-type="bibr" rid="pcbi.1000502-Rothberg1">[3]</xref> has been introduced to the market, the need for algorithms that efficiently map huge amounts of reads to reference genomes has rapidly increased. Later, high throughput sequencing (HTS) methods such as Illumina <xref ref-type="bibr" rid="pcbi.1000502-Bennett1">[4]</xref> and SOLiD (Applied Biosystems) have intensified the demand. The development of read mapping methods decisively depends on specifications and error models of the respective technologies. Unfortunately, little is known about specific error models, and models are likely to change as manufactures are constantly modifying chemistry and machinery. Increasing the read length is a key aim of all vendors — tolerating a trade-off with read accuracy. In a recent investigation on error models of 454 and Illumina technologies, it has been shown that 454 reads are more likely to include insertions and deletions while Illumina reads typically contain mismatches <xref ref-type="bibr" rid="pcbi.1000502-Huse1">[5]</xref>,<xref ref-type="bibr" rid="pcbi.1000502-Dohm1">[6]</xref>. Currently available read mapping programs are specifically designed to allow for mismatches when aligning the reads to the reference genome. Most of the programs, e.g. <monospace>MAQ</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Li1">[7]</xref>, <monospace>SOAP</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Li2">[8]</xref>, <monospace>SHRiMP</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Rumble1">[9]</xref> or <monospace>ELAND</monospace> (proprietary), use seeding techniques that gain their speed from pre-computed hash look-up tables. Some of these programs, in particular <monospace>SOAP</monospace> and <monospace>MAQ</monospace>, are specifically designed to map short Illumina or SOLiD reads. Longer sequences cannot be mapped by these tools. The matching models of <monospace>MAQ</monospace>, <monospace>ZOOM</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Lin1">[10]</xref>, <monospace>SOAP</monospace>, <monospace>SHRiMP</monospace>, <monospace>Bowtie</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Langmead1">[11]</xref>, and <monospace>ELAND</monospace> focus on mismatches and largely neglect insertions and deletions. Indels are only considered during subsequent alignment steps but not while searching for seeds. With indels accounting for more than two thirds of all 454 sequencing errors, this is a major shortcoming for these kinds of reads <xref ref-type="bibr" rid="pcbi.1000502-Huse1">[5]</xref>. Only <monospace>PatMaN</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Prfer1">[12]</xref> and <monospace>BWA</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Li3">[13]</xref> are able to handle a limited number of indels.</p>
<p>Mapping is aggravated by the manufacturers' overestimation of their read accuracies. While an overall error rate of 0.5% has been observed for 454, the error rate increases drastically for reads shorter than 80 bp and longer than 100 bp <xref ref-type="bibr" rid="pcbi.1000502-Huse1">[5]</xref>, leading to considerably larger error frequencies in real-life datasets. This implies that, sequencing projects aiming to find short transcripts such as miRNAs lose a substantial fraction of their data, unless a matching strategy is used that takes indels into account. In Illumina reads, error rates of up to 4% have been observed <xref ref-type="bibr" rid="pcbi.1000502-Dohm1">[6]</xref>. This differs significantly from Illumina's specification. Compared to 454, the frequency of indels is significantly lower. Moreover, differences between reads and reference genome might also occur due to genomic variations such as SNPs. We present a matching method that uses enhanced suffix arrays to compute exact and inexact seeds. Sufficiently good seeds subsequently trigger a full dynamic programming alignment. Our method is insensitive to errors and contaminations at the ends of a read including 3′ and 5′ primers and tags. The <xref ref-type="sec" rid="s2">results</xref> section describes the basic ideas and an evaluation of our <monospace>segemehl</monospace> software implementing our method. The technical details of the matching model are described in the Methods section at the end of this contribution.</p>
</sec><sec id="s2">
<title>Results</title>
<sec id="s2a">
<title>Outline of the Algorithmic Approach</title>
<p>A read aligner should deliver the original position of the read in the reference genome. Such a position will be called the <italic>true position</italic> in the following. Optimally scoring local alignments of the read and the reference genome can be used to obtain a possible true position, but because an alignment of the read with the reference genome at the true position does not always have an optimal score according to the chosen scoring scheme, this method does not always work. Nevertheless, there are no better approaches available unless further information about the read is at hand.</p>
<p>We present a new read mapping approach that aims at finding optimally scoring local alignments of a read and the reference genome. It is based on computing inexact seeds of variable length and allows to handle insertions, deletions (indels; gaps), and mismatches. Throughout the document the notion of differences refers to mismatches, insertions and deletions in some local alignment of the read and the reference genome, irrespective of whether they arise from technical artifacts or sequence variation. A single difference is either a single mismatch, a single character insertion or a single character deletion. Although not limited to a specific scoring scheme, we have implemented our seed search model in the program <monospace>segemehl</monospace> assigning a score of 1 to each match and a score of −1 to each mismatch, insertion or deletion. Our matching strategy derives from a simple and commonly used idea. Assume an optimally scoring local alignment of a read with the reference genome with exactly two differences. If the positions of the differences in the alignment are sufficiently far apart, we can efficiently locate exact seeds which in turn may deliver the position of the optimal local alignment in the reference genome. Likewise, if the distance between the two differences is small, two continuous exact matches at the ends of the read possibly allow to map the read to this position. To exploit this observation, the presented method employs a heuristic based on searches starting at all positions of the read. That is, for each suffix of the read the longest prefix match, i.e. the longest exact match beginning at the first position of the suffix with all substrings of the reference genome is computed. If the longest prefix match is long enough that it only occurs in a few positions of the reference genome, it may be feasible to check all these positions to verify if the longest prefix match is part of a sufficiently good alignment. While this approach works already well for many cases, we need to increase the sensitivity for cases where the computation of the longest prefix match fails to deliver a match at the position of the optimally scoring local alignment. This is the case when a longer prefix match can be obtained at another position of the reference genome by exactly matching characters that would result in a mismatch, insertion or deletion in the optimal local alignment (cf. <xref ref-type="fig" rid="pcbi-1000502-g001">Fig. 1</xref>). Therefore, during the computation of each longest prefix match we check a limited number of differences by enumerating at certain positions all possible mismatches and indels (cf. <xref ref-type="fig" rid="pcbi-1000502-g002">Fig. 2</xref>).</p>
<fig id="pcbi-1000502-g001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g001</object-id><label>Figure 1</label><caption>
<title>Longest prefix matches may fail to deliver the position of the optimally scoring local alignment.</title>
<p>Assume a simple scoring scheme that assigns a score of +1 to a single character match and a score of 0 to a single character mismatch, a single insertions or deletion. Using longest prefix matches bears the risk of ignoring differences in the best, i.e. optimally scoring, local alignment. Its retrieval fails if a longer match can be obtained at another position of the reference sequence by matching a character, that is inserted, deleted, or mismatched in the best local alignment. Depending on the length of the reference genome and its nucleotide composition the probability is determined by the length of the substring that can be matched to the position of the best local alignment before the first difference occurs. (A) The optimally scoring alignment of the read <italic>P</italic>: = cttcttcggc begins at position 3 of the reference genome <italic>S</italic>: = atacttcttcggcaga. Let <italic>P<sub>i</sub></italic> denote the <italic>i<sup>th</sup></italic> suffix of the read <italic>P</italic>. For each <italic>P<sub>i</sub></italic>, the starting positions of the longest match in <italic>S</italic> comprise the position of <italic>P<sub>i</sub></italic> in the best local alignment (solid green lines). That is, the longest match of <italic>P</italic><sub>0</sub> begins at position 3, the longest match of <italic>P</italic><sub>1</sub> begins at position 4, the longest match of <italic>P</italic><sub>2</sub> begins at position 5 and so forth. (B) For the read <italic>P</italic>: = cttc<underline>g</underline>tcggc, the retrieval of the best local alignment fails for all <italic>P<sub>i</sub></italic>, <italic>i</italic>&lt;5 (dashed red line) due to the inclusion of a character that results in a mismatch in the optimally scoring local alignment. (C) The read <italic>P</italic>: = cttct<underline>g</underline>cggc contains, with respect to the best local alignment, a mismatch at position 5 of the read. Here the position 5 of the read is not included in the longest prefix match and nearly all substrings align correctly to the reference genome.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g001" xlink:type="simple"/></fig><fig id="pcbi-1000502-g002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g002</object-id><label>Figure 2</label><caption>
<title>Matching stems and matching branches.</title>
<p>We give an explanation based on a suffix trie which is equivalent to the suffix interval tree shown in <xref ref-type="fig" rid="pcbi-1000502-g005">Fig. 5</xref> (see <xref ref-type="sec" rid="s4">Methods</xref>). The suffix trie for <italic>S</italic>$ with <italic>S</italic>: = acttcttcggc (left) holds twelve leaves. Each numbered leaf corresponds to exactly one suffix in <italic>S</italic>. Nodes with only one child are not explicitly shown. Note, that internal nodes implicitly represent all leafs in their respective subtree. Thus, internal nodes can be regarded as sets of suffixes. The right panel holds the longest matches for different matching paths in the trie. Matching the first three suffixes of the read <italic>P</italic>: = cgtcggc results in three different paths in the suffix trie. Each path is equivalent to a sequence of suffix intervals, a matching stem, in the enhanced suffix array. Let <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e001" xlink:type="simple"/></inline-formula> denote the matching stem for <italic>P<sub>i</sub></italic> = <italic>i<sup>th</sup></italic> suffix of <italic>P</italic>. The <italic>q<sup>th</sup></italic> interval in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e002" xlink:type="simple"/></inline-formula>, denoted by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e003" xlink:type="simple"/></inline-formula>, implicitly represents the set of suffixes in <italic>S</italic> matching <italic>P</italic>[<italic>i</italic>‥<italic>i</italic>+<italic>q</italic>−1]. The path for the first suffix <italic>P</italic><sub>0</sub> is of length two (green solid line). Hence, the equivalent matching stem <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e004" xlink:type="simple"/></inline-formula> is a sequence of three intervals: <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e005" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e006" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e007" xlink:type="simple"/></inline-formula>. Since <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e008" xlink:type="simple"/></inline-formula> only represents the suffix <italic>S</italic><sub>7</sub>, the longest prefix match of <italic>P</italic><sub>0</sub> is of length 2 occurring at position 7 of the reference sequence (right panel). The matching stem <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e009" xlink:type="simple"/></inline-formula> for <italic>P</italic><sub>1</sub> (red solid line) ends with <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e010" xlink:type="simple"/></inline-formula>. Therefore, matches of length one occur at positions 8 and 9 in <italic>S</italic>. The longest prefix match for <italic>P</italic><sub>3</sub> occurs at position 6 of <italic>S</italic> (dashed orange line). Note, that the intervals <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e011" xlink:type="simple"/></inline-formula> of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e012" xlink:type="simple"/></inline-formula> equivalently represent <italic>S</italic><sub>6</sub>. An alternative path leads to a match with position 4. The branch <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e013" xlink:type="simple"/></inline-formula> denotes the alternative that accepts the mismatch of <italic>g</italic> and <italic>t</italic> at position 1 of <italic>P</italic><sub>0</sub>.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g002" xlink:type="simple"/></fig>
<p>To efficiently compute the longest prefix matches, we exploit their properties for two consecutive suffixes of a read, i.e. for two suffixes starting at position <italic>i</italic> and <italic>i</italic>+1. If the suffix starting at position <italic>i</italic> has a longest prefix match of length <italic>ℓ</italic>, <italic>then the suffix starting at position i+1 has a longest prefix match of length at least </italic><italic>ℓ</italic>−1. For example, assume a read ACTGACTG. If the second suffix has a longest prefix match of length 4, i.e. CTGA, with the reference genome, we immediately see that the third suffix has a longest prefix match not shorter than 3—because we already know that the substring TGA exists in the reference genome. Using an enhanced suffix array of the reference sequence, we can easily exploit this fact and determine the longest prefix match of the next suffix without rematching the first <italic>ℓ</italic><italic>−1 characters. Likewise, the enumeration of mismatches and indels is also restricted to the remaining characters of the suffix in our model.</italic></p>
<p>For each suffix of a read, we thus obtain a set of exact matches and alternative inexact matches and their respective positions in the reference sequence. These exact and inexact matches act as seeds. If a seed occurs more than <italic>t</italic> times in the reference genome, then it is omitted, where <italic>t</italic> is a user specified parameter (<monospace>segemehl</monospace> option <monospace>–maxocc</monospace>). The heuristics rigorously selects the exact or inexact seed with the smallest E-value, computed according to the Blast-statistics <xref ref-type="bibr" rid="pcbi.1000502-Karlin1">[14]</xref>. If this E-value is smaller than some user defined threshold (<monospace>segemehl</monospace> option <monospace>-E</monospace>), the bitvector algorithm of <xref ref-type="bibr" rid="pcbi.1000502-Myers1">[1]</xref> is applied to a region around the genomic position of the seed to obtain an alignment of the read and the reference sequence. While the score based search for local alignment seeds controls the sensitivity of our matching model, the bitvector alignment controls its specificity: if the alignment has more matching characters than some user specified percentage <italic>a</italic> of the read (<monospace>segemehl</monospace> option <monospace>-A</monospace>) the corresponding genomic position is reported (see <xref ref-type="sec" rid="s4">Methods</xref>).</p>
<p>The computation of the longest prefix match is implemented by a top-down traversal of a conceptual suffix interval tree, guided by the characters of the read. The suffix interval tree is equivalent to a suffix trie (see <xref ref-type="sec" rid="s4">Methods</xref>). The traversal delivers a matching stem. Note that for the DNA alphabet there are at most four edges outgoing from each node of the suffix interval tree. To introduce mismatches, the traversal is simply continued with alternative edges, i.e. edges diverging from the matching stem. To introduce insertions, the traversal is not regularly continued, but characters of the read are skipped. Deletions are simulated by skipping nodes of the suffix interval tree and continuing the search at their child nodes (see <xref ref-type="sec" rid="s4">Methods</xref>). We refer to these alternative paths that branch off from the matching stem as branches. The maximum number of branches to be considered is controlled by the seed differences threshold <italic>k</italic> (<monospace>segemehl</monospace> option <monospace>-D</monospace>). Note, that while matching character by character along a suffix of a read, the number of branches is expected to decrease quickly.</p>
</sec><sec id="s2b">
<title>Performance Tests</title>
<p><monospace>segemehl</monospace> constructs indices either for each chromosome of a genome and the matching is performed chromosome-wise or, depending on the available <monospace>RAM</monospace>, chromosomes are combined to larger sequences. Compared to other methods, the index structure used by <monospace>segemehl</monospace> is significantly larger. For example, the enhanced suffix array of human chromosome 1 occupies approximately 3 GB of space. As it is stored on disk, the index only needs to be computed once. The construction of the index requires linear time. For example, on a single CPU, the construction of the complete enhanced suffix array for human chromosome 1 takes approximately 15 minutes. For our comparison, we ran <monospace>segemehl</monospace> with maximum occurrence parameter <italic>t</italic> = 500. The maximum E-value for seeds was set to 0.5 and minimum identity threshold to <italic>a</italic> = 85% which corresponds to a maximum of ⌈0.15·<italic>m</italic>⌉ differences in an alignment of the read of length <italic>m</italic>.</p>
<p>We compared <monospace>segemehl</monospace> to <monospace>Bowtie</monospace> v0.9.7 with option –all, <monospace>BWA</monospace> v0.2.0, <monospace>MAQ</monospace> v0.7.1, <monospace>PatMaN</monospace> v1.2.1 and <monospace>SOAP</monospace> v1.11 with option –r 2. <monospace>MAQ</monospace> and <monospace>SOAP</monospace> are based on ungapped alignments which are computed by hash lookups <xref ref-type="bibr" rid="pcbi.1000502-Li1">[7]</xref>,<xref ref-type="bibr" rid="pcbi.1000502-Li2">[8]</xref>,<xref ref-type="bibr" rid="pcbi.1000502-Li3">[13]</xref>. Due to length restrictions, <monospace>MAQ</monospace> is limited to Illumina (and SOLiD) reads. It additionally takes quality scores into account. The quality values needed by <monospace>MAQ</monospace> were, for all nucleotides, uniformly set to a value corresponding to the error rate. <monospace>Bowtie</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Langmead1">[11]</xref> and <monospace>BWA</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Li3">[13]</xref> index the reference genome with the Burrows-Wheeler transform. <monospace>BWA</monospace> allows a limited number of indels. <monospace>PatMaN</monospace> <xref ref-type="bibr" rid="pcbi.1000502-Prfer1">[12]</xref> matches the reads by traversing a non-deterministic suffix automaton constructed from the reference genome. Except for <monospace>PatMaN</monospace>, all programs only report matches with the smallest edit distance. <monospace>BWA</monospace> and <monospace>Bowtie</monospace> each need about 10 minutes to build their index. The fastq files needed by <monospace>MAQ</monospace> are built in approximately 2 minutes. <monospace>PatMaN</monospace> and <monospace>SOAP</monospace> require no indexing steps. The options for the other programs were chosen so as to achieve results similar to <monospace>segemehl</monospace>. For our comparison, we performed tests on simulated as well as real-life read data sets. For the simulation we generated read sets representing different error rates, types and distributions. We used three distinct error sets, one containing only mismatches, one containing only indels and a last one representing reads with mismatches and indels at a ratio of 1∶1. Additionally, different error distributions were used to model error scenarios such as terminal contamination (e.g. linker, poly-A tails) or decreasing read quality. We chose uniform, 5′, 3′ and terminal error distributions.</p>
<p>Each simulated dataset contained 500 000 simulated reads, each of length 35 bp, sampled from a 50 MB large region of the human genome (chromosome 21). We introduced errors to each simulated read according to previously defined rates, error types and distributions. For the 50 MB region we constructed the indexes required for <monospace>segemehl</monospace> and <monospace>Bowtie</monospace>. For <monospace>MAQ</monospace> we constructed the index for the read set under consideration. Index construction took approximately one minute for <monospace>Bowtie</monospace> and <monospace>BWA</monospace>. The construction for the enhanced suffix array for <monospace>segemehl</monospace> took 3.5 minutes. The binary fastq files for <monospace>MAQ</monospace> were created in about 20 seconds.</p>
<p>We ran <monospace>segemehl</monospace> with seed differences threshold <italic>k</italic> = 0 and <italic>k</italic> = 1. For <italic>k</italic> = 0, only exact seeds are computed and for <italic>k</italic> = 1 seeds with at most one difference are computed. All programs were executed single-threaded on the same machine. The results for a uniform error distribution for mismatches only as well as for mismatches and indels are shown in <xref ref-type="fig" rid="pcbi-1000502-g003">Fig. 3</xref>. We measured the performance in terms of running time (<xref ref-type="fig" rid="pcbi-1000502-g003">Fig. 3</xref> (A)) and recall rates, i.e. the percentage of reads mapped to the correct position. <monospace>segemehl</monospace> has recall rates of more than 95% (<italic>k</italic> = 1) and 80% (<italic>k</italic> = 0) in each setup with not more than two errors in the reads. With four uniformly distributed errors in the reads, the recall rate drops below 80% (<italic>k</italic> = 1) and 50% (<italic>k</italic> = 0), respectively. Hence, for <italic>k</italic> = 1 <monospace>segemehl</monospace> outperforms all other methods in terms of recall rates. For reads containing only mismatches and <italic>k</italic> = 0, <monospace>segemehl</monospace> is comparable to other methods (<xref ref-type="fig" rid="pcbi-1000502-g003">Fig. 3</xref> (B)) while it has a significantly better recall rate as soon as insertions and deletions are involved (<xref ref-type="fig" rid="pcbi-1000502-g003">Fig. 3</xref> (C)). As expected, the recall rate of most short read aligners drops if insertions and deletions are introduced into the reads. The running time of <monospace>segemehl</monospace> for <italic>k</italic> = 0 is comparable to other short read aligners. For <italic>k</italic> = 1, the running time increases by a factor of 10.</p>
<fig id="pcbi-1000502-g003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g003</object-id><label>Figure 3</label><caption>
<title>Comparison of recall rates and running time for several short read aligners.</title>
<p>Average running time for the different programs (A) in matching runs with 500 000 reads in two different data sets (logarithmic scale; S refers to <monospace>segemehl</monospace>). The differences are uniformly distributed and consist of only mismatches (B) or mismatches, insertions and deletions (C). The recall rate describes the fraction of reads which was mapped to the correct position. All programs were used with default parameters. <monospace>Bowtie</monospace> was called with option –all and <monospace>SOAP</monospace> with option –r 2.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g003" xlink:type="simple"/></fig>
<p>In contrast to <monospace>Bowtie</monospace>, <monospace>BWA</monospace>, <monospace>MAQ</monospace>, and <monospace>SOAP</monospace>, <monospace>segemehl</monospace> reports, by default, multiple matches for a read within the reference genome if the corresponding alignments have an E-value smaller than some user defined threshold. This behavior leads to an increase in the running time and a decrease in specificity. Compared to <monospace>PatMaN</monospace>, which is also able to report multiple matches, <monospace>segemehl</monospace> can cope with more than two differences and still is on average faster by a factor of 1.7 (<italic>k</italic> = 1) and 14 (<italic>k</italic> = 0). As expected, the worst <monospace>segemehl</monospace> results are seen for high error rates with a uniform error distribution (<xref ref-type="fig" rid="pcbi-1000502-g004">Fig. 4</xref>). Terminal, 3′ and 5′ error distributions yield better results, suggesting that <monospace>segemehl</monospace> implements a robust method that is insensitive to leading and trailing contaminations. Next, we compared <monospace>segemehl</monospace>, <monospace>Bowtie</monospace> and <monospace>MAQ</monospace> on two real-life data sets. We used <monospace>Bowtie</monospace> with option –all and <monospace>MAQ</monospace> with option –C 513 as suggested in the manuals to achieve maximum sensitivity. <monospace>segemehl</monospace>'s sensitivity was controlled by option –M 500 to omit all seeds occurring more than 500 times in the reference sequence.</p>
<fig id="pcbi-1000502-g004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g004</object-id><label>Figure 4</label><caption>
<title><monospace>segemehl</monospace> recall rates for varying difference values and distributions.</title>
<p>Recall rates are depicted for <italic>k</italic> = 0 (dashed) and <italic>k</italic> = 1 (solid). For terminal–, 3′– and 5′– increased difference distributions, <monospace>segemehl</monospace> achieves a recall rate above 80% for reads with 4 errors.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g004" xlink:type="simple"/></fig>
<p>The data set ERR000475 of 20 million Illumina reads (length 45) for <italic>H. sapiens</italic> was downloaded from the NCBIs Short Read Archive (<ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/Traces/sra/" xlink:type="simple">http://www.ncbi.nlm.nih.gov/Traces/sra/</ext-link>). The second data set comprised about 40 000 short 454 reads from the <italic>arabidopsis mpss plus database</italic> (<ext-link ext-link-type="uri" xlink:href="http://mpss.udel.edu/at/" xlink:type="simple">http://mpss.udel.edu/at/</ext-link>). The average length of the 454 reads was 23 bp.</p>
<p>We partitioned the 454-set into subsets of equal size, to satisfy input requirements for <monospace>MAQ</monospace>. An average quality value was assigned to each base.</p>
<p>Mapping multiple reads to a reference genome is a task which can easily be parallelized. Like all other methods, <monospace>segemehl</monospace> offers a parallelization option to run the program on multiple cores. <monospace>segemehl</monospace> runs for the ERR000475 dataset were carried out in eight parallel threads on a single machine with two Quadcore CPUs and 16GB of <monospace>RAM</monospace>. Seven enhanced suffix arrays were constructed representing the whole human genome. <monospace>segemehl</monospace> mapped 92% of the reads to the reference sequence while <monospace>MAQ</monospace> mapped 85% without and 89% with quality values. The corresponding values for <monospace>Bowtie</monospace> are 81% and 89%. The largest difference between the three tools is for the total number of exact matches. Although <monospace>MAQ</monospace> was, according to the manual, running in maximum sensitivity mode, <monospace>segemehl</monospace> computes 20 times more matches than <monospace>MAQ</monospace> (<xref ref-type="table" rid="pcbi-1000502-t001">Tab. 1</xref> (a)). <monospace>Bowtie</monospace> reports 2.5 billion matches which is much more than the two other tools. As expected, for the 454-set, the difference among the compared programs is even larger. While <monospace>Bowtie</monospace> is able to map 71% of all reads, <monospace>segemehl</monospace> achieves 95%. <monospace>MAQ</monospace>, a program explicitly designed for Illumina reads, matches 79% of the reads. Interestingly, compared to <monospace>Bowtie</monospace>, <monospace>MAQ</monospace> reports more matches with two mismatches. <monospace>segemehl</monospace> mainly achieves this result by mapping more reads with one or two errors. In fact, by allowing insertions and deletions <monospace>segemehl</monospace> doubles the number of reads matched at the unit edit distance of 1 (<xref ref-type="table" rid="pcbi-1000502-t001">Tab. 1</xref> (b)).</p>
<table-wrap id="pcbi-1000502-t001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.t001</object-id><label>Table 1</label><caption>
<title>Comparison of the performance of <monospace>Bowtie</monospace>, <monospace>MAQ</monospace>, and <monospace>segemehl</monospace> on two real-life datasets.</title>
</caption><!--===== Grouping alternate versions of objects =====--><alternatives><graphic id="pcbi-1000502-t001-1" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.t001" xlink:type="simple"/><table><colgroup span="1"><col align="left" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/></colgroup>
<thead>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">total</td>
<td align="left" colspan="4" rowspan="1">mismatches+insertions+deletions</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">0</td>
<td align="left" colspan="1" rowspan="1">1</td>
<td align="left" colspan="1" rowspan="1">2</td>
<td align="left" colspan="1" rowspan="1">≥3</td>
</tr>
</thead>
<tbody>
<tr>
<td align="left" colspan="8" rowspan="1">(a) Human genomic data set ERR000475 (Illumina)</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>Bowtie</monospace> (-all)</td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">2 692 341 844</td>
<td align="left" colspan="1" rowspan="1">631 194 732</td>
<td align="left" colspan="1" rowspan="1">925 094 123</td>
<td align="left" colspan="1" rowspan="1">1 136 952 989</td>
<td align="left" colspan="1" rowspan="1">-</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">16 011 867 (81%)</td>
<td align="left" colspan="1" rowspan="1">12 006 627</td>
<td align="left" colspan="1" rowspan="1">2 824 359</td>
<td align="left" colspan="1" rowspan="1">1 180 881</td>
<td align="left" colspan="1" rowspan="1">-</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>Bowtie</monospace> (-all) with qualities</td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">9 264 604 839</td>
<td align="left" colspan="1" rowspan="1">631 194 732</td>
<td align="left" colspan="1" rowspan="1">914 965 615</td>
<td align="left" colspan="1" rowspan="1">1 098 260 521</td>
<td align="left" colspan="1" rowspan="1">6 620 183 971</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">17 693 135 (89%)</td>
<td align="left" colspan="1" rowspan="1">12 006 627</td>
<td align="left" colspan="1" rowspan="1">2 806 842</td>
<td align="left" colspan="1" rowspan="1">1 162 905</td>
<td align="left" colspan="1" rowspan="1">1 716 761</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>MAQ</monospace></td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">67 108 174</td>
<td align="left" colspan="1" rowspan="1">22 545 585</td>
<td align="left" colspan="1" rowspan="1">15 999 878</td>
<td align="left" colspan="1" rowspan="1">14 913 062</td>
<td align="left" colspan="1" rowspan="1">13 649 649</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">16 762 361 (85%)</td>
<td align="left" colspan="1" rowspan="1">12 006 627</td>
<td align="left" colspan="1" rowspan="1">2 829 601</td>
<td align="left" colspan="1" rowspan="1">1 199 110</td>
<td align="left" colspan="1" rowspan="1">727 023</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>MAQ</monospace> with qualities</td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">96 980 574</td>
<td align="left" colspan="1" rowspan="1">15 084 354</td>
<td align="left" colspan="1" rowspan="1">9 867 729</td>
<td align="left" colspan="1" rowspan="1">10 987 486</td>
<td align="left" colspan="1" rowspan="1">61 041 005</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">17 725 314 (89%)</td>
<td align="left" colspan="1" rowspan="1">11 277 928</td>
<td align="left" colspan="1" rowspan="1">2 928 839</td>
<td align="left" colspan="1" rowspan="1">1 364 477</td>
<td align="left" colspan="1" rowspan="1">2 154 070</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>segemehl</monospace></td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">701 943 169</td>
<td align="left" colspan="1" rowspan="1">464 294 770</td>
<td align="left" colspan="1" rowspan="1">112 471 308</td>
<td align="left" colspan="1" rowspan="1">42 794 605</td>
<td align="left" colspan="1" rowspan="1">57 262 900</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">18 191 858 (92%)</td>
<td align="left" colspan="1" rowspan="1">12 002 123</td>
<td align="left" colspan="1" rowspan="1">2 872 615</td>
<td align="left" colspan="1" rowspan="1">1 221 313</td>
<td align="left" colspan="1" rowspan="1">2 095 807</td>
</tr>
<tr>
<td align="left" colspan="8" rowspan="1">(b) <italic>A. thaliana</italic> short RNA data set (454)</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>Bowtie</monospace> (-all)</td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">156 621</td>
<td align="left" colspan="1" rowspan="1">85 254</td>
<td align="left" colspan="1" rowspan="1">42 443</td>
<td align="left" colspan="1" rowspan="1">28 924</td>
<td align="left" colspan="1" rowspan="1">-</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">26 969 (71%)</td>
<td align="left" colspan="1" rowspan="1">18 739</td>
<td align="left" colspan="1" rowspan="1">5 390</td>
<td align="left" colspan="1" rowspan="1">2 840</td>
<td align="left" colspan="1" rowspan="1">-</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>MAQ</monospace></td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">74 994</td>
<td align="left" colspan="1" rowspan="1">26 890</td>
<td align="left" colspan="1" rowspan="1">15 078</td>
<td align="left" colspan="1" rowspan="1">14 482</td>
<td align="left" colspan="1" rowspan="1">18 544</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">29 987 (79%)</td>
<td align="left" colspan="1" rowspan="1">18 738</td>
<td align="left" colspan="1" rowspan="1">5 389</td>
<td align="left" colspan="1" rowspan="1">3 093</td>
<td align="left" colspan="1" rowspan="1">2 767</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"><monospace>segemehl</monospace></td>
<td align="left" colspan="1" rowspan="1">all matches</td>
<td align="left" colspan="1" rowspan="1">262 262</td>
<td align="left" colspan="1" rowspan="1">72 328</td>
<td align="left" colspan="1" rowspan="1">83 070</td>
<td align="left" colspan="1" rowspan="1">51 048</td>
<td align="left" colspan="1" rowspan="1">55 816</td>
</tr>
<tr>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1"/>
<td align="left" colspan="1" rowspan="1">reads found</td>
<td align="left" colspan="1" rowspan="1">35 942 (95%)</td>
<td align="left" colspan="1" rowspan="1">18 737</td>
<td align="left" colspan="1" rowspan="1">10 525</td>
<td align="left" colspan="1" rowspan="1">3 744</td>
<td align="left" colspan="1" rowspan="1">2 936</td>
</tr>
</tbody>
</table></alternatives><table-wrap-foot><fn id="nt101"><p>(a) The genomic paired DNA library with 19 812 604 Illumina reads was matched using <monospace>MAQ</monospace> (chromosome by chromosome), <monospace>Bowtie</monospace> (single index), and <monospace>segemehl</monospace> (seven enhanced suffix arrays each representing a disjoint subset of the human chromosomes). <monospace>Bowtie</monospace> was used with and without quality values. To simulate a <monospace>MAQ</monospace> run without quality information, an average quality value was assigned to all bases of the Illumina data set. The total number of matches differs significantly: <monospace>Bowtie</monospace> outnumbers all other programs. <monospace>segemehl</monospace> still reports ten times more matches than <monospace>MAQ</monospace> without quality values. The number of exact matches shows a 20-fold increase. Although <monospace>MAQ</monospace> improves when quality values are used, the total number of matches remains small in contrast to the other programs. Differences in the number of exactly matching reads reflect the distinct handling of repetitive and uninformative reads. In <monospace>segemehl</monospace>, all reads matching more often than <italic>t</italic> = 500 times are dropped. (b) 38171 reads of a small short RNA library sequenced with 454 were matched to the <italic>A. thaliana</italic> genome. Compared to <monospace>Bowtie</monospace> and <monospace>MAQ</monospace>, <monospace>segemehl</monospace> mapped significantly more reads. Allowing for one error, <monospace>segemehl</monospace> matches twice as many reads as <monospace>Bowtie</monospace>, due to the fact that <monospace>segemehl</monospace>, unlike <monospace>Bowtie</monospace>, allows for indels. Note that <monospace>segemehl</monospace> discarded a few perfect matches since the corresponding seeds occur more than <italic>t</italic> = 500 times in the reference sequence.</p></fn></table-wrap-foot></table-wrap></sec></sec><sec id="s3">
<title>Discussion</title>
<p>We have presented a novel read mapping approach that is able to efficiently handle 3′ and 5′ contaminations as well as mismatches, insertions and deletions in short and medium length reads. It is based on a matching model with inexact seeds containing mismatches, insertions and deletions. The sensitivity and specificity of our method is controlled by a maximum seed differences threshold, a maximum occurence threshold, an E-value threshold and an identity threshold. Compared to previous methods, our approach yields improved recall rates especially for reads containing insertions and deletions. Since indels have been reported to be the predominant error type in 454 reads, allowing for indels is most important to achieve a correct mapping. While <monospace>PatMaN</monospace>, by default, fully enumerates all matches with up to two differences, <monospace>segemehl</monospace>'s heuristic reports only best-scoring matches. The price for the gain in sensitivity is an increase in running time: with <italic>k</italic> = 1 our method is approximately ten times slower than <monospace>Bowtie</monospace>, the fastest program in our comparison. As we used enhanced suffix arrays, matching against a large mammalian genome has to be done chromosome by chromosome when off-the-shelf hardware is used. However, the gain in sensitivity for reads with mismatches and the failure of other methods when dealing with indels may be, depending on the users demands, a reasonable trade off for these shortcomings. Our method is not limited to a specific technology or read length. Although quality values are not considered yet, the matching strategy can easily be adapted to evaluate low quality bases specifically. In principle, we show that for <italic>k</italic> = 0, i.e. exact seeds, our method is sufficiently sensitive to map reads with up to two differences. This is an interesting result since most of the current methods do not tolerate insertions and deletions. In summary, <monospace>segemehl</monospace> with <italic>k</italic> = 0 is among the fastest mapping algorithms. For <italic>k</italic> = 1, <monospace>segemehl</monospace> is able to achieve good recall rates beyond the two error barrier. This is especially interesting since manufacturers try to increase their read lengths at the cost of higher error rates. The increased sensitivity of the presented matching model, along with its ability to handle leading and terminal contaminations is a trade off for the large memory requirements of the enhanced suffix arrays. In the future, compressed index structures like the FM-index <xref ref-type="bibr" rid="pcbi.1000502-Ferragina1">[15]</xref> may be a suitable framework to implement our matching model with smaller memory requirements.</p>
</sec><sec id="s4">
<title>Methods</title>
<p>Our strategy, based on enhanced suffix arrays, aims to find a best local alignment of short reads and reference sequences with respect to a simple scoring system. It does so by determining, for each suffix of the read, the longest prefix occurring as a substring in the reference sequence. This gives a matching backbone, from which a limited number of branches are derived by mismatches, insertions and deletions (<xref ref-type="fig" rid="pcbi-1000502-g002">Fig. 2</xref>). The concept of a matching backbone is equivalent to the concept of matching statistics introduced in <xref ref-type="bibr" rid="pcbi.1000502-Chang1">[16]</xref>. We introduce the concept of matching backbone and branches via a conceptual tree of suffix intervals. Our heuristic approach delivers a small number of inexact seeds of variable length that are subsequently checked by the bitvector algorithm of Myers <xref ref-type="bibr" rid="pcbi.1000502-Myers1">[1]</xref> to verify the existence of alignments with a limited number of differences. First, a short introduction to the basic notions for sequence processing and enhanced suffix arrays will be given, before the concept of suffix intervals is defined. Subsequently, we introduce our new matching strategy.</p>
<sec id="s4a">
<title>Basic Notions for Sequence Processing</title>
<p>We consider sequences over the DNA alphabet Σ<sub>DNA</sub> = {A, C, G, T, N}, where N denotes an undetermined base. In our approach the alignment of N with any character, including N itself, results in a mismatch.</p>
<sec id="s4a1">
<title>Enhanced suffix arrays</title>
<p>First we introduce basic notions for the suffix array and enhanced suffix array. We then formally introduce the concept of a suffix interval.</p>
<p>Suppose that <italic>S</italic> is a sequence of length <italic>n</italic>. We index <italic>S</italic> from position 0. That is, <italic>S</italic>[<italic>i</italic>] denotes the character at position <italic>i</italic> in <italic>S</italic>, for 0≤<italic>i</italic>≤<italic>n</italic>−1. For <italic>i</italic>≤<italic>j</italic>, <italic>S</italic>[<italic>i</italic>‥<italic>j</italic>] denotes the substring of <italic>S</italic> starting with the character at position <italic>i</italic> and ending with the character at position <italic>j</italic>. For <italic>i</italic>&gt;<italic>j</italic>, <italic>S</italic>[<italic>i</italic>‥<italic>j</italic>] denotes the empty string. <italic>occ<sub>S</sub></italic>(<italic>w</italic>) denotes the set of occurrences of some string <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e014" xlink:type="simple"/></inline-formula> in <italic>S</italic>, i.e. the set of positions <italic>i</italic>, 0≤<italic>i</italic>≤|<italic>S</italic>|−|<italic>w</italic>| satisfying <italic>w</italic> = <italic>S</italic>[<italic>i</italic>‥<italic>i</italic>+|<italic>w</italic>|−1]. A substring of <italic>S</italic> beginning at the first position of <italic>S</italic> is a prefix of <italic>S</italic> and a substring ending at the last position of <italic>S</italic> is a suffix of <italic>S</italic>. To prevent that suffixes have a second occurrence in <italic>S</italic>, we add a sentinel character $ (not occurring in <italic>S</italic>) to the end of <italic>S</italic>. For each <italic>i</italic>, 0≤<italic>i</italic>≤<italic>n</italic>, <italic>S<sub>i</sub></italic> = <italic>S</italic>[<italic>i</italic>‥<italic>n</italic>−1]$ denotes the <italic>i</italic>-th non-empty suffix of <italic>S</italic>$, i.e. the suffix beginning at position <italic>i</italic> in <italic>S</italic>$. We identify a suffix of <italic>S</italic>$ by its start position. That is, by suffix <italic>i</italic> we mean <italic>S<sub>i</sub></italic>.</p>
<p>The concept of suffix arrays is based on lexicographically sorting the suffixes of <italic>S</italic>$. Suppose that the characters are ordered such that A&lt;C&lt;G&lt;T&lt;N&lt;$. This character order induces an order on all non-empty suffixes of <italic>S</italic>$, which is captured in the suffix array. Formally, the suffix array suf of <italic>S</italic> is an array of integers in the range 0 to <italic>n</italic>, specifying the lexicographic order of the <italic>n</italic>+1 non-empty suffixes of <italic>S</italic>$. In other words, <italic>S</italic><sub>suf[0]</sub>, <italic>S</italic><sub>suf[1]</sub>, …, <italic>S</italic><sub>suf[<italic>n</italic>]</sub> is the sequence of suffixes of <italic>S</italic> in ascending lexicographic order.</p>
<p>The lcp-table lcp is an array of integers in the range 0 to <italic>n</italic>−1. For each <italic>h</italic>, 1≤<italic>h</italic>≤<italic>n</italic>, lcp[<italic>h</italic>] is the length of the longest common prefix of <italic>S</italic><sub>suf[<italic>h</italic>−1]</sub> and <italic>S</italic><sub>suf[<italic>h</italic>]</sub>. Since the suffix <italic>S<sub>n</sub></italic> = $ is the last suffix in the lexicographic order of all non-empty suffixes, <italic>S</italic><sub>suf[<italic>n</italic>]</sub> = $. Hence we always have lcp[<italic>n</italic>] = 0. The enhanced suffix array is the combination of the suffix array, the lcp-table and two other tables from <xref ref-type="bibr" rid="pcbi.1000502-Abouelhoda1">[2]</xref> not defined here, namely the child-table and the suffix link table.</p>
<p>We now formally introduce the notion of <italic>suffix intervals</italic> that is at the heart of our matching strategy in enhanced suffix arrays.</p>
<p>An interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] is a <italic>suffix interval</italic> if the following holds:</p>
<list list-type="order"><list-item>
<p>0≤<italic>l</italic>≤<italic>r</italic>≤<italic>n</italic></p>
</list-item><list-item>
<p>0≤<italic>h</italic>≤<italic>n</italic>+1</p>
</list-item><list-item>
<p>lcp[<italic>i</italic>]≥<italic>h</italic> for all <italic>i</italic>, <italic>l</italic>+1≤<italic>i</italic>≤<italic>r</italic></p>
</list-item><list-item>
<p><italic>l</italic> = 0 or lcp[<italic>l</italic>]&lt;<italic>h</italic></p>
</list-item><list-item>
<p><italic>r</italic> = <italic>n</italic> or lcp[<italic>r</italic>+1]&lt;<italic>h</italic></p>
</list-item></list>
<p>A suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] refers to table suf, denoting the set <italic>φ</italic>([<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>]) = {suf[<italic>j</italic>] |<italic>l</italic>≤<italic>j</italic>≤<italic>r</italic>} of suffixes of <italic>S</italic>$. <italic>l</italic> and <italic>r</italic> are the interval boundaries of [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>]. We say that suffix <italic>S<sub>i</sub></italic> is in the suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] if <italic>i</italic>∈<italic>φ</italic>([<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>]). <italic>r</italic>−<italic>l</italic>+1 is the <italic>width</italic> of [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>].</p>
<p>All suffixes of <italic>S</italic>$ in a suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] have a common prefix, say <italic>w</italic>, of length <italic>h</italic>. Vice versa, all suffixes of <italic>S</italic>$ having prefix <italic>w</italic> are in [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>]. Due to this correspondence, we say that [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] <italic>is the suffix interval for w</italic>. Note that <italic>φ</italic>([<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>]) = <italic>occ<sub>S</sub></italic>(<italic>w</italic>) whenever [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] is the suffix interval for <italic>w</italic>.</p>
<p>The notion of suffix intervals slightly generalizes the notion of lcp-intervals, as introduced in <xref ref-type="bibr" rid="pcbi.1000502-Abouelhoda1">[2]</xref>. A suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] of width at least 2 is an <italic>lcp-interval</italic> if, besides condition 1.–5. above, we additionally have lcp[<italic>i</italic>] = <italic>h</italic> for at least one <italic>i</italic>, <italic>l</italic>+1≤<italic>i</italic>≤<italic>r</italic>. This condition requires that at least one pair of consecutive suffixes in the suffix interval has a longest common prefix of length exactly <italic>h</italic> (<xref ref-type="fig" rid="pcbi-1000502-g005">Fig. 5</xref>). In other words, a suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] of width 2 which is not an lcp-interval does not have a maximum lcp-value <italic>h</italic>, implying that [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>+1] is also a suffix interval.</p>
<fig id="pcbi-1000502-g005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g005</object-id><label>Figure 5</label><caption>
<title>The enhanced suffix array yields a tree structure of nested suffix intervals.</title>
<p>The enhanced suffix array for the sequence <italic>S</italic>: = attcttcggc (left) and its suffix interval tree (right), equivalent to the suffix trie in <xref ref-type="fig" rid="pcbi-1000502-g002">Fig. 2</xref>, is shown. The array suf represents the lexicographical order of the suffixes in <italic>S</italic>$. In other words, <italic>S</italic><sub>suf[0]</sub>, <italic>S</italic><sub>suf[1]</sub>, …, <italic>S</italic><sub>suf[<italic>n</italic>]</sub> is the sequence of suffixes of <italic>S</italic>$ in ascending lexicographic order. The lcp-table lcp is an array of integers such that for each <italic>h</italic>, 1≤<italic>h</italic>≤<italic>n</italic>, lcp[<italic>h</italic>] is the length of the longest common prefix of <italic>S</italic><sub>suf[<italic>h</italic>−1]</sub> and <italic>S</italic><sub>suf[<italic>h</italic>]</sub>. A suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] denotes an interval in the suffix array with lcp[<italic>i</italic>]≥<italic>h</italic> for all <italic>i</italic>, <italic>l</italic>+1≤<italic>i</italic>≤<italic>r</italic>, i.e. all suffixes in the interval [<italic>l</italic>+1‥<italic>r</italic>] have a longest common prefix of length at least <italic>h</italic>. Additionally, requiring <italic>l</italic> = 0 or lcp[<italic>l</italic>]&lt;<italic>h</italic> makes the suffix interval left maximal and requiring <italic>r</italic> = <italic>n</italic> or lcp[<italic>r</italic>+1]&lt;<italic>h</italic> makes it right maximal. The suffix interval [0‥10, 0] spans the whole suffix array and is equivalent to the root of a suffix interval tree. This interval contains five subintervals, one for each character in <italic>S</italic>$, with <italic>h</italic> = 1. Equivalently, the root node of the suffix interval tree has five children. Note, that two children, labeled by 0 and 11, are singletons. The child nodes of singletons are not explicitly shown here.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g005" xlink:type="simple"/></fig>
<p>While suffix intervals correspond one-to-one to the nodes of a suffix trie for <italic>S</italic>$ (cf. <xref ref-type="bibr" rid="pcbi.1000502-Crochemore1">[17]</xref>), lcp-intervals correspond to the branching nodes of a suffix tree for <italic>S</italic>$ (cf. <xref ref-type="bibr" rid="pcbi.1000502-Abouelhoda1">[2]</xref>). Interpreting the additional condition for lcp-intervals for trees means that in suffix trees nodes with a single child are omitted, while they are allowed in suffix tries.</p>
</sec></sec><sec id="s4b">
<title>Matching Concept</title>
<p>Consider the suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] for <italic>w</italic>. A child of [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] is a suffix interval [<italic>l</italic>′‥<italic>r</italic>′, <italic>h</italic>+1] satisfying <italic>l</italic>≤<italic>l</italic>′≤<italic>r</italic>′≤<italic>r</italic>. We call [<italic>l</italic>′‥<italic>r</italic>′, <italic>h</italic>+1] the a-child of [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] if there is a character <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e077" xlink:type="simple"/></inline-formula> such that [<italic>l</italic>′‥<italic>r</italic>′, <italic>h</italic>+1] is the suffix interval for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e078" xlink:type="simple"/></inline-formula>. Note that for all <italic>q</italic>, <italic>l</italic>′≤<italic>q</italic>≤<italic>r</italic>′, we have <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e079" xlink:type="simple"/></inline-formula> = <italic>S</italic><sub>suf[<italic>q</italic>]</sub>[<italic>h</italic>]. Hence we can easily determine <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e080" xlink:type="simple"/></inline-formula> from [<italic>l</italic>′‥<italic>r</italic>′, <italic>h</italic>+1] or split [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>] into its children. A method computing the <italic>a</italic>-child of a suffix interval in constant time is described in <xref ref-type="bibr" rid="pcbi.1000502-Abouelhoda1">[2]</xref>.</p>
<p>Let <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e015" xlink:type="simple"/></inline-formula> be a suffix interval. For the empty sequence <italic>ε</italic> we define <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e016" xlink:type="simple"/></inline-formula>. For any character <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e081" xlink:type="simple"/></inline-formula> and any sequence <italic>u</italic> we recursively define<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e017" xlink:type="simple"/></disp-formula></p>
<p>That is, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e018" xlink:type="simple"/></inline-formula> delivers the interval <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e019" xlink:type="simple"/></inline-formula>, obtained by greedily matching the characters in <italic>v</italic> beginning at the suffix interval <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e020" xlink:type="simple"/></inline-formula> and <italic>q</italic> is the length of the matching prefix of <italic>v</italic>.</p>
<p>Let <italic>P</italic> denote a sequence of length <italic>m</italic> neither containing a wildcard symbol N nor the sentinel $. For any <italic>i</italic>, 0≤<italic>i</italic>≤<italic>m</italic>, <italic>P<sub>i</sub></italic> = <italic>P</italic>[<italic>i</italic>‥<italic>m</italic>−1] denotes the suffix of <italic>P</italic> beginning at position <italic>i</italic>. Let <italic>ℓ</italic><sub>i</sub> be the length of the longest prefix of <italic>P<sub>i</sub></italic> occurring as a substring of <italic>S</italic>. Then P[i‥i+<italic>ℓ</italic><italic><sub>i</sub></italic>−1] occurs in <italic>S</italic> and either <italic>i</italic>+<italic>ℓ</italic><sub>i</sub> = m <italic>or</italic> P[i‥i+<italic>ℓ</italic><italic><sub>i</sub></italic>] does not occur in <italic>S</italic>. Moreover, there is a sequence of suffix intervals <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e021" xlink:type="simple"/></inline-formula>, such that for all <italic>q</italic>, 0≤<italic>q</italic>≤<italic>ℓ</italic><italic><sub>i</sub></italic>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e022" xlink:type="simple"/></inline-formula> is the suffix interval for <italic>P</italic>[<italic>i</italic>‥<italic>i</italic>+<italic>q</italic>−1]. This implies that <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e023" xlink:type="simple"/></inline-formula>. We call <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e024" xlink:type="simple"/></inline-formula> a matching stem. Obviously, for any <italic>i</italic>, 0≤<italic>i</italic>≤<italic>m</italic>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e025" xlink:type="simple"/></inline-formula>. For any <italic>i</italic>, 0≤<italic>i</italic>≤<italic>m</italic> and any <italic>q</italic>, 1≤<italic>q</italic>≤<italic>ℓ</italic><sub>i</sub>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e026" xlink:type="simple"/></inline-formula> is the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e084" xlink:type="simple"/></inline-formula>-child of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e027" xlink:type="simple"/></inline-formula> where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e086" xlink:type="simple"/></inline-formula> = <italic>S</italic>[<italic>t</italic>+<italic>q</italic>−1] for any <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e028" xlink:type="simple"/></inline-formula>. (Note that all suffixes in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e029" xlink:type="simple"/></inline-formula> have the common prefix <italic>P</italic>[<italic>i</italic>‥<italic>i</italic>+<italic>q</italic>−1] and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e085" xlink:type="simple"/></inline-formula> is the last character of this prefix.) The <italic>ℓ</italic><sub>i</sub>-values are determined in the same way as the length-values of the matching statistics, introduced in <xref ref-type="bibr" rid="pcbi.1000502-Chang1">[16]</xref>. Using the suffix link table, the <italic>ℓ</italic><sub>i</sub>-values can be computed in <italic>O</italic>(<italic>m</italic>) time altogether (cf. <xref ref-type="bibr" rid="pcbi.1000502-Abouelhoda1">[2]</xref>).</p>
<p>We now consider the relation of matching stems of two neighboring suffixes <italic>P<sub>i</sub></italic><sub>−1</sub> and <italic>P<sub>i</sub></italic> for some <italic>i</italic>&gt;0. First note that <italic>ℓ</italic><sub>i</sub><sub><italic>−1</italic></sub>≤<italic>ℓ</italic><italic><sub>i</sub></italic>+1. Moreover, for each <italic>q</italic>, 1≤<italic>q</italic>≤<italic>ℓ</italic><sub>i</sub><sub><italic>−1</italic></sub> we have <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e030" xlink:type="simple"/></inline-formula>where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e082" xlink:type="simple"/></inline-formula> = {x+y | x∈M} denotes the elementwise addition for any set <italic>M</italic>. That is, any suffix in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e031" xlink:type="simple"/></inline-formula> can be found in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e032" xlink:type="simple"/></inline-formula> with offset one.</p>
<p>To allow differences in our matching heuristic, we introduce the concept of matching branches which branch off from sets of the matching stem. We describe the branching in terms of a transformation of some suffix interval <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e033" xlink:type="simple"/></inline-formula>.</p>
<p>Let <italic>i</italic>, 0≤<italic>i</italic>≤<italic>m</italic>−1 be arbitrary but fixed. Let <italic>q</italic> be such that <italic>i</italic>+<italic>q</italic>−1&lt;<italic>m</italic>. Consider some suffix interval <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e034" xlink:type="simple"/></inline-formula> such that the unit edit distance of <italic>S</italic>[suf[<italic>l</italic>]‥suf[<italic>l</italic>]+<italic>h</italic>−1] and <italic>P</italic>[<italic>i</italic>‥<italic>i</italic>+<italic>q</italic>−1] is exactly <italic>d</italic>≤<italic>k</italic>. Then, for the edit operations <italic>x</italic>∈{MM, I, D}, we define the matching branch <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e035" xlink:type="simple"/></inline-formula> as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e036" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e037" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e038" xlink:type="simple"/></disp-formula></p>
<p>Any computation of a triple (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e039" xlink:type="simple"/></inline-formula>, <italic>q</italic>′, <italic>d</italic>+1) according to these equations is called branching step. The MM-branching step implies a mismatch of <italic>a</italic>≠<italic>P</italic>[<italic>i</italic>+<italic>q</italic>] (in the reference sequence) with <italic>P</italic>[<italic>i</italic>+<italic>q</italic>] (in the read). The I-branching step implies an insertion of character <italic>P</italic>[<italic>i</italic>+<italic>q</italic>] in the read. The D-branching step implies a deletion of character <italic>a</italic>∈Σ<sub>DNA</sub> in the read.</p>
<p>Note that in case some <italic>a</italic>-child of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e040" xlink:type="simple"/></inline-formula> does not exist, there is no corresponding contribution to the matching branch. We combine the different types of matching branches by defining:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e041" xlink:type="simple"/></disp-formula></p>
<p>Obviously, any element in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e042" xlink:type="simple"/></inline-formula> can itself be extended by branching from it. To define this, we introduce for all <italic>j</italic>≥1 the iterative matching branch <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e043" xlink:type="simple"/></inline-formula> as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e044" xlink:type="simple"/></disp-formula></p>
<p>This gives us the matching branch closure <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e045" xlink:type="simple"/></inline-formula>, defined by<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e046" xlink:type="simple"/></disp-formula></p>
<p>That is, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e047" xlink:type="simple"/></inline-formula> is the set of matching branches that can be derived by one or more branching steps from (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e048" xlink:type="simple"/></inline-formula>, <italic>q</italic>, <italic>d</italic>) (<xref ref-type="fig" rid="pcbi-1000502-g006">Fig. 6</xref>). Of course, since each step increases the difference value <italic>d</italic>, the number of steps is limited by <italic>k</italic> – <italic>d</italic>. Each element <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e049" xlink:type="simple"/></inline-formula> is extended by exactly matching <italic>P</italic>[<italic>i</italic>+<italic>q</italic>′‥<italic>m</italic>−1] against the enhanced suffix array beginning at the suffix interval <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e050" xlink:type="simple"/></inline-formula>. That is, we compute <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e051" xlink:type="simple"/></inline-formula>.</p>
<fig id="pcbi-1000502-g006" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g006</object-id><label>Figure 6</label><caption>
<title>The branch closure.</title>
<p>The suffix interval [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>], representing some string <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e052" xlink:type="simple"/></inline-formula> of length <italic>h</italic>, is split into its children [<italic>l</italic>‥<italic>u</italic>, <italic>h</italic>+1], [<italic>u</italic>+1‥<italic>v</italic>, <italic>h</italic>+1] and [<italic>v</italic>+1‥<italic>r</italic>, <italic>h</italic>+1] by matching an additional character <italic>a</italic>∈{A, C, T}. We proceed building <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e053" xlink:type="simple"/></inline-formula> by matching the character C (solid bold green line). Beforehand, alternative suffix intervals are stored in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e054" xlink:type="simple"/></inline-formula>, either representing mismatches (dashed red line), insertions (dashed dotted black line) or deletions (dotted blue line). <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e055" xlink:type="simple"/></inline-formula> holds suffix link intervals that in turn branch off from <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e056" xlink:type="simple"/></inline-formula>. The branch closure <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e057" xlink:type="simple"/></inline-formula> holds all such alternative intervals.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g006" xlink:type="simple"/></fig>
<p>While we have defined matching branches for any element in a matching stem, we only compute them for a few elements of the matching stem which make up the matching backbone: Let <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e058" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e059" xlink:type="simple"/></inline-formula> is defined by<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e060" xlink:type="simple"/></disp-formula></p>
<p>Thus, for each suffix <italic>i</italic>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e061" xlink:type="simple"/></inline-formula> is the position in <italic>P</italic> from which to continue processing the next suffix. For any <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e062" xlink:type="simple"/></inline-formula>, we compute <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e063" xlink:type="simple"/></inline-formula>. That is, we omit computing <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e064" xlink:type="simple"/></inline-formula> for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e065" xlink:type="simple"/></inline-formula>. This is due to the fact that some of the suffixes in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e066" xlink:type="simple"/></inline-formula> are already included (with offset one) in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e067" xlink:type="simple"/></inline-formula>, see equation (1). All in all, we arrive at a set <italic>Q</italic>(<italic>P</italic>, <italic>k</italic>) of 4-tuples (<italic>i</italic>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e068" xlink:type="simple"/></inline-formula>, <italic>q</italic>, <italic>d</italic>) such that the unit edit distance of <italic>P</italic>[<italic>i</italic>‥<italic>i</italic>+<italic>q</italic>−1] and <italic>w</italic> is <italic>d</italic>≤<italic>k</italic> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e069" xlink:type="simple"/></inline-formula> is the suffix interval for <italic>w</italic>. The <xref ref-type="fig" rid="pcbi-1000502-g007">Figure 7</xref> gives pseudocode for computing <italic>Q</italic>(<italic>P</italic>, <italic>k</italic>) (which includes the matching backbone).</p>
<fig id="pcbi-1000502-g007" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000502.g007</object-id><label>Figure 7</label><caption>
<title>Algorithm.</title>
<p>Enumeration of exact and inexact seeds.</p>
</caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.g007" xlink:type="simple"/></fig>
<p>Turning to the analysis of the algorithm, first note that<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e070" xlink:type="simple"/></disp-formula></p>
<p>That is, the matching backbone contains at most <italic>m</italic>+1 elements and thus the statements in the inner loop of the algorithm (<xref ref-type="fig" rid="pcbi-1000502-g007">Fig. 7</xref>) are executed <italic>O</italic>(<italic>m</italic>) times altogether. Obviously <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e071" xlink:type="simple"/></inline-formula> contains up to 5 elements, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e072" xlink:type="simple"/></inline-formula> contains at most 1 element and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e073" xlink:type="simple"/></inline-formula> contains at most 6 elements. Since there can be <italic>k</italic> iterations when computing <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e074" xlink:type="simple"/></inline-formula>, the size of this set is at most (12)<italic><sup>k</sup></italic>. Hence the total number of all matching branches is (<italic>m</italic>+1) · (12)<italic><sup>k</sup></italic>. Each matching branch is generated from a previously generated element in constant time. Hence the algorithm runs in time proportional to (<italic>m</italic>+1) · (12)<italic><sup>k</sup></italic>.</p>
<p>From the matching backbone and from the set of all matching branches we select an element achieving a maximum score according to a simple scoring scheme where a character match scores +1 and a mismatch, an insertion and a deletion scores −1. The maximum score element (<italic>i</italic>, [<italic>l</italic>‥<italic>r</italic>, <italic>h</italic>], <italic>q</italic>, <italic>d</italic>) defines a set of substrings of <italic>S</italic> which are aligned to <italic>P</italic>. More precisely, for any <italic>j</italic>, <italic>l</italic>≤<italic>j</italic>≤<italic>r</italic>, <italic>P</italic> is matched against the reference substring <italic>S</italic>[suf[<italic>j</italic>]−(<italic>i</italic>+<italic>k</italic>)‥suf[<italic>j</italic>]+(<italic>m</italic>−<italic>i</italic>+<italic>k</italic>)] using the bit vector algorithm of Myers <xref ref-type="bibr" rid="pcbi.1000502-Myers1">[1]</xref>. For this, we allow a maximum number <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e075" xlink:type="simple"/></inline-formula> of differences, according to the the identity threshold <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e083" xlink:type="simple"/></inline-formula>. Myers algorithm runs in <italic>O</italic>(<italic>m</italic>/<italic>ω</italic> · <italic>ℓ</italic>) time where <italic>ℓ</italic> = 2<italic>k</italic>+<italic>m</italic>+1 is the length of the reference substring and <italic>ω</italic> is the word size of the machine. As <italic>ω</italic> = 64 in our implementation, for reads of size up to 64, we have <italic>m</italic>/<italic>ω</italic> = 1 and so the algorithm runs in <italic>O</italic>(<italic>m</italic>+<italic>k</italic>) time. Note that this running time is independent of <italic>a</italic>. In summary, by specifying <italic>k</italic> along with some E-value <xref ref-type="bibr" rid="pcbi.1000502-Karlin1">[14]</xref> we set the thresholds to search for local alignment seeds. Subsequently, we use Myers algorithm to discards all seeds that produce poor semi-global alignments, according to parameter <italic>a</italic>, typically loosely set to values around 80% (which corresponds to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000502.e076" xlink:type="simple"/></inline-formula>).</p>
</sec></sec></body>
<back>
<ack>
<p>The authors thank Thomas Margraf and Nico Scherf for their valuable suggestions.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1000502-Myers1"><label>1</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Myers</surname><given-names>G</given-names></name>
</person-group>             <year>1999</year>             <article-title>A fast bit-vector algorithm for approximate string matching based on dynamic programming.</article-title>             <source>J ACM</source>             <volume>46</volume>             <fpage>395</fpage>             <lpage>415</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Abouelhoda1"><label>2</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Abouelhoda</surname><given-names>MI</given-names></name>
<name name-style="western"><surname>Kurtz</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Ohlebusch</surname><given-names>E</given-names></name>
</person-group>             <year>2004</year>             <article-title>Replacing suffix trees with enhanced suffix arrays.</article-title>             <source>J Discr Algorithms</source>             <volume>2</volume>             <fpage>53</fpage>             <lpage>86</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Rothberg1"><label>3</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Rothberg</surname><given-names>JM</given-names></name>
<name name-style="western"><surname>Leamon</surname><given-names>JH</given-names></name>
</person-group>             <year>2008</year>             <article-title>The development and impact of 454 sequencing.</article-title>             <source>Nat Biotechnol</source>             <volume>26</volume>             <fpage>1117</fpage>             <lpage>1124</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Bennett1"><label>4</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Bennett</surname><given-names>S</given-names></name>
</person-group>             <year>2004</year>             <article-title>Solexa Ltd.</article-title>             <source>Pharmacogenomics</source>             <volume>5</volume>             <fpage>433</fpage>             <lpage>438</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Huse1"><label>5</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Huse</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Huber</surname><given-names>J</given-names></name>
<name name-style="western"><surname>Morrison</surname><given-names>H</given-names></name>
<name name-style="western"><surname>Sogin</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Welch</surname><given-names>D</given-names></name>
</person-group>             <year>2007</year>             <article-title>Accuracy and quality of massively parallel DNA pyrosequencing.</article-title>             <source>Genome Biology</source>             <volume>8</volume>             <fpage>R143</fpage>          </element-citation></ref>
<ref id="pcbi.1000502-Dohm1"><label>6</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Dohm</surname><given-names>JC</given-names></name>
<name name-style="western"><surname>Lottaz</surname><given-names>C</given-names></name>
<name name-style="western"><surname>Borodina</surname><given-names>T</given-names></name>
<name name-style="western"><surname>Himmelbauer</surname><given-names>H</given-names></name>
</person-group>             <year>2008</year>             <article-title>Substantial biases in ultra-short read data sets from high-throughput DNA sequencing.</article-title>             <source>Nucl Acids Res</source>             <volume>36</volume>             <fpage>e105</fpage>          </element-citation></ref>
<ref id="pcbi.1000502-Li1"><label>7</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Li</surname><given-names>H</given-names></name>
<name name-style="western"><surname>Ruan</surname><given-names>J</given-names></name>
<name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name>
</person-group>             <year>2008</year>             <article-title>Mapping short DNA sequencing reads and calling variants using mapping quality scores.</article-title>             <source>Genome Res</source>             <volume>18</volume>             <fpage>1851</fpage>             <lpage>8</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Li2"><label>8</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Li</surname><given-names>R</given-names></name>
<name name-style="western"><surname>Li</surname><given-names>Y</given-names></name>
<name name-style="western"><surname>Kristiansen</surname><given-names>K</given-names></name>
<name name-style="western"><surname>Wang</surname><given-names>J</given-names></name>
</person-group>             <year>2008</year>             <article-title><monospace>SOAP</monospace>: short oligonucleotide alignment program.</article-title>             <source>Bioinformatics</source>             <volume>24</volume>             <fpage>713</fpage>             <lpage>714</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Rumble1"><label>9</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Rumble</surname><given-names>SM</given-names></name>
<name name-style="western"><surname>Lacroute</surname><given-names>P</given-names></name>
<name name-style="western"><surname>Dalca</surname><given-names>AV</given-names></name>
<name name-style="western"><surname>Fiume</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Sidow</surname><given-names>A</given-names></name>
<etal/></person-group>             <year>2009</year>             <article-title><monospace>SHRiMP</monospace>: Accurate mapping of short color-space reads.</article-title>             <source>PLoS Comput Biol</source>             <volume>5</volume>             <fpage>e1000386</fpage>          </element-citation></ref>
<ref id="pcbi.1000502-Lin1"><label>10</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Lin</surname><given-names>H</given-names></name>
<name name-style="western"><surname>Zhang</surname><given-names>Z</given-names></name>
<name name-style="western"><surname>Zhang</surname><given-names>MQ</given-names></name>
<name name-style="western"><surname>Ma</surname><given-names>B</given-names></name>
<name name-style="western"><surname>Li</surname><given-names>M</given-names></name>
</person-group>             <year>2008</year>             <article-title><monospace>ZOOM</monospace>! Zillions of oligos mapped.</article-title>             <source>Bioinformatics</source>             <volume>24</volume>             <fpage>2431</fpage>             <lpage>2437</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Langmead1"><label>11</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Langmead</surname><given-names>B</given-names></name>
<name name-style="western"><surname>Trapnell</surname><given-names>C</given-names></name>
<name name-style="western"><surname>Pop</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Salzberg</surname><given-names>SL</given-names></name>
</person-group>             <year>2009</year>             <article-title>Ultrafast and memory-efficient alignment of short DNA sequences to the human genome.</article-title>             <source>Genome Biology</source>             <volume>10</volume>             <fpage>R25</fpage>          </element-citation></ref>
<ref id="pcbi.1000502-Prfer1"><label>12</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Prüfer</surname><given-names>K</given-names></name>
<name name-style="western"><surname>Stenzel</surname><given-names>U</given-names></name>
<name name-style="western"><surname>Dannemann</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Green</surname><given-names>RE</given-names></name>
<name name-style="western"><surname>Lachmann</surname><given-names>M</given-names></name>
<etal/></person-group>             <year>2008</year>             <article-title><monospace>PatMaN</monospace>: rapid alignment of short sequences to large databases.</article-title>             <source>Bioinformatics</source>             <volume>24</volume>             <fpage>1530</fpage>             <lpage>1531</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Li3"><label>13</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Li</surname><given-names>H</given-names></name>
<name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name>
</person-group>             <year>2009</year>             <article-title>Fast and Accurate Read Alignment with Burrows-Wheeler Transform.</article-title>             <source>Bioinformatics</source>             <volume>25</volume>             <fpage>1754</fpage>             <lpage>1760</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Karlin1"><label>14</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Karlin</surname><given-names>S</given-names></name>
<name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name>
</person-group>             <year>1990</year>             <article-title>Methods for assessing the statistical significance of molecular sequences features by using general scoring schemes.</article-title>             <source>Proc Natl Acad Sci USA</source>             <volume>87</volume>             <fpage>2264</fpage>             <lpage>2268</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Ferragina1"><label>15</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Ferragina</surname><given-names>P</given-names></name>
<name name-style="western"><surname>Manzini</surname><given-names>G</given-names></name>
</person-group>             <year>2000</year>             <article-title>Opportunistic data structures with applications.</article-title>             <source>IEEE Symposium on Foundations of Computer Science</source>             <fpage>390</fpage>             <lpage>398</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Chang1"><label>16</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Chang</surname><given-names>W</given-names></name>
<name name-style="western"><surname>Lawler</surname><given-names>E</given-names></name>
</person-group>             <year>1994</year>             <article-title>Sublinear approximate string matching and biological applications.</article-title>             <source>Algorithmica</source>             <volume>12</volume>             <fpage>327</fpage>             <lpage>344</lpage>          </element-citation></ref>
<ref id="pcbi.1000502-Crochemore1"><label>17</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author">
<name name-style="western"><surname>Crochemore</surname><given-names>M</given-names></name>
<name name-style="western"><surname>Hancart</surname><given-names>C</given-names></name>
<name name-style="western"><surname>Lecroq</surname><given-names>T</given-names></name>
</person-group>             <year>2007</year>             <source>Algorithms on Strings</source>             <publisher-name>Cambridge University Press</publisher-name>          </element-citation></ref>
</ref-list>

</back>
</article>