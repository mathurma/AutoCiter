<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN">
  <front>
    <journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher>
        <publisher-name>Public Library of Science</publisher-name>
        <publisher-loc>San Francisco, USA</publisher-loc>
      </publisher></journal-meta>
    <article-meta><article-id pub-id-type="publisher-id">PCOMPBIOL-D-11-00572</article-id><article-id pub-id-type="doi">10.1371/journal.pcbi.1002195</article-id><article-categories>
        <subj-group subj-group-type="heading">
          <subject>Research Article</subject>
        </subj-group>
        <subj-group subj-group-type="Discipline-v2">
          <subject>Biology</subject>
          <subj-group>
            <subject>Computational biology</subject>
            <subj-group>
              <subject>Sequence analysis</subject>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group subj-group-type="Discipline">
          <subject>Computational Biology</subject>
        </subj-group>
      </article-categories><title-group><article-title>Accelerated Profile HMM Searches</article-title><alt-title alt-title-type="running-head">Accelerated Profile HMM Searches</alt-title></title-group><contrib-group>
        <contrib contrib-type="author" xlink:type="simple">
          <name name-style="western">
            <surname>Eddy</surname>
            <given-names>Sean R.</given-names>
          </name>
          <xref ref-type="aff" rid="aff1"/>
          <xref ref-type="corresp" rid="cor1">
            <sup>*</sup>
          </xref>
        </contrib>
      </contrib-group><aff id="aff1">          <addr-line>HHMI Janelia Farm Research Campus, Ashburn, Virginia, United States of America</addr-line>       </aff><contrib-group>
        <contrib contrib-type="editor" xlink:type="simple">
          <name name-style="western">
            <surname>Pearson</surname>
            <given-names>William R.</given-names>
          </name>
          <role>Editor</role>
          <xref ref-type="aff" rid="edit1"/>
        </contrib>
      </contrib-group><aff id="edit1">University of Virginia, United States of America</aff><author-notes>
        <corresp id="cor1">* E-mail: <email xlink:type="simple">eddys@janelia.hhmi.org</email></corresp>
        <fn fn-type="con">
          <p>Conceived and designed the experiments: SRE. Performed the experiments: SRE. Analyzed the data: SRE. Contributed reagents/materials/analysis tools: SRE. Wrote the paper: SRE.</p>
        </fn>
      <fn fn-type="conflict">
        <p>The author has declared that no competing interests exist.</p>
      </fn></author-notes><pub-date pub-type="collection">
        <month>10</month>
        <year>2011</year>
      </pub-date><pub-date pub-type="epub">
        <day>20</day>
        <month>10</month>
        <year>2011</year>
      </pub-date><volume>7</volume><issue>10</issue><elocation-id>e1002195</elocation-id><history>
        <date date-type="received">
          <day>27</day>
          <month>4</month>
          <year>2011</year>
        </date>
        <date date-type="accepted">
          <day>29</day>
          <month>7</month>
          <year>2011</year>
        </date>
      </history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2011</copyright-year><copyright-holder>Sean R. Eddy</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract>
        <p>Profile hidden Markov models (profile HMMs) and probabilistic inference methods have made important contributions to the theory of sequence database homology search. However, practical use of profile HMM methods has been hindered by the computational expense of existing software implementations. Here I describe an acceleration heuristic for profile HMMs, the “multiple segment Viterbi” (MSV) algorithm. The MSV algorithm computes an optimal sum of multiple ungapped local alignment segments using a striped vector-parallel approach previously described for fast Smith/Waterman alignment. MSV scores follow the same statistical distribution as gapped optimal local alignment scores, allowing rapid evaluation of significance of an MSV score and thus facilitating its use as a heuristic filter. I also describe a 20-fold acceleration of the standard profile HMM Forward/Backward algorithms using a method I call “sparse rescaling”. These methods are assembled in a pipeline in which high-scoring MSV hits are passed on for reanalysis with the full HMM Forward/Backward algorithm. This accelerated pipeline is implemented in the freely available HMMER3 software package. Performance benchmarks show that the use of the heuristic MSV filter sacrifices negligible sensitivity compared to unaccelerated profile HMM searches. HMMER3 is substantially more sensitive and 100- to 1000-fold faster than HMMER2. HMMER3 is now about as fast as BLAST for protein searches.</p>
      </abstract><abstract abstract-type="summary">
        <title>Author Summary</title>
        <p>Searching sequence databases is one of the most important applications in computational molecular biology. The main workhorse in the field is the BLAST suite of programs. Since the introduction of BLAST in the 1990's, important theoretical advances in homology search methodology have been made using probabilistic inference methods and hidden Markov models (HMMs). However, previous software implementations of these newer probabilistic methods were slower than BLAST by about 100-fold. This hindered their utility, because computation speed is so critical with the rapidly increasing size of modern sequence databases. Here I describe the acceleration methods I implemented in a new, freely available profile HMM software package, HMMER3. HMMER3 makes profile HMM searches about as fast as BLAST, while retaining the power of using probabilistic inference technology.</p>
      </abstract><funding-group><funding-statement>This work was supported by the Howard Hughes Medical Institute (HHMI). HHMI had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts>
        <page-count count="16"/>
      </counts></article-meta>
  </front>
  <body>
    <sec id="s1">
      <title>Introduction</title>
      <p>Sequence database homology searching is one of the most important applications in computational molecular biology. Genome sequences are being acquired rapidly for an ever-widening array of species. To make maximal use of sequence data, we want to maximize the power of computational sequence comparison tools to detect remote homologies between these sequences, to learn clues to their functions and evolutionary histories. The most widely used tool for sequence comparison and database search is BLAST <xref ref-type="bibr" rid="pcbi.1002195-Altschul1">[1]</xref>–<xref ref-type="bibr" rid="pcbi.1002195-Camacho1">[3]</xref>.</p>
      <p>Since BLAST's introduction, some important advances have been made in the theory of sequence comparison, particularly by using probabilistic inference methods based on profile hidden Markov models (profile HMMs) <xref ref-type="bibr" rid="pcbi.1002195-Krogh1">[4]</xref>. Probabilistic modeling approaches provide a consistent framework for parameterizing complex position-specific models of sequence conservation and evolution <xref ref-type="bibr" rid="pcbi.1002195-Durbin1">[5]</xref>. Numerous improvements have been made in BLAST in light of these advances <xref ref-type="bibr" rid="pcbi.1002195-Altschul3">[6]</xref>–<xref ref-type="bibr" rid="pcbi.1002195-Yu1">[9]</xref>. Fundamentally, though, the BLAST implementation computes optimal local alignment scores using <italic>ad hoc</italic> gap penalties. This implementation core may not be readily adaptable to a probabilistic insertion/deletion model and the more powerful “Forward/Backward” HMM algorithm that computes not just one best-scoring alignment, but a sum of probabilities over the entire local alignment ensemble. The Forward algorithm allows a more powerful and formal log-likelihood score statistic to be assigned to each target sequence, and Forward/Backward allows confidence values to be assigned to each aligned residue.</p>
      <p>Nonetheless, regardless of any of the attractive advantages of HMMs, no implementation of fully probabilistic sequence comparison methods has yet approached the utility of BLAST. The most widely used implementations of profile HMM technology, including HMMER from my laboratory, have been slow and computationally expensive, on the order of 100- to 1000-fold slower than BLAST for a comparably sized search. In an era of enormous sequence databases, this speed disadvantage outweighs any advantage of HMM methods. Profile HMM methods have become important only in the niche of protein domain family analysis, where the speed differential is compensated by being able to use a single profile HMM to represent a family of hundreds of homologous individual sequences <xref ref-type="bibr" rid="pcbi.1002195-Hunter1">[10]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Finn1">[11]</xref>.</p>
      <p>HMMER has been a target of many acceleration and optimization efforts <xref ref-type="bibr" rid="pcbi.1002195-Chaudhary1">[12]</xref>–<xref ref-type="bibr" rid="pcbi.1002195-Sachdeva1">[15]</xref> but these efforts have had limited impact. The only accelerations that have reported large gains have implemented HMMER's native dynamic programming algorithms on specialized hardware, including FPGAs (field-programmable gate arrays) <xref ref-type="bibr" rid="pcbi.1002195-Maddimsetty1">[16]</xref>–<xref ref-type="bibr" rid="pcbi.1002195-Oliver1">[19]</xref>, VLSI ASICs (special-purpose chips), GP-GPUs (general purpose graphics processor units) <xref ref-type="bibr" rid="pcbi.1002195-Horn1">[20]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Walters2">[21]</xref>, and large multiprocessor clusters <xref ref-type="bibr" rid="pcbi.1002195-Chukkapalli1">[22]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Rekapalli1">[23]</xref>. Fewer efforts have been made to develop fast heuristic profile HMM algorithms for standard commodity processors <xref ref-type="bibr" rid="pcbi.1002195-Sun1">[24]</xref>–<xref ref-type="bibr" rid="pcbi.1002195-Johnson1">[26]</xref> in ways comparable to how BLAST heuristically approximates and accelerates Smith/Waterman optimal dynamic programming alignment <xref ref-type="bibr" rid="pcbi.1002195-Smith1">[27]</xref>. The challenge is that to preserve the significant yet narrow gain in sensitivity that profile HMM methods show over BLAST <xref ref-type="bibr" rid="pcbi.1002195-Madera1">[28]</xref>–<xref ref-type="bibr" rid="pcbi.1002195-Freyhult1">[30]</xref>, any useful profile HMM acceleration heuristic must be more sensitive than BLAST's already excellent heuristics.</p>
      <p>Another reason for the limited impact of previous acceleration efforts is that they have almost exclusively focused on accelerating the optimal local alignment scoring algorithm (known as the Viterbi algorithm in the HMM literature) as opposed to the more desirable Forward algorithm. In part, this is because optimal local alignment algorithms are more well known, and in part it is because previous versions of HMMER itself implemented Viterbi rather than Forward scoring. Forward implementations are about 3- to 9-fold slower than Viterbi implementations, and the expected statistical distribution of Forward scores for profile HMMs was not understood well enough to assign accurate E-values (expectation values). I recently described a satisfactory solution to the latter problem <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>, which leaves the problem of acceleration.</p>
      <p>Here I describe the heuristic acceleration pipeline implemented by HMMER3, a reimplemented version of the HMMER software. In comparison to the previous version of HMMER, HMMER3 is about 100-fold faster because of the use of a new heuristic algorithm called the MSV filter, while also being significantly more powerful because it moves from optimal local Viterbi alignment to full Forward/Backward evaluation of alignment ensembles, exploiting more of the mathematical advantages of probabilistic modeling. Thus HMMER3 is now about as fast as BLAST, while extending the performance advantages of profile HMM methods.</p>
    </sec>
    <sec id="s2">
      <title>Results</title>
      <sec id="s2a">
        <title>Overview</title>
        <p>The main algorithm that accelerates HMMER3 is called MSV, for Multiple (local, ungapped) Segment Viterbi. It was inspired by a technique used in ParAlign <xref ref-type="bibr" rid="pcbi.1002195-Rognes1">[32]</xref>. As shown in <xref ref-type="fig" rid="pcbi-1002195-g001">Figure 1</xref>, the MSV model is an ungapped version of HMMER3's multihit local alignment model. MSV's probabilistic model of multihit ungapped local alignment is achieved simply by ignoring the match, delete, and insert state transitions of the original profile and implicitly treating match-match transitions as 1.0.</p>
        <fig id="pcbi-1002195-g001" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002195.g001</object-id>
          <label>Figure 1</label>
          <caption>
            <title>The MSV profile.</title>
            <p>A: Profile HMM architecture used by HMMER3 <xref ref-type="bibr" rid="pcbi.1002195-Krogh1">[4]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Durbin1">[5]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. Regions homologously aligned to the query are represented by a linear core model consisting of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e001" xlink:type="simple"/></inline-formula> consensus positions (in this example, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e002" xlink:type="simple"/></inline-formula>), each consisting of a match, a delete, and an insert state (shown as boxes marked M, circles marked D, and diamonds marked I), connected by state transition probabilities (arrows). Match states carry position-specific emission probabilities for scoring residues at each consensus position. Insert states emit residues with emission probabilities identical to a background distribution. Additional flanking states (marked N, C, and J) emit zero or more residues from the background distribution, modeling nonhomologous regions preceding, following, or joining homologous regions aligned to the core model. Start (S), begin (B), end (E) and termination (T) states do not emit. B: The MSV profile is formed by implicitly treating all match-match transition probabilities as 1.0. This corresponds to the virtual removal of the delete and insert states. The rest of the profile parameterization stays the same. This model generates sequences containing one or more ungapped local alignment segments. Note that both models appear to be improperly normalized; for example, each match state in the MSV model has probability 1.0 local exit transition (orange arrows) in addition to the probability 1.0 match-match transition. This is because of a trick used to establish a uniform local fragment length distribution, in which these profiles are collapsed representations of a much larger (and properly normalized) “implicit probability model”, as explained in <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. C: An example of what an alignment of a larger MSV profile (of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e003" xlink:type="simple"/></inline-formula>) to a target sequence (of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e004" xlink:type="simple"/></inline-formula>) might look like, as a path through a dynamic programming (DP) matrix. Here, the model identifies two high-scoring ungapped alignment segments (black dots, indicating residues aligned to profile match states), and assigns all other residues to N, J, and C states in the model (orange dots; unfilled indicates a “mute” nonemitting state or state transition). Note that the ungapped diagonals are not enforced to be consistent with a single gapped alignment.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.g001" xlink:type="simple"/>
        </fig>
        <p>An MSV score is essentially analogous to BLAST's “sum score” of one or more ungapped HSPs (high scoring pairs). A difference is that MSV does not impose alignment consistency (two ungapped alignments are not required to be consistent with a single gapped alignment). In a filtering heuristic, this difference is not important. HMMER3 calculates the MSV score directly by dynamic programming, bypassing the word hit and hit extension heuristics of BLAST.</p>
        <p>The fact that MSV essentially bypasses two of BLAST's main heuristics provides an intuitive argument why MSV scores are expected to be a more sensitive overall heuristic than BLAST's approach. However, I have not attempted to rigorously compare the performance of HMMER's MSV heuristic to other acceleration heuristics such as those in BLAST or FASTA.</p>
        <p>The HMMER3 implementation takes advantage of several synergistic statistical and computational features of the MSV model. I summarize these features here before describing them in detail:</p>
        <list list-type="bullet">
          <list-item>
            <p>MSV alignment scores can be calculated efficiently using so-called “striped” vector-parallel techniques originally developed for Smith/Waterman local sequence alignment <xref ref-type="bibr" rid="pcbi.1002195-Farrar1">[33]</xref>, because the MSV model removes deletion and insertion states that interfere with vector parallelism.</p>
          </list-item>
          <list-item>
            <p>Because the MSV model gives predictable score distributions for nonhomologous sequences, with scores confined to a narrow range that is largely independent of query and target sequence characteristics, MSV values can be approximated with reduced precision (8 bits, in a score range of 0–255). This allows a 16-fold vector parallelism in current commodity processors with 128-bit vector registers.</p>
          </list-item>
          <list-item>
            <p>The MSV model remains a full probabilistic local alignment model, so MSV scores obey conjectures about the expected Gumbel distribution of probabilistic local alignment scores <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. This allows the rapid calculation of P-values.</p>
          </list-item>
          <list-item>
            <p>Because we can calculate MSV P-values, we can use MSV scores as a tunable and selective sequence filter. If a target sequence has an MSV score with a P-value less than a chosen threshold, we pass the entire sequence to more accurate and computationally intensive scoring algorithms. By definition, the P-value threshold is the fraction of nonhomologous sequences expected to pass the filter.</p>
          </list-item>
        </list>
        <p>The MSV filter is a heuristic acceleration, not guaranteed to find all high-scoring targets. Overall performance of the HMMER3 acceleration pipeline in terms of speed, specificity, and sensitivity depends on several issues and tradeoffs, including how fast the filters are, how accurately and quickly P-values can be estimated for filter scores, and whether a threshold on MSV P-values can be set to remove most nonhomologs while removing few if any true homologs that an unfiltered search would have detected. These are empirical questions, which I have addressed by benchmarking experiments.</p>
        <p>The following sections, especially on vector parallelization and on assuring that scores can be kept in limited numeric ranges, are necessarily technical and terse. On a first reading, the reader may want to skip or skim ahead to the “HMMER3 acceleration pipeline” section to see how these technical aspects fit together into an overall scheme, and how that acceleration scheme performs.</p>
      </sec>
      <sec id="s2b">
        <title>MSV model: notation and parameterization</title>
        <p>The MSV score for target sequence <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e005" xlink:type="simple"/></inline-formula> is a standard HMM Viterbi score, a log likelihood ratio score of a single optimal (maximally likely) alignment: the ratio of the probability of the optimal alignment <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e006" xlink:type="simple"/></inline-formula>° for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e007" xlink:type="simple"/></inline-formula> given the MSV model <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e008" xlink:type="simple"/></inline-formula> and the probability of the sequence given a null hypothesis model <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e009" xlink:type="simple"/></inline-formula>:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e010" xlink:type="simple"/></disp-formula>For a query of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e011" xlink:type="simple"/></inline-formula> positions, the MSV profile has <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e012" xlink:type="simple"/></inline-formula> match emission parameters (where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e013" xlink:type="simple"/></inline-formula> is the alphabet size, 4 nucleotides or 20 amino acids), plus <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e014" xlink:type="simple"/></inline-formula> additional state transition parameters involving the flanking N, B, E, C, and J states that account for nonhomologous residues. Other state transitions in the original profile are ignored, which means implicitly treating match-match transitions as 1.0.</p>
        <p>The null model <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e015" xlink:type="simple"/></inline-formula> is assumed to be an HMM with a single state <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e016" xlink:type="simple"/></inline-formula> emitting residues <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e017" xlink:type="simple"/></inline-formula> with background frequencies <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e018" xlink:type="simple"/></inline-formula> (i.e. a standard i.i.d. null model: independent, identically distributed residues), with a geometric length distribution specified by a transition parameter <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e019" xlink:type="simple"/></inline-formula>.</p>
        <p>The <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e020" xlink:type="simple"/></inline-formula> position-specific match scores <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e021" xlink:type="simple"/></inline-formula> are precomputed as log-odds ratios for a residue <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e022" xlink:type="simple"/></inline-formula> emitted from match state M<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e023" xlink:type="simple"/></inline-formula> with emission probability <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e024" xlink:type="simple"/></inline-formula>, compared to the null model background frequencies <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e025" xlink:type="simple"/></inline-formula>:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e026" xlink:type="simple"/></disp-formula>These match scores (as well as the emission probabilities and background frequencies) are the same as in the original profile.</p>
        <p>The only state transition parameters in the MSV model are those that control target sequence length modeling, the uniform local alignment fragment length distribution, and the number of hits to the core homology model per target sequence <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. These too are identical to the parameterization of the original profile <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. Specifically, they are set as follows for a target sequence of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e027" xlink:type="simple"/></inline-formula> residues and a model of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e028" xlink:type="simple"/></inline-formula> consensus positions:</p>
        <p>Target sequence length modeling:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e029" xlink:type="simple"/></disp-formula></p>
        <p>Uniform local alignment fragment length distribution:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e030" xlink:type="simple"/></disp-formula></p>
        <p>Multiple hits per target:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e031" xlink:type="simple"/></disp-formula></p>
      </sec>
      <sec id="s2c">
        <title>MSV score algorithm (serial version)</title>
        <p>The MSV alignment score can be calculated by a dynamic programming recursion in a two-dimensional matrix <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e032" xlink:type="simple"/></inline-formula> indexed by HMM state <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e033" xlink:type="simple"/></inline-formula> and target sequence residue <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e034" xlink:type="simple"/></inline-formula>:</p>
        <p>Initialization:</p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e035" xlink:type="simple"/></disp-formula></p>
        <p>Recursion:</p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e036" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e037" xlink:type="simple"/></disp-formula></p>
        <p>   <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e038" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e039" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e040" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e041" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e042" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e043" xlink:type="simple"/></disp-formula></p>
        <p>Termination: <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e044" xlink:type="simple"/></inline-formula></p>
        <p>The <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e045" xlink:type="simple"/></inline-formula> “state” in the initialization is solely needed for a boundary condition; there is no such state in the model.</p>
        <p>Log-odds ratio scoring relative to the null model is built into the calculation, in the match scores <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e046" xlink:type="simple"/></inline-formula> and in counting the total (constant) null model state transition contribution of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e047" xlink:type="simple"/></inline-formula> as terms in the DP termination step.</p>
        <p>Like other linear sequence alignment recursions, the algorithm requires <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e048" xlink:type="simple"/></inline-formula> time. It is implemented in a single lattice row of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e049" xlink:type="simple"/></inline-formula> space for purposes of obtaining just the optimal score. In the HMMER3 source code, this algorithm is implemented in generic_msv.c::p7_GMSV().</p>
      </sec>
      <sec id="s2d">
        <title>MSV score algorithm: SIMD vector parallelization</title>
        <p>The MSV algorithm is highly amenable to vector parallelization using commodity SIMD (single instruction, multiple data) instructions, such as the Streaming SIMD Extensions (SSE) instructions on Intel-compatible systems and Altivec/VMX instructions on PowerPC systems. These vector instruction sets use 128-bit vectors to compute up to 16 simultaneous operations.</p>
        <p>Several vector methods have been described for accelerating classical Smith/Waterman local sequence alignment <xref ref-type="bibr" rid="pcbi.1002195-Wozniak1">[34]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Rognes2">[35]</xref>, and methods for accelerating Smith/Waterman dynamic programming (DP) recursions are readily adapted to profile HMMs. A remarkably efficient vector-parallel approach called <italic>striped</italic> Smith/Waterman was described by Farrar <xref ref-type="bibr" rid="pcbi.1002195-Farrar1">[33]</xref>.</p>
        <p>Striping addresses a challenge in the data dependency pattern in Smith/Waterman-style dynamic programming recursions. The calculation of each cell <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e050" xlink:type="simple"/></inline-formula> in the dynamic programming lattice requires having previously calculated cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e051" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e052" xlink:type="simple"/></inline-formula>, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e053" xlink:type="simple"/></inline-formula>. In a row-vectorized implementation, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e054" xlink:type="simple"/></inline-formula> individual cells (typically 4, 8, or 16) are stored in each individual vector, such that each row <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e055" xlink:type="simple"/></inline-formula> of the vectorized DP matrix stores cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e056" xlink:type="simple"/></inline-formula> in Q vectors numbered <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e057" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e058" xlink:type="simple"/></inline-formula>. In Farrar's approach, cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e059" xlink:type="simple"/></inline-formula> are assigned nonconsecutively to vectors <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e060" xlink:type="simple"/></inline-formula> in a striped pattern (<xref ref-type="fig" rid="pcbi-1002195-g002">Figure 2</xref>). In striped vectors, when we calculate the set of several cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e061" xlink:type="simple"/></inline-formula> contained in one vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e062" xlink:type="simple"/></inline-formula> on a current row, all the previous diagonal cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e063" xlink:type="simple"/></inline-formula> that we need are neatly available in the correct order in a vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e064" xlink:type="simple"/></inline-formula> on the previous row, and the cells above are in vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e065" xlink:type="simple"/></inline-formula>. Striping minimizes expensive operations such as shifting or rearranging cell values inside vectors. The disadvantage is that calculations on delete paths (dependent on cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e066" xlink:type="simple"/></inline-formula> to the left) may need to be fully serialized. Farrar described effective techniques for minimizing this problem. In the MSV algorithm, because only ungapped diagonals are calculated, this drawback is avoided altogether. The essential idea of how striped indexing works is schematized in <xref ref-type="fig" rid="pcbi-1002195-g002">Figure 2</xref>.</p>
        <fig id="pcbi-1002195-g002" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002195.g002</object-id>
          <label>Figure 2</label>
          <caption>
            <title>Illustration of striped indexing for SIMD vector calculations.</title>
            <p>The top row (magenta outline) shows one row of the dynamic programming lattice for a model of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e067" xlink:type="simple"/></inline-formula>. Assuming an example of vectors containing <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e068" xlink:type="simple"/></inline-formula> cells each, the 14 cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e069" xlink:type="simple"/></inline-formula> are contained in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e070" xlink:type="simple"/></inline-formula> vectors numbered <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e071" xlink:type="simple"/></inline-formula>. (Two unused cells, marked x, are set to a sentinel value.) In the dynamic programming recursion, when we calculate each new cell <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e072" xlink:type="simple"/></inline-formula> in a new row <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e073" xlink:type="simple"/></inline-formula>, we access the value in cell <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e074" xlink:type="simple"/></inline-formula> in the previous row <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e075" xlink:type="simple"/></inline-formula>. With striped indexing, vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e076" xlink:type="simple"/></inline-formula> contains exactly the four <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e077" xlink:type="simple"/></inline-formula> cells needed to calculate the four cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e078" xlink:type="simple"/></inline-formula> in a new vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e079" xlink:type="simple"/></inline-formula> on a new row of the dynamic programming matrix (turquoise outline). For example, when we calculate cells <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e080" xlink:type="simple"/></inline-formula> in vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e081" xlink:type="simple"/></inline-formula>, we access the previous row's vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e082" xlink:type="simple"/></inline-formula> which contains the cells we need in the order we need them, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e083" xlink:type="simple"/></inline-formula> (dashed lines and box). If instead we indexed cells into vectors in the obvious way, in linear order (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e084" xlink:type="simple"/></inline-formula> in vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e085" xlink:type="simple"/></inline-formula> and so on), there is no such correspondence of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e086" xlink:type="simple"/></inline-formula> with four <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e087" xlink:type="simple"/></inline-formula>'s, and each calculation of a new vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e088" xlink:type="simple"/></inline-formula> would require expensive meddling with the order of cells in the previous row's vectors. With striped indexing, only one shift operation is needed per row, outside the innermost loop: the last vector on each finished row is rightshifted (mpv, in grey with red cell <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e089" xlink:type="simple"/></inline-formula> indices) and used to initialize the next row calculation.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.g002" xlink:type="simple"/>
        </fig>
        <p>To maximize parallelism, I implemented MSV as a 16-fold parallel calculation with score values stored as 8-bit unsigned integers restricted to range 0‥255. This takes advantage of the fact that local alignment scores under HMMER3's probabilistic model have a narrow and predictable dynamic range, enabling a numerical stability analysis that justifies using reduced precision. (The details of this analysis are given in the next section.) This rescaling is specified by three values (base, bias, and scale), where “base” is an initial offset from zero to make MSV scores nonnegative (default: 190), “scale” is the scaling factor (default 3, so MSV scores are in units of one-third bits), and “bias” is an offset on individual residue scores, used to make all individual residue scores unsigned byte costs relative to the maximum residue score. Using the scale and bias terms, position-specific residue scores <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e090" xlink:type="simple"/></inline-formula> are converted to precomputed scaled costs by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e091" xlink:type="simple"/></inline-formula> (saturated at a maximum cost of 255) and stored in striped order in vectors <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e092" xlink:type="simple"/></inline-formula> (<xref ref-type="fig" rid="pcbi-1002195-g002">Figure 2</xref>). Transition scores <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e093" xlink:type="simple"/></inline-formula> are converted to precomputed scaled costs <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e094" xlink:type="simple"/></inline-formula> by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e095" xlink:type="simple"/></inline-formula> (saturated at a maximum cost of 255).</p>
        <p>To define MSV's SIMD recursion, I will use five pseudocode vector instructions for operations on <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e096" xlink:type="simple"/></inline-formula>bit integers (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e097" xlink:type="simple"/></inline-formula> in our implementation), either scalars <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e098" xlink:type="simple"/></inline-formula> or vectors <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e099" xlink:type="simple"/></inline-formula> containing <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e100" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e101" xlink:type="simple"/></inline-formula>bit integer elements numbered <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e102" xlink:type="simple"/></inline-formula>. Each of these operations are either available or easily constructed in both SSE and Altivec/VMX:<xref ref-type="table" rid="pcbi-1002195-t001"/></p>
        <table-wrap id="pcbi-1002195-t001" position="float"><!--===== Grouping alternate versions of objects =====--><alternatives><graphic id="pcbi-1002195-t001-1" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.t001" xlink:type="simple"/><table>
            <colgroup span="1">
              <col align="left" span="1"/>
              <col align="center" span="1"/>
              <col align="center" span="1"/>
            </colgroup>
            <thead>
              <tr>
                <td align="left" colspan="1" rowspan="1">Operation</td>
                <td align="left" colspan="1" rowspan="1">Pseudocode</td>
                <td align="left" colspan="1" rowspan="1">Definition</td>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left" colspan="1" rowspan="1">saturated addition</td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e103" xlink:type="simple"/></inline-formula>
                </td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e104" xlink:type="simple"/></inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">saturated subtraction</td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e105" xlink:type="simple"/></inline-formula>
                </td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e106" xlink:type="simple"/></inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">max</td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e107" xlink:type="simple"/></inline-formula>
                </td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e108" xlink:type="simple"/></inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">assignment</td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e109" xlink:type="simple"/></inline-formula>
                </td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e110" xlink:type="simple"/></inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">right shift</td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e111" xlink:type="simple"/></inline-formula>
                </td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e112" xlink:type="simple"/></inline-formula>
                </td>
              </tr>
              <tr>
                <td align="left" colspan="1" rowspan="1">horizontal max</td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e113" xlink:type="simple"/></inline-formula>
                </td>
                <td align="left" colspan="1" rowspan="1">
                  <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e114" xlink:type="simple"/></inline-formula>
                </td>
              </tr>
            </tbody>
          </table></alternatives></table-wrap>
        <p>In this pseudocode, the vectorized MSV algorithm is the following:</p>
        <p>Initialization:</p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e115" xlink:type="simple"/></disp-formula></p>
        <p>Recursion:</p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e116" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e117" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e118" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e119" xlink:type="simple"/></disp-formula></p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e120" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e121" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e122" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e123" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e124" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e125" xlink:type="simple"/></disp-formula></p>
        <p>  <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e126" xlink:type="simple"/></disp-formula></p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e127" xlink:type="simple"/></disp-formula></p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e128" xlink:type="simple"/></disp-formula></p>
        <p> <disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e129" xlink:type="simple"/></disp-formula></p>
        <p>Termination: <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e130" xlink:type="simple"/></inline-formula></p>
        <p>The constant term of −4.3 bits in the termination step arises from an approximation that deals with roundoff error in counting <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e131" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e132" xlink:type="simple"/></inline-formula> transition costs. This is explained in the following section. The termination condition is assuming that <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e133" xlink:type="simple"/></inline-formula>, so that values for the C state are the same as for the J state (thus saving having to calculate C state values in the recursion).</p>
        <p>This algorithm is implemented both for SSE and Altivec/VMX instructions in the HMMER3 source code in impl_{sse,vmx}/msvfilter.c::p7_MSVFilter().</p>
      </sec>
      <sec id="s2e">
        <title>Analysis of consequences of reduced numerical precision</title>
        <p>This section is particularly technical, and may be skipped in a first reading. In reducing the dynamic range of score calculations to small unsigned integers, we must make sure that underflow or overflow either do not occur, or have no erroneous consequences. We must also be sure that the magnitude of any accumulated roundoff error is tolerable. Because the HMMER3 acceleration pipeline (described below) uses vector-parallel, striped, reduced precision implementations of both the MSV algorithm (described above) and the standard Viterbi (optimal alignment) algorithm for the original profile model with insertions/deletions, the following analysis considers both MSV and Viterbi scores.</p>
        <p>For underflow, we use the fact that there is a lower bound on optimal local alignment scores as a function of model length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e134" xlink:type="simple"/></inline-formula> and target sequence length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e135" xlink:type="simple"/></inline-formula>. In the worst possible positive-scoring optimal local alignment, the core profile matches only one match state <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e136" xlink:type="simple"/></inline-formula> against one residue <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e137" xlink:type="simple"/></inline-formula> with a score <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e138" xlink:type="simple"/></inline-formula>, and the remaining <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e139" xlink:type="simple"/></inline-formula> residues of the target sequence are accounted for by flanking N and C states. The worst case therefore has a log-odds likelihood score <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e140" xlink:type="simple"/></inline-formula> of<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e141" xlink:type="simple"/></disp-formula>which is:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e142" xlink:type="simple"/></disp-formula>Known protein sequences can be over 30,000 residues long (human titin, for example, is 34,350aa). If we specify <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e143" xlink:type="simple"/></inline-formula> as design limits, we can assume a lower score bound of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e144" xlink:type="simple"/></inline-formula> bits for optimal local alignments.</p>
        <p>For managing overflow, we use the fact that we will only use a reduced-precision implementation as a filter on target sequences. Any sequence with a P-value<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e145" xlink:type="simple"/></inline-formula>a chosen threshold will be passed on to a slower routine for recomputation at full precision. Using <italic>saturated</italic> arithmetic instructions, any target sequences that overflow will be scored as the highest possible score. Now we only need to be able to guarantee that the upper score bound has a P-value<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e146" xlink:type="simple"/></inline-formula>the lowest P-value threshold we ever plan to use. From Milosajevic <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Milosavljevi1">[36]</xref>, we know a conservative bound <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e147" xlink:type="simple"/></inline-formula> for a bit score threshold <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e148" xlink:type="simple"/></inline-formula>. For a design limit allowing filter thresholds <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e149" xlink:type="simple"/></inline-formula>, an upper score bound of 17 bits suffices. (0.02 is the default P-value threshold for MSV, and 0.001 is the default for Viterbi scores, as discussed below).</p>
        <p>This range of −60 to 17 bits applies to <italic>complete</italic> optimal local alignments; in individual cells of the dynamic programming calculation, we need a little more dynamic range. A high scoring alignment of 17 bits, for example, will have a score of more than 17 bits in the last cell that aligns a match state to a homologous residue, because this state is always followed by negative scores from EC, CC, and CT transitions in the optimal alignment. Taking this into account (including some order of evaluation issues - the fact that the contributions of some transitions, including the null model's contributions, are included in a termination step after the dynamic programming recursion is complete) it can be shown that a range of −61…21 bits suffices to guarantee that no DP cell involved in an optimal local alignment of range −60…17 bits will underflow or overflow.</p>
        <p>These same bounds apply to both the original local alignment model (Viterbi alignments with insertions and deletions) and the MSV model, because no step in ascertaining these bounds required any consideration of the transition probabilities in the core model (match, insertion, and delete states).</p>
        <p>Thus we need a dynamic range of 82 bits (−61 … 21 bits), and the maximum range of an 8-bit integer is 256 values, so scaling log-odds scores to units of 1/3 bits suffices. (Coincidentally, this is comparable to the scaling and roundoff of standard scoring matrices used by BLAST or FASTA; BLOSUM45, for example, is in units of 1/3 bits.) A “base” offset term is then used to adjust the represented value range to the range of bit scores. For unsigned 8-bit integers, a base of +190 means that values 0‥255 represent the range of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e150" xlink:type="simple"/></inline-formula> bits.</p>
        <p>Rounding scores to the nearest 1/3 bit introduces a roundoff error of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e151" xlink:type="simple"/></inline-formula> bit per scoring term. A sum of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e152" xlink:type="simple"/></inline-formula> independent, identically distributed random deviates uniformly distributed on an interval <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e153" xlink:type="simple"/></inline-formula> has mean zero and variance <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e154" xlink:type="simple"/></inline-formula>. Because a local alignment score for a target sequence of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e155" xlink:type="simple"/></inline-formula> is modeled as a sum of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e156" xlink:type="simple"/></inline-formula> emission and transition scoring terms, even if each term's roundoff error were independent and uniformly distributed, accumulated roundoff error would be large (normally distributed with mean zero and variance <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e157" xlink:type="simple"/></inline-formula>; so for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e158" xlink:type="simple"/></inline-formula> the accumulated error would have a standard deviation of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e159" xlink:type="simple"/></inline-formula>2.7 bits). Worse, roundoff errors are neither independent nor uniformly distributed. A particularly bad case is contributed by transition probabilities <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e160" xlink:type="simple"/></inline-formula> close to 1.0, such as most match-match transitions in the original gapped profile model, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e161" xlink:type="simple"/></inline-formula> for all sufficiently large <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e162" xlink:type="simple"/></inline-formula> rounds to a zero cost. Another bad case is contributed by HMM states that have self-loops, such as insert-insert transitions, where a roundoff error is multiplied by the number of times the state is visited. These two bad cases make the self-loops producing chains of N, C, J, or insert states particularly problematic, because these self-transition probabilities are often close to 1.0; an entire chain of them often gets scored as zero, accumulating a large roundoff error.</p>
        <p>The MSV model and its implementation use several features to reduce roundoff error to tolerable limits. First, by eliminating match, delete, and insert transitions and setting all match-match transition probabilities to 1.0 (thus zero cost), the MSV model itself has already eliminated many of the transitions that accumulate non-independent roundoff error, leaving in the core model only the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e163" xlink:type="simple"/></inline-formula> match state emission probabilities (which are all approximately independent and uncorrelated as far as roundoff error analysis is concerned). Second, the emission probabilities in N, C, and J states are assumed to be equal to the background (null model) frequencies, so the emission scores in N, C, and J are treated as zero by construction, thus they contribute no roundoff error terms. Third, we can take advantage of the fact that the total contribution of the NN, CC, and JJ transitions approximates a constant for sufficiently large <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e164" xlink:type="simple"/></inline-formula>, because a local alignment typically assigns nearly all residues of the target sequence to N, C, and J states and few to match states. Thus we expect a typical local alignment to involve on the order of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e165" xlink:type="simple"/></inline-formula> NN, CC, and JJ transitions, each scoring <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e166" xlink:type="simple"/></inline-formula>, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e167" xlink:type="simple"/></inline-formula> bits for large <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e168" xlink:type="simple"/></inline-formula>. Therefore we can score NN, CC, and JJ transitions as zero cost during the recursion, then later add a constant <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e169" xlink:type="simple"/></inline-formula> bits back onto the score to approximate their missing contribution. This approach may alter the optimal local alignment (during the recursion, paths using NN, CC, and JJ transitions look more favorable than they actually are) but in a score filter, we are not interested in the optimal alignment, only its score.</p>
        <p>Thus the roundoff error in a reduced-precision MSV algorithm implementation consists of a bias arising from treating the NN, CC, JJ contributions totalling <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e170" xlink:type="simple"/></inline-formula> bits as a constant −4.3 bits, and a sum of more or less independent and uniformly distributed error terms including five or more log transition probabilities (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e171" xlink:type="simple"/></inline-formula>) and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e172" xlink:type="simple"/></inline-formula> emission scores for match states involved in ungapped alignment diagonals of total length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e173" xlink:type="simple"/></inline-formula> residues. For large <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e174" xlink:type="simple"/></inline-formula>, and assuming <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e175" xlink:type="simple"/></inline-formula> or so for typical MSV alignments at the edge of statistical significance, a back of the envelope calculation suggests an expected error of mean zero and standard deviation of about <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e176" xlink:type="simple"/></inline-formula> bits, and a worst-case maximum error of about <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e177" xlink:type="simple"/></inline-formula> bits. Because higher-scoring alignments involve more match emission terms than low-scoring alignments, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e178" xlink:type="simple"/></inline-formula> is correlated to the optimal score, so the roughly Gaussian error distribution for a given <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e179" xlink:type="simple"/></inline-formula> will be convolved with a Gumbel score distribution, resulting in a slightly non-Gaussian error distribution with some skew towards the higher error side.</p>
        <p>To confirm that this expected roundoff error agrees with empirical observation, I performed simulations in which I examined the differences in MSV scores of a reduced precision implementation (unsigned bytes in <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e180" xlink:type="simple"/></inline-formula> bit units) compared to a full-precision floating point implementation. I did this for many different profiles (9,318 models from Pfam release 22) aligned to 1,000 random sequences of varying lengths <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e181" xlink:type="simple"/></inline-formula>, and to 207,132 real sequences in SwissProt 49.0 (in UniProt 7.0). This experiment showed roundoff errors for each model were distributed with a standard deviation of 0.4–0.6 bits for real sequences in Swissprot and for random sequences of each length. The mean error was approximately zero for random sequences of lengths <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e182" xlink:type="simple"/></inline-formula>; a 0.4 bit mean underestimate for UniProt sequences; a 0.5 bit mean underestimate for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e183" xlink:type="simple"/></inline-formula> random sequences; and a 2.2 bit mean underestimate for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e184" xlink:type="simple"/></inline-formula> random sequences. On real UniProt sequences, I observed some extreme differences of up to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e185" xlink:type="simple"/></inline-formula> bits. These invariably corresponded to long and highly biased composition sequences, where presumably the alignment length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e186" xlink:type="simple"/></inline-formula> was large, increasing the potential for accumulated roundoff error. Because these were rare, and MSV is to be used only as a filter, these extremes seem safe to ignore. Overall the range of roundoff error appears tolerable, particularly for large <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e187" xlink:type="simple"/></inline-formula>.</p>
      </sec>
      <sec id="s2f">
        <title>MSV scores obey conjectures allowing fast P-value determination</title>
        <p>Previously <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref> I conjectured that expected scores for certain probabilistic local alignment models, including the HMMER3 local alignment model, follow easily predictable distributions. Specifically, I conjectured that optimal alignment Viterbi bit scores show Gumbel distributions of fixed slope <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e188" xlink:type="simple"/></inline-formula>, and the high scoring tail of Forward bit scores follow exponentials of the same slope <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e189" xlink:type="simple"/></inline-formula>. The MSV model is fully probabilistic and thus ought to obey these conjectures. Therefore MSV optimal alignment scores are predicted to follow a Gumbel distribution<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e190" xlink:type="simple"/></disp-formula>with slope <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e191" xlink:type="simple"/></inline-formula> and a location <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e192" xlink:type="simple"/></inline-formula> that is estimated by fitting to a small simulation of scores from 200 or so random sequences.</p>
        <p>These statistical conjectures are best obeyed by models or scoring systems with high relative entropy per position (i.e. high mean expected score) <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. Default HMMER3 models have low relative entropy per position (about 0.6 bits/position) because HMMER3 model parameterization uses a technique called entropy-weighting <xref ref-type="bibr" rid="pcbi.1002195-Johnson2">[29]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Karplus1">[37]</xref>, an <italic>ad hoc</italic> method to re-weight the effective number of observed sequences relative to the prior (pseudocounts) to achieve a desired relative entropy target. The standard pairwise residue alignment scoring system (BLOSUM62) has a similar relative entropy of about 0.6 bits per aligned position. At lower relative entropy per position, longer alignments are required to achieve high scores and a finite-length “edge effect” becomes considerable. HMMER3 ameliorates edge effect by calculating an <italic>ad hoc</italic> corrected <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e193" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e194" xlink:type="simple"/></inline-formula> is the length of the profile in match states and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e195" xlink:type="simple"/></inline-formula> is the relative entropy per match emission state in bits <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref>. Although the same <italic>ad hoc</italic> correction suffices for both Viterbi and Forward distributions, it was obtained by empirical fitting with little theoretical guidance, so there is little reason to trust that the same correction would apply to MSV scores. Therefore I empirically tested the ability to estimate accurate P-values for MSV scores for a wide range of HMMER/Pfam models.</p>
        <p><xref ref-type="fig" rid="pcbi-1002195-g003">Figure 3A</xref> shows an example of an MSV score distribution for one typical profile HMM (the CNP1 model from Pfam version 24, representing a lipoprotein family, chosen because it has the median length, median number of representative sequences, and median average pairwise identity over all Pfam 24 seed alignments), for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e196" xlink:type="simple"/></inline-formula> scores of random i.i.d. sequences of varying lengths. For all but the shortest sequences (L = 25), the observed score distributions closely match the conjectured distribution including the <italic>ad hoc</italic> edge correction term (orange line).</p>
        <fig id="pcbi-1002195-g003" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002195.g003</object-id>
          <label>Figure 3</label>
          <caption>
            <title>MSV scores follow a predictable distribution.</title>
            <p>A: example MSV score distributions for a typical Pfam model, CNP1, on <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e197" xlink:type="simple"/></inline-formula> random i.i.d. sequences of varying lengths from 25 to 25,600, with the shortest, typical, and longest lengths highlighted as red, black, and blue lines, respectively. The predicted distribution, following the procedure of <xref ref-type="bibr" rid="pcbi.1002195-Eddy1">[31]</xref> including an edge correction on the slope <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e198" xlink:type="simple"/></inline-formula>, is shown in orange (though largely obscured by the data lines right on top of it). B: Histogram of maximum likelihood <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e199" xlink:type="simple"/></inline-formula> values obtained from score distributions of 11,912 Pfam models, showing that most are tolerably close to the conjectured <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e200" xlink:type="simple"/></inline-formula>, albeit with more dispersion for default entropy-weighted models (black line) than high relative entropy models without entropy-weighting (gray line). C: The observed fraction of nonhomologous sequences that pass the filter at a P-value of 0.02 should be 0.02. Histograms of the actual filter fraction for 11,912 different Pfam 24 models are shown, for a range of random sequence lengths from 25 to 25,600, for both default models (black lines) and high relative entropy models with no entropy weighting (gray lines).</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.g003" xlink:type="simple"/>
        </fig>
        <p><xref ref-type="fig" rid="pcbi-1002195-g003">Figure 3B</xref> shows results of simulations in which 11,912 different profile HMMs from Pfam version 24 <xref ref-type="bibr" rid="pcbi.1002195-Finn1">[11]</xref> were scored by the MSV algorithm against <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e201" xlink:type="simple"/></inline-formula> random sequences of length 400, the resulting distributions were fit to Gumbel distributions to determine maximum likelihood estimates of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e202" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e203" xlink:type="simple"/></inline-formula>, and a histogram of the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e204" xlink:type="simple"/></inline-formula> estimates is plotted. For high relative entropy models (grey line), this distribution is tightly clustered at the expected <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e205" xlink:type="simple"/></inline-formula>. For default entropy-weighted models (black line), the distribution is broader with a higher mean, in accordance with what is observed for Viterbi scores and attributed to finite-length edge effect.</p>
        <p><xref ref-type="fig" rid="pcbi-1002195-g003">Figure 3C</xref> shows a direct evaluation of the accuracy of MSV P-values across many Pfam models and various random sequence lengths. For each of 11,912 Pfam 24 models, MSV scores are calculated for 500,000 random sequences generated at each of several lengths <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e206" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e207" xlink:type="simple"/></inline-formula>, and the number of random sequences that pass the MSV filter at P<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e208" xlink:type="simple"/></inline-formula> is counted. If P-values are accurate, we would expect to see an approximately normal distribution centered at 2% of random sequences passing the filter. Within a tolerance of about 2-fold error, this is true for almost all models and for target sequence lengths <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e209" xlink:type="simple"/></inline-formula> or so. A few models have less well-predicted distributions and produce modest outliers. The largest problems appear with short target sequences (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e210" xlink:type="simple"/></inline-formula>) where P-values can be up to about five-fold overestimated (i.e., fewer sequences pass than predicted), as seen in the CNP1 example in panel A. Default entropy-weighted models (black) are more affected than models with high relative entropy (gray).</p>
        <p>This analysis shows that in general, reasonably accurate P-values for MSV scores can be obtained. It also shows that on short sequences of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e211" xlink:type="simple"/></inline-formula> or so, the MSV filter may be too aggressive (removing more sequences than predicted), and that a few models are outliers with either too few or too many sequences getting through the filter. These are minor issues that would be good to deal with in the future.</p>
      </sec>
      <sec id="s2g">
        <title>Vector parallelization of the Forward and Backward algorithms</title>
        <p>The MSV implementation described above is about 500-fold faster than a standard serial implementation of the full Forward algorithm. This means that a search will still be rate-limited by the speed of the computationally intensive Forward/Backward calculations. Suppose we allow the top 2% (1/50) of sequences through the MSV filter to full HMM Forward log-likelihood scoring; then Forward must be no more than 50-fold slower than MSV, or Forward will be rate-limiting. It was therefore necessary to seek significant accelerations of at least an order of magnitude in the implementations of the Forward and Backward algorithms.</p>
        <p>Numerical underflow is a problem for implementing the Forward and Backward algorithms. The probability of a partial alignment path generally underflows the smallest representable floating-point value. In a Viterbi implementation, underflow is avoided by working in the log probability domain, replacing multiplication and maximization of probabilities with addition and maximization of their logarithms <xref ref-type="bibr" rid="pcbi.1002195-Durbin1">[5]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Rabiner1">[38]</xref>. However, the Forward and Backward dynamic programming recursions require addition of partial paths in the probability domain.</p>
        <p>In both sequence analysis and speech recognition HMM applications, this problem is customarily solved by working in the log probability domain and implementing a “log-sum” operation, such that addition <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e212" xlink:type="simple"/></inline-formula> in the probability domain is replaced by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e213" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e214" xlink:type="simple"/></inline-formula>, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e215" xlink:type="simple"/></inline-formula> <xref ref-type="bibr" rid="pcbi.1002195-Durbin1">[5]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Melnikoff1">[39]</xref>. An efficient log-sum operation rearranges the log-sum to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e216" xlink:type="simple"/></inline-formula> for <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e217" xlink:type="simple"/></inline-formula>, and finds an approximate <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e218" xlink:type="simple"/></inline-formula> term to add to <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e219" xlink:type="simple"/></inline-formula> in a precalculated lookup table indexed by the difference <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e220" xlink:type="simple"/></inline-formula> scaled and rounded to an appropriate precision. The lookup table has finite size, because the term is negligible for large <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e221" xlink:type="simple"/></inline-formula>, but nonetheless it is large (16,000 entries in the HMMER3 “generic” non-vectorized implementation; see logsum.c). I do not know how to implement a large lookup table efficiently in SIMD vector instructions. Only small lookup tables appear feasible using vector permutation instructions (up to perhaps 256 entries in Altivec/VMX, fewer in SSE).</p>
        <p>Another approach is rescaling <xref ref-type="bibr" rid="pcbi.1002195-Durbin1">[5]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Rabiner1">[38]</xref>. In rescaling, the entries in each row <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e222" xlink:type="simple"/></inline-formula> (for each target residue <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e223" xlink:type="simple"/></inline-formula>) of the dynamic programming matrix are multiplied by some scale value <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e224" xlink:type="simple"/></inline-formula>. The scale values <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e225" xlink:type="simple"/></inline-formula> are chosen to keep the largest entries in each row within the allowable numeric range. If the smallest values in a row differ from the largest by greater than the numeric range, the smallest values still underflow, but for many HMMs one can show that no partial path prefix that underflows could have ever rebounded to have a non-negligible probability as a complete path. However, in general this is not the case for profile HMMs (nor for other HMMs with paths involving silent states), because of the possibility of long deletions. Even an optimal alignment can contain a long D-D-D path along a single row <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e226" xlink:type="simple"/></inline-formula>. After many DD transition probabilities are multiplied together, the values in the states at the start versus the end of a long deletion path on the same row can differ by more than the allowable range. A standard normalized IEEE754 32-bit float type has a range of about <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e227" xlink:type="simple"/></inline-formula>, equivalent to 256 bits in the log-odds score domain. Given a typical deletion extension penalty of about −1 to −2 bits, a deletion of about 200 residues or so will typically underflow the rescaled delete states in the correct path. Deletions of this length are rare, but do occur.</p>
        <p>I use the following steps to make an approach that I call “sparse rescaling” work for HMMER3's SIMD vector implementations of the Forward/Backward algorithms.</p>
        <p>First, Forward/Backward values are calculated in an odds-ratio domain rather than the probability domain, so they are naturally pre-scaled to some extent. Each match emission probability <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e228" xlink:type="simple"/></inline-formula> is replaced by its odds ratio <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e229" xlink:type="simple"/></inline-formula>, the same ratio used for log-odds scores. By the same arguments used to analyze underflow of the MSV implementation above, the odds ratio of the worst-case optimal local alignment path is a simple function of model and target lengths <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e230" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e231" xlink:type="simple"/></inline-formula>, with a lower bound of about <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e232" xlink:type="simple"/></inline-formula> (about <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e233" xlink:type="simple"/></inline-formula>) if we assume <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e234" xlink:type="simple"/></inline-formula> as design limits, well within the allowable range of an IEEE754 float representation.</p>
        <p>Second, I exploit the fact that the HMMER3 profile HMM is a multihit local alignment model, not a glocal alignment model (glocal means global with respect to the model, local with respect to the target). When the profile HMM is a multihit local alignment model, a rescaling approach works. For any path with two aligned regions connected by a long deletion, there must exist an alternative path that counts the same two aligned regions as two local alignments, connected by a reinitiation path (M<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e235" xlink:type="simple"/></inline-formula><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e236" xlink:type="simple"/></inline-formula>E<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e237" xlink:type="simple"/></inline-formula>J<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e238" xlink:type="simple"/></inline-formula>B). This reinitiation path, with only three transition probabilities on the same row, presents no underflow difficulties. The path with a long deletion may underflow, but then its complete path must be negligible relative to the alternative multihit local alignment path.</p>
        <p>Determining the appropriate scale factor <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e239" xlink:type="simple"/></inline-formula> requires examining each value in the row, which typically requires extra computation. I exploit the fact that the value in the cell for the E state has already calculated a maximum over all <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e240" xlink:type="simple"/></inline-formula> states. It is sufficient to use the E cell value itself as the scale value <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e241" xlink:type="simple"/></inline-formula>, setting the E cell value to 1 and rescaling all other values in the row.</p>
        <p>Still, rescaling a row also requires extra computation. Here I exploit the fact that rescaling every row is unnecessary. Instead, when the E cell odds-ratio value exceeds a certain threshold, this triggers a rescaling event for that row. Other rows have <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e242" xlink:type="simple"/></inline-formula>.</p>
        <p>I implemented Forward and Backward using sparse rescaling and striped SIMD vectors of four parallel 32-bit floats. Overall these implementations are about 16-fold faster than standard serial implementations using the log-sum lookup table operation. The overall 16-fold acceleration is likely a combination of about a 4-fold speedup from the SIMD vector parallelization with about 4-fold from replacing the log-sum operation with addition and multiplication. This makes the Forward/Backward algorithms only about 30-fold slower than the MSV filter.</p>
      </sec>
      <sec id="s2h">
        <title>The HMMER3 acceleration pipeline</title>
        <p>The MSV and Forward/Backward methods described above are implemented in the so-called “acceleration pipeline” at the core of the HMMER3 software implementation (<ext-link ext-link-type="uri" xlink:href="http://hmmer.janelia.org" xlink:type="simple">http://hmmer.janelia.org</ext-link>). The acceleration pipeline is summarized in <xref ref-type="fig" rid="pcbi-1002195-g004">Figure 4</xref>. One call to the p7_Pipeline() function is executed for each model/sequence comparison.</p>
        <fig id="pcbi-1002195-g004" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002195.g004</object-id>
          <label>Figure 4</label>
          <caption>
            <title>The HMMER3 acceleration pipeline.</title>
            <p>Representative calculation speeds are shown in red, in units of millions of dynamic programming cells per second (Mc/s). Default P-value thresholds for MSV, Viterbi, and Forward filtering steps are shown in orange. The bias filter and the domain definition steps are not described in detail in this manuscript, and are shown in gray.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.g004" xlink:type="simple"/>
        </fig>
        <p>The pipeline either accepts or rejects the entire comparison at each step, based on the P-value of the log-odds score. For example, by default the MSV filter passes if a comparison gets a P-value of less than 0.02 (i.e., the top-scoring 2% of random nonhomologous sequences are expected to pass the filter). I have not yet explored the more sophisticated approach of using alignment information from earlier and faster steps in the pipeline to constrain (band) subsequent dynamic programming calculations.</p>
        <p>All P-value calculations assume that the query profile and target sequence have residue compositions close to the overall average for proteins. In some cases, a query profile has a biased composition, and this bias matches a bias found in many target database sequences. Membrane proteins, for example, are skewed towards a more hydrophobic composition, and tend to match other nonhomologous membrane proteins with scores higher than expected under a simple average-composition null hypothesis. HMMER3 has methodology for recalculating scores and P-values to compensate for biased composition, but this methodology (the so-called “null2” correction, not described here for reasons of space) is placed late in the pipeline because it is computationally intensive. At the MSV filter step, the uncorrected MSV P-value may be underestimated in biased composition matches, which means more than the expected fraction of nonhomologous sequences may passes the MSV filter, which in some cases can be sufficient to slow the pipeline. HMMER3 inserts a “bias filter” step to reduce this problem. The bias filter step is shown in gray in <xref ref-type="fig" rid="pcbi-1002195-g004">Figure 4</xref> because it is not described in detail in this paper. Briefly, the bias filter calculates a fast, heuristic biased composition correction to the MSV filter score using a two-state hidden Markov model with one emission distribution set to the average protein residue composition and the other emission distribution set to the average composition of the query profile, fully connected by four arbitrary hand-tuned transition probabilities. The pipeline rescores the sequence with this correction applied, and retests the modified P-value against the MSV filter threshold of 0.02. The bias filter has no effect on the final reported score of a sequence, which is calculated by the full Forward algorithm; the bias filter only has the effect of making the MSV filter remove additional matches that appear to be due to biased composition.</p>
        <p>To further reduce the computational load that arrives at the full Forward step, an additional filter, the Viterbi filter, was implemented and inserted in the pipeline. The Viterbi filter is a striped SIMD vector implementation of optimal gapped alignment to the profile (<xref ref-type="fig" rid="pcbi-1002195-g001">Figure 1A</xref>). It is implemented 8-fold vector parallel in 16-bit integers, because the numerical analysis of roundoff error accumulation is less favorable for Viterbi than for MSV and more precision is required. Following the same arguments as described for MSV, Viterbi filter scores do not underflow (within design limits of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e243" xlink:type="simple"/></inline-formula>) but may overflow the 16-bit representation, which is in units of 1/500 bits with an integer offset of 12,000, such that representable scores range from −89.5 to 41.5 bits. Any score that overflows the 41.5 bit upper limit is sure to pass any reasonable filter P-value anyway (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e244" xlink:type="simple"/></inline-formula>; the default Viterbi filter threshold is <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e245" xlink:type="simple"/></inline-formula>).</p>
        <p>The Forward and Backward algorithms for the pipeline are implemented in specialized efficient-memory forms called p7_ForwardParser() and p7_BackwardParser(). Each parser stores only a single row <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e246" xlink:type="simple"/></inline-formula> of the dynamic programming matrix for each sequence residue <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e247" xlink:type="simple"/></inline-formula>, plus the complete columns for the “special” states E, N, J, B, and C. This yields <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e248" xlink:type="simple"/></inline-formula> linear-memory implementations, with sufficient stored information to allow Forward/Backward posterior decoding of the probable positions of B and E states on the target sequence, defining the probabilities of local alignment endpoints. A target sequence that passes the Viterbi filter is scored with the full Forward parsing algorithm. If the Forward score passes a P-value threshold (default P<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e249" xlink:type="simple"/></inline-formula>), the Backward parser is calculated. Forward/Backward probabilities are used to estimate local alignment “regions” of substantial posterior probability mass in the target sequence. Each region is then subjected to a conceptually separate analysis pipeline, the “domain definition” pipeline, which identifies individual homologous regions and alignments, using a series of steps including full-matrix Forward/Backward, posterior decoding, maximum expected accuracy alignment, and a region-specific biased composition score correction. The domain definition procedure is not described in detail in this paper.</p>
        <p>The acceleration pipeline is memory efficient. The MSV and Viterbi filters are only concerned with scores, not alignments, so they are implemented in linear-memory <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e250" xlink:type="simple"/></inline-formula> forms that store only a single dynamic programming row. The Forward and Backward algorithms are used in a <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e251" xlink:type="simple"/></inline-formula> “parser” form just described. The domain definition pipeline, however, is not memory efficient. It currently calculates full <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e252" xlink:type="simple"/></inline-formula> Forward/Backward and posterior decoding matrices for each identified subsequence (region) of length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e253" xlink:type="simple"/></inline-formula> in the target sequence. Until these steps in the domain postprocessor are replaced with more memory-efficient algorithms, HMMER3 can occasionally exhaust available memory on some large model/sequence comparisons.</p>
      </sec>
      <sec id="s2i">
        <title>Speed benchmarking</title>
        <p><xref ref-type="fig" rid="pcbi-1002195-g005">Figure 5</xref> shows benchmark measurements of the speed of HMMER3, compared to the speed of BLAST <xref ref-type="bibr" rid="pcbi.1002195-Camacho1">[3]</xref>, FASTA <xref ref-type="bibr" rid="pcbi.1002195-Pearson1">[40]</xref>, SSEARCH (the FASTA implementation of Smith/Waterman), HMMER2, and the UCSC SAM profile HMM software <xref ref-type="bibr" rid="pcbi.1002195-Karplus1">[37]</xref>. Search speeds are shown in units of millions of dynamic programming cells calculated per second (Mc/s), measured on a single processor core (see Methods). The number of dynamic programming cells is the product of the query length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e254" xlink:type="simple"/></inline-formula> and the target database length <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e255" xlink:type="simple"/></inline-formula> in residues. A straightforward implementation of dynamic programming sequence alignment scales in time as <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e256" xlink:type="simple"/></inline-formula>, so reporting a speed in units of Mc/s is expected to be relatively independent of query and target length. In practice, the fastest search programs tend to show some additional dependence on query sequence length, with more efficient performance on longer queries. <xref ref-type="fig" rid="pcbi-1002195-g005">Figure 5</xref> looks at a range of different queries of different lengths.</p>
        <fig id="pcbi-1002195-g005" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002195.g005</object-id>
          <label>Figure 5</label>
          <caption>
            <title>Speed benchmarks.</title>
            <p>Each point represents a speed measurement for one search with one query against <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e257" xlink:type="simple"/></inline-formula> target sequences (<inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e258" xlink:type="simple"/></inline-formula> for the slow HMMER2 and SAM programs, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e259" xlink:type="simple"/></inline-formula> for FASTA and SSEARCH), on a single CPU core (see Methods for more details). Both axes are logarithmic, for speed in millions of dynamic programming cells per second (Mc/s) on the y-axis and query length in residues on the x-axis. Panel A shows “typical best performance” speed measurements for several different programs including HMMER3, for 76 queries of varying consensus lengths, chosen from Pfam 24, for searches of randomized (shuffled) target sequences. Panel B shows a wider range of more realistic speed measurements for all 11,912 profiles in Pfam 24, on searches of real target protein sequences from UniProt TrEMBL.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.g005" xlink:type="simple"/>
        </fig>
        <p>To measure the “typical” performance of each program, without complicating variation arising from producing the voluminous alignment output for some queries that hit large protein superfamilies, panel A (left) shows benchmarks done on random (shuffled) target sequences. The panel shows results for 76 query profiles (or representative single sequences), chosen to sample the full range of query lengths in the Pfam protein domain database from 7 to 2,217 residues. These results show that HMMER3 performance is comparable to other fast database search programs; somewhat slower (by about 2- to 3-fold) than NCBI BLAST, and somewhat faster (by about 3-fold) than WU-BLAST, for example. The speed of SSEARCH, the Smith/Waterman local alignment implementation in the FASTA package, is worth noting in this figure; SSEARCH has recently been accelerated by implementing Farrar's striped SIMD vector methods, allowing it to achieve speed comparable to the heuristic FASTA and WU-BLAST programs. HMMER3 is faster than HMMER2 by up to 140×, even though HMMER3 calculates full Forward scores whereas HMMER2 calculated faster Viterbi optimal alignment scores. Compared to SAM, which does calculate full Forward scores, HMMER3 is about 600× faster.</p>
        <p>To measure a wider and more realistic range of real-world performance, panel B (right) shows benchmarks for 11,912 different queries (every Pfam 24 profile) on real sequences from UniProt TrEMBL. Programs that simply do a dynamic programming alignment to each target sequence, such as HMMER2 (orange points) or SSEARCH (not shown), show performance essentially independent of the properties of the query and target sequences. Programs that use heuristics and filters, however, are sensitive to how well a given search obeys the assumptions of the heuristic and/or filter thresholds. Both HMMER3 and PSI-BLAST speed vary not only by query length, but also vary substantially around their average for a given query length. PSI-BLAST speed in panel B varies both up (by up to about 3-fold) and down (by up to about 10-fold) from its “typical” performance in panel A, presumably reflecting variation in how many word hits and hit extensions need to be processed for a given search. HMMER3 speed tends to vary only downwards from its typical performance, by up to about 20-fold. In panel B, I highlight examples of four poorest-performing HMMER3 searches, on the DivIC, DUF972, IncA, and MFS_1 models. Even with the bias filter step included in the acceleration pipeline, the dominant cause of poorer HMMER3 search performance remains biased composition sequences (such as transmembrane proteins) in which more comparisons pass the fast filters of the acceleration pipeline than expected by P-value calculations that assume average target sequence compositions, causing more comparisons to reach the compute-intensive Forward/Backward calculations.</p>
      </sec>
      <sec id="s2j">
        <title>Sensitivity/specificity benchmarking</title>
        <p>A filtering approach will generally compromise search sensitivity by some degree, because a filter will erroneously remove true homologs at some rate. We want this rate to be negligible. To measure how much search sensitivity is attenuated by the use of the MSV filter and the HMMER3 acceleration pipeline, I performed benchmarks to compare sensitivity/specificity of default HMMER3 hmmsearch (with the acceleration filter pipeline) to hmmsearch --max, an option that turns off all the filters and runs the full Forward scoring algorithm on every target sequence. I also benchmarked HMMER2 and several other homology search programs for comparison. These results are shown in <xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6</xref>.</p>
        <fig id="pcbi-1002195-g006" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002195.g006</object-id>
          <label>Figure 6</label>
          <caption>
            <title>Benchmark of search sensitivity and specificity.</title>
            <p>For different programs, searches are performed either by constructing a single profile from the query alignment (HMMER3, HMMER2, SAM, PSI-BLAST), or by using “family pairwise search” <xref ref-type="bibr" rid="pcbi.1002195-Grundy1">[41]</xref> in which each individual sequence is used as a query and the best E-value per target sequence is recorded (BLASTP, SSEARCH, FASTA). In each benchmark, true positive subsequences have been selected to be no more than 25% identical to any sequence in the query alignment (see Methods). Panel A shows results where nonhomologous sequence has been synthesized by a simple random model, and each true positive sequence contains a single embedded homologous subsequence (a total of 2,141 query multiple alignments, 11,547 true positive sequences, and 200,000 decoys). Panel B shows results where nonhomologous sequence is synthesized by shuffling randomly chosen subsequences from UniProt, and each true positive contains two embedded homologous subsequences (a total of 2,141 query alignments, 24,040 true positive sequences, and 200,000 decoys). The Y-axis is the fraction of true positives detected with an E-value better than the number of false positives per query specified on the X-axis.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002195.g006" xlink:type="simple"/>
        </fig>
        <p>These benchmarks are automatically and semi-randomly generated by a program (create-profmark). The program starts from a source of trusted alignments of homologous protein domains (here, Pfam 24 seed alignments), a source of typical full-length protein sequences (here, UniProt SwissProt 2011_03), and a choice of method for synthesizing nonhomologous sequence segments (such as shuffling a randomly chosen segment of a UniProt sequence). A query alignment and a set of true test domains (trusted to be homologous to the query) is created by applying single-linkage-clustering by percent identity to a Pfam alignment, and using that clustering to select sequences such that no true test domain has more than 25% pairwise identity to any sequence in the query alignment, and no more than 50% pairwise identity to any other test domain. True test sequences are created by concatenating one or two test domains together with nonhomologous sequence segments, with a total sequence length sampled from the distribution of UniProt sequences. False (nonhomologous) test sequences are created by concatenating nonhomologous sequence segments, with both segment length and total sequence length sampled from the length distributions of the true test sequences. The procedure, its rationale, and some of its caveats are described in more detail in Methods.</p>
        <p>To benchmark a profile method (HMMER, SAM, or PSI-BLAST), a profile is built from each query alignment and searched against the target database of test sequences and decoys. The results of all searches (for all different queries) are merged and sorted by E-value, and this ranked list is used to calculate a plot of fraction of true positives detected at increasing thresholds of false positives per query from 0.001 to 10.</p>
        <p>To benchmark a single-sequence query method (BLAST, SSEARCH, FASTA) more fairly against profile methods, a family-pairwise-search (FPS) method is used <xref ref-type="bibr" rid="pcbi.1002195-Grundy1">[41]</xref> (as opposed to selecting just one query sequence from the alignment). Each individual sequence in the query alignment is searched against the target database; the best E-value found to any query sequence is treated as the E-value of the target sequence, and results for all queries are merged, sorted, and treated as above.</p>
        <p><xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6</xref> shows results for two different benchmarks. Panel A shows results where true test sequences have a single embedded domain, and nonhomologous sequences are synthesized as i.i.d. (independent identically distributed) random sequence from the average UniProt residue frequency distribution; there are 2,141 query alignments, 11,547 true test sequences, and 200,000 decoys. Because nonhomologous sequences are unrealistically simple (no biased composition, no repetitive sequence), this benchmark does not exercise the various corrections for biased composition that some programs have (such as HMMER and BLAST), and is more of a baseline test of the best-case sensitivity of a search program. Panel B shows results of my default profmark benchmark, where there are two embedded domains per true test sequence (in order to test the ability of a program to correctly detect and align multiple domains per sequence, although such results are not shown here), and where nonhomologous sequence segments are created by shuffling randomly chosen segments of UniProt sequences. Because nonhomologous segments in this benchmark can show more realistic monoresidue composition biases (though not higher-order bias such as tandem repeats), this version of the benchmark is more realistic and exercises more <italic>ad hoc</italic> parts of programs that try to correct for biased composition. Panel A shows results that are largely independent of biased composition issues, but less realistic. Panel B shows results that are more dependent on the ability of a program to handle biased composition, and probably more realistic.</p>
        <p>The main result in both panels is that sensitivity and specificity are essentially identical for HMMER3 either with the acceleration pipeline (dark black lines) and without it (--max; red lines). There is a slight loss in sensitivity caused by the acceleration pipeline, but this loss is more than compensated by the gain in sensitivity of HMMER3 over HMMER2 (either in its default “glocal” alignment search mode or its local alignment search mode; orange circles and squares respectively). At high specificity (low false positive rates) on more realistic biased decoys, default HMMER3 can appear to be better than unfiltered HMMER3 (hmmsearch --max) because the bias filter removes some problematic biased false positive decoys that the supposedly more powerful biased composition corrections in HMMER3 Forward scores fail to correct.</p>
        <p>Benchmarks for other programs (such as BLAST, SAM, FASTA, and SSEARCH) are shown only for the sake of rough comparison. The intent is not to thoroughly benchmark HMMER against these programs, but to provide an additional sense of scale, putting the difference between HMMER3 with and without its acceleration pipeline in context – that is, showing that the difference between HMMER3 with and without its acceleration pipeline is minor, compared to differences among programs. These programs were only run in their default configuration. I did not explore available options that might improve their performance on this benchmark. Although I believe the results to be fair and representative, I have to interpret these results with caution. I benchmark HMMER routinely on these benchmarks during development. It is impossible to avoid some degree of training on the benchmark, even though the benchmarks are somewhat randomized. Nonetheless, some informative trends in these results agree with previous independent published benchmarking from other groups, so the comparisons are probably useful as a rough guide. For example, Madera and Gough published a benchmark <xref ref-type="bibr" rid="pcbi.1002195-Madera1">[28]</xref> in which they concluded that SAM significantly outperformed HMMER2, which at the time disagreed with my experience. Johnson <xref ref-type="bibr" rid="pcbi.1002195-Johnson2">[29]</xref> traced this to the fact that Madera and Gough had switched HMMER2 from its default glocal alignment mode to its nondefault local search mode, which we had not spent much time testing or tuning, and we had not previously realized how sensitive local alignment is to the model's information content per position. This led us to realize how important SAM's entropy-weighting technique is for local alignment, whereas it is much less important in glocal alignment <xref ref-type="bibr" rid="pcbi.1002195-Johnson2">[29]</xref>. This story is reflected in the benchmarks in <xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6</xref>, where HMMER2 <italic>local</italic> alignment performs poorly relative to SAM, HMMER2 <italic>glocal</italic> alignment is comparable to SAM, and HMMER3 local alignment (with the entropy-weighting technique) is perhaps a bit better than SAM. Most of the difference between HMMER3 and SAM is in the high-specificity regime of the more realistic benchmark that includes biased-composition segments (Panel B), and thus is likely to result from differences in the <italic>ad hoc</italic> bias composition corrections that differ between SAM and HMMER, rather than any fundamental difference in their profile HMM parameterizations or their Forward scoring algorithms, which I believe are quite similar.</p>
        <p>Another story reflected in these benchmarks is about the widespread belief that full Smith/Waterman alignment is superior to BLAST's fast heuristic approximation of Smith/Waterman. This is true in the easier benchmark (Panel A) but not when decoy sequences include biased composition segments (Panel B). Indeed, in Panel A all three fast sequence search programs (WU-BLAST, NCBI-BLAST, and FASTA) perform comparably (and worse than SSEARCH), whereas in Panel B, NCBI BLAST outperforms WU-BLAST, FASTA, and SSEARCH. This again seems likely to be showing the importance of biased composition score corrections. Biased composition correction has received close attention in NCBI BLAST software development <xref ref-type="bibr" rid="pcbi.1002195-Schffer1">[7]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Altschul4">[8]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Gertz1">[42]</xref>, but is not part of the textbook description of “optimal” Smith/Waterman local alignment.</p>
        <p>My main conclusion (that the acceleration pipeline has a negligible impact on the sensitivity/specificity of HMMER3 compared to unaccelerated Forward scoring) is supported by a more direct experiment. I searched all 11,912 Pfam 24 profile HMMs against the 516,081 sequences in UniProt SwissProt 2011_03 using five different option settings to hmmsearch, starting with --max and then successively turning on one filter step at a time in the acceleration pipeline (MSV, bias, Viterbi, and Forward), up to the default configuration with all four filter steps on. With --max, a total of 799,893 hits were found with an E-value of 0.0001 or less. Turning on the MSV filter loses 718 hits (0.09%). Overall, the default pipeline with all filter steps loses 2,701 hits (0.3%). Differences in significant hits are not necessarily all due to true homologs. It is possible for the unfiltered search to find a false positive that one or more of the filters would remove. However, the majority of these differences appear to be true homologs that are removed by the filters. Other than the 718 hits removed by the MSV filter, the great majority of the other losses are due to the bias filter inappropriately removing sequences that have strong biased compositions, but also contain a true homology region. The most obvious problems with HMMER3 sensitivity/specificity seem to lie in its bias filter and bias composition score corrections, rather than in the use of the MSV filter as its primary acceleration.</p>
      </sec>
    </sec>
    <sec id="s3">
      <title>Discussion</title>
      <p>In describing the MSV heuristic and other acceleration methods implemented in HMMER3, I have not addressed the question of whether the MSV heuristic is better or worse than other heuristics, such as those in BLAST or FASTA. In sensitivity/specificity benchmarks (<xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6</xref>), BLAST and FASTA perform about the same as unaccelerated Smith/Waterman, and HMMER3 performs about the same with and without its acceleration pipeline. This show that the overall sensitivity and specificity of these programs are not limited by their respective heuristics, but rather by their fundamental (unaccelerated) sequence comparison methods. Thus a better heuristic would be unlikely to improve overall sensitivity/specificity. A better heuristic would be a faster one with the same sensitivity/specificity. In a question about speed, we cannot satisfactorily show that one algorithm is necessarily faster than another. We can only rigorously compare particular implementations. Trying to mix and match different heuristic approaches and make definitive comparisons of their fully optimized speeds requires a time-consuming engineering and optimization effort dedicated to each implementation. So it remains an open question whether, for example, BLAST-style heuristics could be tuned to have enough sensitivity/specificity to match HMMER3 performance while still being faster. I developed MSV because it was easy for me, not because I tried different heuristics and found MSV to be better. I was working on striped SIMD vectorization of the Viterbi algorithm, and an MSV implementation is easily derived from striped SIMD Viterbi just by deleting the code that handles deletions and insertions. The heuristic approaches in BLAST and FASTA have the advantage of focusing subsequent slower computations on particular diagonals, whereas in HMMER's current approach, we wastefully recalculate full sequence alignments at each step of the acceleration pipeline. I expect that it will be fruitful to develop heuristics focused around high-likelihood diagonals, as BLAST and FASTA do, while using HMMER's SIMD vectorization methods.</p>
      <p>Although this paper is about the acceleration methods used in HMMER3, HMMER3 also appears to be more sensitive than HMMER2. The main reason for this is the adoption of “entropy-weighting”, a method introduced by the UC Santa Cruz group in the SAM profile HMM package <xref ref-type="bibr" rid="pcbi.1002195-Johnson2">[29]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Karplus1">[37]</xref>, where the information content per position is reduced to a specified target number of bits. A second reason is the switch from Viterbi optimal alignment scores to Forward scores summed over the alignment ensemble <xref ref-type="bibr" rid="pcbi.1002195-Johnson2">[29]</xref>.</p>
      <p>On the other hand, I believe that the switch from default glocal alignment in HMMER2 to local alignment in HMMER3 has probably compromised some search sensitivity (“glocal” means global in the query, local in the target sequence: requiring a full-length domain alignment). Restoring glocal alignment to HMMER3 should improve search performance for profiles that are expected to match over their entire length, such as Pfam protein domain models. However, the fast E-value statistics for Forward and Viterbi scores (including MSV filter scores) are only valid for local alignment, and the numeric underflow analysis of the sparse rescaling technique in the Forward/Backward implementation assumes local alignment. Both problems will need to be addressed before glocal alignment is implemented usefully in HMMER3.</p>
      <p>Here I have only described single-core performance. I have not discussed parallelization across multiple cores. HMMER3 search programs include rudimentary implementations of POSIX threads and MPI parallelization (message-passing in a cluster of computing nodes). These implementations currently scale poorly, to only modest numbers of processor cores (2–4 for multithreading, for example). Improved parallelization is a priority for future development.</p>
      <p>HMMER3's handling of biased composition sequences is problematic. I chose to introduce an <italic>ad hoc</italic> “bias filter” into the acceleration pipeline, to deal with a small number of profiles that let too many sequences through the MSV filter and bog down in the slow Forward/Backward stages of the pipeline. The bias filter occasionally filters true positive hits. A disturbing failure mode can occur when a target sequence consists of a homologous subsequence surrounded by a large amount of nonhomologous biased composition sequence; in this case, the bias filter may aggressively remove the entire sequence. Although other database search programs have analogous issues with over-aggressive composition masking, one future focus for HMMER3 development will be on improving its formal probability model of <italic>non</italic>homologous sequence.</p>
      <p>This paper describes an initial baseline for HMMER3 speed performance on a single processor core. The prospects for substantial future improvements are good. There are many obvious opportunities for incremental optimizations. Bjarne Knudsen (CLCbio, Aarhus, Denmark) has already contributed an important optimization of the MSV filter that increases overall HMMER3 speed by about two-fold. The Knudsen optimization will appear in the next HMMER code release, and we will likely describe it in a future manuscript. Another optimization opportunity is to preprocess the target database sequence file into an efficient binary format, as BLAST does with its BLAST databases. HMMER3 still reads standard flatfile sequence databases, such as FASTA and UniProt text formats. Another optimization opportunity is to convert the filters in the pipeline from their current mode of filtering entire target sequences (which was easy to implement) to instead store and retrieve more information about the location of alignment probability mass, so subsequent steps (including Forward/Backward) can be done as banded dynamic programming calculations within high-probability envelopes, as opposed to reprocessing the entire query/target comparison at each pipeline step. Because of these and other straightforward optimization opportunities, I expect HMMER3 speed will surpass NCBI BLAST speed in the relatively near future.</p>
      <p>This speed makes it feasible to apply profile HMM technology to standard sequence database searches with single sequence queries, including iterative database searches. A position-independent scoring system for single sequences is just a special case of a profiled position-specific scoring system. A “profile” HMM can be built from a single sequence, using position-independent probabilities obtained from standard scoring matrices such as BLOSUM62, plus a couple of parameters for gap-open and gap-extend probabilities. The HMMER3 software package includes a program <italic>phmmer</italic> for protein database searches akin to <italic>blastp</italic>, and a program <italic>jackhmmer</italic> for iterative protein database searches akin to <italic>psiblast</italic>. These programs, their parameterization, and the effect of extending profile HMM technology, the Forward algorithm, and probabilistic inference methods to routine sequence database searches will be described elsewhere.</p>
    </sec>
    <sec id="s4" sec-type="materials|methods">
      <title>Materials and Methods</title>
      <sec id="s4a">
        <title>Software implementation and availability</title>
        <p>HMMER3 is implemented in POSIX ANSI/ISO C99. Vector implementations are provided for Intel-compatible (SSE) and PowerPC (Altivec/VMX) processors. A “dummy” non-vectorized implementation is provided for other processors, sufficient to enable compilation but about 100× slower than normal HMMER3 vectorized performance. HMMER3 is portable to any POSIX-compliant operating system, including Linux and Mac OS/X, and also to Windows if an optional POSIX compatibility package has been installed (such as Cygwin). It builds from source using a standard GNU configure script and UNIX make. It includes a suite of automated tests written in Perl, C, and Bourne shell. User documentation is provided as PDF and man pages. Source code is freely available under a GNU GPLv3 license. Precompiled binary distributions are available for several platforms including Intel/Linux, Intel/MacOSX, and Intel/Windows. A web interface to HMMER3-based database searches is available, including batch searches and RESTful web services, hosted on computational resources supported by the Howard Hughes Medical Institute. All these resources are at <ext-link ext-link-type="uri" xlink:href="http://hmmer.janelia.org" xlink:type="simple">http://hmmer.janelia.org</ext-link>.</p>
      </sec>
      <sec id="s4b">
        <title>Software and database versions used</title>
        <p>Software versions used: SAM 3.5 (Jul 2005) <xref ref-type="bibr" rid="pcbi.1002195-Karplus1">[37]</xref>, NCBI BLAST+ 2.2.24+ (Aug 2010) <xref ref-type="bibr" rid="pcbi.1002195-Camacho1">[3]</xref>, FASTA 36.3.3 (Feb 2011) <xref ref-type="bibr" rid="pcbi.1002195-Pearson1">[40]</xref>, WU-BLAST 2.0MP-WashU (May 2006), HMMER 2.3.2 (Oct 2003), and HMMER 3.0 (Mar 2010).</p>
        <p>Example sequence alignments and profile HMMs were sampled from Seed alignments and profiles in Pfam 24 <xref ref-type="bibr" rid="pcbi.1002195-Finn1">[11]</xref>. Example target sequences were sampled from UniProt version 2011_03 <xref ref-type="bibr" rid="pcbi.1002195-The1">[43]</xref>. One experiment that characterized roundoff error used older versions, Pfam 22 and UniProt 7.0.</p>
      </sec>
      <sec id="s4c">
        <title>Speed benchmarking</title>
        <p>All program timings were measured in total (wall clock) time on a single execution thread (single core) of a dedicated and unloaded cluster node, where a node has eight 2.66 GHz Intel Gainestown X5550 cores and 24 GB RAM. The same search was run twice sequentially and timed in the second run, to allow filesystem caching of target databases.</p>
        <p>For speed benchmarks of programs that take a single sequence as a query (instead of an alignment), the median length sequence was extracted from the query alignment.</p>
      </sec>
      <sec id="s4d">
        <title>Construction of the sensitivity/specificity benchmark</title>
        <p>Sensitivity/specificity benchmarks were created with the create-profmark program, included in the HMMER3 source code. This program allows construction of the wide range of different and randomized benchmarks used during HMMER development. My concern is that because benchmarking is repeated at every step of code development, it is nearly impossible for a developer to avoid overtraining on any in-house benchmark. Synthesizing a variety of partially randomized benchmarks helps mitigate this effect somewhat, compared to relying on a single static benchmark.</p>
        <p>The profmark benchmarks use a set of trusted multiple alignments (such as Pfam Seed alignments) as a source of both <italic>query multiple alignments</italic> and distantly related <italic>true test sequences</italic> trusted to be homologous. The individual sequences in each input alignment are clustered by pairwise percent identity, and different clusters are selected to be queries versus test sequences such that no true test domain has more than 25% identity to any sequence in the query alignment, and no true test domain has more than 50% identity to another true test domain. To create realistic-length true test sequences, and to challenge the ability of a program to detect homologous local alignments in a larger target sequence, true test sequences are synthesized by embedding one or two test domains in a larger nonhomologous sequence.</p>
        <p>Using a sequence database like Pfam instead of a 3D structure database like SCOP or CATH as a source of trusted true homology relationships has the advantage that a more challenging variety of sequences is tested. Structure databases are biased toward well-ordered globular domains. A weakness of a sequence-based benchmark is that “true homologs” are inferred by current computational sequence comparison methods, rather than being defined by an independent criterion like 3D structure comparison. In particular, my profmark benchmarks are constructed from Pfam alignments as a trusted definition of true homologs, and Pfam is itself constructed with HMMER. There may be some danger that this circularity creates a bias against other search programs. Specifically the danger is that if there are remote homologs that are undetected by profile HMM methods, but that could be detected by another method, any such sequences have been selected against in Pfam. Intuitively, I think this danger is negligible. If a search program was sufficiently powerful that it could detect homologs excluded from Pfam, it ought to be even better at detecting the closer homologs that were included and artificially separated (by profmark's clustering procedure) into challengingly dissimilar query alignment and true test domains. Empirically too, any danger has seemed negligible, because profmark benchmarks tend to be broadly concordant with other published benchmarks <xref ref-type="bibr" rid="pcbi.1002195-Madera1">[28]</xref>, <xref ref-type="bibr" rid="pcbi.1002195-Price1">[44]</xref>. Nonetheless, I have more confidence in using profmark benchmarks for internal comparisons (HMMER vs. HMMER, for different option settings) than for comparisons to other search programs.</p>
        <p>False (decoy) sequences (including the nonhomologous flanking sequence around embedded test domains in true test sequences) are created synthetically. If we are trying to find methods that detect previously undetectable homologies, no source of real biological sequences will ever be reliably known to be nonhomologous to the benchmark, and we certainly do not want to penalize a powerful method that identifies new true relationships that are currently annotated as nonhomologous “false positives” <xref ref-type="bibr" rid="pcbi.1002195-Johnson2">[29]</xref>. One disadvantage of synthetic nonhomologous sequence is that it is difficult to create realistic sequences with the same challenging properties of real biological sequences, such as biased composition and repetitive sequence.</p>
        <p>In detail, the profmark creation procedure is the following, starting from a source of multiple alignments (usually Pfam seeds) and a source of typical single target sequences (usually UniProt/SwissProt):</p>
        <list list-type="bullet">
          <list-item>
            <p>Convert all degenerate residue characters to X. (Although HMMER reads all standard degeneracy codes for protein and nucleic acid sequences, some search programs do not.)</p>
          </list-item>
          <list-item>
            <p>Remove sequence fragments. By default, any sequence of length less than 70% of the mean unaligned sequence length in the alignment is defined as a fragment.</p>
          </list-item>
          <list-item>
            <p>Cluster the sequences by single-linkage clustering at a default threshold of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e260" xlink:type="simple"/></inline-formula>25% percent identity (defined as the number of identical residues divided by the shorter sequence length, in the given pairwise alignment). Between any two clusters, there is no pair of sequences closer than 25% identity. If there is only one cluster, exclude this alignment from the benchmark and skip to the next alignment. Define the largest cluster as the <italic>query</italic>. Save it to a file, in its original multiple alignment.</p>
          </list-item>
          <list-item>
            <p>Cluster the remaining sequences by single-linkage clustering at a default threshold of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002195.e261" xlink:type="simple"/></inline-formula>50% identity. If there are less than two clusters, exclude this alignment from the benchmark and skip to the next alignment. From each cluster, select one sequence at random. These are the <italic>true test domains</italic>.</p>
          </list-item>
          <list-item>
            <p>Create synthetic true test sequences by embedding one or two true test domains in a larger nonhomologous sequence. The total length of the test sequence is sampled from the length distribution of the input sequence database, conditional on being at least as long as the true test domain(s). True test domains are inserted at randomly sampled locations in the sequence. The remaining two or three nonhomologous sequence segments are synthesized as described below. Thus true test sequences are composed either of three segments (one homologous, two not) or five segments (two homologous, three not).</p>
          </list-item>
          <list-item>
            <p>The program implements a choice of several different methods for generating nonhomologous sequence segments. The default is “monoshuffling”: to select a sequence segment at random from the input sequence database and shuffle its residues, preserving 0th-order residue composition and bias. <xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6</xref> also shows the use of i.i.d. (independent identically distributed) synthetic sequence with each residue simply sampled from the average residue frequency distribution of proteins. Other options include reversed sequences and shuffling while preserving di-residue composition. Though more realistic, and useful when looking carefully and manually for failure modes, di-residue shuffling and reversed sequences are problematic as a source of nonhomologous segments in automated benchmarking. Exact di-residue shuffling preserves significant sequence identity to the original sequence over surprising segment lengths, and reversed sequences are surprisingly significantly more likely to show a significant match to the original sequence (because of a counterintuitive statistical effect of the frequency of approximate palindromes in any sequence).</p>
          </list-item>
          <list-item>
            <p>Decoys (negative sequences) are created by randomly selecting a true test sequence (solely to obtain its three or five segment lengths – not its sequence) then concatenating nonhomologous segments of the same lengths. The length distribution of negative sequences, and the length distribution of potentially biased nonhomologous subsequences embedded in them, is therefore matched to the distributions for the true test sequences.</p>
          </list-item>
        </list>
        <p>For the experiments in <xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6</xref>, the create-profmark procedure was applied to 11,912 Pfam 24 seed alignments <xref ref-type="bibr" rid="pcbi.1002195-Finn1">[11]</xref> and the UniProt/SwissProt sequence database (version 2011_03, 516,081 sequences) <xref ref-type="bibr" rid="pcbi.1002195-The1">[43]</xref> either with options –iid –mono (<xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6A</xref>) or default (<xref ref-type="fig" rid="pcbi-1002195-g006">Figure 6B</xref>). The benchmark in panel A is composed of 2,141 query alignments, 24,040 true test sequences containing single homologous domains, and 200,000 decoys. The benchmark in panel B is composed of 2,141 query alignments, 11,547 true test sequences containing two homologous domains, and 200,000 decoys.</p>
      </sec>
    </sec>
  </body>
  <back>
    <ack>
      <p>Jeremy Buhler and Christopher Swope (Washington University, St. Louis) contributed important optimizations for the Viterbi and Forward implementations in HMMER2. Erik Lindahl (Stanford) contributed the first SIMD vector implementation of HMMER2, for PowerPC processors with VMX/Altivec instructions. Alex Coventry (Cornell), Steve Johnson (Washington Univ., St. Louis), and Elon Portugaly (Hebrew University) did exploratory work that led to the HMMER3 project. Bjarne Knudsen (CLCbio, Denmark) has contributed several optimizations and suggestions based on a careful analysis of the HMMER3 source code. Elena Rivas (Janelia Farm) contributed numerous clarifications and improvements to the source code in the course of reimplementing the core of HMMER3 for continuous emission variables for modeling mouse vocalizations. Although space permits only these brief personal acknowledgments, a great many others have contributed to the development of HMMER3, and I also thank this wide community of developers and users. Goran Ceric provided masterful support of Janelia Farm's high performance computing resources. Heidi Henning, HHMI deputy general counsel, provided invaluable legal assistance on open source issues. HMMER is a trademarked open source project supported by the Howard Hughes Medical Institute. I dedicate this paper to the memory of my colleague and friend Michael Farrar, principal software engineer on the HMMER3 project, who died unexpectedly in December 2010.</p>
    </ack>
    <ref-list>
      <title>References</title>
      <ref id="pcbi.1002195-Altschul1">
        <label>1</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name><name name-style="western"><surname>Gish</surname><given-names>W</given-names></name><name name-style="western"><surname>Miller</surname><given-names>W</given-names></name><name name-style="western"><surname>Myers</surname><given-names>EW</given-names></name><name name-style="western"><surname>Lipman</surname><given-names>DJ</given-names></name></person-group>             <year>1990</year>             <article-title>Basic local alignment search tool.</article-title>             <source>J Mol Biol</source>             <volume>215</volume>             <fpage>403</fpage>             <lpage>410</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Altschul2">
        <label>2</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name><name name-style="western"><surname>Madden</surname><given-names>TL</given-names></name><name name-style="western"><surname>Schaffer</surname><given-names>AA</given-names></name><name name-style="western"><surname>Zhang</surname><given-names>J</given-names></name><name name-style="western"><surname>Zhang</surname><given-names>Z</given-names></name><etal/></person-group>             <year>1997</year>             <article-title>Gapped BLAST and PSIBLAST: A new generation of protein database search programs.</article-title>             <source>Nucleic Acids Res</source>             <volume>25</volume>             <fpage>3389</fpage>             <lpage>3402</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Camacho1">
        <label>3</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Camacho</surname><given-names>C</given-names></name><name name-style="western"><surname>Coulouris</surname><given-names>G</given-names></name><name name-style="western"><surname>Avagyan</surname><given-names>V</given-names></name><name name-style="western"><surname>Ma</surname><given-names>N</given-names></name><name name-style="western"><surname>Papadopoulos</surname><given-names>J</given-names></name><etal/></person-group>             <year>2009</year>             <article-title>BLAST+: Architecture and applications.</article-title>             <source>BMC Bioinformatics</source>             <volume>10</volume>             <fpage>421</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Krogh1">
        <label>4</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Krogh</surname><given-names>A</given-names></name><name name-style="western"><surname>Brown</surname><given-names>M</given-names></name><name name-style="western"><surname>Mian</surname><given-names>IS</given-names></name><name name-style="western"><surname>Sjölander</surname><given-names>K</given-names></name><name name-style="western"><surname>Haussler</surname><given-names>D</given-names></name></person-group>             <year>1994</year>             <article-title>Hidden Markov models in computational biology: Applications to protein modeling.</article-title>             <source>J Mol Biol</source>             <volume>235</volume>             <fpage>1501</fpage>             <lpage>1531</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Durbin1">
        <label>5</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name><name name-style="western"><surname>Eddy</surname><given-names>SR</given-names></name><name name-style="western"><surname>Krogh</surname><given-names>A</given-names></name><name name-style="western"><surname>Mitchison</surname><given-names>GJ</given-names></name></person-group>             <year>1998</year>             <source>Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids</source>             <publisher-loc>Cambridge UK</publisher-loc>             <publisher-name>Cambridge University Press</publisher-name>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Altschul3">
        <label>6</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name><name name-style="western"><surname>Bundschuh</surname><given-names>R</given-names></name><name name-style="western"><surname>Olsen</surname><given-names>R</given-names></name><name name-style="western"><surname>Hwa</surname><given-names>T</given-names></name></person-group>             <year>2001</year>             <article-title>The estimation of statistical parameters for local alignment score distributions.</article-title>             <source>Nucleic Acids Res</source>             <volume>29</volume>             <fpage>351</fpage>             <lpage>361</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Schffer1">
        <label>7</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Schäffer</surname><given-names>AA</given-names></name><name name-style="western"><surname>Aravind</surname><given-names>L</given-names></name><name name-style="western"><surname>Madden</surname><given-names>TL</given-names></name><name name-style="western"><surname>Shavirin</surname><given-names>S</given-names></name><name name-style="western"><surname>Spouge</surname><given-names>JL</given-names></name><etal/></person-group>             <year>2001</year>             <article-title>Improving the accuracy of PSI-BLAST protein database searches with composition-based statistics and other refinements.</article-title>             <source>Nucleic Acids Res</source>             <volume>29</volume>             <fpage>2994</fpage>             <lpage>3005</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Altschul4">
        <label>8</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name><name name-style="western"><surname>Wootton</surname><given-names>JC</given-names></name><name name-style="western"><surname>Gertz</surname><given-names>EM</given-names></name><name name-style="western"><surname>Agarwala</surname><given-names>R</given-names></name><name name-style="western"><surname>Morgulis</surname><given-names>A</given-names></name><etal/></person-group>             <year>2005</year>             <article-title>Protein database searches using compositionally adjusted substitution matrices.</article-title>             <source>FEBS J</source>             <volume>272</volume>             <fpage>5101</fpage>             <lpage>5109</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Yu1">
        <label>9</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Yu</surname><given-names>YK</given-names></name><name name-style="western"><surname>Gertz</surname><given-names>EM</given-names></name><name name-style="western"><surname>Agarwala</surname><given-names>R</given-names></name><name name-style="western"><surname>Schäffer</surname><given-names>AA</given-names></name><name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name></person-group>             <year>2006</year>             <article-title>Retrieval accuracy, statistical significance and compositional similarity in protein sequence database searches.</article-title>             <source>Nucleic Acids Res</source>             <volume>34</volume>             <fpage>5966</fpage>             <lpage>5973</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Hunter1">
        <label>10</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hunter</surname><given-names>S</given-names></name><name name-style="western"><surname>Apweiler</surname><given-names>R</given-names></name><name name-style="western"><surname>Attwood</surname><given-names>TK</given-names></name><name name-style="western"><surname>Bairoch</surname><given-names>A</given-names></name><name name-style="western"><surname>Bateman</surname><given-names>A</given-names></name><etal/></person-group>             <year>2009</year>             <article-title>InterPro: the integrative protein signature database.</article-title>             <source>Nucleic Acids Res</source>             <volume>37</volume>             <fpage>D211</fpage>             <lpage>D215</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Finn1">
        <label>11</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Finn</surname><given-names>RD</given-names></name><name name-style="western"><surname>Mistry</surname><given-names>J</given-names></name><name name-style="western"><surname>Tate</surname><given-names>J</given-names></name><name name-style="western"><surname>Coggill</surname><given-names>P</given-names></name><name name-style="western"><surname>Heger</surname><given-names>A</given-names></name><etal/></person-group>             <year>2010</year>             <article-title>The Pfam protein families database.</article-title>             <source>Nucleic Acids Res</source>             <volume>38</volume>             <fpage>D211</fpage>             <lpage>D222</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Chaudhary1">
        <label>12</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Chaudhary</surname><given-names>V</given-names></name><name name-style="western"><surname>Liu</surname><given-names>F</given-names></name><name name-style="western"><surname>Matta</surname><given-names>V</given-names></name><name name-style="western"><surname>Meng</surname><given-names>X</given-names></name><name name-style="western"><surname>Nambiar</surname><given-names>A</given-names></name><etal/></person-group>             <year>2006</year>             <article-title>Parallel implementations of local sequence alignment: Hardware and software.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Zomaya</surname><given-names>AY</given-names></name></person-group>             <source>Parallel Computing for Bioinformatics and Computational Biology</source>             <publisher-loc>Sydney, Australia</publisher-loc>             <publisher-name>John Wiley &amp; Sons, Inc., chapter 10</publisher-name>             <fpage>233</fpage>             <lpage>264</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Walters1">
        <label>13</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Walters</surname><given-names>JP</given-names></name><name name-style="western"><surname>Qudah</surname><given-names>B</given-names></name><name name-style="western"><surname>Chaudhary</surname><given-names>V</given-names></name></person-group>             <year>2006</year>             <article-title>Accelerating the HMMER sequence analysis suite using conventional processors.</article-title>             <comment>In Proceedings of the 20th International Conference on Advanced Information Networking and Applications; 18–20 April 2006; Vienna, Austria. AINA 2006. Available: <ext-link ext-link-type="uri" xlink:href="http://www.computer.org/portal/web/csdl/doi/10.1109/AINA.2006.68" xlink:type="simple">http://www.computer.org/portal/web/csdl/doi/10.1109/AINA.2006.68</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Landman1">
        <label>14</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Landman</surname><given-names>J</given-names></name><name name-style="western"><surname>Ray</surname><given-names>J</given-names></name><name name-style="western"><surname>Walters</surname><given-names>JP</given-names></name></person-group>             <year>2006</year>             <article-title>Accelerating HMMer searches on Opteron processors with minimally invasive recoding.</article-title>             <comment>In Proceedings of the 20th International Conference on Advanced Information Networking and Applications; 18–20 April 2006; Vienna, Austria. AINA 2006. Available: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/AINA.2006.67" xlink:type="simple">http://dx.doi.org/10.1109/AINA.2006.67</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Sachdeva1">
        <label>15</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Sachdeva</surname><given-names>V</given-names></name><name name-style="western"><surname>Kistler</surname><given-names>M</given-names></name><name name-style="western"><surname>Speight</surname><given-names>E</given-names></name><name name-style="western"><surname>Tzeng</surname><given-names>THK</given-names></name></person-group>             <year>2007</year>             <article-title>Exploring the viability of the Cell Broadband Engine for bioinformatics applications.</article-title>             <source>Parallel Comput</source>             <volume>34</volume>             <fpage>616</fpage>             <lpage>626</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Maddimsetty1">
        <label>16</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Maddimsetty</surname><given-names>RP</given-names></name></person-group>             <year>2006</year>             <source>Acceleration of Profile-HMM Search for Protein Sequences in Reconfigurable Hardware [Master's thesis]</source>             <publisher-loc>(St. Louis)</publisher-loc>             <publisher-name>Department of Computer Science and Engineering, Washington University in St. Louis</publisher-name> <!--===== Restructure page-count as size[@units="page"] =====--><size units="page">70</size>           </element-citation>
      </ref>
      <ref id="pcbi.1002195-Derrien1">
        <label>17</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Derrien</surname><given-names>S</given-names></name><name name-style="western"><surname>Quinton</surname><given-names>P</given-names></name></person-group>             <year>2007</year>             <article-title>Parallelizing HMMER for hardware acceleration on FPGAs.</article-title>             <comment>In Proceedings of the 18th IEEE International Conference on Application-Specific Systems, Architectures, and Processors; 9–11 July 2008; Montreal, Quebec. ASAP 2007. Available: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/ASAP.2007.4429951" xlink:type="simple">http://dx.doi.org/10.1109/ASAP.2007.4429951</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Jacob1">
        <label>18</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Jacob</surname><given-names>A</given-names></name><name name-style="western"><surname>Lancaster</surname><given-names>J</given-names></name><name name-style="western"><surname>Buhler</surname><given-names>J</given-names></name><name name-style="western"><surname>Chamberlain</surname><given-names>RD</given-names></name></person-group>             <year>2007</year>             <article-title>Preliminary results in accelerating profile HMM search on FPGAs.</article-title>             <comment>In Proceedings of the 21st IEEE International Parallel and Distributed Processing Symposium; 26–30 March 2007; Long Beach, California, United States. IPDPS 2007. Available: <ext-link ext-link-type="uri" xlink:href="http://www.computer.org/portal/web/csdl/doi/10.1109/IPDPS.2007.370447" xlink:type="simple">http://www.computer.org/portal/web/csdl/doi/10.1109/IPDPS.2007.370447</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Oliver1">
        <label>19</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Oliver</surname><given-names>T</given-names></name><name name-style="western"><surname>Yeow</surname><given-names>LY</given-names></name><name name-style="western"><surname>Schmidt</surname><given-names>B</given-names></name></person-group>             <year>2007</year>             <article-title>High performance database searching with HMMer on FPGAs.</article-title>             <comment>In Proceedings of the 21st IEEE International Parallel and Distributed Processing Symposium; 26–30 March 2007; Long Beach, California, United States. IPDPS 2007. Available: <ext-link ext-link-type="uri" xlink:href="http://www.computer.org/portal/web/csdl/doi/10.1109/IPDPS.2007.370448" xlink:type="simple">http://www.computer.org/portal/web/csdl/doi/10.1109/IPDPS.2007.370448</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Horn1">
        <label>20</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Horn</surname><given-names>DR</given-names></name><name name-style="western"><surname>Houston</surname><given-names>M</given-names></name><name name-style="western"><surname>Hanrahan</surname><given-names>P</given-names></name></person-group>             <year>2005</year>             <article-title>ClawHMMER: A streaming HMMer-search implementation.</article-title>             <comment>In Proceedings of the ACM/IEEE Conference on Supercomputing; 12–18 November 2005; Seattle, Washington, United States. SC 2005. Available: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/SC.2005.18" xlink:type="simple">http://dx.doi.org/10.1109/SC.2005.18</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Walters2">
        <label>21</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Walters</surname><given-names>JP</given-names></name><name name-style="western"><surname>Balu</surname><given-names>V</given-names></name><name name-style="western"><surname>Kompalli</surname><given-names>S</given-names></name><name name-style="western"><surname>Chaudhary</surname><given-names>V</given-names></name></person-group>             <year>2009</year>             <article-title>Evaluating the use of GPUs in liver image segmentation and HMMER database searches.</article-title>             <comment>In Proceedings of the 23rd IEEE International Symp. on Parallel &amp; Distributed Processing; 23–29 May 2009; Rome, Italy. IPDPS 2009. Available: <ext-link ext-link-type="uri" xlink:href="http://www.computer.org/portal/web/csdl/doi/10.1109/IPDPS.2009.5161073" xlink:type="simple">http://www.computer.org/portal/web/csdl/doi/10.1109/IPDPS.2009.5161073</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Chukkapalli1">
        <label>22</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Chukkapalli</surname><given-names>G</given-names></name><name name-style="western"><surname>Guda</surname><given-names>C</given-names></name><name name-style="western"><surname>Subramaniam</surname><given-names>S</given-names></name></person-group>             <year>2004</year>             <article-title>SledgeHMMER: A web server for batch searching the Pfam database.</article-title>             <source>Nucleic Acids Res</source>             <volume>32</volume>             <fpage>W542</fpage>             <lpage>W544</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Rekapalli1">
        <label>23</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Rekapalli</surname><given-names>B</given-names></name><name name-style="western"><surname>Halloy</surname><given-names>C</given-names></name><name name-style="western"><surname>Zhulin</surname><given-names>IB</given-names></name></person-group>             <year>2009</year>             <article-title>HSP-HMMER: A tool for protein identification on a large scale.</article-title>             <comment>In Proceedings of the 24th ACM Symposium on Applied Computing; 9–12 March 2009; Honolulu, Hawaii, United States. SAC 2009. Available: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1145/1529282.1529443" xlink:type="simple">http://dx.doi.org/10.1145/1529282.1529443</ext-link>. Accessed 22 August 2011</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Sun1">
        <label>24</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Sun</surname><given-names>Y</given-names></name><name name-style="western"><surname>Buhler</surname><given-names>J</given-names></name></person-group>             <year>2007</year>             <article-title>Designing patterns for profile HMM search.</article-title>             <source>Bioinformatics</source>             <volume>23</volume>             <fpage>e36</fpage>             <lpage>e43</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Sun2">
        <label>25</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Sun</surname><given-names>Y</given-names></name><name name-style="western"><surname>Buhler</surname><given-names>J</given-names></name></person-group>             <year>2009</year>             <article-title>Designing patterns and profiles for faster HMM search.</article-title>             <source>IEEE/ACM Trans Comput Biol Bioinform</source>             <volume>6</volume>             <fpage>232</fpage>             <lpage>243</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Johnson1">
        <label>26</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Johnson</surname><given-names>LS</given-names></name><name name-style="western"><surname>Eddy</surname><given-names>SR</given-names></name><name name-style="western"><surname>Portugaly</surname><given-names>E</given-names></name></person-group>             <year>2010</year>             <article-title>Hidden Markov model speed heuristic and iterative HMM search procedure.</article-title>             <source>BMC Bioinformatics</source>             <volume>11</volume>             <fpage>431</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Smith1">
        <label>27</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Smith</surname><given-names>TF</given-names></name><name name-style="western"><surname>Waterman</surname><given-names>MS</given-names></name></person-group>             <year>1981</year>             <article-title>Identification of common molecular subsequences.</article-title>             <source>J Mol Biol</source>             <volume>147</volume>             <fpage>195</fpage>             <lpage>197</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Madera1">
        <label>28</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Madera</surname><given-names>M</given-names></name><name name-style="western"><surname>Gough</surname><given-names>J</given-names></name></person-group>             <year>2002</year>             <article-title>A comparison of profile hidden Markov model procedures for remote homology detection.</article-title>             <source>Nucleic Acids Res</source>             <volume>30</volume>             <fpage>4321</fpage>             <lpage>4328</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Johnson2">
        <label>29</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Johnson</surname><given-names>S</given-names></name></person-group>             <year>2006</year>             <source>Remote Protein Homology Detection Using Hidden Markov Models [Ph.D. thesis]</source>             <publisher-loc>(St. Louis)</publisher-loc>             <publisher-name>Washington University School of Medicine, Washington University in St. Louis</publisher-name> <!--===== Restructure page-count as size[@units="page"] =====--><size units="page">92</size>           </element-citation>
      </ref>
      <ref id="pcbi.1002195-Freyhult1">
        <label>30</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Freyhult</surname><given-names>EK</given-names></name><name name-style="western"><surname>Bollback</surname><given-names>JP</given-names></name><name name-style="western"><surname>Gardner</surname><given-names>PP</given-names></name></person-group>             <year>2007</year>             <article-title>Exploring genomic dark matter: A critical assessment of the performance of homology search methods on noncoding RNA.</article-title>             <source>Genome Res</source>             <volume>17</volume>             <fpage>117</fpage>             <lpage>125</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Eddy1">
        <label>31</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Eddy</surname><given-names>SR</given-names></name></person-group>             <year>2008</year>             <article-title>A probabilistic model of local sequence alignment that simplifies statistical significance estimation.</article-title>             <source>PLoS Comput Biol</source>             <volume>4</volume>             <fpage>e1000069</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Rognes1">
        <label>32</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Rognes</surname><given-names>T</given-names></name></person-group>             <year>2001</year>             <article-title>ParAlign: A parallel sequence alignment algorithm for rapid and sensitive database searches.</article-title>             <source>Nucleic Acids Res</source>             <volume>29</volume>             <fpage>1647</fpage>             <lpage>1652</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Farrar1">
        <label>33</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Farrar</surname><given-names>M</given-names></name></person-group>             <year>2007</year>             <article-title>Striped Smith-Waterman speeds database searches six times over other SIMD implementations.</article-title>             <source>Bioinformatics</source>             <volume>23</volume>             <fpage>156</fpage>             <lpage>161</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Wozniak1">
        <label>34</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Wozniak</surname><given-names>A</given-names></name></person-group>             <year>1997</year>             <article-title>Using video-oriented instructions to speed up sequence comparison.</article-title>             <source>Comput Applic Biosci</source>             <volume>13</volume>             <fpage>145</fpage>             <lpage>150</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Rognes2">
        <label>35</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Rognes</surname><given-names>T</given-names></name><name name-style="western"><surname>Seeberg</surname><given-names>E</given-names></name></person-group>             <year>2000</year>             <article-title>Six-fold speed-up of Smith-Waterman sequence database searches using parallel processing on common microprocessors.</article-title>             <source>Bioinformatics</source>             <volume>16</volume>             <fpage>699</fpage>             <lpage>706</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Milosavljevi1">
        <label>36</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Milosavljević</surname><given-names>A</given-names></name><name name-style="western"><surname>Jurka</surname><given-names>J</given-names></name></person-group>             <year>1993</year>             <article-title>Discovering simple DNA sequences by the algorithmic significance method.</article-title>             <source>Comput Applic Biosci</source>             <volume>9</volume>             <fpage>407</fpage>             <lpage>411</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Karplus1">
        <label>37</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Karplus</surname><given-names>K</given-names></name><name name-style="western"><surname>Barrett</surname><given-names>C</given-names></name><name name-style="western"><surname>Hughey</surname><given-names>R</given-names></name></person-group>             <year>1998</year>             <article-title>Hidden Markov models for detecting remote protein homologies.</article-title>             <source>Bioinformatics</source>             <volume>14</volume>             <fpage>846</fpage>             <lpage>856</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Rabiner1">
        <label>38</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Rabiner</surname><given-names>LR</given-names></name></person-group>             <year>1989</year>             <article-title>A tutorial on hidden Markov models and selected applications in speech recognition.</article-title>             <source>Proc IEEE</source>             <volume>77</volume>             <fpage>257</fpage>             <lpage>286</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Melnikoff1">
        <label>39</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Melnikoff</surname><given-names>SJ</given-names></name><name name-style="western"><surname>Quigley</surname><given-names>SF</given-names></name></person-group>             <year>2003</year>             <article-title>Implementing the log-add algorithm in hardware.</article-title>             <source>Electronics Letters</source>             <volume>12</volume>             <fpage>939</fpage>             <lpage>941</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Pearson1">
        <label>40</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Pearson</surname><given-names>WR</given-names></name></person-group>             <year>2000</year>             <article-title>Flexible sequence similarity searching with the FASTA3 program package.</article-title>             <source>Meth Mol Biol</source>             <volume>132</volume>             <fpage>185</fpage>             <lpage>219</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Grundy1">
        <label>41</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Grundy</surname><given-names>WN</given-names></name></person-group>             <year>1998</year>             <article-title>Homology detection via family pairwise search.</article-title>             <source>J Comput Biol</source>             <volume>5</volume>             <fpage>479</fpage>             <lpage>491</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Gertz1">
        <label>42</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gertz</surname><given-names>EM</given-names></name><name name-style="western"><surname>Yu</surname><given-names>YK</given-names></name><name name-style="western"><surname>Agarwala</surname><given-names>R</given-names></name><name name-style="western"><surname>Schäffer</surname><given-names>AA</given-names></name><name name-style="western"><surname>Altschul</surname><given-names>SF</given-names></name></person-group>             <year>2006</year>             <article-title>Composition-based statistics and translated nucleotide searches: Improving the TBLASTN module of BLAST.</article-title>             <source>BMC Biol</source>             <volume>4</volume>             <fpage>41</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-The1">
        <label>43</label>
        <element-citation publication-type="journal" xlink:type="simple">             <collab xlink:type="simple">The UniProt Consortium</collab>             <year>2011</year>             <article-title>Ongoing and future developments at the universal protein resource.</article-title>             <source>Nucleic Acids Res</source>             <volume>39</volume>             <fpage>D214</fpage>             <lpage>D219</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002195-Price1">
        <label>44</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Price</surname><given-names>GA</given-names></name><name name-style="western"><surname>Crooks</surname><given-names>GE</given-names></name><name name-style="western"><surname>Green</surname><given-names>RE</given-names></name><name name-style="western"><surname>Brenner</surname><given-names>SE</given-names></name></person-group>             <year>2005</year>             <article-title>Statistical evaluation of pairwise protein sequence comparison with the Bayesian bootstrap.</article-title>             <source>Bioinformatics</source>             <volume>21</volume>             <fpage>3824</fpage>             <lpage>3831</lpage>          </element-citation>
      </ref>
    </ref-list>
    
  </back>
</article>