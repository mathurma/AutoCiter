<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN" "http://jats.nlm.nih.gov/publishing/1.1d3/JATS-journalpublishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.1d3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-16-01828</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1005423</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Physiology</subject><subj-group><subject>Electrophysiology</subject><subj-group><subject>Membrane potential</subject><subj-group><subject>Action potentials</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Medicine and health sciences</subject><subj-group><subject>Physiology</subject><subj-group><subject>Electrophysiology</subject><subj-group><subject>Membrane potential</subject><subj-group><subject>Action potentials</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Physiology</subject><subj-group><subject>Electrophysiology</subject><subj-group><subject>Neurophysiology</subject><subj-group><subject>Action potentials</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Medicine and health sciences</subject><subj-group><subject>Physiology</subject><subj-group><subject>Electrophysiology</subject><subj-group><subject>Neurophysiology</subject><subj-group><subject>Action potentials</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Neurophysiology</subject><subj-group><subject>Action potentials</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Optimization</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Imaging techniques</subject><subj-group><subject>Neuroimaging</subject><subj-group><subject>Calcium imaging</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Neuroimaging</subject><subj-group><subject>Calcium imaging</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Cell biology</subject><subj-group><subject>Cellular types</subject><subj-group><subject>Animal cells</subject><subj-group><subject>Neurons</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cellular neuroscience</subject><subj-group><subject>Neurons</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Cell biology</subject><subj-group><subject>Signal transduction</subject><subj-group><subject>Cell signaling</subject><subj-group><subject>Calcium signaling</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Imaging techniques</subject><subj-group><subject>Fluorescence imaging</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Physics</subject><subj-group><subject>Classical mechanics</subject><subj-group><subject>Pressure</subject><subj-group><subject>Osmotic pressure</subject><subj-group><subject>Tonicity</subject><subj-group><subject>Isotonic</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Fast online deconvolution of calcium imaging data</article-title>
<alt-title alt-title-type="running-head">Fast online deconvolution of calcium imaging data</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-1321-5866</contrib-id>
<name name-style="western">
<surname>Friedrich</surname> <given-names>Johannes</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Zhou</surname> <given-names>Pengcheng</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff004"><sup>4</sup></xref>
</contrib>
</contrib-group>
<aff id="aff001">
<label>1</label>
<addr-line>Department of Statistics, Grossman Center for the Statistics of Mind, and Center for Theoretical Neuroscience, Columbia University, New York, New York, United States of America</addr-line>
</aff>
<aff id="aff002">
<label>2</label>
<addr-line>Janelia Research Campus, Ashburn, Virginia, United States of America</addr-line>
</aff>
<aff id="aff003">
<label>3</label>
<addr-line>Center for the Neural Basis of Cognition and Machine Learning Department, Carnegie Mellon University, Pittsburgh, Pennsylvania, United States of America</addr-line>
</aff>
<aff id="aff004">
<label>4</label>
<addr-line>Kavli Institute for Brain Science, and NeuroTechnology Center, Columbia University, New York, New York, United States of America</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Vogelstein</surname> <given-names>Joshua</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>Johns Hopkins University, UNITED STATES</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<fn fn-type="con">
<p>
<list list-type="simple">
<list-item>
<p><bold>Conceptualization:</bold> JF LP.</p>
</list-item>
<list-item>
<p><bold>Formal analysis:</bold> JF LP PZ.</p>
</list-item>
<list-item>
<p><bold>Funding acquisition:</bold> JF LP.</p>
</list-item>
<list-item>
<p><bold>Investigation:</bold> JF PZ.</p>
</list-item>
<list-item>
<p><bold>Methodology:</bold> JF LP PZ.</p>
</list-item>
<list-item>
<p><bold>Software:</bold> JF PZ.</p>
</list-item>
<list-item>
<p><bold>Supervision:</bold> LP.</p>
</list-item>
<list-item>
<p><bold>Writing – original draft:</bold> JF LP PZ.</p>
</list-item>
<list-item>
<p><bold>Writing – review &amp; editing:</bold> JF LP PZ.</p>
</list-item>
</list>
</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">j.friedrich@columbia.edu</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<month>3</month>
<year>2017</year>
</pub-date>
<pub-date pub-type="epub">
<day>14</day>
<month>3</month>
<year>2017</year>
</pub-date>
<volume>13</volume>
<issue>3</issue>
<elocation-id>e1005423</elocation-id>
<history>
<date date-type="received">
<day>7</day>
<month>11</month>
<year>2016</year>
</date>
<date date-type="accepted">
<day>24</day>
<month>2</month>
<year>2017</year>
</date>
</history>
<permissions>
<copyright-year>2017</copyright-year>
<copyright-holder>Friedrich et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1005423"/>
<abstract>
<p>Fluorescent calcium indicators are a popular means for observing the spiking activity of large neuronal populations, but extracting the activity of each neuron from raw fluorescence calcium imaging data is a nontrivial problem. We present a fast online active set method to solve this sparse non-negative deconvolution problem. Importantly, the algorithm 3progresses through each time series sequentially from beginning to end, thus enabling real-time online estimation of neural activity during the imaging session. Our algorithm is a generalization of the pool adjacent violators algorithm (PAVA) for isotonic regression and inherits its linear-time computational complexity. We gain remarkable increases in processing speed: more than one order of magnitude compared to currently employed state of the art convex solvers relying on interior point methods. Unlike these approaches, our method can exploit warm starts; therefore optimizing model hyperparameters only requires a handful of passes through the data. A minor modification can further improve the quality of activity inference by imposing a constraint on the minimum spike size. The algorithm enables real-time simultaneous deconvolution of <italic>O</italic>(10<sup>5</sup>) traces of whole-brain larval zebrafish imaging data on a laptop.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author summary</title>
<p>Calcium imaging methods enable simultaneous measurement of the activity of thousands of neighboring neurons, but come with major caveats: the slow decay of the fluorescence signal compared to the time course of the underlying neural activity, limitations in signal quality, and the large scale of the data all complicate the goal of efficiently extracting accurate estimates of neural activity from the observed video data. Further, current activity extraction methods are typically applied to imaging data after the experiment is complete. However, in many cases we would prefer to run closed-loop experiments—analyzing data on-the-fly to guide the next experimental steps or to control feedback—and this requires new methods for accurate real-time processing. Here we present a fast activity extraction algorithm addressing both issues. Our approach follows previous work in casting the activity extraction problem as a sparse nonnegative deconvolution problem. To solve this optimization problem, we introduce a new algorithm that is an order of magnitude faster than previous methods, and progresses through the data sequentially from beginning to end, thus enabling, in principle, real-time online estimation of neural activity during the imaging session. This computational advance thus opens the door to new closed-loop experiments.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100001711</institution-id>
<institution>Schweizerischer Nationalfonds zur Förderung der Wissenschaftlichen Forschung</institution>
</institution-wrap>
</funding-source>
<award-id>P300P2_158428</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-1321-5866</contrib-id>
<name name-style="western">
<surname>Friedrich</surname> <given-names>Johannes</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award002">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000893</institution-id>
<institution>Simons Foundation</institution>
</institution-wrap>
</funding-source>
<award-id>325171</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award003">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000893</institution-id>
<institution>Simons Foundation</institution>
</institution-wrap>
</funding-source>
<award-id>365002</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award004">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000002</institution-id>
<institution>National Institutes of Health</institution>
</institution-wrap>
</funding-source>
<award-id>2R01MH064537</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Zhou</surname> <given-names>Pengcheng</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award005">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000002</institution-id>
<institution>National Institutes of Health</institution>
</institution-wrap>
</funding-source>
<award-id>R90DA023426</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Zhou</surname> <given-names>Pengcheng</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award006">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000183</institution-id>
<institution>Army Research Office</institution>
</institution-wrap>
</funding-source>
<award-id>W911NF-12-1-0594</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award007">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000002</institution-id>
<institution>National Institutes of Health</institution>
</institution-wrap>
</funding-source>
<award-id>R01 EB22913</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award008">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000002</institution-id>
<institution>National Institutes of Health</institution>
</institution-wrap>
</funding-source>
<award-id>R21 EY027592</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award009">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000185</institution-id>
<institution>Defense Advanced Research Projects Agency</institution>
</institution-wrap>
</funding-source>
<award-id>N66001-15-C-4032</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award010">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000201</institution-id>
<institution>U.S. Department of the Interior</institution>
</institution-wrap>
</funding-source>
<award-id>D16PC00003</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award011">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000201</institution-id>
<institution>U.S. Department of the Interior</institution>
</institution-wrap>
</funding-source>
<award-id>D16PC00007</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Zhou</surname> <given-names>Pengcheng</given-names></name>
</principal-award-recipient>
</award-group>
<funding-statement>Funding for this research was provided by Swiss National Science Foundation (<ext-link ext-link-type="uri" xlink:href="http://www.snf.ch" xlink:type="simple">http://www.snf.ch</ext-link>) Research Award P300P2_158428 (JF), National Institutes of Health (NIH, <ext-link ext-link-type="uri" xlink:href="https://www.nih.gov" xlink:type="simple">https://www.nih.gov</ext-link>) 2R01MH064537 and R90DA023426 (PZ), Simons Foundation (<ext-link ext-link-type="uri" xlink:href="https://www.simonsfoundation.org" xlink:type="simple">https://www.simonsfoundation.org</ext-link>) Global Brain Research Awards 325171 and 365002 (JF,LP), Army Research Office (ARO, <ext-link ext-link-type="uri" xlink:href="https://www.arl.army.mil?page=472" xlink:type="simple">https://www.arl.army.mil?page=472</ext-link>) MURI W911NF-12-1-0594, NIH BRAIN Initiative (<ext-link ext-link-type="uri" xlink:href="https://www.braininitiative.nih.gov" xlink:type="simple">https://www.braininitiative.nih.gov</ext-link>) R01 EB22913 and R21 EY027592, Defense Advanced Research Projects Agency (DARPA, <ext-link ext-link-type="uri" xlink:href="http://www.darpa.mil" xlink:type="simple">http://www.darpa.mil</ext-link>) N66001-15-C-4032 (SIMPLEX), and a Google Faculty Research award (LP); in addition, this work was supported by the Intelligence Advanced Research Projects Activity (IARPA, <ext-link ext-link-type="uri" xlink:href="https://www.iarpa.gov" xlink:type="simple">https://www.iarpa.gov</ext-link>) via Department of Interior/ Interior Business Center (DoI/IBC) contract number D16PC00003, D16PC00008 (LP) and D16PC00007 (PZ). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of IARPA, DoI/IBC, or the U.S. Government.</funding-statement>
</funding-group>
<counts>
<fig-count count="6"/>
<table-count count="1"/>
<page-count count="26"/>
</counts>
<custom-meta-group>
<custom-meta>
<meta-name>PLOS Publication Stage</meta-name>
<meta-value>vor-update-to-uncorrected-proof</meta-value>
</custom-meta>
<custom-meta>
<meta-name>Publication Update</meta-name>
<meta-value>2017-03-28</meta-value>
</custom-meta>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>All code is available on <ext-link ext-link-type="uri" xlink:href="https://github.com/j-friedrich/OASIS" xlink:type="simple">https://github.com/j-friedrich/OASIS</ext-link> and linked repositories therein. We used a publicly available dataset provided by the GENIE project, Svoboda lab, at Janelia Research Campus on <ext-link ext-link-type="uri" xlink:href="http://crcns.org" xlink:type="simple">http://crcns.org</ext-link> (Chen et al., 2013; GENIE project, 2015).</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<disp-quote>
<p>This is a <italic>PLOS Computational Biology</italic> Methods paper.</p>
</disp-quote>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Calcium imaging has become one of the most widely used techniques for recording activity from neural populations in vivo [<xref ref-type="bibr" rid="pcbi.1005423.ref001">1</xref>]. The basic principle of calcium imaging is that neural action potentials (or spikes), the point process signal of interest, each induce an optically measurable transient response in calcium dynamics. The nontrivial problem of extracting the activity of each neuron from a raw fluorescence trace has been addressed with several different approaches, including template matching [<xref ref-type="bibr" rid="pcbi.1005423.ref002">2</xref>] and linear deconvolution [<xref ref-type="bibr" rid="pcbi.1005423.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref004">4</xref>], which are outperformed by sparse non-negative deconvolution [<xref ref-type="bibr" rid="pcbi.1005423.ref005">5</xref>]. The latter can be interpreted as the maximum a posteriori (MAP) estimate under a simple generative model (linear convolution plus noise; <xref ref-type="fig" rid="pcbi.1005423.g001">Fig 1</xref>), whereas fully Bayesian methods [<xref ref-type="bibr" rid="pcbi.1005423.ref006">6</xref>–<xref ref-type="bibr" rid="pcbi.1005423.ref008">8</xref>] can provide some further improvements, but are more computationally expensive. Supervised methods trained on simultaneously-recorded electrophysiological and imaging data [<xref ref-type="bibr" rid="pcbi.1005423.ref009">9</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref010">10</xref>] have also recently achieved state of the art results, but are more black-box in nature; Bayesian methods based on a well-defined generative model are somewhat easier to generalize to more complex multi-neuronal or multi-trial settings [<xref ref-type="bibr" rid="pcbi.1005423.ref011">11</xref>–<xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>].</p>
<fig id="pcbi.1005423.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Generative autoregessive model for calcium dynamics.</title>
<p>Spike train <bold><italic>s</italic></bold> gets filtered to produce calcium trace <bold><italic>c</italic></bold>; here we used <italic>p</italic> = 2 as order of the AR process. Added noise yields the observed fluorescence <bold><italic>y</italic></bold>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.g001" xlink:type="simple"/>
</fig>
<p>The methods above are typically applied to imaging data offline, after the experiment is complete; however, there is a need for accurate and fast real-time processing to enable closed-loop experiments, a powerful strategy for causal investigation of neural circuitry [<xref ref-type="bibr" rid="pcbi.1005423.ref014">14</xref>]. In particular, observing and feeding back the effects of circuit interventions on physiologically relevant timescales will be valuable for directly testing whether inferred models of dynamics, connectivity, and causation are accurate in vivo, and recent experimental advances [<xref ref-type="bibr" rid="pcbi.1005423.ref015">15</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref016">16</xref>] are now enabling work in this direction. Brain-computer interfaces (BCIs) also rely on real-time estimates of neural activity. Whereas most BCI systems rely on electrical recordings, BCIs have been driven by optical signals too [<xref ref-type="bibr" rid="pcbi.1005423.ref017">17</xref>], providing new insight into how neurons change their activity during learning on a finer spatial scale than possible with intracortical electrodes. Finally, adaptive experimental design approaches [<xref ref-type="bibr" rid="pcbi.1005423.ref018">18</xref>–<xref ref-type="bibr" rid="pcbi.1005423.ref020">20</xref>] also rely on online estimates of neural activity.</p>
<p>Even in cases where we do not require the strict timing/latency constraints of real-time processing, we still need methods that scale to large data sets as for example in whole-brain imaging of larval zebrafish [<xref ref-type="bibr" rid="pcbi.1005423.ref021">21</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref022">22</xref>]. A further demand for scalability stems from the fact that the deconvolution problem is solved in the inner loop of constrained non-negative matrix factorization (CNMF) [<xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>], the current state of the art for simultaneous denoising, deconvolution, and demixing of spatiotemporal calcium imaging data.</p>
<p>In this paper we address the pressing need for scalable online spike inference methods. Building on previous work, we frame this estimation problem as a sparse non-negative deconvolution. Current algorithms employ interior point methods to solve the ensuing optimization problem and are fast enough to process hundreds of neurons in about the same time as the recording [<xref ref-type="bibr" rid="pcbi.1005423.ref005">5</xref>], but can not handle larger data sets such as whole-brain zebrafish imaging in real time. Furthermore, these interior point methods scale linearly in the length of the recording, but they cannot be warm started [<xref ref-type="bibr" rid="pcbi.1005423.ref023">23</xref>], i.e., initialized with the solution from a previous iteration to gain speed-ups, and do not run online.</p>
<p>Here we note a close connection between the MAP problem and isotonic regression, which fits data by a monotone piecewise constant function. A classic algorithm for isotonic regression is the pool adjacent violators algorithm (PAVA) [<xref ref-type="bibr" rid="pcbi.1005423.ref024">24</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref025">25</xref>], which can be understood as an online active-set optimization method. We generalized PAVA to derive an Online Active Set method to Infer Spikes (OASIS); this new approach to solve the MAP problem yields speed-ups in processing time by at least one order of magnitude compared to interior point methods on both simulated and real data. Further, OASIS can be warm-started, which is useful in the inner loop of CNMF, and also when adjusting model hyperparameters, as we show below. Importantly, OASIS is not only much faster, but operates in an online fashion, progressing through the fluorescence time series sequentially from beginning to end. The advances in speed paired with the inherently online fashion of the algorithm enable true real-time online spike inference during the imaging session (once the spatial shapes of neurons in the field of view have been identified), with the potential to significantly impact experimental paradigms.</p>
</sec>
<sec id="sec002" sec-type="materials|methods">
<title>Methods</title>
<p>This section is organized as follows. The first subsection introduces the autoregressive (AR(<italic>p</italic>)) model for calcium dynamics.</p>
<p>In the second subsection we derive an Online Active Set method to Infer Spikes (OASIS) for an AR(1) model. The algorithm is inspired by the pool adjacent violators algorithm (PAVA, Alg 1), which we review first and then generalize to obtain OASIS (Alg 2). This algorithm requires some hyperparameter values; the optimization of these hyperparameters is described next, along with several computational tricks for speeding up the hyperparameter estimation. We finally discuss thresholding approaches for reducing the number of small values returned by the original L1-penalized approach. The resulting problem is non-convex, and so we lose guarantees on finding global optima, but we can easily adapt OASIS to quickly find good solutions.</p>
<p>In the third subsection we generalize to AR(<italic>p</italic>) models of the calcium dynamics and describe a dual active set algorithm that is analogous to the one presented for the AR(1) case (Alg 2). However, this algorithm is greedy if <italic>p</italic> &gt; 1 and yields only a good approximate solution. We can refine this solution and obtain the exact result by warm-starting an alternative primal active set method we call ONNLS (Alg 3). Finally, Alg 4 summarizes all of these steps.</p>
<sec id="sec003">
<title>Model for calcium dynamics</title>
<p>We assume we observe the fluorescence signal for <italic>T</italic> timesteps, and denote by <italic>s</italic><sub><italic>t</italic></sub> the number of spikes that the neuron fired at the <italic>t</italic>-th timestep, <italic>t</italic> = 1, …, <italic>T</italic>, cf. <xref ref-type="fig" rid="pcbi.1005423.g001">Fig 1</xref>. Following [<xref ref-type="bibr" rid="pcbi.1005423.ref005">5</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>], we approximate the calcium concentration dynamics <bold><italic>c</italic></bold> using a stable autoregressive process of order <italic>p</italic> (AR(<italic>p</italic>)) where <italic>p</italic> is a small positive integer, usually <italic>p</italic> = 1 or 2,
<disp-formula id="pcbi.1005423.e001"><alternatives><graphic id="pcbi.1005423.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e001" xlink:type="simple"/><mml:math display="block" id="M1"><mml:mrow><mml:msub><mml:mi>c</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>p</mml:mi></mml:munderover> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:msub><mml:mi>c</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mi>i</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(1)</label></disp-formula>
The observed fluorescence <inline-formula id="pcbi.1005423.e002"><alternatives><graphic id="pcbi.1005423.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e002" xlink:type="simple"/><mml:math display="inline" id="M2"><mml:mrow><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∈</mml:mo> <mml:msup><mml:mstyle mathvariant="double-struck"><mml:mi>ℝ</mml:mi></mml:mstyle> <mml:mi>T</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> is related to the calcium concentration as [<xref ref-type="bibr" rid="pcbi.1005423.ref005">5</xref>–<xref ref-type="bibr" rid="pcbi.1005423.ref007">7</xref>]:
<disp-formula id="pcbi.1005423.e003"><alternatives><graphic id="pcbi.1005423.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e003" xlink:type="simple"/><mml:math display="block" id="M3"><mml:mrow><mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mi>a</mml:mi> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>c</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>b</mml:mi> <mml:mo>+</mml:mo> <mml:msub><mml:mi>ϵ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="1.em"/><mml:msub><mml:mi>ϵ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives> <label>(2)</label></disp-formula>
where <italic>a</italic> is a non-negative scalar, <italic>b</italic> is a scalar offset parameter, and the noise is assumed to be i.i.d. zero mean Gaussian with variance <italic>σ</italic><sup>2</sup>. For the remainder we assume units such that <italic>a</italic> = 1 without loss of generality. We begin by assuming <italic>b</italic> = 0 for simplicity, but we will relax this assumption later. (We also assume throughout that all parameters in sight are fixed; in case of e.g. drifting baselines <italic>b</italic> we could generalize the algorithms discussed here to operate over shorter temporal windows, but we do not pursue this here.) The parameters <italic>γ</italic><sub><italic>i</italic></sub> and <italic>σ</italic> can be estimated from the autocovariance function and the power spectral density (PSD) of <bold><italic>y</italic></bold> respectively [<xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>]. The autocovariance approach assumes that the spiking signal <bold><italic>s</italic></bold> comes from a homogeneous Poisson process and in practice often gives a crude estimate of <italic>γ</italic><sub><italic>i</italic></sub>. We will improve on this below by fitting the AR coefficients directly, which leads to better estimates, particularly when the spikes have some significant autocorrelation.</p>
<p>The goal of calcium deconvolution is to extract an estimate <inline-formula id="pcbi.1005423.e004"><alternatives><graphic id="pcbi.1005423.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> of the neural activity <bold><italic>s</italic></bold> from the vector of observations <bold><italic>y</italic></bold>. As discussed in [<xref ref-type="bibr" rid="pcbi.1005423.ref005">5</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>], this leads to the following non-negative LASSO problem for estimating the calcium concentration:
<disp-formula id="pcbi.1005423.e005"><alternatives><graphic id="pcbi.1005423.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e005" xlink:type="simple"/><mml:math display="block" id="M5"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:munder> <mml:mspace width="1.em"/><mml:mstyle displaystyle="false" scriptlevel="0"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:mrow><mml:mo>∥</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msup><mml:mrow><mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:mo>λ</mml:mo> <mml:msub><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>G</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives> <label>(3)</label></disp-formula>
where the <italic>ℓ</italic><sub>1</sub> penalty on <inline-formula id="pcbi.1005423.e006"><alternatives><graphic id="pcbi.1005423.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e006" xlink:type="simple"/><mml:math display="inline" id="M6"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> enforces sparsity of the neural activity and the lower triangular matrix <italic>G</italic> is defined as:
<disp-formula id="pcbi.1005423.e007"><alternatives><graphic id="pcbi.1005423.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e007" xlink:type="simple"/><mml:math display="block" id="M7"><mml:mrow><mml:mi>G</mml:mi> <mml:mo>=</mml:mo> <mml:mrow><mml:mfenced close=")" open="("><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mn>1</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mn>1</mml:mn></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mn>1</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>γ</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mo>.</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives> <label>(4)</label></disp-formula>
The deconvolution matrix <italic>G</italic> is banded with bandwidth <italic>p</italic> for an AR(<italic>p</italic>) process. Equivalently, <bold><italic>s</italic></bold> = <bold><italic>c</italic></bold> * <bold><italic>g</italic></bold> with <bold><italic>g</italic></bold> a finite impulse response filter of order <italic>p</italic> (<italic>p</italic> + 1 filter taps) and * denoting convolution. To produce calcium trace <bold><italic>c</italic></bold>, spike train <bold><italic>s</italic></bold> is filtered with the inverse filter of <bold><italic>g</italic></bold>, an infinite impulse response <bold><italic>h</italic></bold>, <bold><italic>c</italic></bold> = <bold><italic>s</italic></bold> * <bold><italic>h</italic></bold>. (Although our main focus is on the autoregressive model, we will discuss more general convolutional observation models below as well, and touch on nonlinear effects such as saturation in the Appendix.) Following the approach in [<xref ref-type="bibr" rid="pcbi.1005423.ref005">5</xref>], note that the spike signal <inline-formula id="pcbi.1005423.e008"><alternatives><graphic id="pcbi.1005423.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e008" xlink:type="simple"/><mml:math display="inline" id="M8"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is relaxed from non-negative integers to arbitrary non-negative values.</p>
</sec>
<sec id="sec004">
<title>Derivation of the active set algorithm</title>
<p>The optimization <xref ref-type="disp-formula" rid="pcbi.1005423.e005">problem (3)</xref> could be solved using generic convex program solvers. Here we derive the much faster Online Active Set method to Infer Spikes (OASIS). The algorithm is inspired by the pool adjacent violators algorithm (PAVA) [<xref ref-type="bibr" rid="pcbi.1005423.ref024">24</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref025">25</xref>], which we review first for readers not familiar with this classic algorithm before generalizing it to the non-negative LASSO problem.</p>
<sec id="sec005">
<title>Pool Adjacent Violators Algorithm (PAVA)</title>
<p>The pool adjacent violators algorithm (Alg 1) is a classic exact algorithm for isotonic regression, which fits data by a non-decreasing piecewise constant function. This algorithm is due to [<xref ref-type="bibr" rid="pcbi.1005423.ref024">24</xref>] and was independently discovered by other authors [<xref ref-type="bibr" rid="pcbi.1005423.ref026">26</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref027">27</xref>] as reviewed in [<xref ref-type="bibr" rid="pcbi.1005423.ref025">25</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref028">28</xref>]. It can be considered as a dual active set method [<xref ref-type="bibr" rid="pcbi.1005423.ref029">29</xref>]. Formally, the (convex) problem is to
<disp-formula id="pcbi.1005423.e014"><alternatives><graphic id="pcbi.1005423.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e014" xlink:type="simple"/><mml:math display="block" id="M14"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mi mathvariant="bold-italic">x</mml:mi></mml:munder> <mml:mspace width="1.em"/><mml:msup><mml:mrow><mml:mo>∥</mml:mo> <mml:mi mathvariant="bold-italic">x</mml:mi> <mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:msub><mml:mi>x</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>≤</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>≤</mml:mo> <mml:msub><mml:mi>x</mml:mi> <mml:mi>T</mml:mi></mml:msub> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(5)</label></disp-formula></p>
<p>We first present the algorithm in a way that conveys its core ideas (see Alg A in <xref ref-type="supplementary-material" rid="pcbi.1005423.s001">S1 Appendix</xref>), then improve the algorithm’s efficiency by introducing “pools” of variables (adjacent <italic>x</italic><sub><italic>t</italic></sub> values) which are updated simultaneously. We introduce temporary values <bold><italic>x</italic></bold>′ and initialize them to the unconstrained least squares solution, <bold><italic>x</italic></bold>′ = <bold><italic>y</italic></bold>. Initially all constraints are in the “passive set” and possible violations are fixed by subsequently adding the respective constraints to the “active set”. Starting at <italic>t</italic> = 2 the algorithm moves to the right until a violation of the constraint <inline-formula id="pcbi.1005423.e015"><alternatives><graphic id="pcbi.1005423.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e015" xlink:type="simple"/><mml:math display="inline" id="M15"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> at some time <italic>τ</italic> is encountered. Now the monotonicity constraint is added to the active set and enforced by setting <inline-formula id="pcbi.1005423.e016"><alternatives><graphic id="pcbi.1005423.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e016" xlink:type="simple"/><mml:math display="inline" id="M16"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. (Supposing the opposite, i.e. <inline-formula id="pcbi.1005423.e017"><alternatives><graphic id="pcbi.1005423.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e017" xlink:type="simple"/><mml:math display="inline" id="M17"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>&gt;</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, we could move <inline-formula id="pcbi.1005423.e018"><alternatives><graphic id="pcbi.1005423.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e018" xlink:type="simple"/><mml:math display="inline" id="M18"><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1005423.e019"><alternatives><graphic id="pcbi.1005423.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e019" xlink:type="simple"/><mml:math display="inline" id="M19"><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> by some small <italic>ϵ</italic> to decrease the objective without violating the constraints, yielding a proof by contradiction that the monotonicity constraint should be made “active” here—i.e., the constraint holds with strict equality.) We update the values <inline-formula id="pcbi.1005423.e020"><alternatives><graphic id="pcbi.1005423.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e020" xlink:type="simple"/><mml:math display="inline" id="M20"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> at the two time steps to the best possible fit with constraints. Minimizing their contribution to the residual <inline-formula id="pcbi.1005423.e021"><alternatives><graphic id="pcbi.1005423.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e021" xlink:type="simple"/><mml:math display="inline" id="M21"><mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:msup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>τ</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:msup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> by setting the derivative with respect to <inline-formula id="pcbi.1005423.e022"><alternatives><graphic id="pcbi.1005423.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e022" xlink:type="simple"/><mml:math display="inline" id="M22"><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> to zero, <inline-formula id="pcbi.1005423.e023"><alternatives><graphic id="pcbi.1005423.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e023" xlink:type="simple"/><mml:math display="inline" id="M23"><mml:mrow><mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>τ</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, amounts to replacing the values with their average, <inline-formula id="pcbi.1005423.e024"><alternatives><graphic id="pcbi.1005423.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e024" xlink:type="simple"/><mml:math display="inline" id="M24"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>τ</mml:mi></mml:msub></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>. However, this updated value can violate the constraint <inline-formula id="pcbi.1005423.e025"><alternatives><graphic id="pcbi.1005423.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e025" xlink:type="simple"/><mml:math display="inline" id="M25"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and we need to add this constraint to the active set and update <inline-formula id="pcbi.1005423.e026"><alternatives><graphic id="pcbi.1005423.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e026" xlink:type="simple"/><mml:math display="inline" id="M26"><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> as well, <inline-formula id="pcbi.1005423.e027"><alternatives><graphic id="pcbi.1005423.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e027" xlink:type="simple"/><mml:math display="inline" id="M27"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>τ</mml:mi></mml:msub></mml:mrow> <mml:mn>3</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>, etc. In this manner the algorithm continues to back-average to the left as needed until we have backtracked to time <italic>t</italic>′ where the constraint <inline-formula id="pcbi.1005423.e028"><alternatives><graphic id="pcbi.1005423.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e028" xlink:type="simple"/><mml:math display="inline" id="M28"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> is already valid. Solving
<disp-formula id="pcbi.1005423.e029"><alternatives><graphic id="pcbi.1005423.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e029" xlink:type="simple"/><mml:math display="block" id="M29"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:munder> <mml:mspace width="1.em"/><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mi>τ</mml:mi></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives> <label>(6)</label></disp-formula>
by setting the derivative to zero yields an update that corresponds to averaging
<disp-formula id="pcbi.1005423.e030"><alternatives><graphic id="pcbi.1005423.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e030" xlink:type="simple"/><mml:math display="block" id="M30"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>τ</mml:mi></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mi>τ</mml:mi></mml:msubsup> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mrow> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>-</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(7)</label></disp-formula>
The optimal solution that satisfies all constraints up to time <italic>τ</italic> has been found and the search advances to the right again until detection of the next violation, backtracks again, etc. This process continues until the last value <italic>x</italic><sub><italic>T</italic></sub> is reached and having found the optimal solution we return <bold><italic>x</italic></bold> = <bold><italic>x</italic></bold>′.</p>
<p><bold>Algorithm 1</bold> Pool Adjacent Violators Algorithm (PAVA) for isotonic regression</p>
<p specific-use="line"><bold>Require:</bold> data <italic>y</italic><sub><italic>t</italic></sub> ∈ <bold><italic>y</italic></bold> at time of reading</p>
<p specific-use="line">1: initialize set of pools <inline-formula id="pcbi.1005423.e009"><alternatives><graphic id="pcbi.1005423.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e009" xlink:type="simple"/><mml:math display="inline" id="M9"><mml:mrow><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo accent="false">←</mml:mo> <mml:mo form="prefix" stretchy="false">{</mml:mo> <mml:mo form="postfix" stretchy="false">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, data index <italic>t</italic> ← 0, pool index <italic>i</italic> ← 0</p>
<p specific-use="line">2: <bold>for</bold> <italic>y</italic> in <bold><italic>y</italic></bold> <bold>do</bold>                          ▹read next data point <italic>y</italic></p>
<p specific-use="line">3:  <italic>t</italic> ← <italic>t</italic> + 1</p>
<p specific-use="line">4:  <inline-formula id="pcbi.1005423.e010"><alternatives><graphic id="pcbi.1005423.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:mrow><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo accent="false">←</mml:mo> <mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo>∪</mml:mo> <mml:mo form="prefix" stretchy="false">{</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo form="postfix" stretchy="false">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>                           ▹add pool</p>
<p specific-use="line">5:  <bold>while</bold> <italic>i</italic> &gt; 0 and <italic>v</italic><sub><italic>i</italic>+1</sub> &lt; <italic>v</italic><sub><italic>i</italic></sub> <bold>do</bold>                 ▹merge pools if necessary</p>
<p specific-use="line">6:   <inline-formula id="pcbi.1005423.e011"><alternatives><graphic id="pcbi.1005423.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:mrow><mml:msub><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mi>i</mml:mi></mml:msub> <mml:mo accent="false">←</mml:mo> <mml:mrow><mml:mo form="prefix" stretchy="true">(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac> <mml:mo>,</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo form="postfix" stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line">7:   remove <inline-formula id="pcbi.1005423.e012"><alternatives><graphic id="pcbi.1005423.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e012" xlink:type="simple"/><mml:math display="inline" id="M12"><mml:msub><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula></p>
<p specific-use="line">8:   <italic>i</italic> ← <italic>i</italic> − 1</p>
<p specific-use="line">9:  <italic>i</italic> ← <italic>i</italic> + 1</p>
<p specific-use="line">10: <bold>for</bold> (<italic>v</italic>, <italic>w</italic>, <italic>t</italic>) in <inline-formula id="pcbi.1005423.e013"><alternatives><graphic id="pcbi.1005423.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e013" xlink:type="simple"/><mml:math display="inline" id="M13"><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula> <bold>do</bold>                    ▹construct solution for all <italic>t</italic></p>
<p specific-use="line">11:  <bold>for</bold> <italic>τ</italic> = 0, …, <italic>w</italic> − 1 <bold>do</bold> <italic>x</italic><sub><italic>t</italic>+<italic>τ</italic></sub> ← <italic>v</italic></p>
<p specific-use="line">12: <bold>return <italic>x</italic></bold></p>
<p>In a worst case situation a constraint violation is encountered at every step of the forward sweep through the series. Updating all <italic>t</italic> values up to time <italic>t</italic> yields overall <inline-formula id="pcbi.1005423.e031"><alternatives><graphic id="pcbi.1005423.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e031" xlink:type="simple"/><mml:math display="inline" id="M31"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:msubsup> <mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mi>T</mml:mi> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>T</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> updates and an <italic>O</italic>(<italic>T</italic><sup>2</sup>) algorithm. However, note that when a violation is encountered the updated time points all share the same value (the average of the data at these time points, <xref ref-type="disp-formula" rid="pcbi.1005423.e030">Eq 7</xref>) and it suffices to track this value just once for all these updated time points [<xref ref-type="bibr" rid="pcbi.1005423.ref030">30</xref>]. The constraints <inline-formula id="pcbi.1005423.e032"><alternatives><graphic id="pcbi.1005423.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e032" xlink:type="simple"/><mml:math display="inline" id="M32"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> between the updated time points hold with equality <inline-formula id="pcbi.1005423.e033"><alternatives><graphic id="pcbi.1005423.e033g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e033" xlink:type="simple"/><mml:math display="inline" id="M33"><mml:mrow><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>x</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, and are part of the active set. In order to obtain a more efficient algorithm, cf. Algorithm 1 and <xref ref-type="supplementary-material" rid="pcbi.1005423.s002">S1 Video</xref>, we introduce “pools” or groups of the form (<italic>v</italic><sub><italic>i</italic></sub>, <italic>w</italic><sub><italic>i</italic></sub>, <italic>t</italic><sub><italic>i</italic></sub>) with value <italic>v</italic><sub><italic>i</italic></sub>, weight <italic>w</italic><sub><italic>i</italic></sub> and event time <italic>t</italic><sub><italic>i</italic></sub> where <italic>i</italic> indices the groups. Initially the ordered set of pools is empty. During the forward sweep through the data the next data point <italic>y</italic><sub><italic>t</italic></sub> is initialized as its own pool (<italic>y</italic><sub><italic>t</italic></sub>, 1, <italic>t</italic>) and appended to the set of pools. Adjacent pools that violate the constraint <italic>v</italic><sub><italic>i</italic>+1</sub> ≥ <italic>v</italic><sub><italic>i</italic></sub> are combined to a new pool <inline-formula id="pcbi.1005423.e034"><alternatives><graphic id="pcbi.1005423.e034g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e034" xlink:type="simple"/><mml:math display="inline" id="M34"><mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac> <mml:mo>,</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Whenever pools <italic>i</italic> and <italic>i</italic> + 1 are merged, former pool <italic>i</italic> + 1 is removed. It is easy to prove by induction that these updates guarantee that the value of a pool is indeed the average of the corresponding data points (see <xref ref-type="supplementary-material" rid="pcbi.1005423.s001">S1 Appendix</xref>) without having to explicitly calculate it using <xref ref-type="disp-formula" rid="pcbi.1005423.e030">Eq (7)</xref>. The latter would be expensive for long pools, whereas merging two pools has <italic>O</italic>(1) complexity independent of the pool lengths. With pooling the considered worst case situation results in a single pool and only its value and weight are updated at every step forward, yielding <italic>O</italic>(<italic>T</italic>) complexity. Constructing the optimal solution <italic>x</italic><sub><italic>t</italic></sub> for all <italic>t</italic> in a final effort after the optimal pool partition has been reached is also <italic>O</italic>(<italic>T</italic>). At convergence all constraints have been enforced; further note that convergence to the exact solution occurs after a finite number of steps, in contrast to interior point-methods which only approach the optimal solution asymptotically.</p>
</sec>
<sec id="sec006">
<title>Online Active Set method to Infer Spikes (OASIS)</title>
<p>Now we adapt the PAVA approach to <xref ref-type="disp-formula" rid="pcbi.1005423.e005">problem (3)</xref>. PAVA solves a regression problem subject to the constraint that the value at the current time bin must be greater than or equal to the last. The AR(1) model posits a more general but very similar constraint that bounds the rate of decay instead of enforcing monotonicity. The key insight is that <xref ref-type="disp-formula" rid="pcbi.1005423.e005">problem (3)</xref> is a generalization of <xref ref-type="disp-formula" rid="pcbi.1005423.e014">problem (5)</xref>: if <italic>p</italic> = 1 in the AR model and we set <italic>γ</italic> = 1 (we skip the index of <italic>γ</italic> for a single AR coefficient) and λ = 0 in <xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq (3)</xref> we obtain <xref ref-type="disp-formula" rid="pcbi.1005423.e014">Eq (5)</xref>. Therefore we focus first on the <italic>p</italic> = 1 case and deal with <italic>p</italic> &gt; 1 and arbitrary calcium response kernels in the next section.</p>
<p>We begin by inserting the definition of <inline-formula id="pcbi.1005423.e035"><alternatives><graphic id="pcbi.1005423.e035g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e035" xlink:type="simple"/><mml:math display="inline" id="M35"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> (<xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq 3</xref>). Using that <inline-formula id="pcbi.1005423.e036"><alternatives><graphic id="pcbi.1005423.e036g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e036" xlink:type="simple"/><mml:math display="inline" id="M36"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is constrained to be non-negative yields for the sparsity penalty
<disp-formula id="pcbi.1005423.e037"><alternatives><graphic id="pcbi.1005423.e037g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e037" xlink:type="simple"/><mml:math display="block" id="M37"><mml:mrow><mml:mrow><mml:mo>λ</mml:mo> <mml:mo>∥</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:mn mathvariant="bold">1</mml:mn> <mml:msup><mml:mspace width="-0.166667em"/><mml:mi>⊤</mml:mi></mml:msup> <mml:mspace width="-0.166667em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:msub><mml:mi>G</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>γ</mml:mi> <mml:mo>+</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mi>T</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:msup><mml:mspace width="-0.166667em"/><mml:mi>⊤</mml:mi></mml:msup> <mml:mspace width="-0.166667em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:math></alternatives> <label>(8)</label></disp-formula>
with <italic>μ</italic><sub><italic>t</italic></sub> ≔ λ(1 − <italic>γ</italic> + <italic>γδ</italic><sub><italic>tT</italic></sub>) (with <italic>δ</italic> denoting Kronecker’s delta) by noting that the sum of the last column of <italic>G</italic> is 1, whereas all other columns sum to (1 − <italic>γ</italic>).</p>
<p>Now the problem
<disp-formula id="pcbi.1005423.e038"><alternatives><graphic id="pcbi.1005423.e038g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e038" xlink:type="simple"/><mml:math display="block" id="M38"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:munder> <mml:mspace width="1.em"/><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn> <mml:mspace width="1.em"/><mml:mo>∀</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives> <label>(9)</label></disp-formula>
shares some similarity to isotonic regression with the constraint <inline-formula id="pcbi.1005423.e039"><alternatives><graphic id="pcbi.1005423.e039g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e039" xlink:type="simple"/><mml:math display="inline" id="M39"><mml:mrow><mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>≥</mml:mo> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> (<xref ref-type="disp-formula" rid="pcbi.1005423.e014">Eq 5</xref>). However, our constraint <inline-formula id="pcbi.1005423.e040"><alternatives><graphic id="pcbi.1005423.e040g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e040" xlink:type="simple"/><mml:math display="inline" id="M40"><mml:mrow><mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> bounds the rate of decay instead of enforcing monotonicity. Thus we need to generalize PAVA to handle the additional factor <italic>γ</italic>.</p>
<p>For clarity we mimic our approach from the last section: we first present the algorithm in a way that conveys its core ideas, and then improve the algorithm’s efficiency using pools. We introduce temporary values <bold><italic>c</italic></bold>′ and initialize them to the unconstrained least squares solution, <bold><italic>c</italic></bold>′ = <bold><italic>y</italic></bold> − <bold><italic>μ</italic></bold>. Starting at <italic>t</italic> = 2 one moves forward until a violation of the constraint <inline-formula id="pcbi.1005423.e041"><alternatives><graphic id="pcbi.1005423.e041g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e041" xlink:type="simple"/><mml:math display="inline" id="M41"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> at some time <italic>τ</italic> is detected (<xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2A</xref>). Updating the two time steps by minimizing <inline-formula id="pcbi.1005423.e042"><alternatives><graphic id="pcbi.1005423.e042g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e042" xlink:type="simple"/><mml:math display="inline" id="M42"><mml:mrow><mml:mstyle displaystyle="false"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:msup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:mstyle displaystyle="false"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>τ</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:msup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>τ</mml:mi></mml:msub> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> yields an updated value <inline-formula id="pcbi.1005423.e043"><alternatives><graphic id="pcbi.1005423.e043g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e043" xlink:type="simple"/><mml:math display="inline" id="M43"><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula>. However, this updated value can violate the constraint <inline-formula id="pcbi.1005423.e044"><alternatives><graphic id="pcbi.1005423.e044g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e044" xlink:type="simple"/><mml:math display="inline" id="M44"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> and we need to update <inline-formula id="pcbi.1005423.e045"><alternatives><graphic id="pcbi.1005423.e045g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e045" xlink:type="simple"/><mml:math display="inline" id="M45"><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> as well, etc., until we have backtracked some Δ<italic>t</italic> steps to time <italic>t</italic>′ = <italic>τ</italic> − Δ<italic>t</italic> where the constraint <inline-formula id="pcbi.1005423.e046"><alternatives><graphic id="pcbi.1005423.e046g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e046" xlink:type="simple"/><mml:math display="inline" id="M46"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> is already valid. At most one needs to backtrack to the most recent spike, because <inline-formula id="pcbi.1005423.e047"><alternatives><graphic id="pcbi.1005423.e047g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e047" xlink:type="simple"/><mml:math display="inline" id="M47"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>&gt;</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> at spike times <italic>t</italic>′ (<xref ref-type="disp-formula" rid="pcbi.1005423.e001">Eq 1</xref>). Solving
<disp-formula id="pcbi.1005423.e048"><alternatives><graphic id="pcbi.1005423.e048g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e048" xlink:type="simple"/><mml:math display="block" id="M48"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:munder> <mml:mspace width="1.em"/><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:munderover> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives> <label>(10)</label></disp-formula>
by setting the derivative to zero yields
<disp-formula id="pcbi.1005423.e049"><alternatives><graphic id="pcbi.1005423.e049g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e049" xlink:type="simple"/><mml:math display="block" id="M49"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup></mml:mrow> <mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msubsup> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(11)</label></disp-formula>
and the next values are updated according to <inline-formula id="pcbi.1005423.e050"><alternatives><graphic id="pcbi.1005423.e050g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e050" xlink:type="simple"/><mml:math display="inline" id="M50"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>t</italic> = 1, …, Δ<italic>t</italic>. Note the similarity of Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e030">7</xref>) and (<xref ref-type="disp-formula" rid="pcbi.1005423.e049">11</xref>), which differs by weighting the summands by powers of <italic>γ</italic> due to the altered constraints, and by subtracting <bold><italic>μ</italic></bold> from the data <bold><italic>y</italic></bold> due to the sparsity penalty. (Along the way it is worth noting that, because a spike induces a calcium response described by kernel <bold><italic>h</italic></bold> with components <italic>h</italic><sub>1+<italic>t</italic></sub> = <italic>γ</italic><sup><italic>t</italic></sup>, <inline-formula id="pcbi.1005423.e051"><alternatives><graphic id="pcbi.1005423.e051g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e051" xlink:type="simple"/><mml:math display="inline" id="M51"><mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> could be expressed in the more familiar regression form as <inline-formula id="pcbi.1005423.e052"><alternatives><graphic id="pcbi.1005423.e052g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e052" xlink:type="simple"/><mml:math display="inline" id="M52"><mml:mfrac><mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">h</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>⊤</mml:mo></mml:msubsup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>−</mml:mo> <mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:msub><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>:</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:msubsup><mml:mi mathvariant="bold-italic">h</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>⊤</mml:mo></mml:msubsup> <mml:msub><mml:mi mathvariant="bold-italic">h</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:math></alternatives></inline-formula>, where we used the notation <bold><italic>v</italic></bold><sub><italic>i</italic>:<italic>j</italic></sub> to describe a vector formed by components <italic>i</italic> to <italic>j</italic> of <bold><italic>v</italic></bold>.) Now one moves forward again (<xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2C–2E</xref>) until detection of the next violation (<xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2E</xref>), backtracks again to the most recent spike (<xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2G</xref>), etc. Once the end of the time series is reached (<xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2I</xref>) we have found the optimal solution and set <inline-formula id="pcbi.1005423.e053"><alternatives><graphic id="pcbi.1005423.e053g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e053" xlink:type="simple"/><mml:math display="inline" id="M53"><mml:mrow><mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<fig id="pcbi.1005423.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Illustration of OASIS for an AR(1) process (see <xref ref-type="supplementary-material" rid="pcbi.1005423.s003">S2 Video</xref>).</title>
<p>Red lines depict true spike times. The shaded background shows how the time points are gathered in pools. The pool currently under consideration is indicated by the blue crosses. A constraint violation is encountered for the second time step <bold>(A)</bold> leading to backtracking and merging <bold>(B)</bold>. The algorithm proceeds moving forward <bold>(C-E)</bold> until the next violation occurs <bold>(E)</bold> and triggers backtracking and merging <bold>(F-G)</bold> as long as constraints are violated. When the most recent spike time has been reached <bold>(G)</bold> the algorithm proceeds forward again <bold>(H)</bold>. The process continues until the end of the series has been reached <bold>(I)</bold>. The solution is obtained and pools span the inter-spike-intervals.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.g002" xlink:type="simple"/>
</fig>
<p>While this yields a valid algorithm, it frequently updates each value <inline-formula id="pcbi.1005423.e054"><alternatives><graphic id="pcbi.1005423.e054g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e054" xlink:type="simple"/><mml:math display="inline" id="M54"><mml:msubsup><mml:mi>c</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> and recalculates the full sums in <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref> for each step of backtracking. A similar algorithm has been suggested by [<xref ref-type="bibr" rid="pcbi.1005423.ref031">31</xref>] for the problem without sparsity penalty. However, it passes through the time series in reverse direction, from its end to its beginning, and is thus not applicable to online processing. It considers directly the deconvolved activity <inline-formula id="pcbi.1005423.e055"><alternatives><graphic id="pcbi.1005423.e055g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e055" xlink:type="simple"/><mml:math display="inline" id="M55"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and efficiently does not update all time steps but only suspected spike times. However, their algorithm uses the inefficient updates of <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq 11</xref>, rendering it an <italic>O</italic>(<italic>T</italic><sup>2</sup>) algorithm.</p>
<p>As in PAVA, next we introduce “pools” into the algorithm; these are of critical importance in order to obtain a true <italic>O</italic>(<italic>T</italic>) algorithm. In PAVA these pools serve as sufficient statistics summarizing the data between jumps in the estimated output <italic>x</italic><sub><italic>t</italic></sub>; here the pools summarize the data between estimated spike times, where the estimated calcium signal <inline-formula id="pcbi.1005423.e056"><alternatives><graphic id="pcbi.1005423.e056g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e056" xlink:type="simple"/><mml:math display="inline" id="M56"><mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub></mml:math></alternatives></inline-formula> jumps. Pools are now tuples of the form (<italic>v</italic><sub><italic>i</italic></sub>, <italic>w</italic><sub><italic>i</italic></sub>, <italic>t</italic><sub><italic>i</italic></sub>, <italic>l</italic><sub><italic>i</italic></sub>) with value <italic>v</italic><sub><italic>i</italic></sub>, weight <italic>w</italic><sub><italic>i</italic></sub>, event time <italic>t</italic><sub><italic>i</italic></sub> and pool length <italic>l</italic><sub><italic>i</italic></sub>. Here we explicitly track the pool length, which was identical to its weight for PAVA. Initially the ordered set of pools is empty. During the forward sweep through the data the next data point <italic>y</italic><sub><italic>t</italic></sub> is initialized as its own pool (<italic>y</italic><sub><italic>t</italic></sub> − <italic>μ</italic><sub><italic>t</italic></sub>, 1, <italic>t</italic>, 1) and appended to the set of pools. During backtracking pools get combined and only the first value <inline-formula id="pcbi.1005423.e057"><alternatives><graphic id="pcbi.1005423.e057g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e057" xlink:type="simple"/><mml:math display="inline" id="M57"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>c</mml:mi> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> is explicitly considered, while the other values are merely defined implicitly via <inline-formula id="pcbi.1005423.e058"><alternatives><graphic id="pcbi.1005423.e058g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e058" xlink:type="simple"/><mml:math display="inline" id="M58"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. The constraint <inline-formula id="pcbi.1005423.e059"><alternatives><graphic id="pcbi.1005423.e059g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e059" xlink:type="simple"/><mml:math display="inline" id="M59"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>c</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> translates to <inline-formula id="pcbi.1005423.e060"><alternatives><graphic id="pcbi.1005423.e060g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e060" xlink:type="simple"/><mml:math display="inline" id="M60"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>≥</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> as the criterion determining whether pools need to be combined. The introduced weights allow efficient value updates whenever pools are merged by avoiding recalculating the sums in <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref>. Values are updated according to
<disp-formula id="pcbi.1005423.e061"><alternatives><graphic id="pcbi.1005423.e061g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e061" xlink:type="simple"/><mml:math display="block" id="M61"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>←</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(12)</label></disp-formula>
where the denominator is the new weight of the pool and the pool lengths are summed
<disp-formula id="pcbi.1005423.e062"><alternatives><graphic id="pcbi.1005423.e062g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e062" xlink:type="simple"/><mml:math display="block" id="M62"><mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>←</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives> <label>(13)</label></disp-formula> <disp-formula id="pcbi.1005423.e063"><alternatives><graphic id="pcbi.1005423.e063g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e063" xlink:type="simple"/><mml:math display="block" id="M63"><mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>←</mml:mo> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>l</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives> <label>(14)</label></disp-formula>
Whenever pools <italic>i</italic> and <italic>i</italic> + 1 are merged, former pool <italic>i</italic> + 1 is removed. It is easy to prove by induction that the updates according to Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e061">12</xref>–<xref ref-type="disp-formula" rid="pcbi.1005423.e063">14</xref>) guarantee that <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref> holds for all values (see <xref ref-type="supplementary-material" rid="pcbi.1005423.s001">S1 Appendix</xref>).</p>
<p>Analogous to PAVA, the updates solve <xref ref-type="disp-formula" rid="pcbi.1005423.e038">Eq (9)</xref> not just greedily but optimally, finding the exact solution to the convex problem in <italic>O</italic>(<italic>T</italic>). One important point (especially relevant for online use) is that the computation time per observation timestep is not fixed but random, since we might have to backtrack to update an unpredictable number of pools. We found empirically that, over a wide range of hyperparameters, in about 80% of the cases 0–1 merge operation was performed per observation timestep. With less than 0.5% probability four or more merges were necessary; in all our experiments so far, never more than seven merges were needed.</p>
<p>The final algorithm is summarized in Algorithm 2 and illustrated in <xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2</xref> as well as in <xref ref-type="supplementary-material" rid="pcbi.1005423.s003">S2 Video</xref>. Comparing Algorithm 1 with 2 clearly reveals the modifications made and shows that for <italic>γ</italic> = 1 and λ = 0 the algorithm reduces to PAVA.</p>
<p><bold>Algorithm 2</bold> Fast online deconvolution algorithm for AR1 processes with positive jumps</p>
<p specific-use="line"><bold>Require:</bold> decay factor <italic>γ</italic>, regularization parameter λ, data <italic>y</italic><sub><italic>t</italic></sub> ∈ <bold><italic>y</italic></bold> at time of reading</p>
<p specific-use="line">1: initialize set of pools <inline-formula id="pcbi.1005423.e064"><alternatives><graphic id="pcbi.1005423.e064g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e064" xlink:type="simple"/><mml:math display="inline" id="M64"><mml:mrow><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo accent="false">←</mml:mo> <mml:mo form="prefix" stretchy="false">{</mml:mo> <mml:mo form="postfix" stretchy="false">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, time index <italic>t</italic> ← 0, pool index <italic>i</italic> ← 0, solution <inline-formula id="pcbi.1005423.e065"><alternatives><graphic id="pcbi.1005423.e065g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e065" xlink:type="simple"/><mml:math display="inline" id="M65"><mml:mrow><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo accent="false">←</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line">2: <bold>for</bold> <italic>y</italic> in <bold><italic>y</italic></bold> <bold>do</bold>                         ▹read next data point <italic>y</italic></p>
<p specific-use="line">3:  <italic>t</italic> ← <italic>t</italic> + 1</p>
<p specific-use="line">4:  <inline-formula id="pcbi.1005423.e066"><alternatives><graphic id="pcbi.1005423.e066g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e066" xlink:type="simple"/><mml:math display="inline" id="M66"><mml:mrow><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo accent="false">←</mml:mo> <mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo>∪</mml:mo> <mml:mo form="prefix" stretchy="false">{</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>−</mml:mo> <mml:mo>λ</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:mo>+</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mi>T</mml:mi></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo form="postfix" stretchy="false">}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>                ▹add pool</p>
<p specific-use="line">5:  <bold>while</bold> <italic>i</italic> &gt; 0 and <inline-formula id="pcbi.1005423.e067"><alternatives><graphic id="pcbi.1005423.e067g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e067" xlink:type="simple"/><mml:math display="inline" id="M67"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>&lt;</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> <bold>do</bold>              ▹merge pools if necessary</p>
<p specific-use="line">6:   <inline-formula id="pcbi.1005423.e068"><alternatives><graphic id="pcbi.1005423.e068g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e068" xlink:type="simple"/><mml:math display="inline" id="M68"><mml:mrow><mml:msub><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mi>i</mml:mi></mml:msub> <mml:mo accent="false">←</mml:mo> <mml:mrow><mml:mo form="prefix" stretchy="true">(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac> <mml:mo>,</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>l</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>           ▹Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e061">12</xref>–<xref ref-type="disp-formula" rid="pcbi.1005423.e063">14</xref>)</p>
<p specific-use="line">7:   remove <inline-formula id="pcbi.1005423.e069"><alternatives><graphic id="pcbi.1005423.e069g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e069" xlink:type="simple"/><mml:math display="inline" id="M69"><mml:msub><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula></p>
<p specific-use="line">8:   <italic>i</italic> ← <italic>i</italic> − 1</p>
<p specific-use="line">9:  <italic>i</italic> ← <italic>i</italic> + 1</p>
<p specific-use="line">10: <bold>for</bold> (<italic>v</italic>, <italic>w</italic>, <italic>t</italic>, <italic>l</italic>) in <inline-formula id="pcbi.1005423.e070"><alternatives><graphic id="pcbi.1005423.e070g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e070" xlink:type="simple"/><mml:math display="inline" id="M70"><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula> <bold>do</bold>                   ▹construct solution for all <italic>t</italic><sup>†</sup></p>
<p specific-use="line">11:  <bold>for</bold> <italic>τ</italic> = 0, …, <italic>l</italic> − 1 <bold>do</bold> <inline-formula id="pcbi.1005423.e071"><alternatives><graphic id="pcbi.1005423.e071g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e071" xlink:type="simple"/><mml:math display="inline" id="M71"><mml:mrow><mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub> <mml:mo accent="false">←</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>τ</mml:mi></mml:msup> <mml:mtext>max</mml:mtext> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mi>v</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>         ▹enforce <inline-formula id="pcbi.1005423.e072"><alternatives><graphic id="pcbi.1005423.e072g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e072" xlink:type="simple"/><mml:math display="inline" id="M72"><mml:mrow><mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> via max</p>
<p specific-use="line">12:  <bold>if</bold> <italic>t</italic> &gt; 1 <bold>then</bold> <inline-formula id="pcbi.1005423.e073"><alternatives><graphic id="pcbi.1005423.e073g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e073" xlink:type="simple"/><mml:math display="inline" id="M73"><mml:mrow><mml:msub><mml:mover><mml:mi>s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo accent="false">←</mml:mo> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line">13: <bold>return</bold> <inline-formula id="pcbi.1005423.e074">
<alternatives>
<graphic id="pcbi.1005423.e074g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e074" xlink:type="simple"/>
<mml:math display="inline" id="M74">
<mml:mrow>
<mml:mover>
<mml:mi mathvariant="bold-italic">c</mml:mi>
<mml:mo accent="true">^</mml:mo>
</mml:mover>
<mml:mo>,</mml:mo>
<mml:mover>
<mml:mi mathvariant="bold-italic">s</mml:mi>
<mml:mo accent="true">^</mml:mo>
</mml:mover>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula>
</p>
<p specific-use="line"><sup>†</sup>For online estimates of <inline-formula id="pcbi.1005423.e075"><alternatives><graphic id="pcbi.1005423.e075g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e075" xlink:type="simple"/><mml:math display="inline" id="M75"><mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1005423.e076"><alternatives><graphic id="pcbi.1005423.e076g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e076" xlink:type="simple"/><mml:math display="inline" id="M76"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> the solution can be constructed within the loop over <bold><italic>y</italic></bold> not just after it.</p>
</sec>
<sec id="sec007">
<title>Dual formulation with hard noise constraint</title>
<p>The formulation above contains a troublesome free sparsity parameter λ (implicit in <bold><italic>μ</italic></bold>). A more robust deconvolution approach chooses the sparsity implicitly by inclusion of the residual sum of squares (RSS) as a hard constraint and not as a penalty term in the objective function [<xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>]. The expected RSS satisfies 〈‖<bold><italic>c</italic></bold> − <bold><italic>y</italic></bold>‖<sup>2</sup>〉 = <italic>σ</italic><sup>2</sup> <italic>T</italic> and by the law of large numbers ‖<bold><italic>c</italic></bold> − <bold><italic>y</italic></bold>‖<sup>2</sup> ≈ <italic>σ</italic><sup>2</sup> <italic>T</italic> with high probability, leading to the constrained problem
<disp-formula id="pcbi.1005423.e077"><alternatives><graphic id="pcbi.1005423.e077g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e077" xlink:type="simple"/><mml:math display="block" id="M77"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:munder> <mml:mrow><mml:mspace width="1.em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subjectto</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>G</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn> <mml:mspace width="1.em"/><mml:mtext>and</mml:mtext> <mml:mspace width="1.em"/><mml:msup><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>≤</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(15)</label></disp-formula>
(As noted above, we estimate <italic>σ</italic> using the power spectral estimator described in [<xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>]; see also [<xref ref-type="bibr" rid="pcbi.1005423.ref008">8</xref>] for a similar approach.)</p>
<p>We will solve this problem by increasing λ in the dual formulation until the noise constraint is tight. We start with some small λ, e.g. λ = 0, to obtain a first partitioning into pools <inline-formula id="pcbi.1005423.e078"><alternatives><graphic id="pcbi.1005423.e078g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e078" xlink:type="simple"/><mml:math display="inline" id="M78"><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula>, cf. <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3A</xref>. From Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e049">11</xref>–<xref ref-type="disp-formula" rid="pcbi.1005423.e062">13</xref>) along with the definition of <bold><italic>μ</italic></bold> (<xref ref-type="disp-formula" rid="pcbi.1005423.e037">Eq 8</xref>) it follows that given the solution (<italic>v</italic><sub><italic>i</italic></sub>, <italic>w</italic><sub><italic>i</italic></sub>, <italic>t</italic><sub><italic>i</italic></sub>, <italic>l</italic><sub><italic>i</italic></sub>), where
<disp-formula id="pcbi.1005423.e079"><alternatives><graphic id="pcbi.1005423.e079g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e079" xlink:type="simple"/><mml:math display="block" id="M79"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup></mml:mrow> <mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:mo>λ</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>γ</mml:mi> <mml:mo>+</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi> <mml:mo>,</mml:mo> <mml:mi>T</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup></mml:mrow> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(16)</label></disp-formula>
for some λ, the solution <inline-formula id="pcbi.1005423.e080"><alternatives><graphic id="pcbi.1005423.e080g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e080" xlink:type="simple"/><mml:math display="inline" id="M80"><mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msubsup><mml:mi>v</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>w</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>t</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>l</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> for λ + Δλ is
<disp-formula id="pcbi.1005423.e081"><alternatives><graphic id="pcbi.1005423.e081g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e081" xlink:type="simple"/><mml:math display="block" id="M81"><mml:mrow><mml:msubsup><mml:mi>v</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>λ</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>γ</mml:mi> <mml:mo>+</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi> <mml:mo>,</mml:mo> <mml:mi>T</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup></mml:mrow> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mfrac> <mml:mo>=</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>λ</mml:mo> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(17)</label></disp-formula>
where <italic>z</italic> is the index of the last pool and because pools are updated independently we make the approximation that no changes in the pool structure occur. Inserting <xref ref-type="disp-formula" rid="pcbi.1005423.e081">Eq (17)</xref> into the noise constraint (<xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>) results in
<disp-formula id="pcbi.1005423.e082"><alternatives><graphic id="pcbi.1005423.e082g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e082" xlink:type="simple"/><mml:math display="block" id="M82"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>z</mml:mi></mml:munderover> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:msup><mml:mfenced close=")" open="(" separators=""><mml:mfenced close=")" open="(" separators=""><mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>λ</mml:mo> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mfrac></mml:mfenced> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mfenced> <mml:mn>2</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives> <label>(18)</label></disp-formula>
and solving the quadratic equation for Δλ yields
<disp-formula id="pcbi.1005423.e083"><alternatives><graphic id="pcbi.1005423.e083g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e083" xlink:type="simple"/><mml:math display="block" id="M83"><mml:mrow><mml:mo>Δ</mml:mo> <mml:mo>λ</mml:mo> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mo>-</mml:mo> <mml:mi>β</mml:mi> <mml:mo>+</mml:mo> <mml:msqrt><mml:mrow><mml:msup><mml:mi>β</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>-</mml:mo> <mml:mn>4</mml:mn> <mml:mi>α</mml:mi> <mml:mi>ϵ</mml:mi></mml:mrow></mml:msqrt></mml:mrow> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>α</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(19)</label></disp-formula>
with <inline-formula id="pcbi.1005423.e084"><alternatives><graphic id="pcbi.1005423.e084g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e084" xlink:type="simple"/><mml:math display="inline" id="M84"><mml:mrow><mml:mi>α</mml:mi> <mml:mo>=</mml:mo> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:msubsup><mml:mi>ξ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <italic>β</italic> = 2 ∑<sub><italic>i</italic>,<italic>t</italic></sub> <italic>χ</italic><sub><italic>it</italic></sub> <italic>ξ</italic><sub><italic>it</italic></sub> and <inline-formula id="pcbi.1005423.e085"><alternatives><graphic id="pcbi.1005423.e085g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e085" xlink:type="simple"/><mml:math display="inline" id="M85"><mml:mrow><mml:mi>ϵ</mml:mi> <mml:mo>=</mml:mo> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:msubsup><mml:mi>χ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>−</mml:mo> <mml:msup><mml:mover><mml:mi>σ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> where <inline-formula id="pcbi.1005423.e086"><alternatives><graphic id="pcbi.1005423.e086g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e086" xlink:type="simple"/><mml:math display="inline" id="M86"><mml:mrow><mml:msub><mml:mi>ξ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mfrac> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> and <italic>χ</italic><sub><italic>it</italic></sub> = <italic>y</italic><sub><italic>t</italic><sub><italic>i</italic></sub>+<italic>t</italic></sub> − <italic>v</italic><sub><italic>i</italic></sub> <italic>γ</italic><sup><italic>t</italic></sup>.</p>
<fig id="pcbi.1005423.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Optimizing sparsity parameter λ and AR coefficient <inline-formula id="pcbi.1005423.e087"><alternatives><graphic id="pcbi.1005423.e087g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e087" xlink:type="simple"/><mml:math display="inline" id="M87"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>.</title>
<p><bold>(A)</bold> Running the active set method, with conservatively small estimate <inline-formula id="pcbi.1005423.e088"><alternatives><graphic id="pcbi.1005423.e088g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e088" xlink:type="simple"/><mml:math display="inline" id="M88"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, yields an initial <italic>denoised</italic> estimate (blue) of the data (gray) roughly capturing the truth (red). We also report the correlation between the <italic>deconvolved</italic> estimate and true spike train as a direct measure for the accuracy of spike train inference. <bold>(B)</bold> Updating sparsity parameter λ according to <xref ref-type="disp-formula" rid="pcbi.1005423.e082">Eq (18)</xref> such that RSS = <italic>σ</italic><sup>2</sup> <italic>T</italic> (left) shifts the current estimate downward (right, blue). <bold>(C)</bold> Running the active set method enforces the constraints again and is fast due to warm-starting. <bold>(D)</bold> Updating <inline-formula id="pcbi.1005423.e089"><alternatives><graphic id="pcbi.1005423.e089g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e089" xlink:type="simple"/><mml:math display="inline" id="M89"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> by minimizing the polynomial function RSS(<inline-formula id="pcbi.1005423.e090"><alternatives><graphic id="pcbi.1005423.e090g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e090" xlink:type="simple"/><mml:math display="inline" id="M90"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>) and <bold>(E)</bold> running the warm-started active set method completes one iteration, which yields already a decent fit. <bold>(F)</bold> A few more iterations improve the solution further. The obtained estimate (blue) is hardly distinguishable from the one obtained with known true <italic>γ</italic> (yellow dashed trace, plotted in addition to the traces in A-E, is on top of blue solid line). Note that determining <inline-formula id="pcbi.1005423.e091"><alternatives><graphic id="pcbi.1005423.e091g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e091" xlink:type="simple"/><mml:math display="inline" id="M91"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> based on the autocovariance (additionally plotted purple trace) yields a crude solution that even misses spikes (at 24.6 s and 46.5 s).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.g003" xlink:type="simple"/>
</fig>
<p>The solution Δλ provides a good approximate proposal step for updating the pool values <italic>v</italic><sub><italic>i</italic></sub> (using <xref ref-type="disp-formula" rid="pcbi.1005423.e081">Eq 17</xref>). Since this update proposal is only approximate it can give rise to violated constraints (e.g., negative values of <italic>v</italic><sub><italic>i</italic></sub>). To satisfy all constraints Algorithm 2 is run to update the pool structure, cf. <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3C</xref>, but with a <italic>warm start</italic>: we initialize with the current set of merely <italic>z</italic> pools <inline-formula id="pcbi.1005423.e092"><alternatives><graphic id="pcbi.1005423.e092g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e092" xlink:type="simple"/><mml:math display="inline" id="M92"><mml:msup><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo>′</mml:mo></mml:msup></mml:math></alternatives></inline-formula> instead of the <italic>T</italic> pools for a cold start (Alg 2, line 4). This step returns a set of <italic>v</italic><sub><italic>i</italic></sub> values that satisfy the constraints and may merge pools (i.e., delete spikes); then the procedure (update λ then rerun the warm-started Algorithm 2) can be iterated until no further pools need to be merged, at which point the procedure has converged. In practice this leads to an increasing sequence of λ values (corresponding to an increasingly sparse set of spikes), and no pool-split (i.e., add-spike) moves are necessary. (Note that it is possible to cheaply detect any violations of the KKT conditions in a candidate solution; if such a violation is detected, the corresponding pool could be split and the warm-started Algorithm 2 run locally near the detected violations. However, as we noted, due to the increasing λ sequence we did not find this step to be necessary in the examples examined here.)</p>
<p>This warm-starting approach brings major speed benefits: after the residual is updated following a λ update, the computational cost of the algorithm is linear in the number of pools <italic>z</italic>, hence warm starting drastically reduces computational costs from <italic>k</italic><sub>1</sub> <italic>T</italic> to <italic>k</italic><sub>2</sub> <italic>z</italic> with proportionality constants <italic>k</italic><sub>1</sub> and <italic>k</italic><sub>2</sub>: if no pool boundary updates are needed then after warm starting the algorithm only needs to pass once through all pools to verify that no constraint is violated, whereas a cold start might involve a couple passes over the data to update pools, so <italic>k</italic><sub>2</sub> is typically significantly smaller than <italic>k</italic><sub>1</sub>, and <italic>z</italic> is typically much smaller than <italic>T</italic> (especially in sparsely-spiking regimes).</p>
</sec>
<sec id="sec008">
<title>Additional baseline</title>
<p>For ease of exposition we thus far assumed no offsetting baseline. Adding a known baseline <italic>b</italic> ≠ 0 the problem reads
<disp-formula id="pcbi.1005423.e093"><alternatives><graphic id="pcbi.1005423.e093g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e093" xlink:type="simple"/><mml:math display="block" id="M93"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:munder> <mml:mspace width="1.em"/><mml:mstyle displaystyle="false" scriptlevel="0"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:mrow><mml:mo>∥</mml:mo> <mml:mi>b</mml:mi> <mml:mn mathvariant="bold">1</mml:mn> <mml:mo>+</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msup><mml:mrow><mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:mo>λ</mml:mo> <mml:msub><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>G</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(20)</label></disp-formula>
For known baseline one merely needs to initialize OASIS by subtracting not only the sparsity parameter <bold><italic>μ</italic></bold>(λ) from the data <bold><italic>y</italic></bold>, cf. <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref> and Algorithm 2, but also the baseline <italic>b</italic>. The fluorescence <inline-formula id="pcbi.1005423.e094"><alternatives><graphic id="pcbi.1005423.e094g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e094" xlink:type="simple"/><mml:math display="inline" id="M94"><mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> depends only on the sum <bold><italic>ϕ</italic></bold> = <italic>b</italic><bold>1</bold> + <bold><italic>μ</italic></bold>.</p>
<p>If the baseline is not known, we want to optimize it too by solving the noise constrained dual problem
<disp-formula id="pcbi.1005423.e095"><alternatives><graphic id="pcbi.1005423.e095g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e095" xlink:type="simple"/><mml:math display="block" id="M95"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">b</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:munder> <mml:mrow><mml:mspace width="1.em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>G</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn> <mml:mspace width="1.em"/><mml:mtext>and</mml:mtext> <mml:mspace width="1.em"/><mml:msup><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi>b</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn mathvariant="bold">1</mml:mn> <mml:mo>+</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>≤</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(21)</label></disp-formula>
We denote all except the differing last component of <bold><italic>μ</italic></bold> by <italic>μ</italic> = λ(1 − <italic>γ</italic>) (<xref ref-type="disp-formula" rid="pcbi.1005423.e037">Eq 8</xref>) and of <italic>ϕ</italic> by <italic>ϕ</italic> = <italic>b</italic> + λ(1 − <italic>γ</italic>). <italic>ϕ</italic> is the total shift applied to the data (except for the last time step) due to the baseline and sparsity penalty before running OASIS. We increase <italic>ϕ</italic> until the noise constraint is tight. <italic>ϕ</italic> can be initialized by min <italic>y</italic><sub><italic>t</italic></sub> or better by a small percentile of <bold><italic>y</italic></bold>, e.g. 15%. Once OASIS has been run with some <italic>ϕ</italic> the baseline <inline-formula id="pcbi.1005423.e096"><alternatives><graphic id="pcbi.1005423.e096g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e096" xlink:type="simple"/><mml:math display="inline" id="M96"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is obtained by minimizing the objective <xref ref-type="disp-formula" rid="pcbi.1005423.e093">Eq (20)</xref> with respect to it, yielding <inline-formula id="pcbi.1005423.e097"><alternatives><graphic id="pcbi.1005423.e097g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e097" xlink:type="simple"/><mml:math display="inline" id="M97"><mml:mrow><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mo form="prefix" stretchy="false">〈</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>−</mml:mo> <mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo form="postfix" stretchy="false">〉</mml:mo> <mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>T</mml:mi></mml:mfrac> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:msubsup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, and the sparsity parameter is <inline-formula id="pcbi.1005423.e098"><alternatives><graphic id="pcbi.1005423.e098g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e098" xlink:type="simple"/><mml:math display="inline" id="M98"><mml:mrow><mml:mi>μ</mml:mi> <mml:mo>=</mml:mo> <mml:mi>ϕ</mml:mi> <mml:mo>−</mml:mo> <mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>. Appropriately adding <inline-formula id="pcbi.1005423.e099"><alternatives><graphic id="pcbi.1005423.e099g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e099" xlink:type="simple"/><mml:math display="inline" id="M99"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> to <xref ref-type="disp-formula" rid="pcbi.1005423.e082">Eq (18)</xref> <disp-formula id="pcbi.1005423.e100"><alternatives><graphic id="pcbi.1005423.e100g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e100" xlink:type="simple"/><mml:math display="block" id="M100"><mml:mrow><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>z</mml:mi></mml:munderover> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:msup><mml:mfenced close=")" open="(" separators=""><mml:mfenced close=")" open="(" separators=""><mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:mi>ϕ</mml:mi> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>γ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mfenced> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mover accent="true"><mml:mi>b</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mfenced> <mml:mn>2</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives> <label>(22)</label></disp-formula>
and plugging the analytic expression <inline-formula id="pcbi.1005423.e101"><alternatives><graphic id="pcbi.1005423.e101g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e101" xlink:type="simple"/><mml:math display="inline" id="M101"><mml:mrow><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>T</mml:mi></mml:mfrac> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:msubsup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>T</mml:mi></mml:mfrac> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>z</mml:mi></mml:msubsup> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo form="prefix" stretchy="true">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:mrow><mml:mo form="prefix" stretchy="true">(</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mo>Δ</mml:mo> <mml:mi>ϕ</mml:mi> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>j</mml:mi></mml:msub></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>j</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow> <mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac> <mml:mo form="postfix" stretchy="true">)</mml:mo></mml:mrow> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>τ</mml:mi></mml:msup> <mml:mo form="postfix" stretchy="true">)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> into <xref ref-type="disp-formula" rid="pcbi.1005423.e100">Eq (22)</xref> to account for the changing baseline, we obtain an estimate of Δ<italic>ϕ</italic> using a block coordinate update of <italic>ϕ</italic> and <inline-formula id="pcbi.1005423.e102"><alternatives><graphic id="pcbi.1005423.e102g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e102" xlink:type="simple"/><mml:math display="inline" id="M102"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. Solving the ensuing quadratic equation for Δ<italic>ϕ</italic>, yields
<disp-formula id="pcbi.1005423.e103"><alternatives><graphic id="pcbi.1005423.e103g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e103" xlink:type="simple"/><mml:math display="block" id="M103"><mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>ϕ</mml:mi> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mo>-</mml:mo> <mml:mi>β</mml:mi> <mml:mo>+</mml:mo> <mml:msqrt><mml:mrow><mml:msup><mml:mi>β</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>-</mml:mo> <mml:mn>4</mml:mn> <mml:mi>α</mml:mi> <mml:mi>ϵ</mml:mi></mml:mrow></mml:msqrt></mml:mrow> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>α</mml:mi></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(23)</label></disp-formula>
with <inline-formula id="pcbi.1005423.e104"><alternatives><graphic id="pcbi.1005423.e104g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e104" xlink:type="simple"/><mml:math display="inline" id="M104"><mml:mrow><mml:mi>α</mml:mi> <mml:mo>=</mml:mo> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:msubsup><mml:mi>ξ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <italic>β</italic> = 2 ∑<sub><italic>i</italic>,<italic>t</italic></sub> <italic>χ</italic><sub><italic>it</italic></sub> <italic>ξ</italic><sub><italic>it</italic></sub> and <inline-formula id="pcbi.1005423.e105"><alternatives><graphic id="pcbi.1005423.e105g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e105" xlink:type="simple"/><mml:math display="inline" id="M105"><mml:mrow><mml:mi>ϵ</mml:mi> <mml:mo>=</mml:mo> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:msubsup><mml:mi>χ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>−</mml:mo> <mml:msup><mml:mover><mml:mi>σ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> where <inline-formula id="pcbi.1005423.e106"><alternatives><graphic id="pcbi.1005423.e106g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e106" xlink:type="simple"/><mml:math display="inline" id="M106"><mml:mrow><mml:msub><mml:mi>ξ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow> <mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>−</mml:mo> <mml:msub><mml:mo>∑</mml:mo> <mml:mi>j</mml:mi></mml:msub> <mml:mfrac><mml:msup><mml:mrow><mml:mo form="prefix" stretchy="true">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>j</mml:mi></mml:msub></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>j</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo form="postfix" stretchy="true">)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mi>T</mml:mi> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:msup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>w</mml:mi> <mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1005423.e107"><alternatives><graphic id="pcbi.1005423.e107g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e107" xlink:type="simple"/><mml:math display="inline" id="M107"><mml:mrow><mml:msub><mml:mi>χ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>−</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>T</mml:mi></mml:mfrac> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>,</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>τ</mml:mi></mml:msup> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. All pools are updated according to <inline-formula id="pcbi.1005423.e108"><alternatives><graphic id="pcbi.1005423.e108g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e108" xlink:type="simple"/><mml:math display="inline" id="M108"><mml:mrow><mml:msubsup><mml:mi>v</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mo>Δ</mml:mo> <mml:mi>ϕ</mml:mi> <mml:mstyle displaystyle="false"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msub><mml:mi>δ</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>z</mml:mi></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow> <mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mi>γ</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:msub><mml:mi>w</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula>, cf. <xref ref-type="disp-formula" rid="pcbi.1005423.e081">Eq (17)</xref>. To satisfy all constraints Algorithm 2 is run, warm-started by initializing with the current set of pools.</p>
</sec>
<sec id="sec009">
<title>Optimizing the AR coefficient</title>
<p>Thus far the parameter <italic>γ</italic> has been known or been estimated based on the autocovariance function. We can improve upon this estimate by optimizing <inline-formula id="pcbi.1005423.e109"><alternatives><graphic id="pcbi.1005423.e109g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e109" xlink:type="simple"/><mml:math display="inline" id="M109"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> as well, which is illustrated in <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3</xref>. After updating λ (and <inline-formula id="pcbi.1005423.e110"><alternatives><graphic id="pcbi.1005423.e110g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e110" xlink:type="simple"/><mml:math display="inline" id="M110"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>) followed by running Algorithm 2, we perform a coordinate descent step in <inline-formula id="pcbi.1005423.e111"><alternatives><graphic id="pcbi.1005423.e111g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e111" xlink:type="simple"/><mml:math display="inline" id="M111"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> that minimizes the RSS, cf. <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3D</xref>. The RSS as a function of <inline-formula id="pcbi.1005423.e112"><alternatives><graphic id="pcbi.1005423.e112g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e112" xlink:type="simple"/><mml:math display="inline" id="M112"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is a high order polynomial, cf. <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref>, and we need to settle for numerical solutions of
<disp-formula id="pcbi.1005423.e113"><alternatives><graphic id="pcbi.1005423.e113g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e113" xlink:type="simple"/><mml:math display="block" id="M113"><mml:mrow><mml:mover accent="true"><mml:mi>γ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:munder><mml:mrow><mml:mtext>arg</mml:mtext> <mml:mspace width="1pt"/><mml:mtext>min</mml:mtext></mml:mrow> <mml:mi>γ</mml:mi></mml:munder> <mml:mspace width="1.em"/><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>z</mml:mi></mml:munderover> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="1pt"/><mml:msup><mml:mfenced close=")" open="(" separators=""><mml:mover accent="true"><mml:mi>b</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>τ</mml:mi></mml:msup></mml:mrow> <mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>τ</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mfenced> <mml:mn>2</mml:mn></mml:msup> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(24)</label></disp-formula>
We used Brent’s method [<xref ref-type="bibr" rid="pcbi.1005423.ref032">32</xref>] with bounds <inline-formula id="pcbi.1005423.e114"><alternatives><graphic id="pcbi.1005423.e114g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e114" xlink:type="simple"/><mml:math display="inline" id="M114"><mml:mrow><mml:mn>0</mml:mn> <mml:mo>≤</mml:mo> <mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>&lt;</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> to solve this problem. One iteration consists now of steps B-E in <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3</xref>, while for known <italic>γ</italic> only B-C were necessary. If optimizing the baseline too, we obtained better results by minimizing the RSS jointly with respect to <inline-formula id="pcbi.1005423.e115"><alternatives><graphic id="pcbi.1005423.e115g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e115" xlink:type="simple"/><mml:math display="inline" id="M115"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1005423.e116"><alternatives><graphic id="pcbi.1005423.e116g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e116" xlink:type="simple"/><mml:math display="inline" id="M116"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> using L-BFGS-B [<xref ref-type="bibr" rid="pcbi.1005423.ref033">33</xref>] instead of keeping the baseline <inline-formula id="pcbi.1005423.e117"><alternatives><graphic id="pcbi.1005423.e117g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e117" xlink:type="simple"/><mml:math display="inline" id="M117"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> fixed.</p>
</sec>
<sec id="sec010">
<title>Faster optimization of hyperparameters</title>
<p>We have presented methods to estimate the hyperparameters λ, <italic>b</italic> and <italic>γ</italic>, which require a handful of warm-started iterations of OASIS. To gain further speed-ups these parameters can be estimated on decimated data. When downsampling by a factor <italic>k</italic>, the average of <italic>k</italic> subsequent frames is calculated, the noise <inline-formula id="pcbi.1005423.e118"><alternatives><graphic id="pcbi.1005423.e118g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e118" xlink:type="simple"/><mml:math display="inline" id="M118"><mml:mover><mml:mi>σ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> divided by a factor <inline-formula id="pcbi.1005423.e119"><alternatives><graphic id="pcbi.1005423.e119g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e119" xlink:type="simple"/><mml:math display="inline" id="M119"><mml:msqrt><mml:mi>k</mml:mi></mml:msqrt></mml:math></alternatives></inline-formula> and the initial estimate of the AR coefficient scaled to <inline-formula id="pcbi.1005423.e120"><alternatives><graphic id="pcbi.1005423.e120g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e120" xlink:type="simple"/><mml:math display="inline" id="M120"><mml:msup><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>k</mml:mi></mml:msup></mml:math></alternatives></inline-formula>. Alternatively, one could estimate <italic>σ</italic> and <italic>γ</italic> based on the decimated data. Once the hyperparameters have been obtained, the corresponding inverse transformations are performed: <inline-formula id="pcbi.1005423.e121"><alternatives><graphic id="pcbi.1005423.e121g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e121" xlink:type="simple"/><mml:math display="inline" id="M121"><mml:mrow><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo accent="false">→</mml:mo> <mml:msup><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>k</mml:mi></mml:mfrac></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1005423.e122"><alternatives><graphic id="pcbi.1005423.e122g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e122" xlink:type="simple"/><mml:math display="inline" id="M122"><mml:mrow><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo accent="false">→</mml:mo> <mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1005423.e123"><alternatives><graphic id="pcbi.1005423.e123g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e123" xlink:type="simple"/><mml:math display="inline" id="M123"><mml:mrow><mml:mo>λ</mml:mo> <mml:mo accent="false">→</mml:mo> <mml:mo>λ</mml:mo> <mml:mfrac><mml:mrow><mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msup><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> such that the shrinkage <inline-formula id="pcbi.1005423.e124"><alternatives><graphic id="pcbi.1005423.e124g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e124" xlink:type="simple"/><mml:math display="inline" id="M124"><mml:mrow><mml:mi>μ</mml:mi> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> due to the penalty term stays invariant. The final run of OASIS on the full data is warm started using the solution obtained on the decimated data. Data points that are not in the proximity of a spike of the downsampled solution are already combined into large pools, instead of initializing each data point as its own separate pool. More precisely, if the deconvolved decimated data has positive values at times {<italic>t</italic><sub><italic>i</italic></sub>}, for deconvolving the full data time steps ⋃<sub><italic>i</italic></sub>{(<italic>k</italic> − 1)<italic>t</italic><sub><italic>i</italic></sub>, …, (<italic>k</italic> + 1.5)<italic>t</italic><sub><italic>i</italic></sub>} are initialized as individual pools, while the remaining time steps are pooled together into bigger pools, separated from each other by the individual ones, with values given by <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref> and weights by its denominator.</p>
<p>In particular the estimation of the AR coefficient <italic>γ</italic> is computationally burdensome, because it involves expensive repeated evaluations of the RSS in order to minimize it as function of <inline-formula id="pcbi.1005423.e125"><alternatives><graphic id="pcbi.1005423.e125g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e125" xlink:type="simple"/><mml:math display="inline" id="M125"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> (and <inline-formula id="pcbi.1005423.e126"><alternatives><graphic id="pcbi.1005423.e126g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e126" xlink:type="simple"/><mml:math display="inline" id="M126"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>). The computing time depends linearly on the number of pools <italic>z</italic> and we gain further speed-ups by restricting the attention to merely a subset of pools. In particular, because <italic>γ</italic> can be well estimated based on large isolated calcium events, we restrict the calculation of the RSS to the pools with largest product of value and length. A large value indicates a large event and a long pool an isolated event. We present detailed results in the Results section, indicating that altogether we can save about an order of magnitude computation with the greatest savings obtained by reducing the optimization of <inline-formula id="pcbi.1005423.e127"><alternatives><graphic id="pcbi.1005423.e127g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e127" xlink:type="simple"/><mml:math display="inline" id="M127"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> from <italic>O</italic>(<italic>z</italic>) to <italic>O</italic>(1).</p>
<p>It is also worth noting that the hyperparameter estimation discussed above is performed in ‘batch’ mode, not online. However, once good hyperparameter values are obtained on a short initial batch we can switch into online mode (with the hyperparameters held fixed) and handle the remaining data in a stream.</p>
</sec>
<sec id="sec011">
<title>Hard shrinkage and <italic>ℓ</italic><sub>0</sub> penalty</title>
<p>It is well-known that <italic>ℓ</italic><sub>1</sub> penalization results in “soft-thresholding” [<xref ref-type="bibr" rid="pcbi.1005423.ref034">34</xref>], in which small values are zeroed out and large values are shifted to lower values (where the size of this shift is proportional to the penalty λ). We can perform hard instead of soft thresholding (avoiding this shrinkage of large values) by replacing the sparsity penalty by a constraint on the minimum spike size <italic>s</italic><sub>min</sub>. The problem
<disp-formula id="pcbi.1005423.e128"><alternatives><graphic id="pcbi.1005423.e128g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e128" xlink:type="simple"/><mml:math display="block" id="M128"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:munder> <mml:mspace width="1.em"/><mml:mstyle displaystyle="false" scriptlevel="0"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:msup><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>G</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mspace width="0.277778em"/><mml:mtext>with</mml:mtext> <mml:mspace width="0.277778em"/><mml:msub><mml:mover accent="true"><mml:mi>s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>≥</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mtext>min</mml:mtext></mml:msub> <mml:mspace width="0.277778em"/><mml:mtext>or</mml:mtext> <mml:mspace width="0.277778em"/><mml:msub><mml:mover accent="true"><mml:mi>s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives> <label>(25)</label></disp-formula>
is non-convex and we are not guaranteed to find the global minimum. However, we obtain a good local minimum by merely changing the condition to merge pools from <inline-formula id="pcbi.1005423.e129"><alternatives><graphic id="pcbi.1005423.e129g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e129" xlink:type="simple"/><mml:math display="inline" id="M129"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>&lt;</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> to <inline-formula id="pcbi.1005423.e130"><alternatives><graphic id="pcbi.1005423.e130g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e130" xlink:type="simple"/><mml:math display="inline" id="M130"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>&lt;</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mstyle mathvariant="normal"><mml:mi>m</mml:mi> <mml:mi>i</mml:mi> <mml:mi>n</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, modifying lines 3 and 5 in Algorithm 2.</p>
<p>Now we must choose a value for <italic>s</italic><sub>min</sub>. In many cases we found that simply setting <italic>s</italic><sub>min</sub> as a small multiple of the noise level led to good results. If the scaling factor <italic>a</italic> (<xref ref-type="disp-formula" rid="pcbi.1005423.e003">Eq 2</xref>) relating fluorescence to action potentials was known, we could properly normalize the spike train such that <inline-formula id="pcbi.1005423.e131"><alternatives><graphic id="pcbi.1005423.e131g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e131" xlink:type="simple"/><mml:math display="inline" id="M131"><mml:mrow><mml:msub><mml:mover><mml:mi>s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> corresponds to one spike and choose <italic>s</italic><sub>min</sub> = 0.5, or a slightly higher value to avoid splitting one spike into two of size 0.5. However, often the factor is unknown or difficult to estimate, rendering the choice of <italic>s</italic><sub>min</sub> cumbersome. Analogous to the variation of λ, we can start with <italic>s</italic><sub>min</sub> = 0 and increase it until the RSS crosses the <italic>σ</italic><sup>2</sup> <italic>T</italic> threshold by sequentially removing the smallest ‘spike’ and merging the pools it used to separate. By maximizing <italic>s</italic><sub>min</sub> under the noise constraint we minimize the number of non-zero values of <inline-formula id="pcbi.1005423.e132"><alternatives><graphic id="pcbi.1005423.e132g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e132" xlink:type="simple"/><mml:math display="inline" id="M132"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. De facto, we try to find a parsimonious description of the data by minimizing the number of non-zero values of <inline-formula id="pcbi.1005423.e133"><alternatives><graphic id="pcbi.1005423.e133g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e133" xlink:type="simple"/><mml:math display="inline" id="M133"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, thus solving a sparsity problem with <italic>ℓ</italic><sub>0</sub> penalty:
<disp-formula id="pcbi.1005423.e134"><alternatives><graphic id="pcbi.1005423.e134g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e134" xlink:type="simple"/><mml:math display="block" id="M134"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:munder> <mml:mrow><mml:mspace width="1.em"/><mml:mo>∥</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>0</mml:mn></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>G</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn> <mml:mspace width="1.em"/><mml:mtext>and</mml:mtext> <mml:mspace width="1.em"/><mml:msup><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>≤</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives> <label>(26)</label></disp-formula>
Instead of sequentially removing the smallest ‘spike’ we actually obtained the best performance by sequentially adding spikes at the highest values of the <italic>ℓ</italic><sub>1</sub>-solution <inline-formula id="pcbi.1005423.e135"><alternatives><graphic id="pcbi.1005423.e135g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e135" xlink:type="simple"/><mml:math display="inline" id="M135"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> until the RSS is smaller than <inline-formula id="pcbi.1005423.e136"><alternatives><graphic id="pcbi.1005423.e136g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e136" xlink:type="simple"/><mml:math display="inline" id="M136"><mml:mrow><mml:msup><mml:mover><mml:mi>σ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. While the updates resemble those of matching pursuit [<xref ref-type="bibr" rid="pcbi.1005423.ref035">35</xref>], in practice we found that adding spikes at the positions suggested by the <italic>ℓ</italic><sub>1</sub>-solution yields better results than matching pursuit (which adds spikes at positions that greedily lead to the highest RSS reduction per step). Specifically, we found that often matching pursuit cannot resolve spikes in close proximity, but instead results in erroneous placement of one big spike as an explanation for all nearby spikes. Instead of merging pools we now need to split pools. Denoting the time where to add a spike by <italic>t</italic><sub><italic>s</italic></sub>, i.e. the time where the <italic>ℓ</italic><sub>1</sub>-solution has its highest value after ruling out times where spikes have already been added, one searches for the pool <italic>i</italic> in which it falls, i.e. <italic>t</italic><sub><italic>i</italic></sub> &lt; <italic>t</italic><sub><italic>s</italic></sub> &lt; <italic>t</italic><sub><italic>i</italic></sub> + <italic>l</italic><sub><italic>i</italic></sub>. Pool <italic>i</italic> gets updated as <inline-formula id="pcbi.1005423.e137"><alternatives><graphic id="pcbi.1005423.e137g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e137" xlink:type="simple"/><mml:math display="inline" id="M137"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>s</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1005423.e138"><alternatives><graphic id="pcbi.1005423.e138g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e138" xlink:type="simple"/><mml:math display="inline" id="M138"><mml:mrow><mml:msubsup><mml:mi>w</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, and <inline-formula id="pcbi.1005423.e139"><alternatives><graphic id="pcbi.1005423.e139g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e139" xlink:type="simple"/><mml:math display="inline" id="M139"><mml:mrow><mml:msubsup><mml:mi>v</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>/</mml:mo> <mml:msubsup><mml:mi>w</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, which follows directly from <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref> with <italic>μ</italic><sub><italic>t</italic></sub> = 0. All pool indices greater than <italic>i</italic> are increased by one and a new pool is inserted after pool <italic>i</italic> with <inline-formula id="pcbi.1005423.e140"><alternatives><graphic id="pcbi.1005423.e140g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e140" xlink:type="simple"/><mml:math display="inline" id="M140"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:msubsup><mml:mi>l</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1005423.e141"><alternatives><graphic id="pcbi.1005423.e141g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e141" xlink:type="simple"/><mml:math display="inline" id="M141"><mml:mrow><mml:msubsup><mml:mi>t</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1005423.e142"><alternatives><graphic id="pcbi.1005423.e142g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e142" xlink:type="simple"/><mml:math display="inline" id="M142"><mml:mrow><mml:msubsup><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msup><mml:mi>γ</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>t</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, and <inline-formula id="pcbi.1005423.e143"><alternatives><graphic id="pcbi.1005423.e143g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e143" xlink:type="simple"/><mml:math display="inline" id="M143"><mml:mrow><mml:msubsup><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>s</mml:mi></mml:msub></mml:mrow></mml:msub> <mml:msup><mml:mi>γ</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>/</mml:mo> <mml:msubsup><mml:mi>w</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<p>As is the case with all optimized hyperparameters, once we have obtained a decent estimate of <italic>s</italic><sub>min</sub> on an initial subset of the data we can switch back into online mode. In online mode our algorithm is typically faster than matching pursuit, since matching pursuit requires updating <italic>O</italic>(Δ) points of the residual with each update, where Δ is the length of the calcium transient (in number of frames).</p>
</sec>
</sec>
<sec id="sec012">
<title>Generalization beyond the AR(1) case</title>
<sec id="sec013">
<title>A greedy solution for the AR(<italic>p</italic>&gt;1) processes</title>
<p>An AR(1) process models the calcium response to a spike as an instantaneous increase followed by an exponential decay. This is a good description when the fluorescence rise time constant is small compared to the length of a time-bin, e.g. when using GCaMP6f [<xref ref-type="bibr" rid="pcbi.1005423.ref036">36</xref>] with a slow imaging rate. For fast imaging rates and slow indicators such as GCaMP6s it is more accurate to explicitly model the finite rise time. Typically we choose an AR(2) process, though more structured responses (e.g. multiple decay time constants) can also be modeled with higher values for the order <italic>p</italic>.</p>
<p>For an AR(<italic>p</italic>) process the sparsity penalty <inline-formula id="pcbi.1005423.e144"><alternatives><graphic id="pcbi.1005423.e144g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e144" xlink:type="simple"/><mml:math display="inline" id="M144"><mml:mrow><mml:mo>λ</mml:mo> <mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:msub><mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> can again be expressed as <inline-formula id="pcbi.1005423.e145"><alternatives><graphic id="pcbi.1005423.e145g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e145" xlink:type="simple"/><mml:math display="inline" id="M145"><mml:mrow><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:msup><mml:mspace width="-0.167em"/><mml:mo>⊤</mml:mo></mml:msup> <mml:mspace width="-0.167em"/><mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>, because
<disp-formula id="pcbi.1005423.e146"><alternatives><graphic id="pcbi.1005423.e146g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e146" xlink:type="simple"/><mml:math display="block" id="M146"><mml:mrow><mml:mrow><mml:mo>λ</mml:mo> <mml:mo>∥</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msub><mml:mrow><mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:mn mathvariant="bold">1</mml:mn> <mml:msup><mml:mspace width="-0.166667em"/><mml:mi>⊤</mml:mi></mml:msup> <mml:mspace width="-0.166667em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:msub><mml:mi>G</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mo>λ</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mspace width="-8.5pt"/><mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mo>(</mml:mo> <mml:mi>p</mml:mi> <mml:mo>,</mml:mo> <mml:mi>T</mml:mi> <mml:mo>-</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo> <mml:mspace width="-8.5pt"/></mml:mrow></mml:munderover> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>T</mml:mi></mml:munderover> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:msub><mml:mover accent="true"><mml:mi>c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:msup><mml:mspace width="-0.166667em"/><mml:mi>⊤</mml:mi></mml:msup> <mml:mspace width="-0.166667em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives> <label>(27)</label></disp-formula>
with <inline-formula id="pcbi.1005423.e147"><alternatives><graphic id="pcbi.1005423.e147g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e147" xlink:type="simple"/><mml:math display="inline" id="M147"><mml:mrow><mml:msub><mml:mi>μ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>≔</mml:mo> <mml:mo>λ</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>−</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mtext>min</mml:mtext> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>p</mml:mi> <mml:mo>,</mml:mo> <mml:mi>T</mml:mi> <mml:mo>−</mml:mo> <mml:mi>t</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:msubsup> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, by evaluating the column sums of <italic>G</italic>. For <italic>p</italic> &gt; 1 the dynamics are no longer first-order Markov and the next value depends not only on the current but on possibly multiple previous time steps. Now following along the lines of the previous section just leads to a greedy, approximate solution; we will present an exact algorithm later. We use matrix- and vector notation to describe the dynamics of <italic>c</italic><sub><italic>t</italic></sub>. Let the transition matrix <italic>A</italic>, multi time step calcium vectors <bold><italic>ζ</italic></bold><sub><italic>t</italic></sub>, and vector <bold><italic>e</italic></bold> be defined as
<disp-formula id="pcbi.1005423.e148"><alternatives><graphic id="pcbi.1005423.e148g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e148" xlink:type="simple"/><mml:math display="block" id="M148"><mml:mrow><mml:mi>A</mml:mi> <mml:mo>=</mml:mo> <mml:mfenced close=")" open="("><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>γ</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mtd> <mml:mtd><mml:msub><mml:mi>γ</mml:mi> <mml:mn>2</mml:mn></mml:msub></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:msub><mml:mi>γ</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋱</mml:mo></mml:mtd> <mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd> <mml:mtd><mml:mo>⋯</mml:mo></mml:mtd> <mml:mtd><mml:mn>1</mml:mn></mml:mtd> <mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="2.em"/><mml:msub><mml:mi mathvariant="bold-italic">ζ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mfenced close=")" open="("><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mi>c</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mi>p</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mspace width="2.em"/><mml:mi mathvariant="bold-italic">e</mml:mi> <mml:mo>=</mml:mo> <mml:mfenced close=")" open="("><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mo>⋮</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:math></alternatives> <label>(28)</label></disp-formula>
The calcium dynamics is given by <bold><italic>ζ</italic></bold><sub><italic>t</italic></sub> = <italic>A<bold>ζ</bold></italic><sub><italic>t</italic>−1</sub> + <italic>s</italic><sub><italic>t</italic></sub><bold><italic>e</italic></bold>. Analogously to the AR(1) case we derive an algorithm that moves through the time series until it finds a violation of the constraint <inline-formula id="pcbi.1005423.e149"><alternatives><graphic id="pcbi.1005423.e149g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e149" xlink:type="simple"/><mml:math display="inline" id="M149"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>≥</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">e</mml:mi> <mml:mo>⊤</mml:mo></mml:msup> <mml:mspace width="-0.167em"/><mml:mi>A</mml:mi> <mml:msubsup><mml:mi mathvariant="bold-italic">ζ</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for some time <italic>τ</italic>, updates <inline-formula id="pcbi.1005423.e150"><alternatives><graphic id="pcbi.1005423.e150g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e150" xlink:type="simple"/><mml:math display="inline" id="M150"><mml:msubsup><mml:mi>c</mml:mi> <mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1005423.e151"><alternatives><graphic id="pcbi.1005423.e151g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e151" xlink:type="simple"/><mml:math display="inline" id="M151"><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:mi>τ</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula>, and backtracks further until the updates do not violate any constraints at previous time steps. Note that we also implicitly have constraints on <bold><italic>ζ</italic></bold><sub><italic>t</italic></sub>, enforcing the fact that <bold><italic>ζ</italic></bold><sub><italic>t</italic>+1</sub> is mostly a time-shifted version of <bold><italic>ζ</italic></bold><sub><italic>t</italic></sub>.</p>
<p>Assuming we need to backtrack by Δ<italic>t</italic> steps and introducing again <italic>t</italic>′ = <italic>τ</italic> − Δ<italic>t</italic>, the objective is to minimize <inline-formula id="pcbi.1005423.e152"><alternatives><graphic id="pcbi.1005423.e152g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e152" xlink:type="simple"/><mml:math display="inline" id="M152"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mi>τ</mml:mi></mml:msubsup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msubsup><mml:mi>c</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>−</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:msup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:msubsup><mml:mi>c</mml:mi> <mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> with respect to <inline-formula id="pcbi.1005423.e153"><alternatives><graphic id="pcbi.1005423.e153g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e153" xlink:type="simple"/><mml:math display="inline" id="M153"><mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> under the active constraints <bold><italic>ζ</italic></bold><sub><italic>t</italic></sub> = <italic>A<bold>ζ</bold></italic><sub><italic>t</italic>−1</sub> for <italic>t</italic> = <italic>t</italic>′ + 1, …, <italic>τ</italic>. Plugging in the constraints on the dynamics the objective reads
<disp-formula id="pcbi.1005423.e154"><alternatives><graphic id="pcbi.1005423.e154g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e154" xlink:type="simple"/><mml:math display="block" id="M154"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:munder> <mml:mspace width="1.em"/><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:munderover> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">e</mml:mi> <mml:mi>⊤</mml:mi></mml:msup> <mml:mspace width="-0.166667em"/><mml:msup><mml:mi>A</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:msubsup><mml:mi mathvariant="bold-italic">ζ</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>-</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:munderover> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:msup><mml:mi mathvariant="bold-italic">e</mml:mi> <mml:mi>⊤</mml:mi></mml:msup> <mml:mspace width="-0.166667em"/><mml:msup><mml:mi>A</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:msubsup><mml:mi mathvariant="bold-italic">ζ</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(29)</label></disp-formula>
Setting the derivative with respect to <inline-formula id="pcbi.1005423.e155"><alternatives><graphic id="pcbi.1005423.e155g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e155" xlink:type="simple"/><mml:math display="inline" id="M155"><mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> to zero and solving for <inline-formula id="pcbi.1005423.e156"><alternatives><graphic id="pcbi.1005423.e156g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e156" xlink:type="simple"/><mml:math display="inline" id="M156"><mml:msubsup><mml:mi>c</mml:mi> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> yields
<disp-formula id="pcbi.1005423.e157"><alternatives><graphic id="pcbi.1005423.e157g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e157" xlink:type="simple"/><mml:math display="block" id="M157"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msubsup> <mml:mfenced close=")" open="(" separators=""><mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mi>p</mml:mi></mml:msubsup> <mml:msub><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mi>k</mml:mi></mml:mrow></mml:msub> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>k</mml:mi></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mfenced> <mml:msub><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msubsup> <mml:msubsup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives> <label>(30)</label></disp-formula>
where <inline-formula id="pcbi.1005423.e158"><alternatives><graphic id="pcbi.1005423.e158g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e158" xlink:type="simple"/><mml:math display="inline" id="M158"><mml:mrow><mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:mi>t</mml:mi></mml:msup> <mml:msubsup><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> denotes the square of the entry in the first row and column in the matrix obtained as <italic>t</italic>-th matrix power of <italic>A</italic>. Again, note that these entries describe the calcium kernel <bold><italic>h</italic></bold> with components <italic>h</italic><sub>1+<italic>t</italic></sub> = (<italic>A</italic><sup><italic>t</italic></sup>)<sub>1,1</sub>. <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref> reduces to <xref ref-type="disp-formula" rid="pcbi.1005423.e049">Eq (11)</xref> for <italic>p</italic> = 1 where <italic>A</italic> is just a 1 × 1-matrix with entry <italic>γ</italic>. The next values are updated according to <inline-formula id="pcbi.1005423.e159"><alternatives><graphic id="pcbi.1005423.e159g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e159" xlink:type="simple"/><mml:math display="inline" id="M159"><mml:mrow><mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>p</mml:mi></mml:msubsup> <mml:msub><mml:mi>γ</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:msubsup><mml:mi>c</mml:mi> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mi>t</mml:mi> <mml:mo>−</mml:mo> <mml:mi>k</mml:mi></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>t</italic> = 1, …, Δ<italic>t</italic>.</p>
<p>We derive again an efficient formulation of the algorithm using pools. Considering the denominator in <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref> as a weight in analogy to the AR(1) case and calculating the weighted sum upon merging of pools is not valid for <italic>p</italic> &gt; 1 because in general (<italic>A</italic><sup><italic>t</italic></sup>)<sub>1,1</sub>(<italic>A</italic><sup><italic>u</italic></sup>)<sub>1,1</sub> ≠ (<italic>A</italic><sup><italic>t</italic>+<italic>u</italic></sup>)<sub>1,1</sub>. Introducing pools is still useful as it allows us to keep track of only a small number of <italic>p</italic> elements in each pool. While for the case of AR(1) we only kept track of each group’s first element, we now keep track of the first as well as the <italic>p</italic> − 1 last elements. In order to speed up the update in <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref>, we can precompute the powers of <italic>A</italic> and store (<italic>A</italic><sup><italic>t</italic></sup>)<sub>1,:</sub> in memory. Note that only the powers up to the maximal inter-spike-interval are needed, which can be much smaller than <italic>T</italic>; of course, for very large values of <italic>t</italic>, (<italic>A</italic><sup><italic>t</italic></sup>)<sub>1,:</sub> ≈ 0, by the stability of <italic>A</italic>; thus for high powers the entries of (<italic>A</italic><sup><italic>t</italic></sup>)<sub>1,:</sub> can also be well approximated by a quickly computable exponential function or simply be truncated. Analogous to the case <italic>p</italic> = 1, we can also impose a constraint on the minimum spike size <italic>s</italic><sub>min</sub> at the expense of having to deal with a non-convex problem by merely changing the condition to merge pools from <inline-formula id="pcbi.1005423.e160"><alternatives><graphic id="pcbi.1005423.e160g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e160" xlink:type="simple"/><mml:math display="inline" id="M160"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>&lt;</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>u</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> to <inline-formula id="pcbi.1005423.e161"><alternatives><graphic id="pcbi.1005423.e161g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e161" xlink:type="simple"/><mml:math display="inline" id="M161"><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>&lt;</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:msup><mml:mi>A</mml:mi> <mml:msub><mml:mi>l</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:msup> <mml:msub><mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:msub><mml:mi>u</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mstyle mathvariant="normal"><mml:mi>m</mml:mi> <mml:mi>i</mml:mi> <mml:mi>n</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> where <italic>v</italic><sub><italic>i</italic></sub> and <italic>u</italic><sub><italic>i</italic></sub> denote the first and last value of pool <italic>i</italic>.</p>
<p>According to <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref> the solution is a linear function of <bold><italic>μ</italic></bold>, and hence of λ. Thus the hard noise constraint for the RSS ‖<bold><italic>c</italic></bold> − <bold><italic>y</italic></bold>‖<sup>2</sup> = <italic>σ</italic><sup>2</sup> <italic>T</italic> is a quadratic equation in λ, that can be solved analytically, under the assumption of invariant pool structure analogous to above case of AR(1), but involving more lengthy expressions which we state explicitly in <xref ref-type="supplementary-material" rid="pcbi.1005423.s001">S1 Appendix</xref>. Updating all pools independently according to <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref> can give rise to violated constraints, requiring us to rerun the algorithm, warm-started by initializing with the current set of pools, as described above. After 2–3 iterations no pools need to be merged and the final solution has been found. We can again interleave an update step for optimizing the parameters <italic>γ</italic><sub><italic>i</italic></sub>, as described above.</p>
</sec>
<sec id="sec014">
<title>Online Non-Negative Least Squares (ONNLS)</title>
<p>We noted above that <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref> is not first-order Markovian: it includes a dependency on <italic>p</italic> − 1 previous time steps and hence in general the previous pool. In updating only the first value within a pool and using the current values of the <italic>p</italic> − 1 last values of the previous pool within the update <xref ref-type="disp-formula" rid="pcbi.1005423.e157">Eq (30)</xref>, we actually performed greedy updates. These greedy updates can yield remarkably good results, in particular for long pools, such that the last value is already well constrained by a number of data points and hardly affected by the next pool. Nonetheless, in some cases these greedy updates lead to errors in the timing of inferred activity, in particular when the rise time of the calcium response is slow compared to the frame rate. The method described in this section can be used to correct these small errors. It is again an active set method that can be run in online mode; however, the method introduced above is a <italic>dual</italic> active set method, whereas here we describe a <italic>primal</italic> active set method.</p>
<p>We begin by reformulating the problem as
<disp-formula id="pcbi.1005423.e162"><alternatives><graphic id="pcbi.1005423.e162g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e162" xlink:type="simple"/><mml:math display="block" id="M162"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:munder> <mml:mspace width="1.em"/><mml:mstyle displaystyle="false" scriptlevel="0"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:mrow><mml:mo>∥</mml:mo> <mml:mi>K</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msup><mml:mrow><mml:mo>-</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>+</mml:mo> <mml:mo>λ</mml:mo> <mml:msub><mml:mrow><mml:mo>∥</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>1</mml:mn></mml:msub> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives> <label>(31)</label></disp-formula>
where <italic>K</italic> = <italic>G</italic><sup>−1</sup> is the convolution matrix with entries <italic>K</italic><sub><italic>t</italic>,<italic>u</italic></sub> = <italic>h</italic><sub>1+<italic>t</italic>−<italic>u</italic></sub> if <italic>t</italic> ≥ <italic>u</italic> else zero; the kernel vector <bold><italic>h</italic></bold> can be taken as an arbitrary response kernel for most of the development in this section. As noted earlier, <italic>h</italic><sub>1+<italic>t</italic></sub> = (<italic>A</italic><sup><italic>t</italic></sup>)<sub>1,1</sub> for the special case of an AR process. As we have seen previously, the effect of the sparsity penalty (together with the non-negative constraint) is to shift the data down by a vector <bold><italic>μ</italic></bold> = <italic>λK</italic><sup>−⊤</sup><bold>1</bold>, and the problem reduces to a non-negative least squares (NNLS) problem.
<disp-formula id="pcbi.1005423.e163"><alternatives><graphic id="pcbi.1005423.e163g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e163" xlink:type="simple"/><mml:math display="block" id="M163"><mml:mrow><mml:munder><mml:mtext>minimize</mml:mtext> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:munder> <mml:mspace width="1.em"/><mml:mstyle displaystyle="false" scriptlevel="0"><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac></mml:mstyle> <mml:msup><mml:mrow><mml:mo>∥</mml:mo> <mml:mi>K</mml:mi> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>-</mml:mo> <mml:mo>λ</mml:mo> <mml:msup><mml:mi>K</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mi>⊤</mml:mi></mml:mrow></mml:msup> <mml:mspace width="-0.166667em"/><mml:mn mathvariant="bold">1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>∥</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="1.em"/><mml:mtext>subject to</mml:mtext> <mml:mspace width="1.em"/><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>≥</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(32)</label></disp-formula>
(Note that the gradient of <xref ref-type="disp-formula" rid="pcbi.1005423.e163">Eq (32)</xref> is the same as the gradient of <xref ref-type="disp-formula" rid="pcbi.1005423.e162">Eq (31)</xref>, <inline-formula id="pcbi.1005423.e164"><alternatives><graphic id="pcbi.1005423.e164g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e164" xlink:type="simple"/><mml:math display="inline" id="M164"><mml:mrow><mml:msup><mml:mi>K</mml:mi> <mml:mo>⊤</mml:mo></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>K</mml:mi> <mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>−</mml:mo> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>−</mml:mo> <mml:mo>λ</mml:mo> <mml:msup><mml:mi>K</mml:mi> <mml:mrow><mml:mo>−</mml:mo> <mml:mo>⊤</mml:mo></mml:mrow></mml:msup> <mml:mspace width="-0.167em"/><mml:mn mathvariant="bold">1</mml:mn> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo>=</mml:mo> <mml:msup><mml:mi>K</mml:mi> <mml:mo>⊤</mml:mo></mml:msup> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>K</mml:mi> <mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>−</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo> <mml:mo>+</mml:mo> <mml:mo>λ</mml:mo> <mml:mn mathvariant="bold">1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>. In addition, <italic>K</italic> is triangular with positive numbers on the main diagonal, hence det <italic>K</italic> &gt; 0 and <italic>K</italic> is invertible.)</p>
<p>A classic algorithm for solving a NNLS problem is the active set method of [<xref ref-type="bibr" rid="pcbi.1005423.ref037">37</xref>] and [<xref ref-type="bibr" rid="pcbi.1005423.ref038">38</xref>]. This algorithm alternates between normal equation matrix solves involving sub-matrices of <italic>K</italic><sup>⊤</sup><italic>K</italic> and updates of the active set. A naive application of this algorithm would scale cubically with the number of spikes. Instead, we exploit the locality of the problem (the fact that changing a spike height at time <italic>t</italic> does not affect the solution at very distant times <italic>s</italic>) and apply the NNLS algorithm in the inner loop of a sequential coordinate block descent method. Specifically, we apply warm-started NNLS on blocks of size Δ (where Δ is the length of the calcium transient), stepping the block in steps of size Δ<sub>m</sub> &lt; Δ (we found <inline-formula id="pcbi.1005423.e175"><alternatives><graphic id="pcbi.1005423.e175g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e175" xlink:type="simple"/><mml:math display="inline" id="M175"><mml:mrow><mml:msub><mml:mo>Δ</mml:mo> <mml:mstyle mathvariant="normal"><mml:mi>m</mml:mi></mml:mstyle></mml:msub> <mml:mo>=</mml:mo> <mml:mfrac><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> to be effective for offline applications; for online applications Δ<sub>m</sub> would be set smaller) and applying NNLS while holding the values of <italic>s</italic> outside the block fixed. We further exploit the Toeplitz structure of <italic>K</italic> to precompute the necessary sub-matrices of <italic>K</italic><sup>⊤</sup><italic>K</italic>.</p>
<p><bold>Algorithm 3</bold> Fast online deconvolution for arbitrary convolution kernels</p>
<p specific-use="line"><bold>Require:</bold> kernel <bold><italic>h</italic></bold>, regularization parameter λ, window size Δ, shift size Δ<sub>m</sub>, data subset <bold><italic>y</italic></bold><sub><italic>t</italic>:<italic>t</italic>+Δ−1</sub> ⊂ <bold><italic>y</italic></bold> at time of reading</p>
<p specific-use="line">1: initialize <italic>K</italic><sub><italic>t</italic>,<italic>u</italic></sub> ← <italic>h</italic><sub>1+<italic>t</italic> − <italic>u</italic></sub> for 1 ≤ <italic>u</italic> ≤ <italic>t</italic> ≤ Δ, <bold><italic>y</italic></bold> ← <bold><italic>y</italic></bold> − <italic>λK</italic><sup>−⊤</sup><bold>1</bold>, <italic>A</italic> ← <italic>K</italic><sup>⊤</sup><italic>K</italic>, <italic>t</italic> ← 1</p>
<p specific-use="line">2: <bold>while</bold> <italic>t</italic> + Δ ≤ <italic>T</italic> <bold>do</bold></p>
<p specific-use="line">3:  <inline-formula id="pcbi.1005423.e165"><alternatives><graphic id="pcbi.1005423.e165g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e165" xlink:type="simple"/><mml:math display="inline" id="M165"><mml:mrow><mml:msub><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo accent="false">←</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> NNLS <inline-formula id="pcbi.1005423.e166"><alternatives><graphic id="pcbi.1005423.e166g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e166" xlink:type="simple"/><mml:math display="inline" id="M166"><mml:mrow><mml:mo>(</mml:mo><mml:mi>A</mml:mi> <mml:mo>,</mml:mo> <mml:mi>K</mml:mi> <mml:msup><mml:mspace width="-0.167em"/><mml:mo>⊤</mml:mo></mml:msup> <mml:mspace width="-0.167em"/><mml:msub><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:math></alternatives></inline-formula> ▹classic NNLS on <inline-formula id="pcbi.1005423.e167"><alternatives><graphic id="pcbi.1005423.e167g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e167" xlink:type="simple"/><mml:math display="inline" id="M167"><mml:msub><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>, but warm-started<sup>†</sup></p>
<p specific-use="line">4:  <inline-formula id="pcbi.1005423.e168"><alternatives><graphic id="pcbi.1005423.e168g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e168" xlink:type="simple"/><mml:math display="inline" id="M168"><mml:mrow><mml:msub><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo accent="false">←</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>−</mml:mo> <mml:msub><mml:mi>K</mml:mi> <mml:mrow><mml:mo>:</mml:mo> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:msub><mml:mo>Δ</mml:mo> <mml:mstyle mathvariant="normal"><mml:mi>m</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:msub> <mml:msub><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msub><mml:mo>Δ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>     ▹peel off contribution of previous activity</p>
<p specific-use="line">5:  <italic>t</italic> ← <italic>t</italic> + Δ<sub>m</sub></p>
<p specific-use="line">6: <inline-formula id="pcbi.1005423.e169"><alternatives><graphic id="pcbi.1005423.e169g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e169" xlink:type="simple"/><mml:math display="inline" id="M169"><mml:mrow><mml:msub><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>T</mml:mi></mml:mrow></mml:msub> <mml:mo accent="false">←</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> NNLS <inline-formula id="pcbi.1005423.e170"><alternatives><graphic id="pcbi.1005423.e170g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e170" xlink:type="simple"/><mml:math display="inline" id="M170"><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>A</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mi>T</mml:mi> <mml:mo>:</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mo>−</mml:mo> <mml:mi>T</mml:mi> <mml:mo>:</mml:mo> <mml:mo>Δ</mml:mo></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>K</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>T</mml:mi> <mml:mo>−</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>T</mml:mi> <mml:mo>−</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>⊤</mml:mo></mml:msubsup> <mml:msub><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>T</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>:</mml:mo> <mml:mi>T</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:math></alternatives></inline-formula>    ▹robustness to <inline-formula id="pcbi.1005423.e171"><alternatives><graphic id="pcbi.1005423.e171g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e171" xlink:type="simple"/><mml:math display="inline" id="M171"><mml:mrow><mml:mfrac><mml:mrow><mml:mi>T</mml:mi> <mml:mo>−</mml:mo> <mml:mo>Δ</mml:mo></mml:mrow> <mml:msub><mml:mo>Δ</mml:mo> <mml:mstyle mathvariant="normal"><mml:mi>m</mml:mi></mml:mstyle></mml:msub></mml:mfrac> <mml:mo>∉</mml:mo> <mml:mstyle mathvariant="double-struck"><mml:mi>ℕ</mml:mi></mml:mstyle></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line">7: <bold>return</bold> <inline-formula id="pcbi.1005423.e172"><alternatives><graphic id="pcbi.1005423.e172g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e172" xlink:type="simple"/><mml:math display="inline" id="M172"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula></p>
<p specific-use="line"><sup>†</sup>The function NNLS implements a minor variation of the classic algorithm of [<xref ref-type="bibr" rid="pcbi.1005423.ref038">38</xref>] to solve <inline-formula id="pcbi.1005423.e173"><alternatives><graphic id="pcbi.1005423.e173g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e173" xlink:type="simple"/><mml:math display="inline" id="M173"><mml:mrow><mml:msub><mml:mtext>min</mml:mtext> <mml:mrow><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>∈</mml:mo> <mml:msubsup><mml:mstyle mathvariant="double-struck"><mml:mi>ℝ</mml:mi></mml:mstyle> <mml:mo>+</mml:mo> <mml:mi>T</mml:mi></mml:msubsup></mml:mrow></mml:msub> <mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo>−</mml:mo> <mml:mi>K</mml:mi> <mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:msup><mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>: <italic>K</italic><sup>⊤</sup><italic>K</italic> and <italic>K</italic><sup>⊤</sup><bold><italic>y</italic></bold> are precomputed outside the function, to exploit that NNLS is called several times with the same <italic>K</italic>. Further <inline-formula id="pcbi.1005423.e174"><alternatives><graphic id="pcbi.1005423.e174g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e174" xlink:type="simple"/><mml:math display="inline" id="M174"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is warm-started instead of initializing it as <bold>0</bold>.</p>
<p>The resulting algorithm (Alg 3) runs in <italic>O</italic>(<italic>T</italic>) time. It involves solving a least squares problem for the time points within the considered window where <inline-formula id="pcbi.1005423.e176"><alternatives><graphic id="pcbi.1005423.e176g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e176" xlink:type="simple"/><mml:math display="inline" id="M176"><mml:mrow><mml:msub><mml:mover><mml:mi>s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>&gt;</mml:mo> <mml:mn>0</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>; thus it scales cubically with the number of spikes per window and depends on the sparsity of <inline-formula id="pcbi.1005423.e177"><alternatives><graphic id="pcbi.1005423.e177g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e177" xlink:type="simple"/><mml:math display="inline" id="M177"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. (In fact, for AR(<italic>p</italic>) models, the required matrix solves can be performed using linear-time (not cubic-time) Kalman filter-smoother methods, but the matrix sizes were sufficiently small in the examples examined here that the Kalman implementation was not necessary.) Further speedups can be obtained by restricting the set of possible spike times, for example, by running the AR(1) version of OASIS on a temporally decimated version of the signal to crudely identify the set of spike times, then never updating <inline-formula id="pcbi.1005423.e178"><alternatives><graphic id="pcbi.1005423.e178g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e178" xlink:type="simple"/><mml:math display="inline" id="M178"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> away from zero on the complement of this set.</p>
<p>To summarize, we describe in Algorithm 4 how the algorithmic variants introduced here are combined into a final full algorithm that includes hyperparameter optimization, the variants for AR(1) or AR(2), and soft (<italic>ℓ</italic><sub>1</sub> penalty) or hard shrinkage (<italic>ℓ</italic><sub>0</sub> penalty).</p>
<p><bold>Algorithm 4</bold> Full algorithm with hyperparameter optimization</p>
<p specific-use="line"><bold>Require:</bold> data <bold><italic>y</italic></bold>, order <italic>p</italic> of the AR-process, sparsity norm <italic>q</italic></p>
<p specific-use="line">1: initialize</p>
<p specific-use="line">2:   AR parameters <inline-formula id="pcbi.1005423.e179"><alternatives><graphic id="pcbi.1005423.e179g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e179" xlink:type="simple"/><mml:math display="inline" id="M179"><mml:mrow><mml:msub><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> using autocorrelation of <bold><italic>y</italic></bold></p>
<p specific-use="line">3:   noise level <inline-formula id="pcbi.1005423.e180"><alternatives><graphic id="pcbi.1005423.e180g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e180" xlink:type="simple"/><mml:math display="inline" id="M180"><mml:mover><mml:mi>σ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> using PSD of <bold><italic>y</italic></bold></p>
<p specific-use="line">4:   background <inline-formula id="pcbi.1005423.e181"><alternatives><graphic id="pcbi.1005423.e181g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e181" xlink:type="simple"/><mml:math display="inline" id="M181"><mml:mover><mml:mi>b</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> using percentile of <bold><italic>y</italic></bold></p>
<p specific-use="line">5:   dual variable λ ← 0</p>
<p specific-use="line">6: <inline-formula id="pcbi.1005423.e182"><alternatives><graphic id="pcbi.1005423.e182g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e182" xlink:type="simple"/><mml:math display="inline" id="M182"><mml:mrow><mml:mover><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo accent="true">˜</mml:mo></mml:mover> <mml:mo accent="false">←</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> temporally decimate batch of <bold><italic>y</italic></bold>      ▹for faster hyperparameter optimization</p>
<p specific-use="line">7: rescale hyperparamaters due to decimation</p>
<p specific-use="line">8: <bold>while</bold> hyperparamaters not converged <bold>do</bold>     ▹optimize hyperparameters, cf. <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3</xref></p>
<p specific-use="line">9:  Run warm-started Alg 2 on <inline-formula id="pcbi.1005423.e183"><alternatives><graphic id="pcbi.1005423.e183g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e183" xlink:type="simple"/><mml:math display="inline" id="M183"><mml:mover><mml:mi mathvariant="bold-italic">y</mml:mi> <mml:mo accent="true">˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> with current hyperparameters</p>
<p specific-use="line">10:  Update hyperparameters                  ▹Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e083">19</xref>, <xref ref-type="disp-formula" rid="pcbi.1005423.e103">23</xref> and <xref ref-type="disp-formula" rid="pcbi.1005423.e113">24</xref>)</p>
<p specific-use="line">11: <bold>if</bold> <italic>q</italic> = 0 <bold>then</bold> determine <italic>s</italic><sub>min</sub>           ▹Sec. ‘Hard shrinkage and <italic>ℓ</italic><sub>0</sub> penalty’</p>
<p specific-use="line">12: rescale hyperparamaters using the inverse transformations of line 7</p>
<p specific-use="line">13: <inline-formula id="pcbi.1005423.e184"><alternatives><graphic id="pcbi.1005423.e184g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e184" xlink:type="simple"/><mml:math display="inline" id="M184"><mml:mrow><mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo accent="false">←</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> run Alg 2 on full data <bold><italic>y</italic></bold></p>
<p specific-use="line">14: <bold>if</bold> <italic>p</italic> = 1 <bold>then</bold></p>
<p specific-use="line">15:  <bold>return</bold> <inline-formula id="pcbi.1005423.e185"><alternatives><graphic id="pcbi.1005423.e185g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e185" xlink:type="simple"/><mml:math display="inline" id="M185"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula></p>
<p specific-use="line">16: <bold>else</bold></p>
<p specific-use="line">17:  <inline-formula id="pcbi.1005423.e186"><alternatives><graphic id="pcbi.1005423.e186g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e186" xlink:type="simple"/><mml:math display="inline" id="M186"><mml:mrow><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo accent="false">←</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> run warm-started Alg 3 on full data <bold><italic>y</italic></bold></p>
<p specific-use="line">18:  <bold>return</bold> <inline-formula id="pcbi.1005423.e187"><alternatives><graphic id="pcbi.1005423.e187g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e187" xlink:type="simple"/><mml:math display="inline" id="M187"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula></p>
</sec>
</sec>
</sec>
<sec id="sec015" sec-type="results">
<title>Results</title>
<sec id="sec016">
<title>Benchmarking OASIS</title>
<p>We generated datasets of 20 fluorescence traces each for <italic>p</italic> = 1 and 2 with a duration of 100 s at a framerate of 30 Hz, such that <italic>T</italic> = 3,000 frames. The spiking signal came from a homogeneous Poisson process. We used <italic>γ</italic> = 0.95, <italic>σ</italic> = 0.3 for the AR(1) model and <italic>γ</italic><sub>1</sub> = 1.7, <italic>γ</italic><sub>2</sub> = −0.712, <italic>σ</italic> = 1 for the AR(2) model. <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4A–4C</xref> are reassuring that our suggested (dual) active set method yields indeed the same results as other convex solvers for an AR(1) process and that spikes are extracted well. For an AR(2) process OASIS is greedy and yields good results that are similar to the one obtained with convex solvers (lower panels in <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4B and 4C</xref>), with virtually identical denoised fluorescence traces (upper panels).</p>
<fig id="pcbi.1005423.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.g004</object-id>
<label>Fig 4</label>
<caption>
<title>OASIS produces the same high quality results as convex solvers at least an order of magnitude faster.</title>
<p><bold>(A)</bold> Raw and inferred traces for simulated AR(1) data, <bold>(B)</bold> simulated AR(2) and <bold>(C)</bold> real data from [<xref ref-type="bibr" rid="pcbi.1005423.ref036">36</xref>] fitted with an AR(2) model. OASIS solves <xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq (3)</xref> exactly for AR(1) and just approximately for AR(2) processes, nevertheless well extracting spikes. <bold>(D)</bold> Computation time for simulated AR(1) data with given λ (blue circles, <xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq 3</xref>) or inference with hard noise constraint (green x, <xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>). GUROBI failed on the noise constrained problem. The inset shows the same data in logarithmic scale. <bold>(E)</bold> Computation time for simulated AR(2) data. <bold>(F)</bold> Normalized computation time of OASIS for simulated AR(1) data with given λ (blue circles, <xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq 3</xref>) and inference with hard noise constraint on full data (green x, <xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>) or small initial batch followed by processing in online mode (orange crosses).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.g004" xlink:type="simple"/>
</fig>
<p><xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4D and 4E</xref> report the computation time (±SEM) averaged over all 20 traces and ten runs per trace on a MacBook Pro with Intel Core i5 2.7 GHz CPU. We compared the run time of our algorithm to a variety of state of the art convex solvers that can all be conveniently called from the convex optimization toolbox CVXPY [<xref ref-type="bibr" rid="pcbi.1005423.ref039">39</xref>]: embedded conic solver (ECOS, [<xref ref-type="bibr" rid="pcbi.1005423.ref040">40</xref>]), MOSEK [<xref ref-type="bibr" rid="pcbi.1005423.ref041">41</xref>], splitting conic solver (SCS, [<xref ref-type="bibr" rid="pcbi.1005423.ref042">42</xref>]) and GUROBI [<xref ref-type="bibr" rid="pcbi.1005423.ref043">43</xref>]. ECOS and MOSEK are the most competitive methods; these are interior-point methods that cannot use warm starts. With a known sparsity parameter λ (<xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq 3</xref>), OASIS is about two magnitudes faster than any other method for an AR(1) process (<xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4D</xref>, blue disks) and more than one magnitude for an AR(2) process (<xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4E</xref>). Whereas several of the other solvers take almost the same time for the noise constrained problem (<xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>, <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4D and 4E</xref>, green x), our method takes about three times longer to find the value of the dual variable λ compared to the formulation where the residual is part of the objective; nevertheless it still outperforms the other algorithms by a huge margin.</p>
<p>We also ran the algorithms on longer traces up to a length of <italic>T</italic> = 300,000 frames (<xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4F</xref>), confirming that OASIS scales linearly with <italic>T</italic>, where we obtained a proportionality constant of 1 <italic>μ</italic>s/frame. For an unknown hyperparameter λ we obtained its value not only on the full data but on an initial small batch (1,000 frames) and kept it fixed, which sped activity inference up by a factor of three once <italic>T</italic> is sufficiently large (<xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4F</xref>, orange vs green) without compromising quality (correlation between <italic>deconvolved</italic> activity and ground truth spike train 0.882 ± 0.001 vs 0.881 ± 0.002 for <italic>T</italic> = 300,000). Our active set method maintained its lead by 1–2 orders of magnitude in computing time. Further, compared to our active set method the other algorithms required at least an order of magnitude more RAM, confirming that OASIS is not only faster but much more memory efficient. Indeed, because OASIS can run in online mode the memory footprint can be <italic>O</italic>(1), instead of <italic>O</italic>(<italic>T</italic>).</p>
<p>We verified these results on real data as well. Running OASIS with the hard noise constraint and <italic>p</italic> = 2 on the GCaMP6s dataset of 14,400 frames collected at 60 Hz from [<xref ref-type="bibr" rid="pcbi.1005423.ref036">36</xref>, <xref ref-type="bibr" rid="pcbi.1005423.ref044">44</xref>] took 0.101±0.005 s per trace, whereas the fastest other methods required 2.37±0.12 s. <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4C</xref> shows the real data together with the inferred denoised and deconvolved traces as well as the true spike times, which were obtained by simultaneous electrophysiological recordings [<xref ref-type="bibr" rid="pcbi.1005423.ref036">36</xref>].</p>
<p>We also extracted each neuron’s fluorescence activity using CNMF from an unpublished whole-brain zebrafish imaging dataset from the M. Ahrens lab. Running OASIS with hard noise constraint and <italic>p</italic> = 1 (chosen because the calcium onset was fast compared to the acquisition rate of 2 Hz) on 10,000 traces out of a total of 91,478 suspected neurons took 81.5 s whereas ECOS, the fastest competitor, needed 2,818.1 s. For all neurons we would hence expect 745 s for OASIS, which is below the 1,500 s recording duration (3,000 frames), and over 25,780 s for ECOS and other candidates.</p>
<p>OASIS solves the non-negative deconvolution problem exactly for an AR(1) process; however, as discussed above, for <italic>p</italic> &gt; 1 the solution is only a good (greedy) approximation. To obtain the exact solution we ran the ONNLS algorithm on the simulated AR(2) traces using a window size of 200 frames, which was about ten times larger than the fluorescence decay time, and shifting the window by 100 frames. We obtained higher accuracy results than all the state of the art convex solvers we compared to, requiring merely 27.8±0.4 ms per trace for λ = 0 and 20.0±0.4 ms per trace for λ = 30, the value that ensures that the hard noise constraint is tight. The choice of λ regulated the sparsity of the solution, which affects the run time of ONNLS. The fastest state of the art convex solver (ECOS) required 305±9 ms and was thus an order of magnitude slower. It took merely 8.56±0.04 ms to obtain an approximate greedy solution using OASIS, independent of the choice of sparsity parameter λ. Though obtaining the exact solution requires more computing time, it is well within the same order of magnitude. In contrast, running batch NNLS was significantly slower, requiring 2,430±53 ms for λ = 0 and 1,620±37 ms for λ = 30. Solving the noise constrained problem by iterating warm-started ONNLS to obtain the corresponding value of the dual variable λ took 73±1 ms. However, we can improve on that by first running the fast but (for <italic>p</italic> &gt; 1) approximate dual method to obtain a good estimate of λ as well as <italic>s</italic>, and then switching to the slower but exact primal method. Running OASIS and executing warm-started ONNLS just once required collectively merely 23±1 ms, similarly to cold-started ONNLS with given λ. Running ONNLS not just once, but until the value of λ has been further tuned such that the noise constraint holds not approximately but exactly, took altogether 31±1 ms.</p>
</sec>
<sec id="sec017">
<title>Hyperparameter optimization</title>
<p>We have shown that we can solve Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e005">3</xref>) and (<xref ref-type="disp-formula" rid="pcbi.1005423.e077">15</xref>) faster than interior point methods. The AR coeffient <italic>γ</italic> was either known or estimated based on the autocorrelation in the above analyses. The latter approach assumes that the spiking signal comes from a homogeneous Poisson process, which does not generally hold for realistic data. Therefore we were interested in optimizing not only the sparsity parameter λ, but also the AR(1) coeffient <italic>γ</italic>. To illustrate the optimization of both, we generated a fluorescence trace with spiking signal from an inhomogeneous Poisson process with sinusoidal instantaneous firing rate (<xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3</xref>). We conservatively initialized <inline-formula id="pcbi.1005423.e188"><alternatives><graphic id="pcbi.1005423.e188g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e188" xlink:type="simple"/><mml:math display="inline" id="M188"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> to a small value of 0.9. The value obtained based on the autocorrelation was 0.9792 and larger than the true value of 0.95. The left panels in <xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3B and 3D</xref> illustrate the update of λ from the previous value λ<sup>−</sup> to λ* by solving a quadratic equation analytically (<xref ref-type="disp-formula" rid="pcbi.1005423.e082">Eq 18</xref>) and the update of <inline-formula id="pcbi.1005423.e189"><alternatives><graphic id="pcbi.1005423.e189g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e189" xlink:type="simple"/><mml:math display="inline" id="M189"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> by numerical minimization of a high order polynomial respectively. Note that after merely one iteration (<xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3E</xref>) a good solution is obtained and after three iterations the solution is virtually identical to the one obtained when the true value of <italic>γ</italic> has been provided (<xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3F</xref>). This holds not only visually, but also when judged by the correlation between <italic>deconvolved</italic> activity and ground truth spike train, which was 0.869 compared to merely 0.773 if <inline-formula id="pcbi.1005423.e190"><alternatives><graphic id="pcbi.1005423.e190g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e190" xlink:type="simple"/><mml:math display="inline" id="M190"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> was obtained based on the autocorrelation. The optimization was robust to the initial value of <inline-formula id="pcbi.1005423.e191"><alternatives><graphic id="pcbi.1005423.e191g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e191" xlink:type="simple"/><mml:math display="inline" id="M191"><mml:mover><mml:mi>γ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, as long as it was positive and not, or only marginally, greater than the true value. The value obtained based on the autocorrelation was considerably greater and partitioned the time series into pools in a way that missed entire spikes.</p>
<p>After illustrating the hyperparameter optimization we next quantify the computing time and quality of spike inference for various optimization scenarios. We generated 20 fluorescence traces with sinusoidal instantaneous firing rate as used in the illustration (<xref ref-type="fig" rid="pcbi.1005423.g003">Fig 3</xref>), again having a duration of 100 s at a framerate of 30 Hz, such that <italic>T</italic> = 3,000 frames, however we offset the data by an additional positive baseline <italic>b</italic> that can be present in real data. This baseline can be optimized together with the sparsity parameter λ, as shown in Methods (subsection “Additional baseline”). The fastest deconvolution method is to merely estimate all parameters and run OASIS just once, cf. first row in <xref ref-type="table" rid="pcbi.1005423.t001">Table 1</xref> which shows the mean (±SEM) for computing time as well as correlation of the inferred spike train. As a baseline estimate we used the 15% percentile of the fluorescence trace. The sparsity penalty was set to λ = 0. A better choice of λ is actually obtained by optimizing it, such that the hard noise constraint <inline-formula id="pcbi.1005423.e192"><alternatives><graphic id="pcbi.1005423.e192g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e192" xlink:type="simple"/><mml:math display="inline" id="M192"><mml:mrow><mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mi>b</mml:mi> <mml:mn mathvariant="bold">1</mml:mn> <mml:mo>+</mml:mo> <mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>−</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:msup><mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover><mml:mi>σ</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> holds, cf. second row in <xref ref-type="table" rid="pcbi.1005423.t001">Table 1</xref>. The next rows show that optimizing <italic>b</italic> further improves the result, as does adding <italic>γ</italic>. However, the increased number of optimized parameters results in extra computational cost. The computation time can be reduced by estimating <italic>γ</italic> not using the full data but only a limited number of pools, which does not affect the quality of the result, cf. row five and six in <xref ref-type="table" rid="pcbi.1005423.t001">Table 1</xref>. Note that by restricting the optimization to a fixed number of pools, its computational load does not increase with the duration of the recording, hence the gain would be even more dramatic for longer time series. Further speed ups are obtained by estimating the parameters on a decimated version of the data, as the last rows in <xref ref-type="table" rid="pcbi.1005423.t001">Table 1</xref> illustrate. Here we decimated the fluorescence traces by a factor of ten, without harming the inference quality.</p>
<table-wrap id="pcbi.1005423.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.t001</object-id>
<label>Table 1</label>
<caption>
<title>Cost and quality of spike inference with parameter optimization.</title>
</caption>
<alternatives>
<graphic id="pcbi.1005423.t001g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.t001" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left">optimize</th>
<th align="left">accelerate</th>
<th align="left">Time [ms]</th>
<th align="left">Correlation</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">-</td>
<td align="left">-</td>
<td align="center">3.25 ± 0.03</td>
<td align="left">0.831 ± 0.006</td>
</tr>
<tr>
<td align="left">λ</td>
<td align="left">-</td>
<td align="center">9.2 ± 0.1</td>
<td align="left">0.849 ± 0.006</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic></td>
<td align="left">-</td>
<td align="center">8.4 ± 0.2</td>
<td align="left">0.857 ± 0.007</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic>, <italic>γ</italic></td>
<td align="left">-</td>
<td align="center">48.4 ± 2.3</td>
<td align="left">0.875 ± 0.006</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic>, <italic>γ</italic></td>
<td align="left">use 10 pools</td>
<td align="center">16.0 ± 0.4</td>
<td align="left">0.875 ± 0.006</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic>, <italic>γ</italic></td>
<td align="left">use 5 pools</td>
<td align="center">14.2 ± 0.3</td>
<td align="left">0.875 ± 0.006</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic>, <italic>γ</italic></td>
<td align="left">decimate</td>
<td align="center">29.4 ± 1.3</td>
<td align="left">0.878 ± 0.006</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic>, <italic>γ</italic></td>
<td align="left">decimate, use 10 pools</td>
<td align="center">12.1 ± 0.2</td>
<td align="left">0.878 ± 0.006</td>
</tr>
<tr>
<td align="left">λ, <italic>b</italic>, <italic>γ</italic></td>
<td align="left">decimate, use 5 pools</td>
<td align="center">10.6 ± 0.2</td>
<td align="left">0.877 ± 0.006</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t001fn001">
<p>The first column shows the quantities that have been optimized, the second methods used to accelerate the parameter optimization, the third the computing time per trace (±SEM) and the last shows the performance of spike train inference using the correlation between inferred activity and true spike train. We used 20 simulated fluorescence traces with a spiking signal coming from an inhomogeneous Poisson process and a duration of 100 s at a framerate of 30 Hz such that <italic>T</italic> = 3,000 frames.</p>
</fn>
</table-wrap-foot>
</table-wrap>
</sec>
<sec id="sec018">
<title>Hard thresholding</title>
<p>OASIS solves a LASSO problem resulting in soft shrinkage. The deconvolved trace <inline-formula id="pcbi.1005423.e193"><alternatives><graphic id="pcbi.1005423.e193g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e193" xlink:type="simple"/><mml:math display="inline" id="M193"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> typically has values smaller than 1 and often shows “partial spikes” in neighboring bins reflecting the uncertainty regarding the exact position of a spike, cf. <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4</xref>. While this information can be useful, one sometimes wants to merely commit to one event within a time bin instead and get rid of remaining small values in <inline-formula id="pcbi.1005423.e194"><alternatives><graphic id="pcbi.1005423.e194g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e194" xlink:type="simple"/><mml:math display="inline" id="M194"><mml:mover><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. We ran a slightly modified version of the algorithm that replaces the sparsity penalty by a constraint on the minimal spike size <italic>s</italic><sub>min</sub>, yielding sparser solutions but rendering the problem non-convex. Although we are not guaranteed to find the global minimum, we obtained good results, cf. <xref ref-type="fig" rid="pcbi.1005423.g005">Fig 5</xref>. To quantify directly the similarity between the inferred deconvolved trace and ground truth spike train we calculated the correlation between the two. The best results were obtained for <italic>s</italic><sub>min</sub> = 0.5 yielding correlation 0.899 ± 0.009 with the true spike train compared to 0.879 ± 0.006 for the solution of the problem with hard noise constraint (<xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>). However, in a practical application the scaling factor between calcium fluorescence and a single spike, which is 1 for our simulated data, is often unknown, rendering it impossible to simply set the threshold <italic>s</italic><sub>min</sub> to the half of it. Instead, we can vary the threshold until the RSS crosses the threshold <italic>σ</italic><sup>2</sup> <italic>T</italic>. The order in which the pools are merged or split matters for this non-convex case and sequentially adding spikes at the highest values of the <italic>ℓ</italic><sub>1</sub>-solution yielded the best performance with correlation 0.888 ± 0.007.</p>
<fig id="pcbi.1005423.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.g005</object-id>
<label>Fig 5</label>
<caption>
<title>Thresholding can improve the accuracy of spike inference.</title>
<p><bold>(A)</bold> Inferred trace using L1 penalty (L1, blue) and the thresholded OASIS (Thresh., green). The data (gray) are simulated with AR(1) model. <bold>(B)</bold> Inferred spiking activity. <bold>(C)</bold> The detected events using thresholded OASIS depend on the selection of <italic>s</italic><sub>min</sub>. The ground truth is shown in red. <bold>(D,E,F)</bold>, same as <bold>(A,B,C)</bold>, but the data are simulated with AR(2).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.g005" xlink:type="simple"/>
</fig>
<p><xref ref-type="fig" rid="pcbi.1005423.g005">Fig 5</xref> also shows results with a constraint on the minimal spike size for an AR(2) process. Adding the constraint helps when pressed for a binary decision whether to assign a spike or not, yielding visually excellent results. However, with a finite rise time of the calcium response the onset detection is notoriously difficult, because for a low threshold there are a lot of false positives due to noise, whereas for a high threshold, closer to the peak of the calcium kernel, the onset has already occurred earlier. Indeed, the greedy method for an AR(2) process tends to register spikes too late, which is further exacerbated when a threshold on the spike size (<italic>s</italic><sub>min</sub> = 0.5) is introduced, leading to low values of spike similarity (correlation 0.419 ± 0.016) compared to the solution of basis pursuit denoising (<xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>) (correlation 0.497 ± 0.013). We can incorporate a correction step that whenever a new spike is added, slightly jitters the previous one and calculates the change in the optimization objective in order to determine the optimal placement of the spike. For simplicity and low computational burden, we restrict the consideration of the changing RSS to the pools prior and after the jittered spike, which improves the spike detection (correlation 0.462 ± 0.015) while only marginally increasing computational cost (from 8.65 ms to 11.65 ms). Further improvements can be obtained by following up with (O)NNLS. The solution obtained by OASIS with threshold on the minimal spike size and jittering can be used to restrict (O)NNLS to have non-zero values only in close proximity to the spikes of the greedily obtained solution. This processing step increased the performance of spike inference to correlation 0.530 ± 0.010, which is better than the already mentioned one obtained for exactly solving the convex problem (<xref ref-type="disp-formula" rid="pcbi.1005423.e077">Eq 15</xref>). Hence, though imposing a minimal spike size renders the problem non-convex, a tractable approximate solution to this problem can improve over the exact solution of the convex basis pursuit denoising problem.</p>
<p>In the AR(2) case the exact solutions (ONNLS with λ or ONNLS with support only in the proximity of the thresholded solution) consistently improved over the faster greedy methods, as measured by spike train correlation. The performance was hardly affected by whether the penalized or the thresholded version was chosen. Spike train correlation harshly penalizes spikes that are detected but at an incorrect time, no matter how close; therefore the activity plots and correlation values convey somewhat complementary information about the quality of the inference. We attribute the performance gap between greedy and exact solutions to greedy methods missing the exact time step more often. However, the optimally attainable time resolution is already limited by low SNR, in particular if the rise time of the calcium indicator is finite. Indeed, being more lenient regarding the exact spike timing we calculated the correlations after convolving the spike trains with a Gaussian with standard deviation of one bin width. The correlation values increased to 0.731 ± 0.008 for the greedy thresholded solution and to 0.800 ± 0.007 if followed up by ONNLS, but did not increase further for wider Gaussian kernels. This indicates that in the considered SNR regime single time bin resolution is out of reach, but spike times can be inferred with an uncertainty of about one time bin width.</p>
</sec>
<sec id="sec019">
<title>Online spike inference with limited lag</title>
<p>For an exact solution of the non-negative deconvolution problem of an AR(1) process OASIS needs to backtrack to the most recent spike. (For an AR(2) process the solution is greedy and merely approximate. ONNLS yields an exact solution in this case but considers an even wider time window.) Such delays could be too long for some interesting closed loop experiments; therefore we were interested in how well the method performs if backtracking is limited to just a few frames. We varied the lag in the online estimator, i.e. the number of future samples observed before assigning a spike at time zero, for different signal-to-noise ratios (SNR). For each lag we chose the sparsity parameter λ such that the noise constraint <inline-formula id="pcbi.1005423.e195"><alternatives><graphic id="pcbi.1005423.e195g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e195" xlink:type="simple"/><mml:math display="inline" id="M195"><mml:mrow><mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mover><mml:mi mathvariant="bold-italic">c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mo>−</mml:mo> <mml:mi mathvariant="bold-italic">y</mml:mi> <mml:msup><mml:mo form="postfix" stretchy="false">‖</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>≤</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>T</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> was tight. This yielded increasing values of λ for smaller lags, compensating for the fact that limiting backtracking to fewer frames also imposes fewer constraints (<inline-formula id="pcbi.1005423.e196"><alternatives><graphic id="pcbi.1005423.e196g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1005423.e196" xlink:type="simple"/><mml:math display="inline" id="M196"><mml:mrow><mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>≥</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mover><mml:mi>c</mml:mi> <mml:mo accent="true">^</mml:mo></mml:mover> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>−</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>) on the dynamics. In the case of hard thresholding, better results were obtained with higher <italic>s</italic><sub>min</sub> for smaller lags too, in order to avoid that one spike is split in two. We used a hand-chosen value of <italic>s</italic><sub>min</sub> = 0.5 + 0.175 <italic>e</italic><sup>−<italic>τ</italic></sup> where <italic>τ</italic> is the lag, that asymptotically approaches the 0.5 for batch processing. The obtained results are depicted in <xref ref-type="fig" rid="pcbi.1005423.g006">Fig 6</xref>. For realistic SNR (3–5, though [<xref ref-type="bibr" rid="pcbi.1005423.ref036">36</xref>] report even higher values, cf. <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4C</xref>) and sample rates (30 Hz), lags of 2–5 yielded virtually the same results as offline estimation. The exact number depends on the noise; however, the main effect of noise was to reduce the optimal performance attainable even with batch processing, as the asymptotic values in <xref ref-type="fig" rid="pcbi.1005423.g006">Fig 6A and 6B</xref> reveal.</p>
<fig id="pcbi.1005423.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1005423.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Varied lag in the online estimator.</title>
<p><bold>(A,B)</bold> Performance of spike inference as function of lag for various noise levels (i.e., inverse SNR) without (A) and with positive threshold <italic>s</italic><sub>min</sub> (B). We used correlation of the inferred spike train as similarity measure and compared to ground truth as well as to the optimally recoverable activity when the lag is unlimited as in offline processing. <bold>(C)</bold> Inferred trace with positive threshold <italic>s</italic><sub>min</sub> for increasing lag using the data depicted in <xref ref-type="fig" rid="pcbi.1005423.g004">Fig 4A</xref> with high noise level (<italic>σ</italic> = 0.3). The gray lines indicate the true spike times.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.g006" xlink:type="simple"/>
</fig>
</sec>
</sec>
<sec id="sec020" sec-type="conclusions">
<title>Discussion</title>
<p>We presented an online active set method for spike inference from calcium imaging data. We assumed that the forward model to generate a fluorescence trace from a spike train is linear-Gaussian. Further development will extend the method to nonlinear models [<xref ref-type="bibr" rid="pcbi.1005423.ref045">45</xref>] incorporating saturation effects and a noise variance that increases with the mean fluorescence to better resemble the Poissonian statistics of photon counts. In <xref ref-type="supplementary-material" rid="pcbi.1005423.s001">S1 Appendix</xref> we already extend our mathematical formulation to include weights for each time point as a first step in this direction.</p>
<p>Our method considered spike inference as a sparse non-negative deconvolution problem. We focused on the formulation that imposes sparsity using an <italic>ℓ</italic><sub>1</sub> penalty that renders the problem convex. Using this problem formulation for spike inference has already long standing success within the neuroscientific community. We were able to speed it up by an order of magnitude compared to previously employed interior point methods and derived an algorithm that lends itself to online applications. However, recently several investigators [<xref ref-type="bibr" rid="pcbi.1005423.ref046">46</xref>–<xref ref-type="bibr" rid="pcbi.1005423.ref048">48</xref>] have advocated sparser methods, e.g. by using an <italic>ℓ</italic><sub><italic>q</italic></sub>-norm with <italic>q</italic> &lt; 1 instead of <italic>q</italic> = 1 [<xref ref-type="bibr" rid="pcbi.1005423.ref046">46</xref>] or by enforcing refractoriness [<xref ref-type="bibr" rid="pcbi.1005423.ref047">47</xref>] (see also [<xref ref-type="bibr" rid="pcbi.1005423.ref013">13</xref>] for some further discussion of sparsening beyond <italic>ℓ</italic><sub>1</sub> penalization). They report improved results, however in some cases at the expense of non-convexity, thus losing the guarantee of finding the global optimum. We leave it to future work to incorporate refractoriness into the methods developed here, but we did slightly modify the sparse non-negative deconvolution problem by adding the constraint that positive spikes need to be larger than some minimal value. A minor modification to our algorithm enabled it to find an (approximate) solution of this non-convex problem, which can be marginally better than the solution obtained with <italic>ℓ</italic><sub>1</sub> regularizer. The <italic>ℓ</italic><sub>1</sub>-penalized solution reflects the uncertainty regarding the exact position of a spike by distributing it as “partial spikes” over neighboring bins. The thresholded solution lets go of this potentially useful information and instead commits to one event within the locally optimal time bin. We leave it up to the user which approach to choose.</p>
<sec id="sec021">
<title>Availability</title>
<p>We provide Python and MATLAB implementations of our algorithm online (<ext-link ext-link-type="uri" xlink:href="https://github.com/j-friedrich/OASIS" xlink:type="simple">https://github.com/j-friedrich/OASIS</ext-link> and linked repositories therein). The code is readily usable on new data and includes example scripts that produce all figures and <xref ref-type="table" rid="pcbi.1005423.t001">Table 1</xref> of this article.</p>
<p>Here we focused on temporal data, i.e. noisy neural fluorescence data that has been extracted and demixed from raw pixel data. We further added OASIS as deconvolution subroutine to CaImAn (<ext-link ext-link-type="uri" xlink:href="https://github.com/simonsfoundation/CaImAn" xlink:type="simple">https://github.com/simonsfoundation/CaImAn</ext-link>) [<xref ref-type="bibr" rid="pcbi.1005423.ref049">49</xref>], which implements CNMF for simultaneous denoising, deconvolution, and demixing of spatio-temporal calcium imaging data.</p>
</sec>
</sec>
<sec id="sec022">
<title>Supporting information</title>
<supplementary-material id="pcbi.1005423.s001" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.s001" xlink:type="simple">
<label>S1 Appendix</label>
<caption>
<title>Technical appendix.</title>
<p>The supplementary material includes a naïve isotonic regression algorithm without pooling. We generalize OASIS to the case of weighted regression and provide a mathematical proof for updates according to Eqs (<xref ref-type="disp-formula" rid="pcbi.1005423.e061">12</xref>–<xref ref-type="disp-formula" rid="pcbi.1005423.e063">14</xref>). We further discuss how to account for elevated initial calcium fluorescence levels and provide explicit expressions of the hyperparameter updates for an AR(2) model.</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1005423.s002" mimetype="video/mp4" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.s002" xlink:type="simple">
<label>S1 Video</label>
<caption>
<title>Illustration of PAVA.</title>
<p>The supplementary video illustrates PAVA. The pool currently under consideration is indicated by the blue crosses. The algorithm sweeps through the time series and enforces the order constraints <italic>x</italic><sub>1</sub> ≤ … ≤ <italic>x</italic><sub><italic>T</italic></sub>.</p>
<p>(MP4)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1005423.s003" mimetype="video/mp4" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1005423.s003" xlink:type="simple">
<label>S2 Video</label>
<caption>
<title>Illustration of OASIS.</title>
<p>The supplementary video illustrates OASIS for an AR(1) process. As in <xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2</xref>, red lines depict true spike times and the shaded background shows how the time points are gathered in pools. The pool currently under consideration is indicated by the blue crosses. The upper panel shows how the calcium fluorescence trace <bold><italic>c</italic></bold>′ develops while the algorithm runs, cf. <xref ref-type="fig" rid="pcbi.1005423.g002">Fig 2</xref>. The video additionally shows the deconvolved trace <bold><italic>s</italic></bold>′ = <italic>G<bold>c</bold></italic>′ (<xref ref-type="disp-formula" rid="pcbi.1005423.e005">Eq 3</xref>) in the lower panel. The algorithm sweeps through the time series and enforces the constraint <bold><italic>s</italic></bold>′ ≥ 0.</p>
<p>(MP4)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ack>
<p>We would like to thank Misha Ahrens and Yu Mu for providing whole-brain imaging data of larval zebrafish. We thank John Cunningham and Eftychios Pnevmatikakis for helpful conversations as well as Scott Linderman and Daniel Soudry for valuable comments on the manuscript.</p>
<p>Part of this work was previously presented at the Thirtieth Annual Conference on Neural Information Processing Systems (NIPS, 2016) [<xref ref-type="bibr" rid="pcbi.1005423.ref050">50</xref>].</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1005423.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Grienberger</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Konnerth</surname> <given-names>C</given-names></name>. <article-title>Imaging calcium in neurons</article-title>. <source>Neuron</source>. <year>2012</year>;<volume>73</volume>(<issue>5</issue>):<fpage>862</fpage>–<lpage>885</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2012.02.011" xlink:type="simple">10.1016/j.neuron.2012.02.011</ext-link></comment> <object-id pub-id-type="pmid">22405199</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Grewe</surname> <given-names>BF</given-names></name>, <name name-style="western"><surname>Langer</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Kasper</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Kampa</surname> <given-names>BM</given-names></name>, <name name-style="western"><surname>Helmchen</surname> <given-names>F</given-names></name>. <article-title>High-speed in vivo calcium imaging reveals neuronal network activity with near-millisecond precision</article-title>. <source>Nat Methods</source>. <year>2010</year>;<volume>7</volume>(<issue>5</issue>):<fpage>399</fpage>–<lpage>405</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.1453" xlink:type="simple">10.1038/nmeth.1453</ext-link></comment> <object-id pub-id-type="pmid">20400966</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Yaksi</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Friedrich</surname> <given-names>RW</given-names></name>. <article-title>Reconstruction of firing rate changes across neuronal populations by temporally deconvolved Ca<sup>2+</sup> imaging</article-title>. <source>Nat Methods</source>. <year>2006</year>;<volume>3</volume>(<issue>5</issue>):<fpage>377</fpage>–<lpage>383</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth874" xlink:type="simple">10.1038/nmeth874</ext-link></comment> <object-id pub-id-type="pmid">16628208</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Holekamp</surname> <given-names>TF</given-names></name>, <name name-style="western"><surname>Turaga</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Holy</surname> <given-names>TE</given-names></name>. <article-title>Fast three-dimensional fluorescence imaging of activity in neural populations by objective-coupled planar illumination microscopy</article-title>. <source>Neuron</source>. <year>2008</year>;<volume>57</volume>(<issue>5</issue>):<fpage>661</fpage>–<lpage>672</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2008.01.011" xlink:type="simple">10.1016/j.neuron.2008.01.011</ext-link></comment> <object-id pub-id-type="pmid">18341987</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref005">
<label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Vogelstein</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Packer</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>Machado</surname> <given-names>TA</given-names></name>, <name name-style="western"><surname>Sippy</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Babadi</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Yuste</surname> <given-names>R</given-names></name>, <etal>et al</etal>. <article-title>Fast nonnegative deconvolution for spike train inference from population calcium imaging</article-title>. <source>J Neurophysiol</source>. <year>2010</year>;<volume>104</volume>(<issue>6</issue>):<fpage>3691</fpage>–<lpage>3704</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1152/jn.01073.2009" xlink:type="simple">10.1152/jn.01073.2009</ext-link></comment> <object-id pub-id-type="pmid">20554834</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref006">
<label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Vogelstein</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Watson</surname> <given-names>BO</given-names></name>, <name name-style="western"><surname>Packer</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>Yuste</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Jedynak</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Spike inference from calcium imaging using sequential Monte Carlo methods</article-title>. <source>Biophys J</source>. <year>2009</year>;<volume>97</volume>(<issue>2</issue>):<fpage>636</fpage>–<lpage>655</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.bpj.2008.08.005" xlink:type="simple">10.1016/j.bpj.2008.08.005</ext-link></comment> <object-id pub-id-type="pmid">19619479</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref007">
<label>7</label>
<mixed-citation publication-type="other" xlink:type="simple">Pnevmatikakis, EA, Merel, J, Pakman, A, Paninski, L. Bayesian spike inference from calcium imaging data. Asilomar Conference on Signals, Systems and Computers. 2013;.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref008">
<label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Deneux</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Kaszas</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Szalay</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Katona</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Lakner</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Grinvald</surname> <given-names>A</given-names></name>, <etal>et al</etal>. <article-title>Accurate spike estimation from noisy calcium signals for ultrafast three-dimensional imaging of large neuronal populations in vivo</article-title>. <source>Nat Commun</source>. <year>2016</year>;<volume>7</volume>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/ncomms12190" xlink:type="simple">10.1038/ncomms12190</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref009">
<label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Sasaki</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Takahashi</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Matsuki</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Ikegaya</surname> <given-names>Y</given-names></name>. <article-title>Fast and accurate detection of action potentials from somatic calcium fluctuations</article-title>. <source>J Neurophysiol</source>. <year>2008</year>;<volume>100</volume>(<issue>3</issue>):<fpage>1668</fpage>–<lpage>1676</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1152/jn.00084.2008" xlink:type="simple">10.1152/jn.00084.2008</ext-link></comment> <object-id pub-id-type="pmid">18596182</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Theis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Berens</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Froudarakis</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Reimer</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Rosón</surname> <given-names>MR</given-names></name>, <name name-style="western"><surname>Baden</surname> <given-names>T</given-names></name>, <etal>et al</etal>. <article-title>Benchmarking spike rate inference in population calcium imaging</article-title>. <source>Neuron</source>. <year>2016</year>;<volume>90</volume>(<issue>3</issue>):<fpage>471</fpage>–<lpage>482</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2016.04.014" xlink:type="simple">10.1016/j.neuron.2016.04.014</ext-link></comment> <object-id pub-id-type="pmid">27151639</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Mishchencko</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Vogelstein</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>A Bayesian approach for inferring neuronal connectivity from calcium fluorescent imaging data</article-title>. <source>Ann Appl Stat</source>. <year>2011</year>; p. <fpage>1229</fpage>–<lpage>1261</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1214/09-AOAS303" xlink:type="simple">10.1214/09-AOAS303</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref012">
<label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Picardo</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>Merel</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Katlowitz</surname> <given-names>KA</given-names></name>, <name name-style="western"><surname>Vallentin</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Okobi</surname> <given-names>DE</given-names></name>, <name name-style="western"><surname>Benezra</surname> <given-names>SE</given-names></name>, <etal>et al</etal>. <article-title>Population-Level Representation of a Temporal Sequence Underlying Song Production in the Zebra Finch</article-title>. <source>Neuron</source>. <year>2016</year>;<volume>90</volume>(<issue>4</issue>):<fpage>866</fpage>–<lpage>876</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2016.02.016" xlink:type="simple">10.1016/j.neuron.2016.02.016</ext-link></comment> <object-id pub-id-type="pmid">27196976</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref013">
<label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Pnevmatikakis</surname> <given-names>EA</given-names></name>, <name name-style="western"><surname>Soudry</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Gao</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Machado</surname> <given-names>TA</given-names></name>, <name name-style="western"><surname>Merel</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Pfau</surname> <given-names>D</given-names></name>, <etal>et al</etal>. <article-title>Simultaneous Denoising, Deconvolution, and Demixing of Calcium Imaging Data</article-title>. <source>Neuron</source>. <year>2016</year>;<volume>89</volume>(<issue>2</issue>):<fpage>285</fpage>–<lpage>299</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2015.11.037" xlink:type="simple">10.1016/j.neuron.2015.11.037</ext-link></comment> <object-id pub-id-type="pmid">26774160</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Grosenick</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Marshel</surname> <given-names>JH</given-names></name>, <name name-style="western"><surname>Deisseroth</surname> <given-names>K</given-names></name>. <article-title>Closed-loop and activity-guided optogenetic control</article-title>. <source>Neuron</source>. <year>2015</year>;<volume>86</volume>(<issue>1</issue>):<fpage>106</fpage>–<lpage>139</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2015.03.034" xlink:type="simple">10.1016/j.neuron.2015.03.034</ext-link></comment> <object-id pub-id-type="pmid">25856490</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref015">
<label>15</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Rickgauer</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Deisseroth</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Tank</surname> <given-names>DW</given-names></name>. <article-title>Simultaneous cellular-resolution optical perturbation and imaging of place cell firing fields</article-title>. <source>Nat Neurosci</source>. <year>2014</year>;<volume>17</volume>(<issue>12</issue>):<fpage>1816</fpage>–<lpage>1824</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nn.3866" xlink:type="simple">10.1038/nn.3866</ext-link></comment> <object-id pub-id-type="pmid">25402854</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref016">
<label>16</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Packer</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>Russell</surname> <given-names>LE</given-names></name>, <name name-style="western"><surname>Dalgleish</surname> <given-names>HW</given-names></name>, <name name-style="western"><surname>Häusser</surname> <given-names>M</given-names></name>. <article-title>Simultaneous all-optical manipulation and recording of neural circuit activity with cellular resolution in vivo</article-title>. <source>Nat Methods</source>. <year>2015</year>;<volume>12</volume>(<issue>2</issue>):<fpage>140</fpage>–<lpage>146</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.3217" xlink:type="simple">10.1038/nmeth.3217</ext-link></comment> <object-id pub-id-type="pmid">25532138</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref017">
<label>17</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Clancy</surname> <given-names>KB</given-names></name>, <name name-style="western"><surname>Koralek</surname> <given-names>AC</given-names></name>, <name name-style="western"><surname>Costa</surname> <given-names>RM</given-names></name>, <name name-style="western"><surname>Feldman</surname> <given-names>DE</given-names></name>, <name name-style="western"><surname>Carmena</surname> <given-names>JM</given-names></name>. <article-title>Volitional modulation of optically recorded calcium signals during neuroprosthetic learning</article-title>. <source>Nat Neurosci</source>. <year>2014</year>;<volume>17</volume>(<issue>6</issue>):<fpage>807</fpage>–<lpage>809</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nn.3712" xlink:type="simple">10.1038/nn.3712</ext-link></comment> <object-id pub-id-type="pmid">24728268</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref018">
<label>18</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Lewi</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Butera</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Sequential optimal design of neurophysiology experiments</article-title>. <source>Neural Comput</source>. <year>2009</year>;<volume>21</volume>(<issue>3</issue>):<fpage>619</fpage>–<lpage>687</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1162/neco.2008.08-07-594" xlink:type="simple">10.1162/neco.2008.08-07-594</ext-link></comment> <object-id pub-id-type="pmid">18928364</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref019">
<label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Park</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Pillow</surname> <given-names>JW</given-names></name>. <article-title>Bayesian active learning with localized priors for fast receptive field characterization</article-title>. In: <source>Adv Neural Inf Process Syst</source>; <year>2012</year>. p. <fpage>2348</fpage>–<lpage>2356</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref020">
<label>20</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Shababo</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Paige</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Pakman</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Bayesian inference and online experimental design for mapping neural microcircuits</article-title>. In: <source>Adv Neural Inf Process Syst</source>; <year>2013</year>. p. <fpage>1304</fpage>–<lpage>1312</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref021">
<label>21</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Ahrens</surname> <given-names>MB</given-names></name>, <name name-style="western"><surname>Orger</surname> <given-names>MB</given-names></name>, <name name-style="western"><surname>Robson</surname> <given-names>DN</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Keller</surname> <given-names>PJ</given-names></name>. <article-title>Whole-brain functional imaging at cellular resolution using light-sheet microscopy</article-title>. <source>Nat Methods</source>. <year>2013</year>;<volume>10</volume>(<issue>5</issue>):<fpage>413</fpage>–<lpage>420</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.2434" xlink:type="simple">10.1038/nmeth.2434</ext-link></comment> <object-id pub-id-type="pmid">23524393</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref022">
<label>22</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Vladimirov</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Mu</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Kawashima</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Bennett</surname> <given-names>DV</given-names></name>, <name name-style="western"><surname>Yang</surname> <given-names>CT</given-names></name>, <name name-style="western"><surname>Looger</surname> <given-names>LL</given-names></name>, <etal>et al</etal>. <article-title>Light-sheet functional imaging in fictively behaving zebrafish</article-title>. <source>Nat Methods</source>. <year>2014</year>;. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.3040" xlink:type="simple">10.1038/nmeth.3040</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref023">
<label>23</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Potra</surname> <given-names>FA</given-names></name>, <name name-style="western"><surname>Wright</surname> <given-names>SJ</given-names></name>. <article-title>Interior-point methods</article-title>. <source>J Comput Appl Math</source>. <year>2000</year>;<volume>124</volume>(<issue>1</issue>):<fpage>281</fpage>–<lpage>302</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/S0377-0427(00)00433-7" xlink:type="simple">10.1016/S0377-0427(00)00433-7</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref024">
<label>24</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Ayer</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Brunk</surname> <given-names>HD</given-names></name>, <name name-style="western"><surname>Ewing</surname> <given-names>GM</given-names></name>, <name name-style="western"><surname>Reid</surname> <given-names>WT</given-names></name>, <name name-style="western"><surname>Silverman</surname> <given-names>E</given-names></name>. <article-title>An empirical distribution function for sampling with incomplete information</article-title>. <source>Ann Math Stat</source>. <year>1955</year>;<volume>26</volume>(<issue>4</issue>):<fpage>641</fpage>–<lpage>647</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1214/aoms/1177728423" xlink:type="simple">10.1214/aoms/1177728423</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref025">
<label>25</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Barlow</surname> <given-names>RE</given-names></name>, <name name-style="western"><surname>Bartholomew</surname> <given-names>DJ</given-names></name>, <name name-style="western"><surname>Bremner</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Brunk</surname> <given-names>HD</given-names></name>. <source>Statistical inference under order restrictions: The theory and application of isotonic regression</source>. <publisher-name>Wiley New York</publisher-name>; <year>1972</year>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref026">
<label>26</label>
<mixed-citation publication-type="other" xlink:type="simple">van Eeden C. Testing and Estimating Ordered Parameters of Probability Distributions. PhD thesis, University of Amsterdam; 1958.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref027">
<label>27</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Miles</surname> <given-names>RE</given-names></name>. <article-title>The complete amalgamation into blocks, by weighted means, of a finite set of real numbers</article-title>. <source>Biometrika</source>. <year>1959</year>;<volume>46</volume>(<issue>3/4</issue>):<fpage>317</fpage>–<lpage>327</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/biomet/46.3-4.317" xlink:type="simple">10.1093/biomet/46.3-4.317</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref028">
<label>28</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Mair</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Hornik</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>de Leeuw</surname> <given-names>J</given-names></name>. <article-title>Isotone optimization in R: pool-adjacent-violators algorithm (PAVA) and active set methods</article-title>. <source>J Stat Softw</source>. <year>2009</year>;<volume>32</volume>(<issue>5</issue>):<fpage>1</fpage>–<lpage>24</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref029">
<label>29</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Best</surname> <given-names>MJ</given-names></name>, <name name-style="western"><surname>Chakravarti</surname> <given-names>N</given-names></name>. <article-title>Active set algorithms for isotonic regression; a unifying framework</article-title>. <source>Math Prog</source>. <year>1990</year>;<volume>47</volume>(<issue>1–3</issue>):<fpage>425</fpage>–<lpage>439</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/BF01580873" xlink:type="simple">10.1007/BF01580873</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref030">
<label>30</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Grotzinger</surname> <given-names>SJ</given-names></name>, <name name-style="western"><surname>Witzgall</surname> <given-names>C</given-names></name>. <article-title>Projections onto order simplexes</article-title>. <source>Appl Math Optim</source>. <year>1984</year>;<volume>12</volume>(<issue>1</issue>):<fpage>247</fpage>–<lpage>270</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/BF01449044" xlink:type="simple">10.1007/BF01449044</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref031">
<label>31</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Podgorski</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Haas</surname> <given-names>K</given-names></name>. <article-title>Fast non-negative temporal deconvolution for laser scanning microscopy</article-title>. <source>J Biophotonics</source>. <year>2013</year>;<volume>6</volume>(<issue>2</issue>):<fpage>153</fpage>–<lpage>162</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1002/jbio.201100133" xlink:type="simple">10.1002/jbio.201100133</ext-link></comment> <object-id pub-id-type="pmid">22438321</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref032">
<label>32</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Brent</surname> <given-names>RP</given-names></name>. <source>Algorithms for Minimization Without Derivatives</source>. <publisher-name>Courier Corporation</publisher-name>; <year>1973</year>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref033">
<label>33</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Nocedal</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Wright</surname> <given-names>S</given-names></name>. <source>Numerical optimization</source>. <publisher-name>Springer Science &amp; Business Media</publisher-name>; <year>2006</year>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref034">
<label>34</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Donoho</surname> <given-names>DL</given-names></name>. <article-title>De-noising by soft-thresholding</article-title>. <source>IEEE Trans Inf Theory</source>. <year>1995</year>;<volume>41</volume>(<issue>3</issue>):<fpage>613</fpage>–<lpage>627</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/18.382009" xlink:type="simple">10.1109/18.382009</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref035">
<label>35</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Mallat</surname> <given-names>SG</given-names></name>, <name name-style="western"><surname>Zhang</surname> <given-names>Z</given-names></name>. <article-title>Matching pursuits with time-frequency dictionaries</article-title>. <source>IEEE Trans Signal Processing</source>. <year>1993</year>;<volume>41</volume>(<issue>12</issue>):<fpage>3397</fpage>–<lpage>3415</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/78.258082" xlink:type="simple">10.1109/78.258082</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref036">
<label>36</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Chen</surname> <given-names>TW</given-names></name>, <name name-style="western"><surname>Wardill</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Sun</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Pulver</surname> <given-names>SR</given-names></name>, <name name-style="western"><surname>Renninger</surname> <given-names>SL</given-names></name>, <name name-style="western"><surname>Baohan</surname> <given-names>A</given-names></name>, <etal>et al</etal>. <article-title>Ultrasensitive fluorescent proteins for imaging neuronal activity</article-title>. <source>Nature</source>. <year>2013</year>;<volume>499</volume>(<issue>7458</issue>):<fpage>295</fpage>–<lpage>300</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature12354" xlink:type="simple">10.1038/nature12354</ext-link></comment> <object-id pub-id-type="pmid">23868258</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref037">
<label>38</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Lawson</surname> <given-names>CL</given-names></name>, <name name-style="western"><surname>Hanson</surname> <given-names>RJ</given-names></name>. <article-title>Solving least squares problems</article-title>. vol. <volume>15</volume>. <source>SIAM</source>; <year>1995</year>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref038">
<label>37</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Bro</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>De Jong</surname> <given-names>S</given-names></name>. <article-title>A fast non-negativity-constrained least squares algorithm</article-title>. <source>J Chemometrics</source>. <year>1997</year>;<volume>11</volume>(<issue>5</issue>):<fpage>393</fpage>–<lpage>401</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1002/(SICI)1099-128X(199709/10)11:5%3C393∷AID-CEM483%3E3.3.CO;2-C" xlink:type="simple">10.1002/(SICI)1099-128X(199709/10)11:5%3C393∷AID-CEM483%3E3.3.CO;2-C</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref039">
<label>39</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Diamond</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Boyd</surname> <given-names>S</given-names></name>. <article-title>CVXPY: A Python-Embedded Modeling Language for Convex Optimization</article-title>. <source>J Mach Learn Res</source>. <year>2016</year>;<volume>17</volume>(<issue>83</issue>):<fpage>1</fpage>–<lpage>5</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref040">
<label>40</label>
<mixed-citation publication-type="other" xlink:type="simple">Domahidi A, Chu E, Boyd S. ECOS: An SOCP solver for embedded systems. In: European Control Conference (ECC); 2013. p. 3071–3076.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref041">
<label>41</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Andersen</surname> <given-names>ED</given-names></name>, <name name-style="western"><surname>Andersen</surname> <given-names>KD</given-names></name>. <chapter-title>The MOSEK interior point optimizer for linear programming: an implementation of the homogeneous algorithm</chapter-title>. In: <source>High performance optimization</source>. <publisher-name>Springer</publisher-name>; <year>2000</year>. p. <fpage>197</fpage>–<lpage>232</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref042">
<label>42</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>O’Donoghue</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Chu</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Parikh</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Boyd</surname> <given-names>S</given-names></name>. <article-title>Conic Optimization via Operator Splitting and Homogeneous Self-Dual Embedding</article-title>. <source>J Optim Theory Appl</source>. <year>2016</year>; p. <fpage>1</fpage>–<lpage>27</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref043">
<label>43</label>
<mixed-citation publication-type="other" xlink:type="simple">Gurobi Optimization Inc. Gurobi Optimizer Reference Manual; 2015. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.gurobi.com" xlink:type="simple">http://www.gurobi.com</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref044">
<label>44</label>
<mixed-citation publication-type="other" xlink:type="simple">GENIE project, Janelia Research Campus, HHMI; Karel Svoboda (contact). Simultaneous imaging and loose-seal cell-attached electrical recordings from neurons expressing a variety of genetically encoded calcium indicators. CRCNS.org; 2015. Available from: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.6080/K02R3PMN" xlink:type="simple">http://dx.doi.org/10.6080/K02R3PMN</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref045">
<label>45</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Pologruto</surname> <given-names>TA</given-names></name>, <name name-style="western"><surname>Yasuda</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Svoboda</surname> <given-names>K</given-names></name>. <article-title>Monitoring neural activity and [Ca<sup>2+</sup>] with genetically encoded Ca<sup>2+</sup> indicators</article-title>. <source>J Neurosci</source>. <year>2004</year>;<volume>24</volume>(<issue>43</issue>):<fpage>9572</fpage>–<lpage>9579</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1523/JNEUROSCI.2854-04.2004" xlink:type="simple">10.1523/JNEUROSCI.2854-04.2004</ext-link></comment> <object-id pub-id-type="pmid">15509744</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref046">
<label>46</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Quan</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Lv</surname> <given-names>X</given-names></name>, <name name-style="western"><surname>Liu</surname> <given-names>X</given-names></name>, <name name-style="western"><surname>Zeng</surname> <given-names>S</given-names></name>. <article-title>Reconstruction of burst activity from calcium imaging of neuronal population via Lq minimization and interval screening</article-title>. <source>Biomed Opt Express</source>. <year>2016</year>;<volume>7</volume>(<issue>6</issue>):<fpage>2103</fpage>–<lpage>2117</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1364/BOE.7.002103" xlink:type="simple">10.1364/BOE.7.002103</ext-link></comment> <object-id pub-id-type="pmid">27375930</object-id></mixed-citation>
</ref>
<ref id="pcbi.1005423.ref047">
<label>47</label>
<mixed-citation publication-type="other" xlink:type="simple">Dyer EL, Studer C, Robinson JT, Baraniuk RG. A robust and efficient method to recover neural events from noisy and corrupted data. In: Int IEEE/EMBS Conf Neural Eng (NER). 2013; p. 593–596.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref048">
<label>48</label>
<mixed-citation publication-type="other" xlink:type="simple">Pachitariu M, Stringer C, Schröder S, Dipoppa M, Rossi LF, Carandini M, et al. Suite2p: beyond 10,000 neurons with standard two-photon microscopy. bioRxiv. 2016.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref049">
<label>49</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Giovannucci</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Friedrich</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Deverett</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Staneva</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Chklovskii</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Pnevmatikakis</surname> <given-names>E</given-names></name>. <chapter-title>CaImAn: An open source toolbox for large scale calcium imaging data analysis on standalone machines</chapter-title>. <source>Cosyne Abstracts 2017</source>, <publisher-loc>Salt Lake City USA</publisher-loc>.</mixed-citation>
</ref>
<ref id="pcbi.1005423.ref050">
<label>50</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Friedrich</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Fast Active Set Methods for Online Spike Inference from Calcium Imaging</article-title>. In: <source>Adv Neural Inf Process Syst</source>; <year>2016</year>. p. <fpage>1984</fpage>–<lpage>1992</lpage>.</mixed-citation>
</ref>
</ref-list>
</back>
</article>