<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article article-type="research-article" dtd-version="3.0" xml:lang="en" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1004772</article-id>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-15-00456</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Data visualization</subject><subj-group><subject>Infographics</subject><subj-group><subject>Graphs</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Organisms</subject><subj-group><subject>Animals</subject><subj-group><subject>Vertebrates</subject><subj-group><subject>Mammals</subject><subj-group><subject>Dogs</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Computational biology</subject><subj-group><subject>Genome analysis</subject><subj-group><subject>Transcriptome analysis</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Genome analysis</subject><subj-group><subject>Transcriptome analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Gene expression</subject><subj-group><subject>RNA processing</subject><subj-group><subject>Alternative splicing</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Biochemistry</subject><subj-group><subject>Nucleic acids</subject><subj-group><subject>RNA</subject><subj-group><subject>RNA processing</subject><subj-group><subject>Alternative splicing</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Molecular biology</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>Sequencing techniques</subject><subj-group><subject>RNA sequencing</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Molecular biology techniques</subject><subj-group><subject>Sequencing techniques</subject><subj-group><subject>RNA sequencing</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Animal genomics</subject><subj-group><subject>Mammalian genomics</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Gene expression</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Agriculture</subject><subj-group><subject>Animal management</subject><subj-group><subject>Animal performance</subject></subj-group></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>BinPacker: Packing-Based <italic>De Novo</italic> Transcriptome Assembly from RNA-seq Data</article-title>
<alt-title alt-title-type="running-head">BinPacker-Transcriptome Assembler</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" equal-contrib="yes" xlink:type="simple">
<name name-style="western">
<surname>Liu</surname>
<given-names>Juntao</given-names>
</name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" corresp="yes" equal-contrib="yes" xlink:type="simple">
<name name-style="western">
<surname>Li</surname>
<given-names>Guojun</given-names>
</name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Chang</surname>
<given-names>Zheng</given-names>
</name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Yu</surname>
<given-names>Ting</given-names>
</name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Liu</surname>
<given-names>Bingqiang</given-names>
</name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>McMullen</surname>
<given-names>Rick</given-names>
</name>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Chen</surname>
<given-names>Pengyin</given-names>
</name>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
</contrib>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<name name-style="western">
<surname>Huang</surname>
<given-names>Xiuzhen</given-names>
</name>
<xref ref-type="aff" rid="aff004"><sup>4</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
</contrib-group>
<aff id="aff001"><label>1</label> <addr-line>School of Mathematics, Shandong University, Jinan, China</addr-line></aff>
<aff id="aff002"><label>2</label> <addr-line>High Performance Computing Center, University of Arkansas, Fayetteville, Arkansas, United States of America</addr-line></aff>
<aff id="aff003"><label>3</label> <addr-line>Crop, Soil, and Environmental Sciences, University of Arkansas, Fayetteville, Arkansas, United States of America</addr-line></aff>
<aff id="aff004"><label>4</label> <addr-line>Department of Computer Science, Arkansas State University, Jonesboro, Arkansas, United States of America</addr-line></aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Lengauer</surname>
<given-names>Thomas</given-names>
</name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1"><addr-line>Max-Planck-Institut für Informatik, GERMANY</addr-line></aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<fn fn-type="con" id="contrib001">
<p>Conceived and designed the experiments: GL. Performed the experiments: JL. Analyzed the data: JL TY BL. Contributed reagents/materials/analysis tools: JL ZC. Wrote the paper: JL GL XH. Designed the software used in analysis: JL TY RM PC. Oversaw the project: GL XH.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">guojunsdu@gmail.com</email> (GL); <email xlink:type="simple">xhuang@astate.edu</email> (XH)</corresp>
</author-notes>
<pub-date pub-type="epub">
<day>19</day>
<month>2</month>
<year>2016</year>
</pub-date>
<pub-date pub-type="collection">
<month>2</month>
<year>2016</year>
</pub-date>
<volume>12</volume>
<issue>2</issue>
<elocation-id>e1004772</elocation-id>
<history>
<date date-type="received">
<day>19</day>
<month>3</month>
<year>2015</year>
</date>
<date date-type="accepted">
<day>18</day>
<month>1</month>
<year>2016</year>
</date>
</history>
<permissions>
<copyright-year>2016</copyright-year>
<copyright-holder>Liu et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1004772"/>
<abstract>
<p>High-throughput RNA-seq technology has provided an unprecedented opportunity to reveal the very complex structures of transcriptomes. However, it is an important and highly challenging task to assemble vast amounts of short RNA-seq reads into transcriptomes with alternative splicing isoforms. In this study, we present a novel <italic>de novo</italic> assembler, BinPacker, by modeling the transcriptome assembly problem as tracking a set of trajectories of items with their sizes representing coverage of their corresponding isoforms by solving a series of bin-packing problems. This approach, which subtly integrates coverage information into the procedure, has two exclusive features: 1) only splicing junctions are involved in the assembling procedure; 2) massive pell-mell reads are assembled seemingly by moving a comb along junction edges on a splicing graph. Being tested on both real and simulated RNA-seq datasets, it outperforms almost all the existing <italic>de novo</italic> assemblers on all the tested datasets, and even outperforms those <italic>ab initio</italic> assemblers on the real dog dataset. In addition, it runs substantially faster and requires less memory space than most of the assemblers. BinPacker is published under GNU GENERAL PUBLIC LICENSE and the source is available from: <ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/transcriptomeassembly/files/BinPacker_1.0.tar.gz/download" xlink:type="simple">http://sourceforge.net/projects/transcriptomeassembly/files/BinPacker_1.0.tar.gz/download</ext-link>. Quick installation version is available from: <ext-link ext-link-type="uri" xlink:href="http://sourceforge.net/projects/transcriptomeassembly/files/BinPacker_binary.tar.gz/download" xlink:type="simple">http://sourceforge.net/projects/transcriptomeassembly/files/BinPacker_binary.tar.gz/download</ext-link>.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author Summary</title>
<p>The availability of RNA-seq technology drives the development of algorithms for transcriptome assembly from very short RNA sequences. However, the problem of how to (<italic>de novo</italic>) assemble transcriptome using RNA-seq datasets has not been modeled well; e.g. sequence coverage information has even not been accurately and effectively integrated into the appropriate assembling procedure, leading to a bottleneck that all the existing (<italic>de novo</italic>) strategies have encountered. We present a novel approach to remodel the problem as tracking a set of trajectories of items with their sizes representing the coverage of their corresponding isoforms by solving a series of bin-packing problems. This approach, which subtly integrates the coverage information into the procedure, has two exclusive features: 1) only splicing junctions are involved in the assembling procedure; 2) massive pell-mell reads are assembled seemingly by moving a comb along junction edges on a splicing graph. Being tested on both real and simulated RNA-seq datasets, it outperforms almost all existing <italic>de novo</italic> assemblers on all the tested datasets, even outperforms those <italic>ab initio</italic> assemblers on the dog dataset, in terms of commonly used comparison standards.</p>
</abstract>
<funding-group>
<funding-statement>This work was funded by National Natural Science Foundation of China with codes 61432010, 61272016 and 31571354 (<ext-link ext-link-type="uri" xlink:href="http://www.nsfc.gov.cn/" xlink:type="simple">http://www.nsfc.gov.cn/</ext-link>); National Science Foundation with number 1553680 (<ext-link ext-link-type="uri" xlink:href="http://www.nsf.gov/" xlink:type="simple">http://www.nsf.gov/</ext-link>); National Center for Research Resources with number P20RR016460 (<ext-link ext-link-type="uri" xlink:href="http://sdminutes.cit.nih.gov/about/almanac/organization/NCRR.htm" xlink:type="simple">http://sdminutes.cit.nih.gov/about/almanac/organization/NCRR.htm</ext-link>); and National Institute of General Medical Sciences with number P20GM103429 (<ext-link ext-link-type="uri" xlink:href="http://www.nigms.nih.gov/Pages/default.aspx" xlink:type="simple">http://www.nigms.nih.gov/Pages/default.aspx</ext-link>). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="7"/>
<table-count count="0"/>
<page-count count="15"/>
</counts>
<custom-meta-group>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>All relevant data are within the paper and its Supporting Information files.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<disp-quote>
<p>This is a <italic>PLOS Computational Biology</italic> Methods paper.</p>
</disp-quote>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>The advent of RNA-seq techniques are changing how transcription, splicing variations and associated mechanisms can be studied since they provide unprecedented accuracy about the mRNA expression level [<xref ref-type="bibr" rid="pcbi.1004772.ref001">1</xref>]. They allow accurate elucidation of all splicing variants, including the rare and lowly expressed splicing isoforms. This clearly opens many new doors for studying the mechanisms of various human diseases that are related to abnormal splicing [<xref ref-type="bibr" rid="pcbi.1004772.ref001">1</xref>], including cancers. With the RNA-seq techniques, there come new challenges associated with the interpretation of the generated datasets. Although sequencing reads from PacBio RS II sequencer are long enough to cover multiple exons, they have not been commonly used to improve the state of the art transcripts reconstruction because they are suffering from higher error rates [<xref ref-type="bibr" rid="pcbi.1004772.ref002">2</xref>]. Therefore the RNA-seq techniques for short sequencing reads [<xref ref-type="bibr" rid="pcbi.1004772.ref003">3</xref>] remain necessary. One major challenge is how to accurately assemble the short sequencing reads into full-length transcripts possibly involving multiple splicing variants, the so-called RNA-seq based transcriptome assembly problem.</p>
<p>According to the literatures [<xref ref-type="bibr" rid="pcbi.1004772.ref004">4</xref>–<xref ref-type="bibr" rid="pcbi.1004772.ref006">6</xref>], there are various alternative splicing events capable of producing multiple isoforms in eukaryotic genes. Event types include skipped exons, retained introns and mutually exclusive exons. Even more complicated, some exons may be partially involved in transcripts during the alternative splicing process. At first glance, the transcriptome assembly is similar to genome assembly, but they are actually fundamentally different. In contrast, the following facts make the transcriptome assembly more challenging: (i) some transcripts have a very low expression level, while others may be expressed in a dramatically high level [<xref ref-type="bibr" rid="pcbi.1004772.ref007">7</xref>]; (ii) each locus usually produces multiple transcripts due to various alternative splicing events [<xref ref-type="bibr" rid="pcbi.1004772.ref008">8</xref>]; (iii) some transcripts with low expression level may be submerged due to the sequencing errors [<xref ref-type="bibr" rid="pcbi.1004772.ref008">8</xref>,<xref ref-type="bibr" rid="pcbi.1004772.ref009">9</xref>]. Therefore, a successful transcriptome assembler should overcome all these difficulties, and be capable of recovering all full-length transcripts of variable lengths, expression levels and noises.</p>
<p>Computational strategies for transcriptome assembly can be generally divided into two categories, <italic>ab initio</italic> and <italic>de novo</italic> [<xref ref-type="bibr" rid="pcbi.1004772.ref001">1</xref>,<xref ref-type="bibr" rid="pcbi.1004772.ref008">8</xref>]. If a reference genome is available, <italic>ab initio</italic> approaches, such as Cufflinks [<xref ref-type="bibr" rid="pcbi.1004772.ref010">10</xref>] and Scripture [<xref ref-type="bibr" rid="pcbi.1004772.ref011">11</xref>], usually start by mapping RNA-Seq reads to the reference genome, and then sequences with overlapping alignment are merged into a connectivity graph on which the well studied min-cost minimum path cover model is subtly employed to extract a minimum set of paths which explain the RNA-seq dataset. A very recently published <italic>ab initio</italic> assembler, StringTie [<xref ref-type="bibr" rid="pcbi.1004772.ref012">12</xref>], also first maps RNA-Seq reads to the reference genome, then constructs alternative splicing graphs and then assembles transcripts by using a maximum-flow network model. <italic>De novo</italic> approaches, such as ABySS [<xref ref-type="bibr" rid="pcbi.1004772.ref013">13</xref>], SOAPdenovo-Trans [<xref ref-type="bibr" rid="pcbi.1004772.ref014">14</xref>], Oases [<xref ref-type="bibr" rid="pcbi.1004772.ref015">15</xref>] and IDBA-Tran [<xref ref-type="bibr" rid="pcbi.1004772.ref016">16</xref>], directly use the reads to assemble transcripts, without mapping them to a reference genome, which is important when the reference genome is unavailable, incomplete, highly fragmented or substantially altered as in cancer tissues. These <italic>de novo</italic> approaches which were developed based on the techniques used in genome assembly are not solving all the transcriptome assembly problems in general [<xref ref-type="bibr" rid="pcbi.1004772.ref007">7</xref>]. Trinity [<xref ref-type="bibr" rid="pcbi.1004772.ref008">8</xref>] which was designed specifically for <italic>de novo</italic> transcriptome assembly has substantially improved the state of the art <italic>de novo</italic> transcriptome assemblers. It starts by extending short reads through overlaps into contigs, connecting contigs into a graph, and then extracts paths from this graph to construct splicing variants based on a brute-force enumeration strategy. Trinity does improve previous <italic>de novo</italic> assemblers which have their roots in genome assembly techniques, but it does not introduce an appropriate model to optimize its solution, and even not incorporate sequencing coverage depth information into the assembly procedure either, although the authors in Trinity have noticed that similarity of the coverage depth across different coding regions in a transcript could be useful. To this end, we have recently presented a new <italic>de novo</italic> transcriptome assembler, Bridger [<xref ref-type="bibr" rid="pcbi.1004772.ref017">17</xref>], which “bridges” between Cufflinks and Trinity so that the techniques used in Cufflinks can be employed to overcome the limitations of Trinity. Bridger does incorporate the coverage information into the assembly procedure via an appropriate model, but it could not guarantee a genuine solution due to (1) in-weight and out-weight are defined somewhat arbitrarily in Bridger; (2) a node with both in-edges and out-edges has no chance to be an end of any transcripts. Therefore, there still remains room for improvement.</p>
<p>In this paper we develop a novel <italic>de novo</italic> algorithm, BinPacker, to assemble full-length transcripts by remodeling the problem as tracking a set of trajectories of items over a splicing graph, which is constructed by employing the techniques used in Bridger [<xref ref-type="bibr" rid="pcbi.1004772.ref017">17</xref>] with several updates described in <xref ref-type="sec" rid="sec012">Methods</xref>. The set of trajectories of items over the splicing graph can be achieved by solving a series of variants of the bin-packing problem, which are different from the traditional bin-packing problem, which is defined to pack a given number of items of different sizes into as few bins of a given size as possible, and each bin can only hold items with the sum of their sizes no more than the size of the bin. We have tested and compared BinPacker with seven competitive <italic>de novo</italic> assemblers, Trinity [<xref ref-type="bibr" rid="pcbi.1004772.ref008">8</xref>], ABySS [<xref ref-type="bibr" rid="pcbi.1004772.ref013">13</xref>], Trans-ABySS [<xref ref-type="bibr" rid="pcbi.1004772.ref018">18</xref>], SOAPdenovo-Trans [<xref ref-type="bibr" rid="pcbi.1004772.ref014">14</xref>], Oases [<xref ref-type="bibr" rid="pcbi.1004772.ref015">15</xref>], IDBA-Tran [<xref ref-type="bibr" rid="pcbi.1004772.ref016">16</xref>] and Bridger [<xref ref-type="bibr" rid="pcbi.1004772.ref017">17</xref>] on real and simulated datasets. The simulation dataset is generated as described in Results section. For the real datasets, three datasets are used, including two standard RNA-seq datasets, one dog and one human, and one strand-specific mouse RNA-seq dataset. The comparison results show that BinPacker outperforms almost all the compared assemblers on all datasets, including real and simulated, in terms of commonly used standards for evaluation of transcriptome assemblers. Even more surprisingly, it outperforms StringTie, a most recently published <italic>ab initio</italic> assembler [<xref ref-type="bibr" rid="pcbi.1004772.ref012">12</xref>], on dog dataset.</p>
</sec>
<sec id="sec002" sec-type="results">
<title>Results</title>
<p>We ran BinPacker, and seven other <italic>de novo</italic> assemblers: ABySS (version 1.3.4), Trans-ABySS (version 1.4.4), Trinity (version 2012-10-05), Velvet (version 1.2.01) + Oases (version 0.2.02), SOAPdenovo-Trans (version 1.01), IDBA-Tran (version 1.1.1), and Bridger, and also the most recently published <italic>ab initio</italic> assembler StringTie on real and simulated datasets below, and tested their performance with the optimized parameters on the same server with 512GB of RAM (see <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref> for details).</p>
<p>The criteria that have previously been used to test the assemblers are employed in our testing. All assembled transcripts are matched against all known transcripts in the annotation (referred to as ‘‘reference transcripts”) using BLAT [<xref ref-type="bibr" rid="pcbi.1004772.ref019">19</xref>], with 95% identity as the cutoff. If an assembled transcript full-length covers a reference transcript with at least 95% sequence identity and at most 0.5% indels, this reference transcript is counted as full-length recovered, and noted as a true positive. The indel cutoff is used to avoid the over-estimated consistencies between the predicted and the references. In this paper, sensitivity is defined as the number of full-length recovered reference transcripts, and accuracy is defined as the true positive rate. We further consider two types of accuracy. One is related to a reference true positive rate which is the rate between the number of full-length recovered reference transcripts and the number of assembled transcripts, and the other is related to an assembled true positive rate which is the fraction of assembled transcripts that are in the reference transcripts. The reliability of an assembler is defined by the distribution of its recovered reference transcripts against recovered sequence length rates ranging from 80% to 100%. An assembler is considered of higher reliability if it recovers more reference transcripts with recovered sequence length rates ranging from 90% to 100%.</p>
<sec id="sec003">
<title>1. Tests on real datasets</title>
<p>We ran and tested all the 9 assemblers on three real RNA-seq datasets which include two standard (non-strand specific) Illumina datasets from dog and human, and one strand-specific dataset from mouse.</p>
<sec id="sec004">
<title>1.1. Collection of real datasets</title>
<p>The dog dataset was collected from NCBI SRA database (Accession Code: SRR882093), the human dataset was collected from the DDBJ SRA database (Accession Codes: SRX011545 and SRX011546) and the mouse dataset was collected from C567BL/6 mouse primary immune dendritic cells (Accession Code: SRX062280 in the DDBJ SRA database). The reference transcripts of dog were downloaded from UCSC [<xref ref-type="bibr" rid="pcbi.1004772.ref020">20</xref>]. The human and mouse reference transcripts were downloaded from Ensemble Genome Browser [<xref ref-type="bibr" rid="pcbi.1004772.ref021">21</xref>].</p>
</sec>
<sec id="sec005">
<title>1.2. Comparing BinPacker to the other assemblers on real datasets</title>
<p>We compare BinPacker to the other assemblers on the real datasets mentioned above in terms of sensitivities, accuracies and their distributions against recovered sequence length rates ranging from 80% to 100%.</p>
<p><italic>1.2.1 Comparison of sensitivities and their distributions against recovered sequence length rates on dog and mouse datasets</italic>. We run all the <italic>de novo</italic> assemblers on dog and mouse datasets. The results show that BinPacker reaches the highest sensitivity, recovering 1149 and 10012 full-length transcripts among 33665 and 39060 candidates respectively on dog and mouse datasets, while Trinity recovers 1091 and 9599 among 49311 and 78333, and Bridger recovers 1147 and 9991 among 37234 and 50051. Bridger performs a little worse than BinPacker, but better than Trinity and all the other <italic>de novo</italic> assemblers (<xref ref-type="fig" rid="pcbi.1004772.g001">Fig 1A and 1C</xref>, shaded area). Trinity performs worse than BinPacker because it uses an exhaustive enumeration algorithm to search for paths in <italic>de Bruijn</italic> graphs without using sequencing depth information in the searching process, which results in the increase of false positives and the decrease of true positives. Bridger performing worse than BinPacker is due to the facts: 1) the weights in compatibility graph are defined a bit arbitrarily, and 2) a node with both in-edges and out-edges in the splicing graph will never be an end of a transcript. Apart from the three best <italic>de novo</italic> assemblers mentioned above, Trans-ABySS performs best on dog dataset, while Oases does best on mouse dataset. We further compared BinPacker with StringTie, a most recently published <italic>ab initio</italic> assembler. As expected, StringTie performs best on mouse dataset. Surprisingly, while it is defeated by BinPacker on dog dataset, StringTie recovers 1072 full-length transcripts, compared to 1149 recovered by BinPacker.</p>
<fig id="pcbi.1004772.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Comparison of recovered reference sensitivity and its distribution against recovered sequence length rates (sequence identity) ranging from 80% to 100% on (A) dog, (B) human and (C) mouse datasets.</title>
<p>Solid colored circles in shaded areas represent the number of full-length recovered reference transcripts for different assemblers.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g001" xlink:type="simple"/>
</fig>
<p>To test the reliability of these <italic>de novo</italic> assemblers, we compare their sensitivity distributions against recovered sequence length rates ranging from 80% to 100%. As shown in <xref ref-type="fig" rid="pcbi.1004772.g001">Fig 1A and 1C</xref>, BinPacker keeps the highest sensitivity in the whole interval [80%, 100%] on both dog and mouse datasets. Bridger's sensitivity is a little lower than BinPacker's, while Trinity is lower than both BinPacker and Bridger, but higher than the others in the whole interval [80%, 100%].</p>
<p><italic>1.2.2 Comparison of accuracies and distributions against recovered sequence length rates on dog and mouse datasets</italic>. Our comparison results show that BinPacker outperforms all the other <italic>de novo</italic> assemblers we are comparing with in terms of both types of accuracy on dog and mouse datasets (Figs <xref ref-type="fig" rid="pcbi.1004772.g002">2A and 2C</xref> and <xref ref-type="fig" rid="pcbi.1004772.g003">3A and 3C</xref>, shaded area). Of all the other assemblers, Bridger performs best on dog dataset in terms of both types of accuracy, while ABySS performs best on mouse dataset in terms of both types of accuracy. Trinity suffers from very low accuracy on both dog and mouse datasets because of its large false positives. StringTie as expected performs best on mouse dataset, but unexpectedly worse than BinPacker on the dog dataset in terms of both types of accuracy.</p>
<fig id="pcbi.1004772.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Comparison of assembled true positive rate and its distribution against recovered sequence length rates (sequence identity) ranging from 80% to 100% on (A) dog, (B) human and (C) mouse datasets.</title>
<p>Solid colored circles in shaded areas represent the assembled true positive rate for different assemblers.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g002" xlink:type="simple"/>
</fig>
<fig id="pcbi.1004772.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Comparison of reference true positive rate and its distribution against recovered sequence length rates (sequence identity) ranging from 80% to 100% on (A) dog, (B) human and (C) mouse datasets.</title>
<p>Solid colored circles in shaded areas represent the reference true positive rate for different assemblers.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g003" xlink:type="simple"/>
</fig>
<p>The comparison results of accuracy distributions against recovered sequence length rates ranging from 80% to 100% (Figs <xref ref-type="fig" rid="pcbi.1004772.g002">2A and 2C</xref> and <xref ref-type="fig" rid="pcbi.1004772.g003">3A and 3C</xref>) show that BinPacker keeps the highest accuracy level in the interval [90%, 100%] on both dog and mouse datasets. The following are some details of the performances of the other assemblers excluding BinPacker. Bridger keeps the highest accuracy level among the others on dog dataset in terms of both types of accuracy in the interval [90%, 100%]. On the mouse dataset, ABySS keeps the highest among the others excluding Bridger in terms of reference true positive rate in the interval [90%, 100%], and Oases keeps the highest among the others excluding Bridger in terms of assembled true positive rate in the interval [80%, 100%] excluding [94%, 99%]. Trinity again loses in accuracy of both types in the interval [80%, 100%] on both dog and mouse datasets.</p>
<p>Therefore we conclude that BinPacker has the highest reliability among all the <italic>de novo</italic> assemblers we are comparing with in terms of their distributions of sensitivity and accuracy against recovered sequence length rates on real dog and mouse datasets.</p>
<p><italic>1.2.3 BinPacker maintains a stable performance on human dataset</italic>. The human dataset is also adopted to test the performance of BinPacker and the other assemblers. The results show that BinPacker outperforms all the other <italic>de novo</italic> assemblers except Trinity on some cases. The following are some details. For the sensitivity, BinPacker, Bridger and Trinity recovered 5859, 5822 and 6122 full-length reference transcripts from 41691, 41470 and 54315 candidates, respectively. StringTie recovered 9177 full-length reference transcripts out of 43757 candidates. Again Trinity gets more false positives than BinPacker and Bridger. The reference true positive rate of BinPacker is 14.05%, best of all <italic>de novo</italic> assemblers, while that of Trinity is 11.27%, higher than all the other assemblers except Bridger, which performs only a little worse than BinPacker in this measure, with its reference true positive rate 14.03%; the assembled true positive rate of BinPacker achieves 10.37%, while Trinity reaches 11.14%, highest among the compared <italic>de novo</italic> assemblers, including Bridger, with its assembled true positive rate 9.56%. We also compute the sensitivity and accuracy distributions against recovered sequence length rates ranging from 80% to 100%. For the sensitivity distribution, the three curves of BinPacker, Bridger and Trinity are almost coincident with the highest sensitivity among all <italic>de novo</italic> assemblers. For the accuracy, the reference true positive rate of BinPacker keeps the highest in the interval [90%, 100%]. For the assembled true positive rate, BinPacker performs a little worse than Trinity, which reaches the highest in the whole interval, but much better than the others. The performance of the other assemblers on human dataset is almost the same as on dog and mouse datasets (See Figs <xref ref-type="fig" rid="pcbi.1004772.g001">1B</xref>–<xref ref-type="fig" rid="pcbi.1004772.g003">3B</xref> for details).</p>
</sec>
</sec>
<sec id="sec009">
<title>2. Tests on simulated dataset</title>
<p>It is necessary to test the assemblers using simulated RNA-seq dataset since we may know all the genuine transcripts hidden in it in advance. An <italic>in silico</italic> RNA-Seq data generator, Flux Simulator [<xref ref-type="bibr" rid="pcbi.1004772.ref022">22</xref>], is applied to UCSC hg19 gene annotation to generate an error-free dataset of approximately 50 million paired-end strand-specific RNA-seq reads. To demonstrate the advantage of BinPacker over other assemblers on the simulated dataset, we ran all the assemblers and did comparison among them in terms of their sensitivities, accuracies and their distributions against recovered sequence length rates.</p>
<p>Our comparison results show that BinPacker not only reaches the highest sensitivity, but also the highest accuracy levels of both types. Furthermore, BinPacker keeps the highest sensitivity and accuracy of both types in the whole interval [80%, 100%]. Therefore it can be concluded that BinPacker has the highest reliability among all the <italic>de novo</italic> assemblers we are comparing with in terms of their distributions of both sensitivity and accuracy against recovered sequence length rates on the simulated dataset. See <xref ref-type="fig" rid="pcbi.1004772.g004">Fig 4</xref> and <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref> for details.</p>
<fig id="pcbi.1004772.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Comparison of assemblers on simulated dataset.</title>
<p>(A) Recovered reference sensitivity and its distribution against recovered sequence length rates. The solid colored circles in shaded areas represent the number of full-length recovered reference transcripts for different assemblers; (B) Reference true positive rate and its distribution against recovered sequence length rates. The solid colored circles in shaded areas represent the reference true positive rate for different assemblers; (C) Assembled true positive rate and its distribution against recovered sequence length rates. The solid colored circles in shaded areas represent the assembled true positive rate for different assemblers.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g004" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec010">
<title>3. Comparison of running time and memory usage on real datasets</title>
<p>We examined the computing resources required by these <italic>de novo</italic> assemblers: the running time and the memory usage on the same server. The results are shown in Figs <xref ref-type="fig" rid="pcbi.1004772.g005">5</xref> and <xref ref-type="fig" rid="pcbi.1004772.g006">6</xref>. ABySS uses the least memory (<xref ref-type="fig" rid="pcbi.1004772.g005">Fig 5</xref>), while SOAPdenovo-Trans takes the shortest time (<xref ref-type="fig" rid="pcbi.1004772.g006">Fig 6</xref>). Oases performs well on dog dataset but it consumes the most memory and has almost the longest running time on both human and mouse dataset. We noted that the computing resource requirement by Oases is sensitive to the <italic>k</italic>-mer value, which had also been found in another research paper [<xref ref-type="bibr" rid="pcbi.1004772.ref023">23</xref>]. As an enumeration algorithm, Trinity consumes the most memory on dog dataset and takes the longest time on both dog and mouse datasets. For the memory usage (<xref ref-type="fig" rid="pcbi.1004772.g005">Fig 5</xref>) BinPacker and Bridger almost require the same amount of memory, more than most of the compared assemblers except Trinity and Oases, which consume much more memory than BinPacker on human and mouse datasets. For the time usage (<xref ref-type="fig" rid="pcbi.1004772.g006">Fig 6</xref>), BinPacker is among the fastest assemblers and it has also made a great improvement compared to Bridger, which takes much more time than BinPacker on both human and mouse datasets.</p>
<fig id="pcbi.1004772.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g005</object-id>
<label>Fig 5</label>
<caption>
<title>RAM usage for each assembler on (A) dog, (B) human and (C) mouse datasets.</title>
<p>Same parameter values are used for all assemblers: k = 25 and CPU = 6.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g005" xlink:type="simple"/>
</fig>
<fig id="pcbi.1004772.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Running time for each assembler on (A) dog, (B) human and (C) mouse datasets.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g006" xlink:type="simple"/>
</fig>
</sec>
</sec>
<sec id="sec011" sec-type="conclusions">
<title>Discussion</title>
<p>In this study, we presented a novel <italic>de novo</italic> method BinPacker for transcriptome assembly using short RNA-seq reads. Compared with Trinity, one of the most popular <italic>de novo</italic> assemblers, BinPacker has the following advantages: (i) Trinity uses a fixed k-mer length 25, which is not necessarily optimal for all datasets, while BinPacker allows different user-specified k-mer values for different problems for optimal performance. One crucial parameter of BinPacker is the k-mer length. Generally speaking, with larger k values it performs better on high expression datasets or longer reads and with smaller k values it performs better on low expression datasets or shorter reads [<xref ref-type="bibr" rid="pcbi.1004772.ref017">17</xref>]. In light of our testing results, k = 25 is chosen to be the default value, however, larger k values are recommended for reads with length longer than 75bp. (ii) Compared to the exhaustive enumeration method used in Trinity, BinPacker uses a rigorous mathematical model to search for an optimal set of paths from the splicing graph, which makes BinPacker achieve a lower false positive rate at the same level of sensitivity. (iii) BinPacker makes full use of the sequencing depth information, which is applied to define the junction weights of the splicing graphs, constraining the deconvolution of splicing graphs into individual transcripts, and hence making its assembly results more accurate. (iv) BinPacker makes a different use of the paired-end information compared with Trinity. While Trinity uses the paired-end information to search for paths in the <italic>de Bruijn</italic> graphs, this information is mainly used in our process of constructing splicing graphs. Firstly, the paired-end information is used to help reconstruct more complete splicing graphs, making contigs even not covered by overlapping k-mers be recovered during assembly. Secondly, paired-end information is also used to trim error branches of the constructed splicing graphs, removing error junctions from splicing graphs. In practice, BinPacker uses less memory space and shorter running time.</p>
<p>As showed in Results section, the assemblers have a high variance in sensitivity, accuracy and time and memory usage across the different RNA-seq datasets. Several facts may cause such a variance. 1) Different RNA-Seq datasets may contain different transcripts expression levels and different sequencing depths, both of which lead to the same transcripts in different RNA-Seq datasets covered by quite a different number of reads. And so they could have a large effect on sensitivity, accuracy and time and memory usage. 2) The reads in different RNA-Seq datasets may have different lengths, maybe shorter than 50, and maybe longer than 100, which may also cause differences in sensitivity, accuracy and time and memory usage. 3) The qualities of reference transcripts for different species are also quite different. For example, human and mouse genomes have been studied more extensively than dog genome, so the rate of known reference transcripts will certainly be larger than that of dog. We have seen in our comparison the sensitivity and accuracy of dog is lower than that of human and mouse. 4) Other reasons, such as different sequencing error rates, the usage of paired-end reads or single-end reads, may also contribute to the variance in sensitivity, accuracy and time and memory usage.</p>
<p>The E. coli dataset is also adopted to evaluate the performance of the <italic>de novo</italic> assemblers on low complexity genome species without alternative splicing isoforms. Since the dataset is much smaller than that of dog, human and mouse, all the compared assemblers use much less running time and memory usage. For the sensitivity and accuracy, because most compared assemblers are designed to assemble transcripts from genes with alternative splicing events, they all do not perform very well on low complexity genome species such as E. coli without alternative splicing isoforms. Details are described in the first section of the <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>.</p>
<p>As far as we know, BinPacker is the first algorithm using the bin-packing strategy for <italic>de novo</italic> assembly, without the utilization of any other reference information. Tested on both real and simulated RNA-seq datasets, BinPacker shows the best sensitivity and accuracy compared to all the other <italic>de novo</italic> assemblers, and even outperforms the most popular <italic>ab initio</italic> assembler StringTie on real dog dataset, only slightly worse than Trinity in some aspects on real human dataset. In addition, it requires fewer computational resources and less running time compared to most of the other assemblers. With these demonstrated advantages, we anticipate that BinPacker will play an important role for new discoveries in transcriptome study using RNA-seq datasets, especially for cancer transcriptomic data analyses.</p>
</sec>
<sec id="sec012" sec-type="materials|methods">
<title>Methods</title>
<p>The splicing graph was first introduced by Heber, et al in 2002 [<xref ref-type="bibr" rid="pcbi.1004772.ref024">24</xref>]. BinPacker assembles transcripts on each splicing graph it constructs. Each splicing graph constructed by BinPacker is a directed acyclic graph, with its nodes and edges representing exons and splicing events of the gene. The nodes in the splicing graph are continuous genome sequences without any alternative splicing events, which may not be real exons of the gene. Based on the generalized definition of exons, BinPacker first builds splicing graphs for all expressed genes encoded in the genome using the given RNA-seq datasets. Ideally, each splicing graph constructed by BinPacker has a correspondence to a specific (expressed) gene. Unfortunately, it may not always be this case due to the existence of sequencing errors, homologous genes and low expression levels of some genes. But it does not cause a serious impact on our full-length transcripts recovery of individual genes even though some splicing graphs cover multiple genes or only parts of a gene. Without loss of generality, we assume that each splicing graph represents one expressed gene. Having constructed all the splicing graphs, BinPacker searches for an optimal edge-path-cover over all the individual splicing graphs by iteratively solving a series of bin packing problems. Each edge-path-cover output by BinPacker can explain all the observed splicing events encoded in the corresponding splicing graph. A flowchart of the BinPacker algorithm is given in Fig C in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>.</p>
<sec id="sec013">
<title>1. Construction of splicing graphs</title>
<p>BinPacker constructs splicing graphs based on the method of Bridger [<xref ref-type="bibr" rid="pcbi.1004772.ref017">17</xref>] with several updates as follows. First of all, while Bridger is not able to process RNA-Seq reads with different lengths, BinPacker can handle reads with variable lengths. Secondly, Bridger trims the branches of the splicing graphs after all splicing graphs have been constructed. However, BinPacker trims splicing graphs during the construction of splicing graphs.</p>
</sec>
<sec id="sec014">
<title>2. Topological ordering of splicing graph and detecting a maximal set of pairwise incompatible edges</title>
<p>Two directed edges in a splicing graph are said to be compatible if they may come from one directed path, and incompatible otherwise (see Fig I in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>). We may imagine that the splicing graphs one-to-one correspond to the expressed genes, with nodes corresponding to exons and edges corresponding to splicing junctions. Since exons are linearly arranged in a gene, we may suppose that the nodes in the splicing graph of the gene are also linearly arranged, but not necessarily to be identical to that of the gene. We did this linearly arrangement by topological ordering of the splicing graph, which can be solved in linear time [<xref ref-type="bibr" rid="pcbi.1004772.ref025">25</xref>]. After topological ordering, all nodes with only out-edges are moved to the leftmost of the graph and all nodes with only in-edges to the rightmost. From now on, we refer to the splicing graph with all nodes being linearly arranged as a canonical splicing graph. Note that each directed edge in the canonical splicing graph can only go in the direction of the gene (Fig I in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>). Each edge in a splicing graph is assigned a weight using its sequencing depth (number of reads spanning the junction edge in the splicing graph). It is obvious that the edges crossing two consecutive nodes in the splicing graph are pairwise incompatible (Fig J in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>). In fact, the maximum set of edges crossing two consecutive nodes in a canonical splicing graph must be a maximal set of pairwise incompatible edges in the splicing graph (see Theorem 1 in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>). BinPacker will iteratively execute a series of bin packing programs based on such a maximal set of pairwise incompatible edges.</p>
</sec>
<sec id="sec015">
<title>3. Bin packing</title>
<p>BinPacker iteratively calls a variant of bin packing model to comb all the transcripts encoded in a splicing graph. To do so, we add a source node <italic>s</italic> and a sink node <italic>t</italic> into the splicing graph (Fig I in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>), and connect <italic>s</italic> to the nodes with only out-going edges, and connect all the nodes with only in-coming edges to <italic>t</italic>. The weight of the new edge connecting <italic>s</italic> and <italic>u</italic> is assigned to be the sum of the weights of the edges going out from <italic>u</italic>. Similarly, the new edges going to <italic>t</italic> can be weighted.</p>
<sec id="sec016">
<title>Step 1: Balancing splicing graphs</title>
<p>Let <italic>u</italic> be a node in a splicing graph, the sum of the weights of the in-edges of <italic>u</italic> is said to be in-weight of <italic>u</italic>, denoted by <italic>w</italic><sub><italic>in</italic></sub>(<italic>u</italic>). Out-weight of <italic>u</italic> is defined similarly, denoted by <italic>w</italic><sub><italic>out</italic></sub>(<italic>u</italic>). Let <italic>w</italic><sub><italic>min</italic></sub> = min{<italic>w</italic><sub><italic>in</italic></sub>(<italic>u</italic>), <italic>w</italic><sub><italic>out</italic></sub>(<italic>u</italic>)}, <italic>c</italic> = <italic>α</italic>(<italic>γ</italic>—<italic>β</italic>)/<italic>w</italic><sub><italic>min</italic></sub> <italic>+ β</italic>, where <italic>α</italic>, <italic>β</italic> and <italic>γ</italic> are parameters that users can specify (see Methods and Fig M in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref> for details). When there is a significant difference between <italic>w</italic><sub><italic>in</italic></sub>(<italic>u</italic>) and <italic>w</italic><sub><italic>out</italic></sub>(<italic>u</italic>), the node u is supposed to be an end of a transcript. We handle this by adding a new edge from the source s to the node u, with weight <italic>w</italic><sub><italic>out</italic></sub>(<italic>u</italic>)<italic>−w</italic><sub><italic>in</italic></sub>(<italic>u</italic>) whenever <italic>w</italic><sub><italic>out</italic></sub><italic>(u)/w</italic><sub><italic>in</italic></sub><italic>(u) ≥ c</italic>, which means that the difference between <italic>win</italic>(<italic>u</italic>) and <italic>w</italic><sub><italic>out</italic></sub>(<italic>u</italic>) is significant. Similarly, we may add a new edge from the node u to the sink t if <italic>w</italic><sub><italic>in</italic></sub>(<italic>u</italic>)<italic>/w</italic><sub><italic>out</italic></sub>(<italic>u</italic>) <italic>≥ c</italic>. BinPacker sets α = 10, β = 1.4 and γ = 1.5 as default.</p>
</sec>
<sec id="sec017">
<title>Step 2: Iterations of the bin packing</title>
<p>Suppose that we have a maximal set <italic>I</italic> of pairwise incompatible edges crossing the two consecutive nodes obtained above. BinPacker identifies each edge in the splicing graph as a bin with its capacity being the weight (sequencing depth) of the edge, and puts an item <italic>i</italic> in each bin (edge) in <italic>I</italic>. The size of the item <italic>i</italic>, denoted by <italic>w</italic><sub><italic>i</italic></sub>, is simply the weight of the edge (bin) where the item <italic>i</italic> resides. During the execution, BinPacker always faces a bin packing problem, which is slightly different from the traditional bin packing model. In our model, each item must be packed into one and only one bin and each bin can hold several items with the sum of their sizes smaller or larger than or equal to the capacity of the bin. At the very beginning, all the |<italic>I</italic>| items are one-to-one put in the |<italic>I</italic>| bins accordingly. Let <italic>n</italic><sub><italic>L</italic></sub> denote the left one of the two consecutive nodes and <italic>n</italic><sub><italic>R</italic></sub> the right one.</p>
<p>Starting from <italic>n</italic><sub><italic>L</italic></sub>, BinPacker carries out the first iteration of the bin packing. The first instance of bin packing towards left is formed as follows: we have as input the |<italic>I</italic>| items defined from the edges in <italic>I</italic>, and a set <italic>I'</italic> of bins (edges) crossing the two consecutive nodes <italic>n</italic><sub><italic>L</italic></sub><italic>-1</italic> and <italic>n</italic><sub><italic>L</italic></sub>. What we are going to do is to optimally pack the |<italic>I</italic>| items into the |<italic>I'</italic>| bins. For the (heuristic) algorithm design, we partition the edges in <italic>I</italic> U <italic>I'</italic> into three sets <italic>I</italic><sub><italic>in</italic></sub>, <italic>I</italic><sub><italic>out</italic></sub> and <italic>I</italic><sub><italic>m</italic></sub>, with <italic>I</italic><sub><italic>in</italic></sub> consisting of the edges coming to <italic>n</italic><sub><italic>L</italic></sub>, <italic>I</italic><sub><italic>out</italic></sub> of the edges going out of <italic>n</italic><sub><italic>L</italic></sub>, and <italic>I</italic><sub><italic>m</italic></sub> of the remaining edges. Clearly, edges in <italic>I</italic><sub><italic>in</italic></sub> belong to <italic>I'</italic> but not to <italic>I</italic>, edges in <italic>I</italic><sub><italic>out</italic></sub> belong to <italic>I</italic> but not to <italic>I'</italic>, and edges in <italic>I</italic><sub><italic>m</italic></sub> belong to both <italic>I</italic> and <italic>I'</italic>. For the first instance, we have that <italic>|I</italic><sub><italic>out</italic></sub><italic>|≥|I</italic><sub><italic>in</italic></sub><italic>|</italic> since <italic>|I|≥|I'|</italic>. Executing the bin packing, BinPacker keeps the items in the bins (edges) of <italic>I</italic><sub><italic>m</italic></sub> staying unchanged, and optimally packs the items in the bins (edges) of <italic>I</italic><sub><italic>out</italic></sub> into the bins (edges) of <italic>I</italic><sub><italic>in</italic></sub> whenever <italic>|I</italic><sub><italic>out</italic></sub><italic>|≥|I</italic><sub><italic>in</italic></sub><italic>|</italic>, then reset <italic>n</italic><sub><italic>L</italic></sub> <italic>= n</italic><sub><italic>L</italic></sub><italic>-1</italic>, <italic>I</italic><sub><italic>in</italic></sub> and <italic>I</italic><sub><italic>out</italic></sub> accordingly. Repeat this procedure until encountering a <italic>trap node n</italic><sub><italic>L</italic></sub> with <italic>|I</italic><sub><italic>out</italic></sub><italic>|&lt;|I</italic><sub><italic>in</italic></sub><italic>|</italic>, which may happen in two cases (see Methods in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>), or reaching the source node <italic>s</italic>. If the former occurs in some iteration, BinPacker replaces the <italic>n</italic> (= |<italic>I</italic><sub><italic>out</italic></sub>|) items in the bins (edges) of <italic>I</italic><sub><italic>out</italic></sub> by <italic>m</italic> (= |<italic>I</italic><sub><italic>in</italic></sub>|) new items with sizes, <italic>w</italic><sub><italic>1</italic></sub>, <italic>w</italic><sub><italic>2</italic></sub>,…, <italic>w</italic><sub><italic>m</italic></sub>, the weights of the <italic>m</italic> edges of <italic>I</italic><sub><italic>in</italic></sub>, while the other items in the bins (edges) of <italic>I</italic><sub><italic>m</italic></sub> stay unchanged, and then executes the next iteration starting from the trap node <italic>n</italic><sub><italic>L</italic></sub> towards the opposite direction until encountering another trap node or reaching the sink node <italic>t</italic>; otherwise, the latter occurs, BinPacker jumps back to the starting node of the current iteration and processes the remaining nodes one by one until encountering a new trap node or reaching the sink node <italic>t</italic>. Repeat the procedure until all nodes are processed (see <xref ref-type="fig" rid="pcbi.1004772.g007">Fig 7</xref>). The forth and back iteration must terminate within a few times (no more than |<italic>V</italic>| times, where <italic>V</italic> is the node set of the splicing graph) due to the fact that the nodes previously processed will never be trapped again (see Theorem 2 in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref>).</p>
<fig id="pcbi.1004772.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004772.g007</object-id>
<label>Fig 7</label>
<caption>
<title>An example which shows the iterations of BinPacker in the packing process.</title>
<p>(A) The first iteration of BinPacker starts from node 4 to the left. (B) When BinPacker processes nodes one by one to the left, it encounters a trap node 2, and then enters the next iteration starting from node 2 to the right. (C) When BinPacker processes nodes to the right, it encounters another trap node 6 and then enters the next iteration starting from node 6 towards left. (D) In this iteration, BinPacker reaches a terminal <italic>s</italic>, and then jumps back to the starting node 6 and processes the remaining nodes one by one to the right. (E) BinPacker reaches another terminal <italic>t</italic> and terminates its iterations.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.g007" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec018">
<title>Step 3: Bin packing by 0–1 quadratic programming</title>
<p>Suppose that BinPacker is processing the node <italic>n</italic><sub><italic>L</italic></sub> towards left and we have <italic>m</italic> edges (bins) coming to <italic>n</italic><sub><italic>L</italic></sub> from which the bins (edges) containing <italic>n</italic> items go out.</p>
<p>If <italic>m</italic>≤<italic>n</italic>, the bin packing can be solved by the following 0–1 quadratic programming:
<disp-formula id="pcbi.1004772.e001">
<alternatives>
<graphic id="pcbi.1004772.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004772.e001" xlink:type="simple"/>
<mml:math display="block" id="M1">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>min</mml:mtext><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mstyle></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mstyle></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable>
</mml:math>
</alternatives>
<label>(1)</label>
</disp-formula>
where <italic>c</italic><sub><italic>i</italic></sub> represents the capacity of bin <italic>i</italic>, <italic>w</italic><sub>j</sub> the size of item <italic>j</italic>, and <italic>x</italic><sub><italic>ij</italic></sub> is a binary variable with <italic>x</italic><sub><italic>ij</italic></sub> = 1 if item <italic>j</italic> is packed into bin <italic>i</italic>, 0 otherwise. The first constraint ensures that one item goes into one and only one bin, and the second one guarantees that each bin receives at least one item.</p>
<p>Otherwise, we have <italic>m</italic>&gt;<italic>n</italic>, and get trapped at the node <italic>n</italic><sub><italic>L</italic></sub>. Then the bin packing can be solved by the following quadratic programming:
<disp-formula id="pcbi.1004772.e002">
<alternatives>
<graphic id="pcbi.1004772.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004772.e002" xlink:type="simple"/>
<mml:math display="block" id="M2">
<mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>min</mml:mtext><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mtext>k</mml:mtext></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>−</mml:mo><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mi>s</mml:mi><mml:mo>.</mml:mo><mml:mi>t</mml:mi><mml:mo>.</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mtext>k</mml:mtext></mml:munderover><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mstyle></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mstyle displaystyle="true"><mml:munderover><mml:mo>∑</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>m</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>≥</mml:mo><mml:msub><mml:mi>n</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mtext>k</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable>
</mml:math>
</alternatives>
<label>(2)</label>
</disp-formula>
where <italic>k</italic> represents the number of edges going out of <italic>n</italic><sub><italic>L</italic></sub>, <italic>n</italic><sub><italic>i</italic></sub> the number of items packed into bin (edge) <italic>i</italic> (1 ≤ <italic>i</italic> ≤ <italic>k</italic>). This constraint ensures that each bin previously packed will get at least the same number of items as in the last iteration.</p>
</sec>
<sec id="sec019">
<title>Step 4: Transformation into 0–1 ILP</title>
<p>The 0–1 quadratic programming can be equivalently transformed into a 0–1 linear programming (see Methods and Theorem 3 in <xref ref-type="supplementary-material" rid="pcbi.1004772.s001">S1 Text</xref> for details). To do so, we simply introduce a new variable <italic>x</italic><sub><italic>ijik</italic></sub> for each quadratic term <italic>x</italic><sub><italic>ij</italic></sub><italic>·x</italic><sub><italic>ik</italic></sub> (or <italic>x</italic><sub><italic>ik</italic></sub><italic>·x</italic><sub><italic>ij</italic></sub>) in the objective function along with the constraints:
<disp-formula id="pcbi.1004772.e003">
<alternatives>
<graphic id="pcbi.1004772.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004772.e003" xlink:type="simple"/>
<mml:math display="block" id="M3">
<mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>≤</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>−</mml:mo><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mi>j</mml:mi><mml:mi>i</mml:mi><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>∈</mml:mo><mml:mo>{</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>}</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mo>∀</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>…</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>1</mml:mn><mml:mo>≤</mml:mo><mml:mi>j</mml:mi><mml:mo>≤</mml:mo><mml:mi>k</mml:mi><mml:mo>≤</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mrow></mml:mrow>
</mml:math>
</alternatives>
</disp-formula></p>
</sec>
</sec>
<sec id="sec020">
<title>4. Recovery of an optimal set of full-length transcripts</title>
<p>All the 0–1 ILPs are optimally solved by GLPK-4.40. The GLPK (GNU Linear Programming Kit) package is intended for solving large-scale linear programming (LP), mixed integer programming (MIP), and other related problems. It is a set of routines written in ANSIC and organized in the form of a callable library. Since each programming is modeled from one node of a splicing graph, the number of variables of the 0–1 ILP is |<italic>I</italic><sub><italic>in</italic></sub>|⋅|<italic>I</italic><sub><italic>out</italic></sub>|⋅(|<italic>I</italic><sub><italic>out</italic></sub>|+3)/2 or |<italic>I</italic><sub><italic>out</italic></sub>|⋅|<italic>I</italic><sub><italic>in</italic></sub>|⋅(|<italic>I</italic><sub><italic>in</italic></sub>|+3)/2. In most cases, |<italic>I</italic><sub><italic>out</italic></sub>|&lt;3 and |<italic>I</italic><sub><italic>in</italic></sub>|&lt;3, so the number of variables of the 0–1 ILP is almost always less than 27 and it can be optimally solved by GLPK extremely fast. And even in many cases, |<italic>I</italic><sub><italic>out</italic></sub>| = 1 or |<italic>I</italic><sub><italic>in</italic></sub>| = 1, in which cases, items can be directly packed into corresponding bins without using GLPK.</p>
<p>The solution {<italic>x</italic><sub><italic>ij</italic></sub>} tells us that item <italic>j</italic> is in bin <italic>i</italic> if and only if <italic>x</italic><sub><italic>ij</italic></sub> = 1. All the bins (edges) containing the same item induce an <italic>s-t</italic> path in the splicing graph of a gene which may correspond to a transcript of the gene. Finally, BinPacker outputs all the transcripts induced by individual items in the splicing graph of the gene.</p>
</sec>
</sec>
<sec id="sec021">
<title>Supporting Information</title>
<supplementary-material id="pcbi.1004772.s001" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004772.s001" xlink:type="simple">
<label>S1 Text</label>
<caption>
<title>Supplementary material of BinPacker.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ref-list>
<title>References</title>
<ref id="pcbi.1004772.ref001"><label>1</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Sharon</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Tilgner</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Grubert</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Snyder</surname> <given-names>M</given-names></name> (<year>2013</year>) <article-title>A single-molecule long-read survey of the human transcriptome</article-title>. <source>Nat Biotechnol</source> <volume>31</volume>: <fpage>1009</fpage>–<lpage>1014</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nbt.2705" xlink:type="simple">10.1038/nbt.2705</ext-link></comment> <object-id pub-id-type="pmid">24108091</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref002"><label>2</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Bao</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Jiang</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Girke</surname> <given-names>T</given-names></name> (<year>2013</year>) <article-title>BRANCH: boosting RNA-Seq assemblies with partial or related genomic sequences</article-title>. <source>Bioinformatics</source> <volume>29</volume>: <fpage>1250</fpage>–<lpage>1259</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btt127" xlink:type="simple">10.1093/bioinformatics/btt127</ext-link></comment> <object-id pub-id-type="pmid">23493323</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref003"><label>3</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Metzker</surname> <given-names>ML</given-names></name> (<year>2009</year>) <article-title>Sequencing technologies—the next generation</article-title>. <source>Nature Reviews Genetics</source> <volume>11</volume>: <fpage>31</fpage>–<lpage>46</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nrg2626" xlink:type="simple">10.1038/nrg2626</ext-link></comment> <object-id pub-id-type="pmid">19997069</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref004"><label>4</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Matlin</surname> <given-names>AJ</given-names></name>, <name name-style="western"><surname>Clark</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Smith</surname> <given-names>CW</given-names></name> (<year>2005</year>) <article-title>Understanding alternative splicing: towards a cellular code</article-title>. <source>Nat Rev Mol Cell Biol</source> <volume>6</volume>: <fpage>386</fpage>–<lpage>398</lpage>. <object-id pub-id-type="pmid">15956978</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref005"><label>5</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Black</surname> <given-names>DL</given-names></name> (<year>2003</year>) <article-title>Mechanisms of alternative pre-messenger RNA splicing</article-title>. <source>Annu Rev Biochem</source> <volume>72</volume>: <fpage>291</fpage>–<lpage>336</lpage>. <object-id pub-id-type="pmid">12626338</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref006"><label>6</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Wang</surname> <given-names>ET</given-names></name>, <name name-style="western"><surname>Sandberg</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Luo</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Khrebtukova</surname> <given-names>I</given-names></name>, <name name-style="western"><surname>Zhang</surname> <given-names>L</given-names></name>, <etal>et al</etal>. (<year>2008</year>) <article-title>Alternative isoform regulation in human tissue transcriptomes</article-title>. <source>Nature</source> <volume>456</volume>: <fpage>470</fpage>–<lpage>476</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature07509" xlink:type="simple">10.1038/nature07509</ext-link></comment> <object-id pub-id-type="pmid">18978772</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref007"><label>7</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Martin</surname> <given-names>JA</given-names></name>, <name name-style="western"><surname>Wang</surname> <given-names>Z</given-names></name> (<year>2011</year>) <article-title>Next-generation transcriptome assembly</article-title>. <source>Nature Reviews Genetics</source> <volume>12</volume>: <fpage>671</fpage>–<lpage>682</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nrg3068" xlink:type="simple">10.1038/nrg3068</ext-link></comment> <object-id pub-id-type="pmid">21897427</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref008"><label>8</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Grabherr</surname> <given-names>MG</given-names></name>, <name name-style="western"><surname>Haas</surname> <given-names>BJ</given-names></name>, <name name-style="western"><surname>Yassour</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Levin</surname> <given-names>JZ</given-names></name>, <name name-style="western"><surname>Thompson</surname> <given-names>DA</given-names></name>, <etal>et al</etal>. (<year>2011</year>) <article-title>Full-length transcriptome assembly from RNA-Seq data without a reference genome</article-title>. <source>Nature biotechnology</source> <volume>29</volume>: <fpage>644</fpage>–<lpage>652</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nbt.1883" xlink:type="simple">10.1038/nbt.1883</ext-link></comment> <object-id pub-id-type="pmid">21572440</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref009"><label>9</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Haas</surname> <given-names>BJ</given-names></name>, <name name-style="western"><surname>Zody</surname> <given-names>MC</given-names></name> (<year>2010</year>) <article-title>Advancing RNA-Seq analysis</article-title>. <source>Nature Biotechnology</source> <volume>28</volume>: <fpage>421</fpage>–<lpage>423</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nbt0510-421" xlink:type="simple">10.1038/nbt0510-421</ext-link></comment> <object-id pub-id-type="pmid">20458303</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref010"><label>10</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Trapnell</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Williams</surname> <given-names>BA</given-names></name>, <name name-style="western"><surname>Pertea</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Mortazavi</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Kwan</surname> <given-names>G</given-names></name>, <etal>et al</etal>. (<year>2010</year>) <article-title>Transcript assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</article-title>. <source>Nature biotechnology</source> <volume>28</volume>: <fpage>511</fpage>–<lpage>515</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nbt.1621" xlink:type="simple">10.1038/nbt.1621</ext-link></comment> <object-id pub-id-type="pmid">20436464</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref011"><label>11</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Guttman</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Garber</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Levin</surname> <given-names>JZ</given-names></name>, <name name-style="western"><surname>Donaghey</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Robinson</surname> <given-names>J</given-names></name>, <etal>et al</etal>. (<year>2010</year>) <article-title>Ab initio reconstruction of cell type-specific transcriptomes in mouse reveals the conserved multi-exonic structure of lincRNAs</article-title>. <source>Nature biotechnology</source> <volume>28</volume>: <fpage>503</fpage>–<lpage>510</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nbt.1633" xlink:type="simple">10.1038/nbt.1633</ext-link></comment> <object-id pub-id-type="pmid">20436462</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref012"><label>12</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Pertea</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Pertea</surname> <given-names>GM</given-names></name>, <name name-style="western"><surname>Antonescu</surname> <given-names>CM</given-names></name>, <name name-style="western"><surname>Chang</surname> <given-names>TC</given-names></name>, <name name-style="western"><surname>Mendell</surname> <given-names>JT</given-names></name>, <etal>et al</etal>. (<year>2015</year>) <article-title>StringTie enables improved reconstruction of a transcriptome from RNA-seq reads</article-title>. <source>Nature Biotechnology</source> <volume>33</volume>: <fpage>290-+</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nbt.3122" xlink:type="simple">10.1038/nbt.3122</ext-link></comment> <object-id pub-id-type="pmid">25690850</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref013"><label>13</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Simpson</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Wong</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Jackman</surname> <given-names>SD</given-names></name>, <name name-style="western"><surname>Schein</surname> <given-names>JE</given-names></name>, <name name-style="western"><surname>Jones</surname> <given-names>SJM</given-names></name>, <etal>et al</etal>. (<year>2009</year>) <article-title>ABySS: A parallel assembler for short read sequence data</article-title>. <source>Genome Research</source> <volume>19</volume>: <fpage>1117</fpage>–<lpage>1123</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1101/gr.089532.108" xlink:type="simple">10.1101/gr.089532.108</ext-link></comment> <object-id pub-id-type="pmid">19251739</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref014"><label>14</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Xie</surname> <given-names>YL</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>GX</given-names></name>, <name name-style="western"><surname>Tang</surname> <given-names>JB</given-names></name>, <name name-style="western"><surname>Luo</surname> <given-names>RB</given-names></name>, <name name-style="western"><surname>Patterson</surname> <given-names>J</given-names></name>, <etal>et al</etal>. (<year>2014</year>) <article-title>SOAPdenovo-Trans: de novo transcriptome assembly with short RNA-Seq reads</article-title>. <source>Bioinformatics</source> <volume>30</volume>: <fpage>1660</fpage>–<lpage>1666</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btu077" xlink:type="simple">10.1093/bioinformatics/btu077</ext-link></comment> <object-id pub-id-type="pmid">24532719</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref015"><label>15</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Schulz</surname> <given-names>MH</given-names></name>, <name name-style="western"><surname>Zerbino</surname> <given-names>DR</given-names></name>, <name name-style="western"><surname>Vingron</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Birney</surname> <given-names>E</given-names></name> (<year>2012</year>) <article-title>Oases: robust de novo RNA-seq assembly across the dynamic range of expression levels</article-title>. <source>Bioinformatics</source> <volume>28</volume>: <fpage>1086</fpage>–<lpage>1092</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/bts094" xlink:type="simple">10.1093/bioinformatics/bts094</ext-link></comment> <object-id pub-id-type="pmid">22368243</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref016"><label>16</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Peng</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Leung</surname> <given-names>HC</given-names></name>, <name name-style="western"><surname>Yiu</surname> <given-names>SM</given-names></name>, <name name-style="western"><surname>Lv</surname> <given-names>MJ</given-names></name>, <name name-style="western"><surname>Zhu</surname> <given-names>XG</given-names></name>, <etal>et al</etal>. (<year>2013</year>) <article-title>IDBA-tran: a more robust de novo de Bruijn graph assembler for transcriptomes with uneven expression levels</article-title>. <source>Bioinformatics</source> <volume>29</volume>: <fpage>i326</fpage>–<lpage>334</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/bioinformatics/btt219" xlink:type="simple">10.1093/bioinformatics/btt219</ext-link></comment> <object-id pub-id-type="pmid">23813001</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref017"><label>17</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Chang</surname> <given-names>Z</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>GJ</given-names></name>, <name name-style="western"><surname>Liu</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Zhang</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Ashby</surname> <given-names>C</given-names></name>, <etal>et al</etal>. (<year>2015</year>) <article-title>Bridger: a new framework for de novo transcriptome assembly using RNA-seq data</article-title>. <source>Genome Biology</source> <volume>16</volume>.</mixed-citation></ref>
<ref id="pcbi.1004772.ref018"><label>18</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Robertson</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Schein</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Chiu</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Corbett</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Field</surname> <given-names>M</given-names></name>, <etal>et al</etal>. (<year>2010</year>) <article-title>De novo assembly and analysis of RNA-seq data</article-title>. <source>Nature Methods</source> <volume>7</volume>: <fpage>909</fpage>–<lpage>U962</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nmeth.1517" xlink:type="simple">10.1038/nmeth.1517</ext-link></comment> <object-id pub-id-type="pmid">20935650</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref019"><label>19</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Kent</surname> <given-names>WJ</given-names></name> (<year>2002</year>) <article-title>BLAT—the BLAST-like alignment tool</article-title>. <source>Genome research</source> <volume>12</volume>: <fpage>656</fpage>–<lpage>664</lpage>. <object-id pub-id-type="pmid">11932250</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref020"><label>20</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Rosenbloom</surname> <given-names>KR</given-names></name>, <name name-style="western"><surname>Armstrong</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Barber</surname> <given-names>GP</given-names></name>, <name name-style="western"><surname>Casper</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Clawson</surname> <given-names>H</given-names></name>, <etal>et al</etal>. (<year>2015</year>) <article-title>The UCSC Genome Browser database: 2015 update</article-title>. <source>Nucleic Acids Research</source> <volume>43</volume>: <fpage>D670</fpage>–<lpage>D681</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/nar/gku1177" xlink:type="simple">10.1093/nar/gku1177</ext-link></comment> <object-id pub-id-type="pmid">25428374</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref021"><label>21</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Cunningham</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Amode</surname> <given-names>MR</given-names></name>, <name name-style="western"><surname>Barrell</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Beal</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Billis</surname> <given-names>K</given-names></name>, <etal>et al</etal>. (<year>2015</year>) <article-title>Ensembl 2015</article-title>. <source>Nucleic Acids Research</source> <volume>43</volume>: <fpage>D662</fpage>–<lpage>D669</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/nar/gku1010" xlink:type="simple">10.1093/nar/gku1010</ext-link></comment> <object-id pub-id-type="pmid">25352552</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref022"><label>22</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Griebel</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Zacher</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Ribeca</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Raineri</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Lacroix</surname> <given-names>V</given-names></name>, <etal>et al</etal>. (<year>2012</year>) <article-title>Modelling and simulating generic RNA-Seq experiments with the flux simulator</article-title>. <source>Nucleic Acids Research</source> <volume>40</volume>: <fpage>10073</fpage>–<lpage>10083</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1093/nar/gks666" xlink:type="simple">10.1093/nar/gks666</ext-link></comment> <object-id pub-id-type="pmid">22962361</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref023"><label>23</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Zhao</surname> <given-names>QY</given-names></name>, <name name-style="western"><surname>Wang</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Kong</surname> <given-names>YM</given-names></name>, <name name-style="western"><surname>Luo</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Li</surname> <given-names>X</given-names></name>, <etal>et al</etal>. (<year>2011</year>) <article-title>Optimizing de novo transcriptome assembly from short-read RNA-Seq data: a comparative study</article-title>. <source>Bmc Bioinformatics</source> <volume>12</volume>.</mixed-citation></ref>
<ref id="pcbi.1004772.ref024"><label>24</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Heber</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Alekseyev</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Sze</surname> <given-names>SH</given-names></name>, <name name-style="western"><surname>Tang</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Pevzner</surname> <given-names>PA</given-names></name> (<year>2002</year>) <article-title>Splicing graphs and EST assembly problem</article-title>. <source>Bioinformatics</source> <volume>18</volume> <issue>Suppl 1</issue>: <fpage>S181</fpage>–<lpage>188</lpage>. <object-id pub-id-type="pmid">12169546</object-id></mixed-citation></ref>
<ref id="pcbi.1004772.ref025"><label>25</label><mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Kahn</surname> <given-names>AB</given-names></name> (<year>1962</year>) <article-title>Topological sorting of large networks</article-title>. <source>Communications of the ACM</source> <volume>5</volume>: <fpage>558</fpage>–<lpage>562</lpage>.</mixed-citation></ref>
</ref-list>
</back>
</article>