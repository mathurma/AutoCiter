<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.1d3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-19-00396</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1007347</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject><subj-group><subject>Phylogenetic analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Taxonomy</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject><subj-group><subject>Phylogenetic analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Data management</subject><subj-group><subject>Taxonomy</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject><subj-group><subject>Phylogenetic analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Taxonomy</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Data management</subject><subj-group><subject>Taxonomy</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Plant science</subject><subj-group><subject>Plant anatomy</subject><subj-group><subject>Leaves</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Graph theory</subject><subj-group><subject>Directed graphs</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Graph theory</subject><subj-group><subject>Directed graphs</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Database and informatics methods</subject><subj-group><subject>Bioinformatics</subject><subj-group><subject>Sequence analysis</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Evolutionary processes</subject><subj-group><subject>Speciation</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Network analysis</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Generation of Binary Tree-Child phylogenetic networks</article-title>
<alt-title alt-title-type="running-head">Generation of Binary Tree-Child phylogenetic networks</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8845-4290</contrib-id>
<name name-style="western">
<surname>Cardona</surname> <given-names>Gabriel</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Pons</surname> <given-names>Joan Carles</given-names></name>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Scornavacca</surname> <given-names>Celine</given-names></name>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
</contrib-group>
<aff id="aff001">
<label>1</label>
<addr-line>Department of Mathematics and Computer Science, University of the Balearic Islands, Ctra. de Valldemossa Ctra. de Valldemossa km. 7.5. 07122 - Palma, Spain</addr-line>
</aff>
<aff id="aff002">
<label>2</label>
<addr-line>Institut des Sciences de l’Evolution (ISE-M), Université de Montpellier, CNRS, IRD, EPHE, 34095 Montpellier Cedex 5, France</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>van Nimwegen</surname> <given-names>Erik</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>University of Basel, SWITZERLAND</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">gabriel.cardona@uib.es</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<month>9</month>
<year>2019</year>
</pub-date>
<pub-date pub-type="epub">
<day>11</day>
<month>9</month>
<year>2019</year>
</pub-date>
<volume>15</volume>
<issue>9</issue>
<elocation-id>e1007347</elocation-id>
<history>
<date date-type="received">
<day>14</day>
<month>3</month>
<year>2019</year>
</date>
<date date-type="accepted">
<day>20</day>
<month>8</month>
<year>2019</year>
</date>
</history>
<permissions>
<copyright-year>2019</copyright-year>
<copyright-holder>Cardona et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1007347"/>
<abstract>
<p>Phylogenetic networks generalize phylogenetic trees by allowing the modelization of events of reticulate evolution. Among the different kinds of phylogenetic networks that have been proposed in the literature, the subclass of binary tree-child networks is one of the most studied ones. However, very little is known about the combinatorial structure of these networks. In this paper we address the problem of generating all possible binary tree-child (BTC) networks with a given number of leaves in an efficient way via reduction/augmentation operations that extend and generalize analogous operations for phylogenetic trees, and are biologically relevant. Since our solution is recursive, this also provides us with a recurrence relation giving an upper bound on the number of such networks. We also show how the operations introduced in this paper can be employed to extend the evolutive history of a set of sequences, represented by a BTC network, to include a new sequence. An implementation in python of the algorithms described in this paper, along with some computational experiments, can be downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/bielcardona/TCGenerators" xlink:type="simple">https://github.com/bielcardona/TCGenerators</ext-link>.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author summary</title>
<p>Phylogenetic networks are widely used to represent evolutionary scenarios with reticulated events, and among them, the class of binary tree-child (BTC for short) networks is one of the most studied ones. Despite its importance, BTC networks, as mathematical objects, are not yet fully understood. In this paper we introduce two operations (reduction and augmentation) on the set of BTC networks that generalize well known operations on phylogenetic trees, and show how they can be used to analyze and synthesize any BTC network. Apart from the mathematical formulation of the problem, we exhibit how these operations can be used in biological applications to add a new sequence to a given BTC network. This can be useful, for instance, to update the network without redoing the whole search, or in a phylogenetic placement perspective. We also obtain a recursive formula for a bound on the number of such networks. We have implemented the algorithms in this paper, made them available on a public repository, and used this implementation to perform some computational simulations.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100003329</institution-id>
<institution>Ministerio de Economía y Competitividad</institution>
</institution-wrap>
</funding-source>
<award-id>DPI2015-67082-P</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8845-4290</contrib-id>
<name name-style="western">
<surname>Cardona</surname> <given-names>Gabriel</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award002">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/501100003329</institution-id>
<institution>Ministerio de Economía y Competitividad</institution>
</institution-wrap>
</funding-source>
<award-id>DPI2015-67082-P</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Pons</surname> <given-names>Joan Carles</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award003">
<funding-source>
<institution>Ministry of Science, Innovation and Universities (ES)</institution>
</funding-source>
<award-id>PGC2018-096956-B-C43</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-8845-4290</contrib-id>
<name name-style="western">
<surname>Cardona</surname> <given-names>Gabriel</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award004">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100014440</institution-id>
<institution>Ministry of Science, Innovation and Universities</institution>
</institution-wrap>
</funding-source>
<award-id>PGC2018-096956-B-C43</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Pons</surname> <given-names>Joan Carles</given-names></name>
</principal-award-recipient>
</award-group>
<funding-statement>Research of GC and JCP has been partially supported by the Spanish Ministry of Science, Innovation and Universities (<ext-link ext-link-type="uri" xlink:href="http://www.ciencia.gob.es/" xlink:type="simple">http://www.ciencia.gob.es/</ext-link>) and European Regional Development Fund (<ext-link ext-link-type="uri" xlink:href="https://ec.europa.eu/regional_policy/es/funding/erdf/" xlink:type="simple">https://ec.europa.eu/regional_policy/es/funding/erdf/</ext-link>) projects DPI2015-67082-P and PGC2018-096956-B-C43. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="17"/>
<table-count count="1"/>
<page-count count="29"/>
</counts>
<custom-meta-group>
<custom-meta>
<meta-name>PLOS Publication Stage</meta-name>
<meta-value>vor-update-to-uncorrected-proof</meta-value>
</custom-meta>
<custom-meta>
<meta-name>Publication Update</meta-name>
<meta-value>2019-09-23</meta-value>
</custom-meta>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>All relevant data are within the manuscript.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Phylogenetic networks are, mathematically, a generalization of phylogenetic trees that, containing nodes with more than one ancestor, permit to model reticulated evolutionary events such as recombinations, lateral gene transfers and hybridizations. We note here that other representations, for example gene tree-species tree reconciliations [<xref ref-type="bibr" rid="pcbi.1007347.ref001">1</xref>], permit to model scenarios including other classes of evolutionary events such as duplications, losses and transfers of genes.</p>
<p>In this paper, we shall focus on directed phylogenetic networks (see [<xref ref-type="bibr" rid="pcbi.1007347.ref002">2</xref>] for a short survey on the phylogenetic network paradigm also covering undirected phylogenetic networks). Mathematically, such networks are, in the broadest sense, directed acyclic graphs with a single node with no incoming arcs –the <italic>root</italic>– representing the common ancestor of all the Operational Taxonomic Units (OTUs for short) under study, which are represented by the nodes with no outgoing arcs –the <italic>leaves</italic>– of the graph; internal nodes represent either (hypothetical) speciations or (hypothetical) reticulated events. Nodes with a single incoming arc –<italic>tree</italic> nodes– model extant or non-extant OTUs, and arcs between tree nodes model direct descent through mutation; nodes with two incoming arcs –<italic>hybrid</italic> nodes– model reticulated events involving the OTUs corresponding to the two parents of the node under consideration, and whose resulting OTU is modeled as its single child. Unfortunately, this definition is too broad, both for representing biologically-meaningful evolutionary scenarios, and for giving objects that can be efficiently handled.</p>
<p>So far, several restrictions on this general definition have been introduced in the literature. A few of them are based on biological considerations, while the majority have been introduced to artificially narrow the space of networks under study. This led to the introduction of a panoply of different classes of phylogenetic networks, such as time-consistent networks [<xref ref-type="bibr" rid="pcbi.1007347.ref003">3</xref>], regular networks [<xref ref-type="bibr" rid="pcbi.1007347.ref004">4</xref>], orchard networks [<xref ref-type="bibr" rid="pcbi.1007347.ref005">5</xref>], galled trees [<xref ref-type="bibr" rid="pcbi.1007347.ref006">6</xref>] and galled networks [<xref ref-type="bibr" rid="pcbi.1007347.ref007">7</xref>], level-<italic>k</italic> networks [<xref ref-type="bibr" rid="pcbi.1007347.ref008">8</xref>], tree-sibling networks [<xref ref-type="bibr" rid="pcbi.1007347.ref009">9</xref>], tree-based networks [<xref ref-type="bibr" rid="pcbi.1007347.ref010">10</xref>] and LGT networks [<xref ref-type="bibr" rid="pcbi.1007347.ref011">11</xref>], just to name a few.</p>
<p>In this paper, we shall focus on binary tree-child networks (BTC networks, for short), which were introduced by [<xref ref-type="bibr" rid="pcbi.1007347.ref009">9</xref>] and are one of the most studied classes of phylogenetic networks [<xref ref-type="bibr" rid="pcbi.1007347.ref012">12</xref>–<xref ref-type="bibr" rid="pcbi.1007347.ref015">15</xref>]. Mathematically, being tree-child means that every internal node is compelled to have at least a child node that is a tree node. BTC networks have been introduced in order to adjust a complex biological reality in a computationally tractable way. Although the original motivation for these networks is not biological, and hence they present some limitations, the mathematical constraint on BTC networks translates biologically as follows: every non-extant OTU is required to have at least an offspring species that evolved only through mutation. This means that not all biologically-meaningful evolutionary scenarios can be modeled with BTC networks. For example, the scenarios depicted in <xref ref-type="fig" rid="pcbi.1007347.g001">Fig 1(a) and 1(e)</xref> are not allowed since, in these cases, the node labeled with <italic>u</italic> has no child with a single incoming arc. Still, BTC networks are one of the most permissive classes of phylogenetic networks and they permit to model quite a lot of meaningful scenarios, and those that cannot be modeled can be approximated pretty well, see <xref ref-type="fig" rid="pcbi.1007347.g001">Fig 1</xref>.</p>
<fig id="pcbi.1007347.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Limitations of BTC networks.</title>
<p>The scenarios in (a) and (e) are not BTC networks since in both cases the node labeled with <italic>u</italic> has no tree-node child. Still, the scenario in (a) can be approximated either by the scenario in (b) or by that in (c), both scenarios being BTC networks. Also, if we are lucky enough to find an OTU between the hybrid event represented by the node <italic>u</italic> and that represented by <italic>v</italic>, e.g. the node <italic>q</italic> in (d), then the hybrid event in <italic>v</italic> can be modeled. The same reasoning holds for the scenario in (e) and those in (f,g,h). Thus, if the “true” network is not BTC, we can always find a BTC network those topology is not far from the true one. In our example, the networks in (b,c) are both a head-moving rSPR [<xref ref-type="bibr" rid="pcbi.1007347.ref016">16</xref>] away from the true network in (a). The same holds for the networks in (f,g) w.r.t. the one in (e). In general, each violation of the TC property, i.e. each hybrid node that has only hybrid children, moves the reconstructible network a head-moving rSPR away from the true one. Note that the configuration in (a) is known to generate severe indistinguishability issues [<xref ref-type="bibr" rid="pcbi.1007347.ref017">17</xref>].</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g001" xlink:type="simple"/>
</fig>
<p>The combinatorial study of phylogenetic networks is nowadays a challenging and active field of research. Nevertheless, the problem of counting how many phylogenetic networks are in a given subclass of networks is still open even for long-established classes. More precisely, this problem has been only recently solved for galled networks [<xref ref-type="bibr" rid="pcbi.1007347.ref018">18</xref>]; for other classes, including tree-child networks, we only have asymptotic results [<xref ref-type="bibr" rid="pcbi.1007347.ref019">19</xref>, <xref ref-type="bibr" rid="pcbi.1007347.ref020">20</xref>]. Associated to the problem of counting networks, we find the problem of their “injective” generation, i.e. without having to check for isomorphism between pairs of constructed networks.</p>
<p>The main result of this paper is a systematic way of recursively generating, with unicity, all BTC networks with a given number of leaves. This generation relies on a pair of reduction/augmentation operations –both producing BTC networks– where reductions decrease by one the number of leaves in a network, and augmentations increase it. The idea of using pairs of operations has already been used to deal either with other classes of phylogenetic networks [<xref ref-type="bibr" rid="pcbi.1007347.ref021">21</xref>, <xref ref-type="bibr" rid="pcbi.1007347.ref022">22</xref>], or for BTC networks but without the unicity feature [<xref ref-type="bibr" rid="pcbi.1007347.ref005">5</xref>].</p>
<p>In order to give a biological meaning to these augmentation operations, assume that the evolutive history of a given group of species is known and modeled by a BTC network, and a new species has to be taken into account. The augmentation operation determines exactly how the phylogenetic network has to be modified, and what is the minimum information needed to establish this modification, in order to model the evolution of the group of species with the newly incorporated one.</p>
<p>As an interesting side product, this procedure gives a recursive formula providing an upper bound on the number of BTC networks. Note also that being able to generate all BTC networks with a given number of leaves may also be interesting as part of a divide-and-conquer framework to reconstruct phylogenetic networks, where we start by computing BTC networks on 3/5 leaves that are then combined together, as done for example in [<xref ref-type="bibr" rid="pcbi.1007347.ref023">23</xref>, <xref ref-type="bibr" rid="pcbi.1007347.ref024">24</xref>].</p>
<p>The paper is organized as follows. In Section Methods, we review the basic definitions that will be used throughout the paper. The main part of the paper is in Section Results, which is split between different subsections. Subsection Reduction of networks is devoted to the reduction procedure, while in Subsection Generation of networks we introduce the augmentation operation and prove that any BTC network can be obtained, in a unique way, via a sequence of augmentation operations applied to the trivial network with one leaf. In Subsection Bounding the number of networks, we show how to relax the conditions for the applicability of the augmentation operation to obtain a recursive formula providing an upper bound on the number of BTC networks. In Subsection An application to phylogenetic reconstruction, we give a concrete biological application of the methods we have developed. In Subsection Computational experiments, we introduce the implementation of the algorithms presented in the paper, and some experimental results, including the exhaustive generation of all BTC networks with up to six leaves and an upper bound of their number up to ten leaves. Finally, in Section Discussion we discuss how our reduction/augmentation operations extend and generalize analogous operations for phylogenetic trees.</p>
</sec>
<sec id="sec002" sec-type="materials|methods">
<title>Methods</title>
<p>In this section we introduce the mathematical notations that are used in the rest of the paper.</p>
<p>Throughout this paper, a <italic>tree node</italic> in a directed graph is a node <italic>u</italic> whose pair of degrees <italic>d</italic>(<italic>u</italic>) = (indegree <italic>u</italic>, outdegree <italic>u</italic>) is (1, 0) for the <italic>leaves</italic>, (0, 2) for the <italic>roots</italic>, or (1, 2) for <italic>internal</italic> tree nodes; a <italic>hybrid node</italic> is a node <italic>u</italic> with <italic>d</italic>(<italic>u</italic>) = (2, 1). If two nodes <italic>u</italic> and <italic>v</italic> are linked by an arc (<italic>u</italic>, <italic>v</italic>) we say that <italic>u</italic> is a <italic>parent</italic> of <italic>v</italic>, or that <italic>v</italic> is a <italic>child</italic> of <italic>u</italic>. Also, two nodes are <italic>siblings</italic> if they have a common parent.</p>
<p>A <italic>binary phylogenetic network</italic> over a set <italic>X</italic> of taxa is a directed acyclic graph with a single root such that all its nodes are either tree nodes or hybrid nodes, and whose leaf set is bijectively labeled by the set <italic>X</italic>. In the following, we will implicitly identify every leaf with its label. A binary phylogenetic network is <italic>tree-child</italic> if every node either is a leaf or has at least one child that is a tree node [<xref ref-type="bibr" rid="pcbi.1007347.ref009">9</xref>]; in particular, the single child of a hybrid node must be a tree node. We will denote by <inline-formula id="pcbi.1007347.e001"><alternatives><graphic id="pcbi.1007347.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e001" xlink:type="simple"/><mml:math display="inline" id="M1"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula> the set of binary tree-child phylogenetic networks over the set [<italic>n</italic>] = {1, …, <italic>n</italic>}.</p>
<p>An <italic>elementary node</italic> in a directed graph is a node <italic>u</italic> with <italic>d</italic>(<italic>u</italic>) = (1, 1) or <italic>d</italic>(<italic>u</italic>) = (0, 1). An <italic>elementary path</italic> <italic>p</italic> is a path <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>k</italic></sub> composed of elementary nodes such that neither the single parent of <italic>u</italic><sub>1</sub> (if it exists) nor the single child of <italic>u</italic><sub><italic>k</italic></sub> are elementary. We call these last two nodes respectively the <italic>grantor</italic> (if this node is well-defined) and <italic>heir</italic> of the nodes in the elementary path. In case of an elementary node, its grantor and heir are those of the nodes in the single elementary path that contains the given node. The <italic>elimination</italic> of an elementary path <italic>p</italic> consists in deleting all nodes in <italic>p</italic>, together with their incident arcs, and adding an arc between the grantor and the heir of <italic>p</italic> (provided that the grantor exists; otherwise, no arc is added). The elimination of an elementary node is defined as the elimination of the elementary path that contains the given node.</p>
<p>Given a node <italic>u</italic>, we can <italic>split</italic> it by adding a new node <inline-formula id="pcbi.1007347.e002"><alternatives><graphic id="pcbi.1007347.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e002" xlink:type="simple"/><mml:math display="inline" id="M2"><mml:mover accent="true"><mml:mi>u</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, an arc <inline-formula id="pcbi.1007347.e003"><alternatives><graphic id="pcbi.1007347.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e003" xlink:type="simple"/><mml:math display="inline" id="M3"><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>u</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:mi>u</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, and replacing every arc (<italic>v</italic>, <italic>u</italic>) with <inline-formula id="pcbi.1007347.e004"><alternatives><graphic id="pcbi.1007347.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:mrow><mml:mo>(</mml:mo> <mml:mi>v</mml:mi> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>u</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. If <italic>u</italic> is a tree node, then <inline-formula id="pcbi.1007347.e005"><alternatives><graphic id="pcbi.1007347.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e005" xlink:type="simple"/><mml:math display="inline" id="M5"><mml:mover accent="true"><mml:mi>u</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is an elementary node whose heir is <italic>u</italic>, and the elimination of <inline-formula id="pcbi.1007347.e006"><alternatives><graphic id="pcbi.1007347.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e006" xlink:type="simple"/><mml:math display="inline" id="M6"><mml:mover accent="true"><mml:mi>u</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> recovers the original network. The successive splitting (say <italic>k</italic> times) of a tree node <italic>u</italic> generates an elementary path formed by <italic>k</italic> nodes, whose heir is <italic>u</italic>, and whose elimination recovers the original network. <xref ref-type="fig" rid="pcbi.1007347.g002">Fig 2</xref> illustrates the definitions given in this section.</p>
<fig id="pcbi.1007347.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g002</object-id>
<label>Fig 2</label>
<caption>
<title>The definitions introduced in the methods section.</title>
<p>For the network <italic>N</italic> in the figure (black nodes and arcs only), we have the following: <italic>X</italic> = {1, 2, 3, 4} is the set of taxa, <italic>u</italic> is the root, <italic>x</italic> is a hybrid node and all other nodes are internal tree nodes. If we split <italic>v</italic> twice by adding the elementary nodes <italic>e</italic><sub>1</sub> and <italic>e</italic><sub>2</sub> in grey, we have that (<italic>e</italic><sub>1</sub>, <italic>e</italic><sub>2</sub>) is an elementary path with grantor and heir equal respectively to <italic>u</italic> and <italic>v</italic>. <italic>N</italic> is a binary tree-child network since both parents <italic>v</italic> and <italic>w</italic> of the only hybrid node <italic>x</italic> have another child (1 and <italic>y</italic>, respectively) that is a tree node.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g002" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec003" sec-type="results">
<title>Results</title>
<sec id="sec004">
<title>Reduction of networks</title>
<p>The goal of this subsection is to define a reduction procedure on BTC networks that can be applied to any such network, and producing a BTC network with one leaf less. By successive application of this procedure, any BTC network can thus be reduced to the trivial network with a single leaf.</p>
<p>We start by associating to each leaf <italic>ℓ</italic> a path whose removal will produce the desired reduction (up to elementary paths).</p>
<p>Let <italic>ℓ</italic> be a leaf of a BTC network <italic>N</italic>. A <italic>pre-TH-path</italic> for <italic>ℓ</italic> is a path <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub> = <italic>ℓ</italic> such that (see <xref ref-type="fig" rid="pcbi.1007347.g003">Fig 3</xref>):</p>
<list list-type="order">
<list-item>
<p>Each node <italic>u</italic><sub><italic>i</italic></sub> in the path is a tree node.</p>
</list-item>
<list-item>
<p>For each <italic>i</italic> = 1, …, <italic>r</italic> − 1, the child of <italic>u</italic><sub><italic>i</italic></sub> different from <italic>u</italic><sub><italic>i</italic>+1</sub>, denoted by <italic>v</italic><sub><italic>i</italic></sub>, is a hybrid node.</p>
</list-item>
<list-item>
<p>For each <italic>i</italic> ≠ <italic>j</italic>, we have that <italic>v</italic><sub><italic>i</italic></sub> ≠ <italic>v</italic><sub><italic>j</italic></sub>.</p>
</list-item>
</list>
<fig id="pcbi.1007347.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g003</object-id>
<label>Fig 3</label>
<caption>
<title>A pre-TH-path for the leaf <italic>ℓ</italic>.</title>
<p>Tree nodes are represented by circles and hybrid nodes by squares; snake arrows represent paths. The path inside the dotted box is a pre-TH-path for <italic>ℓ</italic>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g003" xlink:type="simple"/>
</fig>
<p>A <italic>TH-path</italic> is a maximal pre-TH-path, i.e. a pre-TH-path that cannot be further extended. Note that, since all nodes in a pre-TH-path <italic>p</italic> are tree nodes, if <italic>p</italic> can be extended by prepending one node, then this extension is unique. Hence, starting with the trivial pre-TH-path formed by the leaf <italic>ℓ</italic> alone, and extending it by prepending the parent of the first node in the path as many times as possible, we obtain a TH-path that is unique by construction. Let <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub> = <italic>ℓ</italic> be a TH-path; different possibilities may arise that make it maximal: (1) <italic>u</italic><sub>1</sub> is the root of <italic>N</italic>; (2) the parent of <italic>u</italic><sub>1</sub>, call it <italic>x</italic>, is a hybrid node; (3) <italic>x</italic> is a tree node whose both children are tree nodes; (4) <italic>x</italic> is a parent of <italic>v</italic><sub><italic>i</italic></sub> for some <italic>i</italic> ∈ [<italic>r</italic> − 1]. We shall see in Lemma 1 that the first case cannot hold; the other three possibilities are depicted in <xref ref-type="fig" rid="pcbi.1007347.g004">Fig 4</xref>.</p>
<fig id="pcbi.1007347.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g004</object-id>
<label>Fig 4</label>
<caption>
<title>The different possibilities for the TH-path of a leaf <italic>ℓ</italic>.</title>
<p>Depiction of the conditions (2), (3) and (4), respectively, under which a pre-TH-path cannot be extended, making the path inside the dotted box a TH-path for <italic>ℓ</italic>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g004" xlink:type="simple"/>
</fig>
<p>For each leaf <italic>ℓ</italic>, we denote by TH(<italic>ℓ</italic>) its single TH-path and by TH(<italic>ℓ</italic>)<sub>1</sub> the first node of this path. Note that we allow the case <italic>r</italic> = 1. In this case, if we are not in a trivial BTC network (i.e. a network consisting of a single node), the parent of <italic>ℓ</italic> is either a hybrid node, or a tree node whose two children are tree nodes.</p>
<p><bold>Lemma 1</bold>. <italic>Let N be a non-trivial BTC network and let ℓ be any of its leaves. Then</italic>, TH(<italic>ℓ</italic>)<sub>1</sub> <italic>cannot be the root of N</italic>.</p>
<p><italic>Proof</italic>. Let <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub> = <italic>ℓ</italic> be the path TH(<italic>ℓ</italic>) and assume for the sake of contradiction that <italic>u</italic><sub>1</sub> is the root of <italic>N</italic>. For each <italic>i</italic> = 1, …, <italic>r</italic> − 1, let <italic>v</italic><sub><italic>i</italic></sub> be the hybrid node that is a child of <italic>u</italic><sub><italic>i</italic></sub> and <italic>x</italic><sub><italic>i</italic></sub> the parent of <italic>v</italic><sub><italic>i</italic></sub> different from <italic>u</italic><sub><italic>i</italic></sub> (see <xref ref-type="fig" rid="pcbi.1007347.g005">Fig 5</xref>); recall that <italic>x</italic><sub><italic>i</italic></sub> does not belong to TH(<italic>ℓ</italic>) by the definition of a pre-TH-path. Since <italic>u</italic><sub>1</sub> is the root of <italic>N</italic>, every node of <italic>N</italic> either belongs to the path TH(<italic>ℓ</italic>) or is descendant of a node in {<italic>v</italic><sub><italic>i</italic></sub> ∣ <italic>i</italic> ∈ [<italic>r</italic> − 1]}. In particular, for each <italic>i</italic> ∈ [<italic>r</italic> − 1], there exists some <italic>σ</italic>(<italic>i</italic>) ∈ [<italic>r</italic> − 1] such that <italic>x</italic><sub><italic>i</italic></sub> is descendant of <italic>v</italic><sub><italic>σ</italic>(<italic>i</italic>)</sub>, and since this node is descendant of <italic>x</italic><sub><italic>σ</italic>(<italic>i</italic>)</sub>, <italic>x</italic><sub><italic>i</italic></sub> is descendant of <italic>x</italic><sub><italic>σ</italic>(<italic>i</italic>)</sub>. Hence, starting with <italic>x</italic><sub>1</sub> we get a sequence <italic>x</italic><sub>1</sub>, <italic>x</italic><sub><italic>σ</italic>(1)</sub>, <italic>x</italic><sub><italic>σ</italic>(<italic>σ</italic>(1))</sub>, … where each node in the sequence is a descendant of the following one. Since there is a finite number of nodes, at some point we find a repeated node, which means that <italic>N</italic> contains a cycle and hence we have a contradiction.■</p>
<fig id="pcbi.1007347.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g005</object-id>
<label>Fig 5</label>
<caption>
<title>The first node in a TH-path cannot be the root.</title>
<p>Illustration of the nodes involved in the proof of Lemma 1.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g005" xlink:type="simple"/>
</fig>
<p>We say that a leaf <italic>ℓ</italic> is of <italic>type</italic> <italic>T</italic> (resp. of <italic>type</italic> <italic>H</italic>) if the parent of TH(<italic>ℓ</italic>)<sub>1</sub> is a tree node (resp. a hybrid node). If <italic>ℓ</italic> is of type <italic>H</italic>, we indicate by <inline-formula id="pcbi.1007347.e007"><alternatives><graphic id="pcbi.1007347.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e007" xlink:type="simple"/><mml:math display="inline" id="M7"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> the path obtained by prepending to TH(<italic>ℓ</italic>) the parent of TH(<italic>ℓ</italic>)<sub>1</sub>. For convenience, we let <inline-formula id="pcbi.1007347.e008"><alternatives><graphic id="pcbi.1007347.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e008" xlink:type="simple"/><mml:math display="inline" id="M8"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo form="prefix">TH</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> if <italic>ℓ</italic> is of type <italic>T</italic>.</p>
<p><bold>Definition 1</bold>. Let <italic>ℓ</italic> be a leaf in a BTC network <italic>N</italic>. We define the <italic>reduction of N with respect to ℓ</italic> as the result of the following procedure (see Figs <xref ref-type="fig" rid="pcbi.1007347.g006">6</xref> and <xref ref-type="fig" rid="pcbi.1007347.g007">7</xref>):</p>
<list list-type="order">
<list-item>
<p>Delete all nodes in <inline-formula id="pcbi.1007347.e009"><alternatives><graphic id="pcbi.1007347.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e009" xlink:type="simple"/><mml:math display="inline" id="M9"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> (together with any arc incident on them).</p>
</list-item>
<list-item>
<p>Eliminate all elementary nodes.</p>
</list-item>
</list>
<fig id="pcbi.1007347.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Reduction operation of type <italic>T</italic>.</title>
<p>Depiction of the reduction operation <italic>T</italic>(<italic>N</italic>, <italic>ℓ</italic>). The nodes inside the dotted box form <inline-formula id="pcbi.1007347.e010"><alternatives><graphic id="pcbi.1007347.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and will be removed, which will create elementary nodes that will be substituted by arcs.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g006" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007347.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g007</object-id>
<label>Fig 7</label>
<caption>
<title>Reduction operation of type <italic>H</italic>.</title>
<p>Depiction of the reduction operation <italic>H</italic>(<italic>N</italic>, <italic>ℓ</italic>). The nodes inside the dotted box form <inline-formula id="pcbi.1007347.e011"><alternatives><graphic id="pcbi.1007347.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and will be removed, which will create elementary nodes that will be substituted by arcs.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g007" xlink:type="simple"/>
</fig>
<p>We indicate this reduction by <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>). If we want to emphasize the type of the deleted leaf, we indicate the reduction by <italic>T</italic>(<italic>N</italic>, <italic>ℓ</italic>) and say it is a <italic>T</italic>-reduction if <italic>ℓ</italic> is of type <italic>T</italic>, or by <italic>H</italic>(<italic>N</italic>, <italic>ℓ</italic>) and say that it is a <italic>H</italic>-reduction if <italic>ℓ</italic> is of type <italic>H</italic>.</p>
<p>To ease of reading, we shall introduce some notations that will be used hereafter and are also illustrated in Figs <xref ref-type="fig" rid="pcbi.1007347.g006">6</xref> and <xref ref-type="fig" rid="pcbi.1007347.g007">7</xref>:</p>
<p><bold>Definition 2</bold>. Let <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub> = <italic>ℓ</italic> be the path TH(<italic>ℓ</italic>) and let <italic>u</italic><sub>0</sub> be the first node in <inline-formula id="pcbi.1007347.e012"><alternatives><graphic id="pcbi.1007347.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e012" xlink:type="simple"/><mml:math display="inline" id="M12"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. For each <italic>i</italic> ∈ [<italic>r</italic> − 1], <italic>v</italic><sub><italic>i</italic></sub> is the hybrid child of <italic>u</italic><sub><italic>i</italic></sub>, <italic>x</italic><sub><italic>i</italic></sub> the parent of <italic>v</italic><sub><italic>i</italic></sub> different from <italic>u</italic><sub><italic>i</italic></sub>, and <italic>y</italic><sub><italic>i</italic></sub> the single child of <italic>v</italic><sub><italic>i</italic></sub>. The parent(s) of <italic>u</italic><sub>0</sub> is <italic>w</italic><sub>1</sub> (are <italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub>); the node <italic>w</italic><sub><italic>j</italic></sub> is always a tree node, <italic>z</italic><sub><italic>j</italic></sub> is its parent (if it exists, since <italic>w</italic><sub><italic>j</italic></sub> could be the root of <italic>N</italic>), and <italic>t</italic><sub><italic>j</italic></sub> its child different from <italic>u</italic><sub>0</sub>, where <italic>j</italic> = 1 for <italic>T</italic>-reductions and <italic>j</italic> ∈ [2] for <italic>H</italic>-reductions.</p>
<p><bold>Remark 1</bold>. Since <italic>N</italic> is tree-child, the nodes <italic>y</italic><sub><italic>i</italic></sub> are always tree nodes, and so are <italic>t</italic><sub>1</sub> and <italic>t</italic><sub>2</sub> in case of an <italic>H</italic>-reduction. In case of a <italic>T</italic>-reduction, by definition of a TH-path, <italic>t</italic><sub>1</sub> is either a tree node or coincides with one of the hybrid nodes <italic>v</italic><sub><italic>i</italic></sub>. Also, the removal of the arcs of the form (<italic>u</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>) and (<italic>w</italic><sub><italic>j</italic></sub>, <italic>u</italic><sub>0</sub>) makes nodes <italic>v</italic><sub><italic>i</italic></sub> and <italic>w</italic><sub><italic>j</italic></sub> elementary in <inline-formula id="pcbi.1007347.e013"><alternatives><graphic id="pcbi.1007347.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e013" xlink:type="simple"/><mml:math display="inline" id="M13"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <italic>i</italic> ∈ [<italic>r</italic> − 1], and <italic>j</italic> = 1 for <italic>T</italic>-reductions and <italic>j</italic> ∈ [2] for <italic>H</italic>-reductions. Since no other arc is removed, no other node can be elementary. In order to find the heirs of nodes <italic>v</italic><sub><italic>i</italic></sub> and <italic>w</italic><sub><italic>j</italic></sub>, we must analyse under which circumstances two of these elementary nodes are adjacent in <inline-formula id="pcbi.1007347.e014"><alternatives><graphic id="pcbi.1007347.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e014" xlink:type="simple"/><mml:math display="inline" id="M14"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<list list-type="order">
<list-item>
<p>If we had that two nodes <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub> were connected by an arc in <inline-formula id="pcbi.1007347.e015"><alternatives><graphic id="pcbi.1007347.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e015" xlink:type="simple"/><mml:math display="inline" id="M15"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, then the single child of a hybrid node in <italic>N</italic> would be also a hybrid. This contradicts the fact that <italic>N</italic> is tree-child.</p>
</list-item>
<list-item>
<p>The existence of an arc (<italic>v</italic><sub><italic>i</italic></sub>, <italic>w</italic><sub><italic>j</italic></sub>) would imply the existence of a cycle in <italic>N</italic>, which is impossible.</p>
</list-item>
<list-item>
<p>Consider now the case of an arc (<italic>w</italic><sub><italic>j</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>). In case of an <italic>H</italic>-reduction, it would imply that both children of <italic>w</italic><sub><italic>j</italic></sub> are hybrid nodes, which is impossible. However, such an arc can be present in a <italic>T</italic>-reduction: when <italic>t</italic><sub>1</sub> is equal to <italic>v</italic><sub><italic>i</italic></sub>. In this last case, <italic>w</italic><sub>1</sub> and <italic>v</italic><sub><italic>i</italic></sub> form an elementary path in <inline-formula id="pcbi.1007347.e016"><alternatives><graphic id="pcbi.1007347.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e016" xlink:type="simple"/><mml:math display="inline" id="M16"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and their common heir is <italic>y</italic><sub><italic>i</italic></sub> (see <xref ref-type="fig" rid="pcbi.1007347.g008">Fig 8</xref>).</p>
</list-item>
<list-item>
<p>Finally, in case of an <italic>H</italic>-reduction, it can exist an arc between <italic>w</italic><sub>1</sub> and <italic>w</italic><sub>2</sub>, say that the arc is (<italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub>) (which implies, <italic>t</italic><sub>1</sub> = <italic>w</italic><sub>2</sub>, <italic>z</italic><sub>2</sub> = <italic>w</italic><sub>1</sub>). In this case, <italic>w</italic><sub>1</sub> and <italic>w</italic><sub>2</sub> form an elementary path in <inline-formula id="pcbi.1007347.e017"><alternatives><graphic id="pcbi.1007347.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e017" xlink:type="simple"/><mml:math display="inline" id="M17"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and their common heir is <italic>t</italic><sub>2</sub> (see <xref ref-type="fig" rid="pcbi.1007347.g009">Fig 9</xref>).</p>
</list-item>
</list>
<fig id="pcbi.1007347.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g008</object-id>
<label>Fig 8</label>
<caption>
<title>Reduction operation of type <italic>T</italic> (particular case).</title>
<p>Particular case of the reduction operation of type <italic>T</italic> when <italic>t</italic><sub>1</sub> = <italic>v</italic><sub><italic>i</italic></sub> for some <italic>i</italic> ∈ [<italic>r</italic> − 1].</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g008" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007347.g009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g009</object-id>
<label>Fig 9</label>
<caption>
<title>Reduction operation of type <italic>H</italic> (particular case).</title>
<p>Particular case of the reduction operation of type <italic>H</italic> when <italic>w</italic><sub>1</sub> and <italic>w</italic><sub>2</sub> are linked by an arc.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g009" xlink:type="simple"/>
</fig>
<p>In all other cases, the elementary nodes <italic>v</italic><sub><italic>i</italic></sub> and <italic>w</italic><sub><italic>j</italic></sub> are isolated, and their respective heirs are <italic>y</italic><sub><italic>i</italic></sub> and <italic>t</italic><sub><italic>j</italic></sub>.</p>
<p>We study now what we call the <italic>recovering data</italic> of a reduction. This information will be used in the next subsection to recover the original network from its reduction.</p>
<p><bold>Definition 3</bold>. The <italic>recovering data</italic> of the reduction <italic>N</italic>′ = <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) is the pair (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>), where:</p>
<list list-type="bullet">
<list-item>
<p><italic>S</italic><sub>1</sub> is the multiset of the nodes of <italic>N</italic>′ that are heirs of the nodes <italic>w</italic><sub><italic>j</italic></sub>. The cardinality of <italic>S</italic><sub>1</sub> (as a multiset) is either 1 or 2, depending on the type of the reduction, and will be denoted by |<italic>S</italic><sub>1</sub>|.</p>
</list-item>
<list-item>
<p><italic>S</italic><sub>2</sub> is the tuple (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) of nodes of <italic>N</italic>′, which are the heirs of the nodes <italic>v</italic><sub><italic>i</italic></sub>. This tuple could be empty, corresponding to the case <italic>r</italic> = 1.</p>
</list-item>
</list>
<p>We introduce now a set of conditions on multisets and tuples of nodes, and prove that the recovering data associated to any of the defined reductions satisfies them.</p>
<p><bold>Definition 4</bold>. Given a BTC network <italic>N</italic>′ and a pair (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) with</p>
<list list-type="bullet">
<list-item>
<p><italic>S</italic><sub>1</sub> a multiset of tree nodes of <italic>N</italic>′,</p>
</list-item>
<list-item>
<p><italic>S</italic><sub>2</sub> = (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>), with <italic>r</italic> ≥ 1, a (potentially empty) tuple of <italic>r</italic> − 1 tree nodes of <italic>N</italic>′,</p>
</list-item>
</list>
<p specific-use="continuation">consider the following set of conditions:</p>
<list list-type="simple">
<list-item>
<label>1</label>
<p>For every <italic>i</italic>, <italic>j</italic> ∈ [<italic>r</italic> − 1] with <italic>i</italic> ≠ <italic>j</italic>, the nodes <italic>y</italic><sub><italic>i</italic></sub> and <italic>y</italic><sub><italic>j</italic></sub> are different, and if they are siblings, then <italic>y</italic><sub><italic>i</italic></sub> ∈ <italic>S</italic><sub>1</sub> or <italic>y</italic><sub><italic>j</italic></sub> ∈ <italic>S</italic><sub>1</sub>.</p>
</list-item>
<list-item>
<label>2</label>
<p>For every <italic>i</italic> ∈ [<italic>r</italic> − 1], if <italic>y</italic><sub><italic>i</italic></sub> is the child of a hybrid node or has a hybrid sibling, then <italic>y</italic><sub><italic>i</italic></sub> ∈ <italic>S</italic><sub>1</sub>.</p>
</list-item>
<list-item>
<label>3</label>
<p>No node in <italic>S</italic><sub>1</sub> is a proper descendant of any node in <italic>S</italic><sub>2</sub>.</p>
</list-item>
<list-item>
<label>4T</label>
<p>|<italic>S</italic><sub>1</sub>| = 1.</p>
</list-item>
<list-item>
<label>4H</label>
<p>|<italic>S</italic><sub>2</sub>| = 2 and no node of <italic>S</italic><sub>1</sub> appears in <italic>S</italic><sub>2</sub>.</p>
</list-item>
</list>
<p>We say that (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) is <italic>T-feasible</italic> if it satisfies conditions 1, 2, 3, and 4T, and <italic>H-feasible</italic> if it satisfies conditions 1, 2, 3, and 4H. Finally, we say that (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) is <italic>feasible</italic> if it is either <italic>T</italic>-feasible or <italic>H</italic>-feasible.</p>
<p><bold>Proposition 2</bold>. <italic>Let N</italic>′ = <italic>T</italic>(<italic>N</italic>, <italic>ℓ</italic>) <italic>be a T-reduction of a BTC network N. Then, its recovering data</italic> ({<italic>τ</italic><sub>1</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) <italic>is T-feasible</italic>.</p>
<p><italic>Proof</italic>. First, note that, by Remark 1, all nodes in ({<italic>τ</italic><sub>1</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) are tree nodes and that Condition 4T holds trivially. Note also that <italic>τ</italic><sub>1</sub> is equal to <italic>y</italic><sub><italic>i</italic></sub> if <italic>t</italic><sub>1</sub> = <italic>v</italic><sub><italic>i</italic></sub>, or to <italic>t</italic><sub>1</sub> if this node is different from all the nodes <italic>v</italic><sub><italic>i</italic></sub>. We now prove that Conditions 1, 2 and 3 hold:</p>
<list list-type="order">
<list-item>
<p>If <italic>y</italic><sub><italic>i</italic></sub> = <italic>y</italic><sub><italic>j</italic></sub>, then in <italic>N</italic> we have <italic>v</italic><sub><italic>i</italic></sub> = <italic>v</italic><sub><italic>j</italic></sub>, which is impossible by definition of TH-path. If <italic>y</italic><sub><italic>i</italic></sub> and <italic>y</italic><sub><italic>j</italic></sub> are siblings in <italic>N</italic>′ but none of these nodes is equal to <italic>τ</italic><sub>1</sub>, then <italic>v</italic><sub><italic>i</italic></sub> and <italic>v</italic><sub><italic>j</italic></sub> are siblings in <italic>N</italic>, which implies that their common parent has two hybrid children, which is impossible in a BTC network.</p>
</list-item>
<list-item>
<p>If <italic>y</italic><sub><italic>i</italic></sub> is the child in <italic>N</italic>′ of a hybrid node and <italic>τ</italic><sub>1</sub> ≠ <italic>y</italic><sub><italic>i</italic></sub>, then in <italic>N</italic> we have that <italic>v</italic><sub><italic>i</italic></sub>, which is a hybrid node, is the child of a hybrid node, which is impossible in a tree-child network. Analogously, if <italic>y</italic><sub><italic>i</italic></sub> has a sibling in <italic>N</italic>′ which is a hybrid node, and <italic>y</italic><sub><italic>i</italic></sub> ≠ <italic>τ</italic><sub>1</sub>, then in <italic>N</italic> we have that <italic>v</italic><sub><italic>i</italic></sub> is sibling of another hybrid node, which is again impossible.</p>
</list-item>
<list-item>
<p>The existence of a non-trivial path in <italic>N</italic>′ from <italic>y</italic><sub><italic>i</italic></sub> to <italic>τ</italic><sub>1</sub> would, by construction, imply the existence of a path from <italic>y</italic><sub><italic>i</italic></sub> to <italic>w</italic><sub>1</sub> in <italic>N</italic>. Since there exists also a path in <italic>N</italic> from <italic>w</italic><sub>1</sub> to <italic>y</italic><sub><italic>i</italic></sub>, this would contradict the fact that <italic>N</italic> is a DAG.■</p>
</list-item>
</list>
<p><bold>Proposition 3</bold>. <italic>Let N</italic>′ = <italic>H</italic>(<italic>N</italic>, <italic>ℓ</italic>) <italic>be an H-reduction of a BTC network N. Then, its recovering data</italic> ({<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) <italic>is H-feasible</italic>.</p>
<p><italic>Proof</italic>. Again we have, by Remark 1, that all nodes in the recovering data are tree nodes. Additionally, by the same remark, we have that |<italic>S</italic><sub>1</sub>| = 2 –and hence the first part of Condition 4H holds– and if (<italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub>) is an arc of <italic>N</italic>, then <italic>S</italic><sub>1</sub> = {<italic>t</italic><sub>2</sub>, <italic>t</italic><sub>2</sub>}, otherwise <italic>S</italic><sub>1</sub> = {<italic>t</italic><sub>1</sub>, <italic>t</italic><sub>2</sub>} with <italic>t</italic><sub>1</sub> ≠ <italic>t</italic><sub>2</sub>. Note that Condition 3 implies that Conditions 1 and 2 can be simplified as follows: for all <italic>i</italic>, <italic>j</italic> ∈ [<italic>r</italic> − 1] with <italic>i</italic> ≠ <italic>j</italic>, <italic>y</italic><sub><italic>i</italic></sub> and <italic>y</italic><sub><italic>j</italic></sub> are neither equal nor siblings, and for all <italic>i</italic> ∈ [<italic>r</italic> − 1], <italic>y</italic><sub><italic>i</italic></sub> is neither the child nor the sibling of a hybrid node.</p>
<p>Conditions 1 and Conditions 2 and 3 in their simplified form follow using the same arguments as in the previous proposition. As for the condition 4H, the nodes <italic>τ</italic><sub>1</sub> and <italic>τ</italic><sub>2</sub> are different from the nodes <italic>y</italic><sub><italic>i</italic></sub> since the parents of <italic>τ</italic><sub>1</sub> and <italic>τ</italic><sub>2</sub> in <italic>N</italic> are tree nodes, while the parent of each of the nodes <italic>y</italic><sub><italic>i</italic></sub> is hybrid.■</p>
<p>The following proposition is the main result of this subsection, since it shows that the reduction that we have defined, when applied to a BTC network, gives another BTC network with one leaf less. Hence, successive applications of these reductions reduce any BTC network to the trivial BTC network.</p>
<p><bold>Proposition 4</bold>. <italic>Let N be a BTC network over X and ℓ one of its leaves. Then, R</italic>(<italic>N</italic>, <italic>ℓ</italic>) <italic>is a BTC network over X</italic> \ {<italic>ℓ</italic>}.</p>
<p><italic>Proof</italic>. First, it is easy to see that, since no new path is added, the resulting directed graph is still acyclic.</p>
<p>Then, we need to check that <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) is binary. To do so, we start noting that every node in <inline-formula id="pcbi.1007347.e018"><alternatives><graphic id="pcbi.1007347.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e018" xlink:type="simple"/><mml:math display="inline" id="M18"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is either a tree node, a hybrid node, or an elementary node. Indeed, the removal of <inline-formula id="pcbi.1007347.e019"><alternatives><graphic id="pcbi.1007347.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e019" xlink:type="simple"/><mml:math display="inline" id="M19"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> (Phase 1 of Definition 1) only affects the nodes adjacent to this path, that is the nodes <italic>v</italic><sub><italic>i</italic></sub> and <italic>w</italic><sub><italic>i</italic></sub>, which, as shown in Remark 1, become elementary. The elimination of all elementary nodes (Phase 2 of Definition 1) does not affect the indegree and outdegree of any other node, apart when the root <italic>ρ</italic> of <inline-formula id="pcbi.1007347.e020"><alternatives><graphic id="pcbi.1007347.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e020" xlink:type="simple"/><mml:math display="inline" id="M20"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is elementary. In such a case, the heir of <italic>ρ</italic> becomes the new root. Hence, <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) is binary and rooted.</p>
<p>Note also that the set of leaves of <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) is <italic>X</italic> \ {<italic>ℓ</italic>}, since in <inline-formula id="pcbi.1007347.e021"><alternatives><graphic id="pcbi.1007347.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e021" xlink:type="simple"/><mml:math display="inline" id="M21"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>\</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> no node becomes a leaf and the only leaf that is removed is <italic>ℓ</italic>.</p>
<p>Finally, we need to prove that <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) is tree-child. Note that, from what we have just said about how the reduction affects indegrees and outdegrees of the nodes that persist in the network, it follows that each hybrid node of <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) is also a hybrid node of <italic>N</italic>, and that its parents in <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) are the same as in <italic>N</italic>. It follows that no node in <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>) can have that all its children are hybrid, since this would imply that <italic>N</italic> is not tree-child, a contradiction.■</p>
<p><bold>Corollary 5</bold>. <italic>Let</italic> <inline-formula id="pcbi.1007347.e022"><alternatives><graphic id="pcbi.1007347.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e022" xlink:type="simple"/><mml:math display="inline" id="M22"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>∈</mml:mo> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> <italic>be a BTC network over</italic> [<italic>n</italic>]. <italic>Let N</italic><sub><italic>n</italic></sub> = <italic>N and define recursively N</italic><sub><italic>i</italic></sub> = <italic>R</italic>(<italic>N</italic><sub><italic>i</italic>+1</sub>, <italic>i</italic> + 1) <italic>for each i</italic> = <italic>n</italic> − 1, <italic>n</italic> − 2, …, 1. <italic>Then, N</italic><sub><italic>i</italic></sub> <italic>is a BTC network over</italic> [<italic>i</italic>]. <italic>In particular, N</italic><sub>1</sub> <italic>is the trivial BTC network with its single node labeled by</italic> 1.</p>
<p>We finish this subsection with the computation of the number of tree nodes and hybrid nodes that the reduced network has, both in terms of the original network and of the reduction operation that has been applied. But before, we give an absolute bound on the number of these nodes in terms of the number of leaves.</p>
<p><bold>Lemma 6</bold>. <italic>Let N be BTC network over</italic> [<italic>n</italic>] <italic>with t tree nodes and h hybrid nodes. Then t</italic> − <italic>h</italic> = 2<italic>n</italic> − 1, <italic>h</italic> ≤ <italic>n</italic> − 1 <italic>and t</italic> ≤ 3<italic>n</italic> − 2.</p>
<p><italic>Proof</italic>. The equality <italic>t</italic> − <italic>h</italic> = 2<italic>n</italic> − 1 follows easily from the handshake lemma taking into account the number of roots, internal tree nodes, leaves and hybrid nodes in <italic>N</italic>, and their respective indegrees and outdegrees. The inequality <italic>h</italic> ≤ <italic>n</italic> − 1 is shown in Proposition 1 in [<xref ref-type="bibr" rid="pcbi.1007347.ref009">9</xref>], and the last inequality is a simple consequence of the equality and the inequality already proved.■</p>
<p><bold>Proposition 7</bold>. <italic>Let N be a BTC network and ℓ one of its leaves, and N</italic>′ = <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>). <italic>Let t, h (resp. t′, h′) be the number of tree nodes and hybrid nodes of N (resp. of N′). Then</italic> <disp-formula id="pcbi.1007347.e023"><alternatives><graphic id="pcbi.1007347.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e023" xlink:type="simple"/><mml:math display="block" id="M23"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mrow><mml:mo>=</mml:mo> <mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mo>|</mml:mo></mml:mrow> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>|</mml:mo> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mspace width="2.em"/></mml:mrow> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mrow><mml:mo>|</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>|</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula> <italic>where</italic> <inline-formula id="pcbi.1007347.e024"><alternatives><graphic id="pcbi.1007347.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e024" xlink:type="simple"/><mml:math display="inline" id="M24"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> <italic>is the number of nodes in</italic> <inline-formula id="pcbi.1007347.e025"><alternatives><graphic id="pcbi.1007347.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e025" xlink:type="simple"/><mml:math display="inline" id="M25"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<p><italic>Proof</italic>. Since the number of tree nodes and hybrid nodes are linked by the equality in Lemma 6, it is enough to prove that <inline-formula id="pcbi.1007347.e026"><alternatives><graphic id="pcbi.1007347.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e026" xlink:type="simple"/><mml:math display="inline" id="M26"><mml:mrow><mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mrow><mml:mo>|</mml:mo> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>|</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>. From the discussion in Remark 1, it is straightforward to see that the number of hybrid nodes in <italic>N</italic> that are not in <italic>N</italic>′ is <italic>r</italic> − 1 if <italic>ℓ</italic> is of kind <italic>T</italic>, and <italic>r</italic> otherwise. Hence, in both cases we have <inline-formula id="pcbi.1007347.e027"><alternatives><graphic id="pcbi.1007347.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e027" xlink:type="simple"/><mml:math display="inline" id="M27"><mml:mrow><mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>|</mml:mo></mml:mrow> <mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>|</mml:mo> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and the result follows.■</p>
</sec>
<sec id="sec005">
<title>Generation of networks</title>
<p>In this subsection, we consider the problem of how to revert the reductions defined in the previous subsection, taking as input the reduced network and its recovering data. This will allow us to define a procedure that, starting with the trivial BTC network with one leaf, generates all the BTC networks with any number of leaves in a unique way.</p>
<p>We start by defining two augmentation procedures that take as input a BTC network and a feasible pair, and produce a BTC network with one leaf more.</p>
<p><bold>Definition 5</bold>. Let <italic>N</italic> be a BTC network over <italic>X</italic>, <italic>ℓ</italic> a label not in <italic>X</italic>, and ({<italic>τ</italic><sub>1</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) a <italic>T</italic>-feasible pair. We apply the following operations to <italic>N</italic> (see <xref ref-type="fig" rid="pcbi.1007347.g010">Fig 10</xref>):</p>
<list list-type="order">
<list-item>
<p>Create a path of new nodes <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub>.</p>
</list-item>
<list-item>
<p>Split the node <italic>τ</italic><sub>1</sub> creating one elementary node <italic>w</italic><sub>1</sub> and add an arc (<italic>w</italic><sub>1</sub>, <italic>u</italic><sub>1</sub>).</p>
</list-item>
<list-item>
<p>For each node <italic>y</italic><sub><italic>i</italic></sub>, split it introducing one elementary node <italic>v</italic><sub><italic>i</italic></sub> and add an arc (<italic>u</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>).</p>
</list-item>
<list-item>
<p>Label the node <italic>u</italic><sub><italic>r</italic></sub> by <italic>ℓ</italic>.</p>
</list-item>
</list>
<fig id="pcbi.1007347.g010" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g010</object-id>
<label>Fig 10</label>
<caption>
<title>Augmentation operation of type <italic>T</italic>.</title>
<p>Depiction of the augmentation operation <italic>T</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; {<italic>τ</italic><sub>1</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) when <italic>τ</italic><sub>1</sub> ≠ <italic>y</italic><sub><italic>i</italic></sub> for all <italic>i</italic> ∈ [<italic>r</italic> − 1].</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g010" xlink:type="simple"/>
</fig>
<p>We denote by <italic>T</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; {<italic>τ</italic><sub>1</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) the resulting network and say that it has been obtained by an <italic>augmentation operation of type</italic> <italic>T</italic>.</p>
<p>Note that the order in which steps 2 and 3 are done is relevant in the case that <italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub> for some <italic>i</italic> ∈ [<italic>r</italic> − 1]. In such a case, two nodes <italic>w</italic><sub>1</sub> and <italic>v</italic><sub><italic>i</italic></sub> are created, linked by an arc (<italic>w</italic><sub>1</sub>, <italic>v</italic><sub><italic>i</italic></sub>) (see <xref ref-type="fig" rid="pcbi.1007347.g011">Fig 11</xref>).</p>
<fig id="pcbi.1007347.g011" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g011</object-id>
<label>Fig 11</label>
<caption>
<title>Augmentation operation of type <italic>T</italic> (particular case).</title>
<p>Depiction of the augmentation operation <italic>T</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; {<italic>τ</italic><sub>1</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) when <italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g011" xlink:type="simple"/>
</fig>
<p><bold>Proposition 8</bold>. <italic>Using the notations of Definition 5, the network</italic> <disp-formula id="pcbi.1007347.e028"><alternatives><graphic id="pcbi.1007347.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e028" xlink:type="simple"/><mml:math display="block" id="M28"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>T</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>;</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:msub><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula> <italic>is a BTC network over X</italic> ∪ {<italic>ℓ</italic>}. <italic>Moreover, if N has h hybrid nodes, then</italic> <inline-formula id="pcbi.1007347.e029"><alternatives><graphic id="pcbi.1007347.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e029" xlink:type="simple"/><mml:math display="inline" id="M29"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> <italic>has h</italic> + <italic>r</italic> − 1 <italic>hybrid nodes</italic>.</p>
<p><italic>Proof</italic>. We first check that the resulting directed graph is acyclic. Let us assume that <inline-formula id="pcbi.1007347.e030"><alternatives><graphic id="pcbi.1007347.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e030" xlink:type="simple"/><mml:math display="inline" id="M30"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> contains a cycle. If we define <italic>U</italic><sub>1</sub> = {<italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub>} and <inline-formula id="pcbi.1007347.e031"><alternatives><graphic id="pcbi.1007347.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e031" xlink:type="simple"/><mml:math display="inline" id="M31"><mml:mrow><mml:msub><mml:mi>U</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>=</mml:mo> <mml:mi>V</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>\</mml:mo> <mml:msub><mml:mi>U</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, we have that the only arcs connecting <italic>U</italic><sub>1</sub> with <italic>U</italic><sub>2</sub> are (<italic>u</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>) (with <italic>i</italic> = 1, …, <italic>r</italic> − 1), and (<italic>w</italic><sub>1</sub>, <italic>u</italic><sub>1</sub>) is the only arc connecting <italic>U</italic><sub>2</sub> with <italic>U</italic><sub>1</sub>. The cycle can be contained neither inside <italic>U</italic><sub>1</sub>, since these nodes are linked by a single path, nor inside <italic>U</italic><sub>2</sub>, since otherwise <italic>N</italic> would contain a cycle. Hence, the cycle must contain at least the arc (<italic>w</italic><sub>1</sub>, <italic>u</italic><sub>1</sub>) and an arc (<italic>u</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>). This implies the existence of a path from <italic>v</italic><sub><italic>i</italic></sub> to <italic>w</italic><sub>1</sub> visiting only nodes in <italic>U</italic><sub>2</sub>, which in turn means that <italic>N</italic> contains a path from <italic>y</italic><sub><italic>i</italic></sub> to <italic>τ</italic><sub>1</sub>, against Condition 3 of Definition 4.</p>
<p>Note that the nodes in <italic>U</italic><sub>1</sub> are tree nodes by construction. Also by construction, the node <italic>w</italic><sub>1</sub> is a tree node, the nodes <italic>v</italic><sub><italic>i</italic></sub> are hybrid nodes and <italic>u</italic><sub><italic>r</italic></sub> is a leaf which is labelled with <italic>ℓ</italic>. Finally, the other nodes keep the same degrees they had in <italic>N</italic> and hence <inline-formula id="pcbi.1007347.e032"><alternatives><graphic id="pcbi.1007347.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e032" xlink:type="simple"/><mml:math display="inline" id="M32"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is a binary phylogenetic network over <italic>X</italic> ∪ {<italic>ℓ</italic>} with <italic>h</italic> + <italic>r</italic> − 1 hybrid nodes.</p>
<p>Since <italic>N</italic> is tree-child, in order to check that <inline-formula id="pcbi.1007347.e033"><alternatives><graphic id="pcbi.1007347.e033g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e033" xlink:type="simple"/><mml:math display="inline" id="M33"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is also tree-child, we only need to check the newly added hybrid nodes, which are the parents of the nodes <italic>v</italic><sub><italic>i</italic></sub>.</p>
<p>Let us first consider the case that <italic>τ</italic><sub>1</sub> ≠ <italic>y</italic><sub><italic>i</italic></sub> for all <italic>i</italic> ∈ [<italic>r</italic> − 1]. For each node <italic>v</italic><sub><italic>i</italic></sub>, its parents are <italic>u</italic><sub><italic>i</italic></sub> and the parent <italic>x</italic><sub><italic>i</italic></sub> of <italic>y</italic><sub><italic>i</italic></sub> in <italic>N</italic>. The node <italic>u</italic><sub><italic>i</italic></sub> is by construction a tree node whose other child is <italic>u</italic><sub><italic>i</italic>+1</sub>, which, in turn, is a tree node. Since <italic>τ</italic><sub>1</sub> ≠ <italic>y</italic><sub><italic>i</italic></sub>, by Condition 2 of Definition 4, <italic>y</italic><sub><italic>i</italic></sub> can have neither a hybrid parent nor a hybrid sibling, and it cannot be a sibling of any other node <italic>y</italic><sub><italic>j</italic></sub> with <italic>j</italic> ∈ [<italic>r</italic> − 1]. This latter restriction implies that <italic>y</italic><sub><italic>i</italic></sub> has the same sibling <inline-formula id="pcbi.1007347.e034"><alternatives><graphic id="pcbi.1007347.e034g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e034" xlink:type="simple"/><mml:math display="inline" id="M34"><mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula> in <italic>N</italic> and <inline-formula id="pcbi.1007347.e035"><alternatives><graphic id="pcbi.1007347.e035g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e035" xlink:type="simple"/><mml:math display="inline" id="M35"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. Thus both <italic>x</italic><sub><italic>i</italic></sub> and <inline-formula id="pcbi.1007347.e036"><alternatives><graphic id="pcbi.1007347.e036g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e036" xlink:type="simple"/><mml:math display="inline" id="M36"><mml:msub><mml:mover accent="true"><mml:mi>x</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula> are not hybrid nodes, and the network is tree-child.</p>
<p>Let us now consider the case that <italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub> for a single choice of <italic>i</italic> ∈ [<italic>r</italic> − 1]. The hybrid node <italic>v</italic><sub><italic>i</italic></sub> in <inline-formula id="pcbi.1007347.e037"><alternatives><graphic id="pcbi.1007347.e037g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e037" xlink:type="simple"/><mml:math display="inline" id="M37"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> has as parents the nodes <italic>w</italic><sub>1</sub> and <italic>u</italic><sub><italic>i</italic></sub>, and these two nodes have as respective children <italic>u</italic><sub>1</sub> and <italic>u</italic><sub><italic>i</italic>+1</sub>, which are tree nodes. For each other node <italic>v</italic><sub><italic>j</italic></sub> with <italic>j</italic> ≠ <italic>i</italic> and such that <italic>y</italic><sub><italic>j</italic></sub> is a not sibling of <italic>y</italic><sub><italic>i</italic></sub>, the same argument as in the previous case proves that both parents of <italic>v</italic><sub><italic>j</italic></sub> have a tree child. If <italic>y</italic><sub><italic>j</italic></sub> is a sibling of <italic>y</italic><sub><italic>i</italic></sub>, it is easy to see that the parent of <italic>v</italic><sub><italic>j</italic></sub> is still tree-child since it has <italic>w</italic><sub>1</sub> as child.■</p>
<p><bold>Definition 6</bold>. Let <italic>N</italic> be a BTC network over <italic>X</italic>, <italic>ℓ</italic> a label not in <italic>X</italic>, and ({<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) a <italic>H</italic>-feasible pair. We apply the following operations to <italic>N</italic> (see <xref ref-type="fig" rid="pcbi.1007347.g012">Fig 12</xref>):</p>
<list list-type="order">
<list-item>
<p>Create a path of new nodes <italic>u</italic><sub>0</sub>, <italic>u</italic><sub>1</sub>, …, <italic>u</italic><sub><italic>r</italic></sub>.</p>
</list-item>
<list-item>
<p>Split each of the nodes <italic>τ</italic><sub><italic>i</italic></sub> introducing one elementary node <italic>w</italic><sub><italic>i</italic></sub> and add an arc from <italic>w</italic><sub><italic>i</italic></sub> to <italic>u</italic><sub>0</sub>. Note that, if <italic>τ</italic><sub>1</sub> = <italic>τ</italic><sub>2</sub>, two consecutive elementary nodes must be created (see <xref ref-type="fig" rid="pcbi.1007347.g013">Fig 13</xref> for this case).</p>
</list-item>
<list-item>
<p>For each node <italic>y</italic><sub><italic>i</italic></sub>, split it introducing one elementary node <italic>v</italic><sub><italic>i</italic></sub> and add an arc (<italic>u</italic><sub><italic>i</italic></sub>, <italic>v</italic><sub><italic>i</italic></sub>).</p>
</list-item>
<list-item>
<p>Label the node <italic>u</italic><sub><italic>r</italic></sub> by <italic>ℓ</italic>.</p>
</list-item>
</list>
<fig id="pcbi.1007347.g012" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g012</object-id>
<label>Fig 12</label>
<caption>
<title>Augmentation operation of type <italic>H</italic>.</title>
<p>Depiction of the augmentation operation <italic>H</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) when <italic>τ</italic><sub>1</sub> ≠ <italic>τ</italic><sub>2</sub>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g012" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007347.g013" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g013</object-id>
<label>Fig 13</label>
<caption>
<title>Augmentation operation of type <italic>H</italic> (particular case).</title>
<p>Depiction of the augmentation operation <italic>H</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) when <italic>τ</italic><sub>1</sub> = <italic>τ</italic><sub>2</sub>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g013" xlink:type="simple"/>
</fig>
<p>We denote by <italic>H</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>;{<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>}, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>)) the resulting network and say that it has been obtained by an augmentation operation of type <italic>H</italic>.</p>
<p><bold>Proposition 9</bold>. <italic>Using the notations of Definition 6, the network</italic> <disp-formula id="pcbi.1007347.e038"><alternatives><graphic id="pcbi.1007347.e038g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e038" xlink:type="simple"/><mml:math display="block" id="M38"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>H</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>;</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:msub><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>τ</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula> <italic>is a BTC network over X</italic> ∪ {<italic>ℓ</italic>}. <italic>If N has h hybrid nodes, then</italic> <inline-formula id="pcbi.1007347.e039"><alternatives><graphic id="pcbi.1007347.e039g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e039" xlink:type="simple"/><mml:math display="inline" id="M39"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> <italic>has h</italic> + <italic>r hybrid nodes</italic>.</p>
<p><italic>Proof</italic>. The proof is completely analogous to that of Proposition 8, taking into account that one extra hybrid node is created.■</p>
<p>Given a BTC network over <italic>X</italic>, a label <italic>ℓ</italic> ∉ <italic>X</italic> and a feasible pair (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>), in order to unify notations we define the augmented network <italic>R</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) as <italic>T</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>), if |<italic>S</italic><sub>1</sub>| = 1, and as <italic>H</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>), if |<italic>S</italic><sub>1</sub>| = 2. Also, we shall generically say that the <italic>offspring</italic> of a BTC network is the set of networks that can be obtained from it by means of augmentation operations.</p>
<p>Our next goal is to prove that different augmentation operations applied to a same BTC network or different BTC networks over the same set of taxa provide different networks. We start with the case of different networks.</p>
<p><bold>Proposition 10</bold>. <italic>Let</italic> <inline-formula id="pcbi.1007347.e040"><alternatives><graphic id="pcbi.1007347.e040g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e040" xlink:type="simple"/><mml:math display="inline" id="M40"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>and</italic> <inline-formula id="pcbi.1007347.e041"><alternatives><graphic id="pcbi.1007347.e041g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e041" xlink:type="simple"/><mml:math display="inline" id="M41"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>be two BTC networks, both obtained by one augmentation operation applied to two non-isomorphic BTC networks N</italic><sub>1</sub> <italic>and N</italic><sub>2</sub> <italic>over the same set of taxa X. Then</italic> <inline-formula id="pcbi.1007347.e042"><alternatives><graphic id="pcbi.1007347.e042g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e042" xlink:type="simple"/><mml:math display="inline" id="M42"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>and</italic> <inline-formula id="pcbi.1007347.e043"><alternatives><graphic id="pcbi.1007347.e043g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e043" xlink:type="simple"/><mml:math display="inline" id="M43"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>are not isomorphic</italic>.</p>
<p><italic>Proof</italic>. If <inline-formula id="pcbi.1007347.e044"><alternatives><graphic id="pcbi.1007347.e044g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e044" xlink:type="simple"/><mml:math display="inline" id="M44"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007347.e045"><alternatives><graphic id="pcbi.1007347.e045g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e045" xlink:type="simple"/><mml:math display="inline" id="M45"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> have different sets of labels, then it is clear that they are not isomorphic. We can therefore assume that both augmentation operations introduced the same new leaf <italic>ℓ</italic>. Suppose that <inline-formula id="pcbi.1007347.e046"><alternatives><graphic id="pcbi.1007347.e046g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e046" xlink:type="simple"/><mml:math display="inline" id="M46"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>≃</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. Then <inline-formula id="pcbi.1007347.e047"><alternatives><graphic id="pcbi.1007347.e047g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e047" xlink:type="simple"/><mml:math display="inline" id="M47"><mml:mrow><mml:mi>R</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≃</mml:mo> <mml:mi>R</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. Now, from the definitions of the reductions and augmentations it is straightforward to check that <inline-formula id="pcbi.1007347.e048"><alternatives><graphic id="pcbi.1007347.e048g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e048" xlink:type="simple"/><mml:math display="inline" id="M48"><mml:mrow><mml:mi>R</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>N</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> and we get that <italic>N</italic><sub>1</sub> ≃ <italic>N</italic><sub>2</sub>, a contradiction.■</p>
<p>We treat now the case of applying different augmentation operations to the same BTC network. But first, we give a technical lemma that will be useful in the proof of the proposition.</p>
<p><bold>Lemma 11</bold>. <italic>Let N be a BTC network. Then, the identity is the only automorphism (as a leaf-labeled directed graph) of N</italic>.</p>
<p><italic>Proof</italic>. Let <italic>ϕ</italic> be any automorphism of <italic>N</italic>. Since <italic>ϕ</italic> is an automorphism of directed graphs and sends each leaf to itself, it follows that <italic>μ</italic>(<italic>u</italic>) = <italic>μ</italic>(<italic>ϕ</italic>(<italic>u</italic>)) for each node <italic>u</italic> of <italic>N</italic>, where <italic>μ</italic>(<italic>u</italic>) is the <italic>μ</italic>-vector of <italic>u</italic> as defined in [<xref ref-type="bibr" rid="pcbi.1007347.ref009">9</xref>]. Then, by [<xref ref-type="bibr" rid="pcbi.1007347.ref009">9</xref>, Lemma 5c], it follows that <italic>u</italic> and <italic>ϕ</italic>(<italic>u</italic>) are either equal, or one of them is the single child of the other one; according to our definition of BTC networks, this last possibility implies that one of them is a hybrid node and the other one is a tree node, which is impossible if <italic>ϕ</italic> is an automorphism. Hence <italic>ϕ</italic>(<italic>u</italic>) = <italic>u</italic> for every node <italic>u</italic>.■</p>
<p><bold>Proposition 12</bold>. <italic>Let</italic> <inline-formula id="pcbi.1007347.e049"><alternatives><graphic id="pcbi.1007347.e049g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e049" xlink:type="simple"/><mml:math display="inline" id="M49"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>and</italic> <inline-formula id="pcbi.1007347.e050"><alternatives><graphic id="pcbi.1007347.e050g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e050" xlink:type="simple"/><mml:math display="inline" id="M50"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>be two BTC networks, both obtained by one augmentation operation applied to the same BTC network N. If either the kinds of operation or the feasible pairs used to construct</italic> <inline-formula id="pcbi.1007347.e051"><alternatives><graphic id="pcbi.1007347.e051g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e051" xlink:type="simple"/><mml:math display="inline" id="M51"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>and</italic> <inline-formula id="pcbi.1007347.e052"><alternatives><graphic id="pcbi.1007347.e052g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e052" xlink:type="simple"/><mml:math display="inline" id="M52"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>are different, then</italic> <inline-formula id="pcbi.1007347.e053"><alternatives><graphic id="pcbi.1007347.e053g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e053" xlink:type="simple"/><mml:math display="inline" id="M53"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>and</italic> <inline-formula id="pcbi.1007347.e054"><alternatives><graphic id="pcbi.1007347.e054g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e054" xlink:type="simple"/><mml:math display="inline" id="M54"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> <italic>are not isomorphic</italic>.</p>
<p><italic>Proof</italic>. Let us assume that <inline-formula id="pcbi.1007347.e055"><alternatives><graphic id="pcbi.1007347.e055g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e055" xlink:type="simple"/><mml:math display="inline" id="M55"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007347.e056"><alternatives><graphic id="pcbi.1007347.e056g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e056" xlink:type="simple"/><mml:math display="inline" id="M56"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> are isomorphic. Then, it is clear that they have the same set of labels, and exactly one of them, say <italic>ℓ</italic>, is not a label of <italic>N</italic>. Since <inline-formula id="pcbi.1007347.e057"><alternatives><graphic id="pcbi.1007347.e057g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e057" xlink:type="simple"/><mml:math display="inline" id="M57"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007347.e058"><alternatives><graphic id="pcbi.1007347.e058g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e058" xlink:type="simple"/><mml:math display="inline" id="M58"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> are isomorphic, the kind of <italic>ℓ</italic> is the same in both networks, which implies that the kind of augmentation operations used to construct <inline-formula id="pcbi.1007347.e059"><alternatives><graphic id="pcbi.1007347.e059g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e059" xlink:type="simple"/><mml:math display="inline" id="M59"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007347.e060"><alternatives><graphic id="pcbi.1007347.e060g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e060" xlink:type="simple"/><mml:math display="inline" id="M60"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> are the same. Also, since <inline-formula id="pcbi.1007347.e061"><alternatives><graphic id="pcbi.1007347.e061g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e061" xlink:type="simple"/><mml:math display="inline" id="M61"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007347.e062"><alternatives><graphic id="pcbi.1007347.e062g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e062" xlink:type="simple"/><mml:math display="inline" id="M62"><mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub></mml:math></alternatives></inline-formula> are isomorphic, the nodes in the respective recovering data of the reductions <inline-formula id="pcbi.1007347.e063"><alternatives><graphic id="pcbi.1007347.e063g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e063" xlink:type="simple"/><mml:math display="inline" id="M63"><mml:mrow><mml:mi>R</mml:mi> <mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> must be linked by an isomorphism of phylogenetic networks. Therefore, and since by Lemma 11 BTC networks do not have a nontrivial automorphism, the respective recovering data must be equal.■</p>
<p>The following proposition shows that the reduction procedure defined in the previous subsection can be reverted using the augmentation operations presented in this subsection.</p>
<p><bold>Proposition 13</bold>. <italic>Let N be a BTC network and ℓ a leaf of N. Let N</italic>′ = <italic>R</italic>(<italic>N</italic>, <italic>ℓ</italic>), (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) <italic>its recovering data, and</italic> <inline-formula id="pcbi.1007347.e064"><alternatives><graphic id="pcbi.1007347.e064g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e064" xlink:type="simple"/><mml:math display="inline" id="M64"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>R</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>N</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>;</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. <italic>Then, N and</italic> <inline-formula id="pcbi.1007347.e065"><alternatives><graphic id="pcbi.1007347.e065g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e065" xlink:type="simple"/><mml:math display="inline" id="M65"><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover></mml:math></alternatives></inline-formula> <italic>are isomorphic</italic>.</p>
<p><italic>Proof</italic>. It is straightforward to see that the operations <italic>T</italic><sup>−1</sup> and <italic>H</italic><sup>−1</sup> reverse the effects of <italic>T</italic> and <italic>H</italic>, respectively. The only points worthy of attention correspond to the cases where the single node in <italic>S</italic><sub>1</sub> appears in <italic>S</italic><sub>2</sub> (for reductions/augmentations of type <italic>T</italic>) or where there is a single node in <italic>S</italic><sub>1</sub> with multiplicity two (for reductions/augmentations of type <italic>H</italic>). In the first case, the augmentation process creates two elementary nodes, <italic>w</italic><sub>1</sub> and <italic>v</italic><sub><italic>i</italic></sub>, connected by an arc (<italic>w</italic><sub>1</sub>, <italic>v</italic><sub><italic>i</italic></sub>), which is the same situation as in <italic>N</italic> after the removal of the nodes in <inline-formula id="pcbi.1007347.e066"><alternatives><graphic id="pcbi.1007347.e066g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e066" xlink:type="simple"/><mml:math display="inline" id="M66"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. In the second case, two elementary nodes <italic>τ</italic><sub>1</sub> and <italic>τ</italic><sub>2</sub> are created, connected by an arc, once again the same situation as in <italic>N</italic> after the removal of the nodes in <inline-formula id="pcbi.1007347.e067"><alternatives><graphic id="pcbi.1007347.e067g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e067" xlink:type="simple"/><mml:math display="inline" id="M67"><mml:mrow><mml:mover><mml:mo form="prefix">TH</mml:mo> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.■</p>
<p>A direct consequence of the results in this subsection is the following theorem, which can be used to generate in an effective way all BTC networks over a set of taxa. See <xref ref-type="fig" rid="pcbi.1007347.g014">Fig 14</xref> for an example.</p>
<fig id="pcbi.1007347.g014" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g014</object-id>
<label>Fig 14</label>
<caption>
<title>Construction of a BTC network.</title>
<p>Example of a chain of augmentation operations that generate a BTC network.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g014" xlink:type="simple"/>
</fig>
<p><bold>Theorem 14</bold>. <italic>Let</italic> <inline-formula id="pcbi.1007347.e068"><alternatives><graphic id="pcbi.1007347.e068g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e068" xlink:type="simple"/><mml:math display="inline" id="M68"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>∈</mml:mo> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> <italic>be a BTC network over</italic> [<italic>n</italic>]. <italic>Then, N can be constructed from the trivial network in</italic> <inline-formula id="pcbi.1007347.e069"><alternatives><graphic id="pcbi.1007347.e069g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e069" xlink:type="simple"/><mml:math display="inline" id="M69"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mn>1</mml:mn></mml:msub></mml:math></alternatives></inline-formula> (<italic>with one node labeled by</italic> 1) <italic>by application of n</italic> − 1 <italic>augmentation operations, where at each step i, the leaf i</italic> + 1 <italic>is added. Moreover, these augmentation operations are unique</italic>.</p>
<p><italic>Proof</italic>. The existence is a direct consequence of Corollary 5 and Proposition 13. Unicity comes from Propositions 10 and 12.■</p>
<p>It should be noted that very recently, other methods to generate all BTC networks over a set of taxa have been proposed [<xref ref-type="bibr" rid="pcbi.1007347.ref005">5</xref>], but, to our knowledge, this is the first time that the networks are generated with unicity. In previous attempts, an isomorphism check was needed after the generation phase.</p>
</sec>
<sec id="sec006">
<title>Bounding the number of networks</title>
<p>In this subsection, we shall first give bounds for the number of BTC networks that can be obtained from a given one by means of augmentation operations. This will be done by bounding the number of feasible pairs in such a network. Then, we shall find bounds for the number of BTC networks with a fixed number <italic>n</italic> of leaves.</p>
<p>Let <italic>N</italic> be a BTC network over [<italic>n</italic>] with <italic>h</italic> hybrid nodes. From Lemma 6 we know that it has <italic>t</italic> = 2<italic>n</italic> + <italic>h</italic> − 1 tree nodes, and that <italic>h</italic> ≤ <italic>n</italic> − 1 and <italic>t</italic> ≤ 3<italic>n</italic> − 2. In the following, we shall show how to compute the number of pairs (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) satisfying all conditions of Definition 4, except for Condition 3, via an auxiliary problem. Note that this will only give an upper bound for the number of networks, since the pairs we find can produce networks with cycles.</p>
<sec id="sec007">
<title>An auxiliary problem</title>
<p>Let <italic>P</italic>(<italic>N</italic>, <italic>k</italic>) be the set of tuples of length <italic>k</italic> of tree nodes of <italic>N</italic> such that (1) no pair of them are equal or siblings, and (2) none of them has a hybrid parent or sibling. We indicate the number of such tuples as <italic>p</italic>(<italic>N</italic>, <italic>k</italic>) = |<italic>P</italic>(<italic>N</italic>, <italic>k</italic>)|, and since this number will only depend on <italic>n</italic>, <italic>h</italic> and <italic>k</italic>, we indicate it also by <italic>p</italic>(<italic>n</italic>, <italic>h</italic>, <italic>k</italic>). We consider the problem of computing <italic>p</italic>(<italic>n</italic>, <italic>h</italic>, <italic>k</italic>).</p>
<p>We compute first how many tree nodes are there that neither have a hybrid parent nor a hybrid sibling. Since the single child of a hybrid node must be a tree node, there are <italic>h</italic> tree nodes that have a hybrid parent. Note that each hybrid node has two siblings that must be tree nodes; also, a tree node cannot be sibling of two different hybrid nodes; hence, there are 2<italic>h</italic> tree nodes that have a hybrid sibling. Since there cannot be a tree node having the two properties (if it has a hybrid parent, then it does not have any hybrid sibling), there are 3<italic>h</italic> tree nodes that are either a child or a sibling of a hybrid node. Then, the number of tree nodes that neither have a hybrid parent nor a hybrid sibling is <italic>t</italic> − 3<italic>h</italic> = 2<italic>n</italic> − 2<italic>h</italic> − 1. Note that this set of nodes is composed by the root of the network and pairs of tree nodes that are siblings.</p>
<p>Consider now the problem of counting the number of tuples (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic></sub>) in this set that are neither equal nor siblings. We distinguish two cases:</p>
<list list-type="bullet">
<list-item>
<p>If none of the nodes <italic>y</italic><sub><italic>i</italic></sub> is the root of <italic>N</italic>, we start having 2<italic>n</italic> − 2<italic>h</italic> − 2 choices for <italic>y</italic><sub>1</sub>, and at each stage the number of choices decreases by two units. Hence, the number of choices is
<disp-formula id="pcbi.1007347.e070"><alternatives><graphic id="pcbi.1007347.e070g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e070" xlink:type="simple"/><mml:math display="block" id="M70"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>p</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>4</mml:mn> <mml:mo>)</mml:mo> <mml:mo>⋯</mml:mo> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msup><mml:mn>2</mml:mn> <mml:mi>k</mml:mi></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>⋯</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msup><mml:mn>2</mml:mn> <mml:mi>k</mml:mi></mml:msup> <mml:mfrac><mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</list-item>
<list-item>
<p>If one of the nodes <italic>y</italic><sub><italic>i</italic></sub> is the root of <italic>N</italic>, then the process of constructing an element in <italic>P</italic>(<italic>N</italic>, <italic>k</italic>) can be described as first choosing at which position <italic>i</italic> one puts the root, and then filling in the remaining <italic>k</italic> − 1 positions with a tuple of the set <italic>P</italic>(<italic>N</italic>, <italic>k</italic> − 1) such that none of the nodes is the root (which is what we have just computed). Hence, the number of possibilities is
<disp-formula id="pcbi.1007347.e071"><alternatives><graphic id="pcbi.1007347.e071g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e071" xlink:type="simple"/><mml:math display="block" id="M71"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>p</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi>k</mml:mi> <mml:msup><mml:mn>2</mml:mn> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mfrac><mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</list-item>
</list>
<p>Then we get that
<disp-formula id="pcbi.1007347.e072"><alternatives><graphic id="pcbi.1007347.e072g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e072" xlink:type="simple"/><mml:math display="block" id="M72"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>p</mml:mi> <mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msub><mml:mi>p</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:msub><mml:mi>p</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msup><mml:mn>2</mml:mn> <mml:mi>k</mml:mi></mml:msup> <mml:mfrac><mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mi>k</mml:mi> <mml:msup><mml:mn>2</mml:mn> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mfrac><mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo> <mml:mo>!</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</sec>
<sec id="sec008">
<title>Counting pairs satisfying conditions 1, 2 and 4H</title>
<p>Consider pairs (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) satisfying Conditions 1, 2 and 4H. Recall that, since condition 4H implies that <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub> cannot have elements in common, Conditions 1 and 2 are simplified: no pair of nodes in <italic>S</italic><sub>2</sub> can be siblings and none of them can either be the child of a hybrid node or have a hybrid sibling. Hence, the problem is equivalent to finding a tuple (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) in <italic>P</italic>(<italic>N</italic>, <italic>r</italic> − 1) and then either a tree node <italic>τ</italic><sub>1</sub> or an unordered pair {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>} of different tree nodes, in either case disjoint from those in (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>). Once the tuple (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) is fixed, the number of tree nodes available for choosing <italic>τ</italic><sub>1</sub> and <italic>τ</italic><sub>2</sub> is <italic>t</italic> − <italic>r</italic> + 1 = 2<italic>n</italic> + <italic>h</italic> − <italic>r</italic>. Hence, the number of possible pairs is
<disp-formula id="pcbi.1007347.e073"><alternatives><graphic id="pcbi.1007347.e073g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e073" xlink:type="simple"/><mml:math display="block" id="M73"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>H</mml:mi> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>H</mml:mi> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where
<disp-formula id="pcbi.1007347.e074"><alternatives><graphic id="pcbi.1007347.e074g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e074" xlink:type="simple"/><mml:math display="block" id="M74"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>H</mml:mi> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>p</mml:mi> <mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>·</mml:mo> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>r</mml:mi> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>H</mml:mi> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>r</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</sec>
<sec id="sec009">
<title>Counting pairs satisfying conditions 1, 2 and 4T</title>
<p>The problem now is to count the ways of choosing <italic>S</italic><sub>1</sub> = {<italic>τ</italic><sub>1</sub>} and a tuple <italic>S</italic><sub>2</sub> = (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) satisfying Conditions 1, 2 and 4T. Now <italic>τ</italic><sub>1</sub> can appear in <italic>S</italic><sub>2</sub>, and different possibilities arise, since it allows that one of the nodes in <italic>S</italic><sub>2</sub> has a sibling in <italic>S</italic><sub>2</sub>, or that it has a hybrid parent or sibling. We consider, thus, these different possibilities:</p>
<list list-type="bullet">
<list-item>
<p><italic>τ</italic><sub>1</sub> ≠ <italic>y</italic><sub><italic>i</italic></sub> (for all <italic>i</italic>): This case is very similar to the one considered in the previous paragraph, specifically the case where only a single node <italic>τ</italic><sub>1</sub> had to be taken. The number of possible pairs is
<disp-formula id="pcbi.1007347.e075"><alternatives><graphic id="pcbi.1007347.e075g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e075" xlink:type="simple"/><mml:math display="block" id="M75"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mi>r</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</list-item>
<list-item>
<p><italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub> is a child or a sibling of a hybrid node: Choosing one of these pairs is equivalent to first choosing the position <italic>i</italic>, then filling the other <italic>r</italic> − 2 positions with a tuple in <italic>P</italic>(<italic>N</italic>, <italic>r</italic> − 2), and then choosing a node that is a child or sibling of a hybrid node to be put in the position <italic>i</italic>. The number of ways to do this procedure is
<disp-formula id="pcbi.1007347.e076"><alternatives><graphic id="pcbi.1007347.e076g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e076" xlink:type="simple"/><mml:math display="block" id="M76"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mn>3</mml:mn> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
since each hybrid node has a single child and two siblings, and none of these 3<italic>h</italic> nodes appears twice, associated to two different hybrid nodes.</p>
</list-item>
<list-item>
<p><italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub> is a sibling of some other node <italic>y</italic><sub><italic>j</italic></sub> in <italic>S</italic><sub>2</sub>: In this case one has to choose the positions <italic>i</italic> and <italic>j</italic> where to put the pair of sibling nodes, fill the other <italic>r</italic> − 3 positions with a tuple in <italic>P</italic>(<italic>N</italic>, <italic>r</italic> − 3), choose a pair of sibling tree nodes to take as <italic>y</italic><sub><italic>i</italic></sub> and <italic>y</italic><sub><italic>j</italic></sub>, and finally set <italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub>. The choice of <italic>i</italic> and <italic>j</italic> can be done in (<italic>r</italic> − 1)(<italic>r</italic> − 2) different ways. The choice of the tuple of length <italic>r</italic> − 3 can be done in <italic>p</italic>(<italic>n</italic>, <italic>h</italic>, <italic>r</italic> − 3) ways; <italic>p</italic><sub>1</sub>(<italic>n</italic>, <italic>h</italic>, <italic>r</italic> − 3) of them contain the root of <italic>N</italic> (and <italic>r</italic> − 4 tree nodes with a sibling tree node) and <italic>p</italic><sub>0</sub>(<italic>n</italic>, <italic>h</italic>, <italic>r</italic> − 3) do not contain the root (and contain <italic>r</italic> − 3 tree nodes with a sibling tree node). Once this is done, the number of available pairs of sibling tree nodes is <italic>n</italic> − <italic>h</italic> − 1 − (<italic>r</italic> − 4) = <italic>n</italic> − <italic>h</italic> − <italic>r</italic> + 3, if the root of <italic>N</italic> was chosen, or <italic>n</italic> − <italic>h</italic> − 1 − (<italic>r</italic> − 3) = <italic>n</italic> − <italic>h</italic> − <italic>r</italic> + 2 otherwise. Hence, the total number of pairs is <italic>F</italic><sub><italic>T</italic>,3</sub>(<italic>n</italic>, <italic>h</italic>, <italic>r</italic> − 1) = <italic>F</italic><sub><italic>T</italic>,3, <italic>A</italic></sub>(<italic>n</italic>, <italic>h</italic>, <italic>r</italic> − 1) + <italic>F</italic><sub><italic>T</italic>,3,<italic>B</italic></sub>(<italic>n</italic>, <italic>h</italic>, <italic>r</italic> − 1), corresponding to these two cases, with:
<disp-formula id="pcbi.1007347.e077"><alternatives><graphic id="pcbi.1007347.e077g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e077" xlink:type="simple"/><mml:math display="block" id="M77"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn> <mml:mo>,</mml:mo> <mml:mi>A</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>p</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>r</mml:mi> <mml:mo>+</mml:mo> <mml:mn>6</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn> <mml:mo>,</mml:mo> <mml:mi>B</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>p</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mi>r</mml:mi> <mml:mo>+</mml:mo> <mml:mn>4</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</list-item>
<list-item>
<p><italic>τ</italic><sub>1</sub> = <italic>y</italic><sub><italic>i</italic></sub> but none of the previous conditions hold: In this case one only has to take a tuple in <italic>P</italic>(<italic>N</italic>, <italic>r</italic> − 1) and choose which of the <italic>r</italic> − 1 nodes to take as <italic>τ</italic><sub>1</sub>. The number of possible pairs is then
<disp-formula id="pcbi.1007347.e078"><alternatives><graphic id="pcbi.1007347.e078g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e078" xlink:type="simple"/><mml:math display="block" id="M78"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>4</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</list-item>
</list>
<p>Note that the four conditions above are mutually exclusive. Hence, the overall number of possible pairs (<italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) is the sum of all numbers found:
<disp-formula id="pcbi.1007347.e079"><alternatives><graphic id="pcbi.1007347.e079g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e079" xlink:type="simple"/><mml:math display="block" id="M79"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>F</mml:mi> <mml:mi>T</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mrow><mml:mi>T</mml:mi> <mml:mo>,</mml:mo> <mml:mn>4</mml:mn></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
</sec>
<sec id="sec010">
<title>Bounds for the number of networks</title>
<p>Each network <inline-formula id="pcbi.1007347.e080"><alternatives><graphic id="pcbi.1007347.e080g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e080" xlink:type="simple"/><mml:math display="inline" id="M80"><mml:mrow><mml:mi>N</mml:mi> <mml:mo>∈</mml:mo> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> with <italic>h</italic> hybrid nodes, appears as augmentation <italic>R</italic><sup>−1</sup>(<italic>N</italic>′, <italic>n</italic>, <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) of a unique network <inline-formula id="pcbi.1007347.e081"><alternatives><graphic id="pcbi.1007347.e081g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e081" xlink:type="simple"/><mml:math display="inline" id="M81"><mml:mrow><mml:msup><mml:mi>N</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>∈</mml:mo> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> with <italic>h</italic>′ hybrid nodes, where <italic>S</italic><sub>2</sub> has length <italic>r</italic> − 1 = <italic>h</italic> − <italic>h</italic>′, if the augmentation is of type <italic>T</italic>, or <italic>r</italic> − 1 = <italic>h</italic> − <italic>h</italic>′ − 1 if it is of type <italic>H</italic>. If we call <italic>B</italic>(<italic>n</italic>, <italic>h</italic>) the number of networks in <inline-formula id="pcbi.1007347.e082"><alternatives><graphic id="pcbi.1007347.e082g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e082" xlink:type="simple"/><mml:math display="inline" id="M82"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula> with <italic>h</italic> hybrid nodes, and since we have bounded the number of feasible pairs, we have that
<disp-formula id="pcbi.1007347.e083"><alternatives><graphic id="pcbi.1007347.e083g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e083" xlink:type="simple"/><mml:math display="block" id="M83"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>≤</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mi>h</mml:mi></mml:munderover> <mml:mi>B</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mi>T</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mrow/></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mspace width="2.em"/><mml:mo>+</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mi>B</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>F</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>-</mml:mo> <mml:msup><mml:mi>h</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>Also, since the number of hybrid nodes in a BTC network with <italic>n</italic> leaves is at most <italic>n</italic> − 1, we have that
<disp-formula id="pcbi.1007347.e084"><alternatives><graphic id="pcbi.1007347.e084g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e084" xlink:type="simple"/><mml:math display="block" id="M84"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo> <mml:mo>=</mml:mo></mml:mrow> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>h</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mi>B</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>,</mml:mo> <mml:mi>h</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
and the expression above allows us to compute a bound for this number of networks. See Subsection Computational experiments for an experiment with these bounds.</p>
<p>The asymptotic formula <inline-formula id="pcbi.1007347.e085"><alternatives><graphic id="pcbi.1007347.e085g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e085" xlink:type="simple"/><mml:math display="inline" id="M85"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo> <mml:mo>=</mml:mo></mml:mrow> <mml:msup><mml:mn>2</mml:mn> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>n</mml:mi> <mml:mo form="prefix">log</mml:mo> <mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mi>O</mml:mi> <mml:mo>(</mml:mo> <mml:mi>n</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> is given in [<xref ref-type="bibr" rid="pcbi.1007347.ref019">19</xref>], and both our experimental results in Subsection Computational experiments for <italic>n</italic> ≤ 8 and the bounds that we have computed for <italic>n</italic> ≤ 10 are coherent with this expression. However, the problem of finding a closed expression for the asymptotic behaviour of our bounds is still open.</p>
</sec>
</sec>
<sec id="sec011">
<title>An application to phylogenetic reconstruction</title>
<p>Several models of reticulate evolution on biological sequences have been proposed in the last decades, for example the displayed trees model [<xref ref-type="bibr" rid="pcbi.1007347.ref025">25</xref>], an extension of the multispecies coalescent (MSC) to phylogenetic networks [<xref ref-type="bibr" rid="pcbi.1007347.ref026">26</xref>] and the ancestral recombination graph model –ARG for short [<xref ref-type="bibr" rid="pcbi.1007347.ref027">27</xref>]– to only name a few. The associated problems are difficult to solve and big efforts have been done by the community to provide practitioners with fast algorithms.</p>
<p>Suppose we are given a BTC network <italic>N</italic> over a set of OTUs <italic>X</italic>, where each tree node is associated with a word in an alphabet (for instance a DNA sequence) <italic>s</italic>(<italic>u</italic>) ∈ Σ*. The pair (<italic>N</italic>, <italic>s</italic>) can, for example, be the outcome of an ML search in the space of BTC networks given an alignment over <italic>X</italic>. Now, suppose we are given a new sequence and we want to update <italic>N</italic> to include it, ensuring that the resulting network is still BTC. We may want to do this, for instance, to update the network without redoing the whole ML search, or in a phylogenetic placement perspective (for example, we want to know where to place a given strain of a virus in <italic>N</italic>), or even because we use a heuristic algorithm that reconstructs a network by adding one sequence at the time.</p>
<p>We assume that a model of evolution is given, and we assume that we can compute the following probabilities:</p>
<list list-type="order">
<list-item>
<p>Given <italic>s</italic>, <italic>s</italic>′ ∈ Σ*, <italic>P</italic><sub><italic>S</italic></sub>(<italic>s</italic>, <italic>s</italic>′) is the probability that the sequence <italic>s</italic> evolved by descent with modification giving as a result the sequence <italic>s</italic>′.</p>
</list-item>
<list-item>
<p>Given <italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>, <italic>s</italic>′ ∈ Σ*, <italic>P</italic><sub><italic>H</italic></sub>(<italic>s</italic><sub>1</sub>, <italic>s</italic><sub>2</sub>, <italic>s</italic>′) is the probability that a hybridization between sequences <italic>s</italic><sub>1</sub> and <italic>s</italic><sub>2</sub> –possibly coupled with descent with modification– gives as result the sequence <italic>s</italic>′.</p>
</list-item>
</list>
<p>For each tree node <italic>t</italic> of <italic>N</italic>, we let <italic>ϕ</italic><sub><italic>t</italic></sub>: Σ* → [0, 1] be the function defined as follows. If <italic>t</italic> is the root of <italic>N</italic>, then <italic>ϕ</italic><sub><italic>t</italic></sub> is the constant function equal to 1. Otherwise, if the single parent <italic>p</italic> of <italic>t</italic> is a tree node, then <italic>ϕ</italic><sub><italic>t</italic></sub>(<italic>s</italic>) = <italic>P</italic><sub><italic>S</italic></sub>(<italic>s</italic>(<italic>p</italic>), <italic>s</italic>). If <italic>p</italic> is a hybrid node with parents <italic>g</italic><sub>1</sub>, <italic>g</italic><sub>2</sub>, then <italic>ϕ</italic><sub><italic>t</italic></sub>(<italic>s</italic>) = <italic>P</italic><sub><italic>H</italic></sub>(<italic>s</italic>(<italic>g</italic><sub>1</sub>), <italic>s</italic>(<italic>g</italic><sub>2</sub>), <italic>s</italic>). That is, <italic>ϕ</italic><sub><italic>t</italic></sub>(<italic>s</italic>) is the probability that a given sequence <italic>s</italic> is the result of the evolution of the sequences at the parent node (or grandparents, in case of hybrid parent) of <italic>t</italic>.</p>
<p>Now, we want to extend <italic>N</italic> to another BTC network in order to include an extant OTU <italic>ℓ</italic> ∉ <italic>X</italic> identified by its sequence <italic>s</italic><sub><italic>ℓ</italic></sub> ∈ Σ*, while keeping the sequences associated to all tree nodes of <italic>N</italic>. According to the results presented in this paper, we need to identify the augmentation operation <italic>R</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, <italic>S</italic><sub>2</sub>) that has to be applied, and determine the sequences at the newly created tree nodes. If the operation to be applied is of type <italic>T</italic>, that is, <inline-formula id="pcbi.1007347.e086"><alternatives><graphic id="pcbi.1007347.e086g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e086" xlink:type="simple"/><mml:math display="inline" id="M86"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>T</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>;</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, we need to find certain nodes <italic>τ</italic><sub>1</sub>, <italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>, with the additional condition that <italic>S</italic><sub>1</sub> = {<italic>τ</italic><sub>1</sub>} and <italic>S</italic><sub>2</sub> = (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) form a <italic>T</italic>-feasible pair. Analogously, if it is of type <italic>H</italic>, <inline-formula id="pcbi.1007347.e087"><alternatives><graphic id="pcbi.1007347.e087g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e087" xlink:type="simple"/><mml:math display="inline" id="M87"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>H</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>;</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, then <italic>S</italic><sub>1</sub> = {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>} and <italic>S</italic><sub>2</sub> = (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>r</italic>−1</sub>) must form a <italic>H</italic>-feasible pair.</p>
<p>Intuitively, the node <italic>τ</italic><sub>1</sub> in case of an augmentation of type <italic>T</italic>, or the nodes <italic>τ</italic><sub>1</sub> and <italic>τ</italic><sub>2</sub> in case of type <italic>H</italic>, have to be chosen in order to maximize the probability of appearance of the new OTU, while the other nodes appear in order to give a better explanation of the corresponding sequences by means of hybridization with the lineage leading to <italic>ℓ</italic>.</p>
<p>We present here an heuristic to find the augmentation operation, together with the assignment of sequences to new tree nodes, that deploys this intuitive idea:</p>
<list list-type="order">
<list-item>
<p>Assume that an augmentation of type <italic>T</italic> is going to take place. To determine <italic>τ</italic><sub>1</sub>, for each tree node <italic>t</italic> of <italic>N</italic>, we find a sequence <italic>σ</italic>(<italic>t</italic>) ∈ Σ* that maximizes
<disp-formula id="pcbi.1007347.e088"><alternatives><graphic id="pcbi.1007347.e088g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e088" xlink:type="simple"/><mml:math display="block" id="M88"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>ϕ</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mo>ℓ</mml:mo></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>The rationale behind this expression is that we look for the best way to divide the arc entering <italic>t</italic> to add the new taxon with sequence <italic>s</italic><sub><italic>ℓ</italic></sub> as child of the newly created node. See <xref ref-type="fig" rid="pcbi.1007347.g015">Fig 15</xref>(left) for a depiction of this. Then <italic>τ</italic><sub>1</sub> is a node with the maximum value of <italic>π</italic> over all nodes of <italic>N</italic>, that is the best location where to hang <italic>s</italic><sub><italic>ℓ</italic></sub> in <italic>N</italic>. For future reference, let <italic>σ</italic><sup><italic>T</italic></sup> = <italic>σ</italic>(<italic>τ</italic><sub>1</sub>), <italic>π</italic><sup><italic>T</italic></sup> = <italic>π</italic>(<italic>τ</italic><sub>1</sub>) and <inline-formula id="pcbi.1007347.e089"><alternatives><graphic id="pcbi.1007347.e089g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e089" xlink:type="simple"/><mml:math display="inline" id="M89"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi> <mml:mn>1</mml:mn> <mml:mi>T</mml:mi></mml:msubsup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:msub><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<p>Assume that an augmentation of type <italic>H</italic> is going to take place. To determine <italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>, for each unordered pair of tree nodes {<italic>t</italic><sub>1</sub>, <italic>t</italic><sub>2</sub>} ≔ <bold><italic>t</italic></bold> of <italic>N</italic>, we find sequences <italic>σ</italic><sup>1</sup>(<bold><italic>t</italic></bold>), <italic>σ</italic><sup>2</sup>(<bold><italic>t</italic></bold>) ∈ Σ* that maximize
<disp-formula id="pcbi.1007347.e090"><alternatives><graphic id="pcbi.1007347.e090g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e090" xlink:type="simple"/><mml:math display="block" id="M90"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>ϕ</mml:mi> <mml:msub><mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>ϕ</mml:mi> <mml:msub><mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mn>2</mml:mn></mml:msub></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mo>ℓ</mml:mo></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>See <xref ref-type="fig" rid="pcbi.1007347.g015">Fig 15</xref>(right). The rationale for this choice is the same as in the previous point.</p>
<p>Let <bold><italic>τ</italic></bold> = {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>} be a pair with maximum value of <italic>π</italic>. For future reference, let <inline-formula id="pcbi.1007347.e091"><alternatives><graphic id="pcbi.1007347.e091g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e091" xlink:type="simple"/><mml:math display="inline" id="M91"><mml:mrow><mml:msup><mml:mi>σ</mml:mi> <mml:mi>H</mml:mi></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">τ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">τ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, <italic>π</italic><sup><italic>H</italic></sup> = <italic>π</italic>(<bold><italic>τ</italic></bold>) and <inline-formula id="pcbi.1007347.e092"><alternatives><graphic id="pcbi.1007347.e092g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e092" xlink:type="simple"/><mml:math display="inline" id="M92"><mml:mrow><mml:msubsup><mml:mi>S</mml:mi> <mml:mn>1</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>=</mml:mo> <mml:mi mathvariant="bold-italic">τ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<p>If <italic>π</italic><sup><italic>T</italic></sup> ≥ <italic>π</italic><sup><italic>H</italic></sup>, we opt for an augmentation of type <italic>T</italic> and we let <inline-formula id="pcbi.1007347.e093"><alternatives><graphic id="pcbi.1007347.e093g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e093" xlink:type="simple"/><mml:math display="inline" id="M93"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>S</mml:mi> <mml:mn>1</mml:mn> <mml:mi>T</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>; otherwise, we opt for an augmentation of type <italic>H</italic> and we let <inline-formula id="pcbi.1007347.e094"><alternatives><graphic id="pcbi.1007347.e094g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e094" xlink:type="simple"/><mml:math display="inline" id="M94"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>S</mml:mi> <mml:mn>1</mml:mn> <mml:mi>H</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. The tree nodes in <italic>R</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, ∅) that were present in <italic>N</italic> keep their sequences. Moreover, in case of an augmentation of type <italic>T</italic>, we subdivide the arc entering <italic>τ</italic><sub>1</sub> via a new node <italic>w</italic><sub>1</sub> associated to the sequence <italic>σ</italic><sup><italic>T</italic></sup> and we add a new leaf <italic>ℓ</italic> with sequence <italic>s</italic><sub><italic>ℓ</italic></sub> as child of <italic>w</italic><sub>1</sub>. In case of an augmentation of type <italic>H</italic>, we subdivide the arcs entering <italic>τ</italic><sub>1</sub> and <italic>τ</italic><sub>2</sub> via two new nodes <italic>w</italic><sub>1</sub>, <italic>w</italic><sub>2</sub> that are assigned to the two sequences <inline-formula id="pcbi.1007347.e095"><alternatives><graphic id="pcbi.1007347.e095g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e095" xlink:type="simple"/><mml:math display="inline" id="M95"><mml:mrow><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn> <mml:mi>H</mml:mi></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>; then, we add a new hybrid node with parents <italic>w</italic><sub>1</sub> and <italic>w</italic><sub>2</sub> and having as child a new leaf <italic>ℓ</italic> with sequence <italic>s</italic><sub><italic>ℓ</italic></sub>.</p>
</list-item>
<list-item>
<p>For each <italic>k</italic> ≥ 1, we assume that <italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic>−1</sub> are already determined. Let <italic>C</italic> be the set of tree nodes <italic>y</italic> such that (<italic>S</italic><sub>1</sub>, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic>−1</sub>, <italic>y</italic>)) is a feasible pair. To determine <italic>y</italic><sub><italic>k</italic></sub> we proceed as follows:</p>
<list list-type="bullet">
<list-item>
<p>If <italic>k</italic> = 1 and we opted for a type <italic>H</italic> augmentation, for each <italic>y</italic> ∈ <italic>C</italic> with parent <italic>p</italic>, we find a sequence <italic>σ</italic>(<italic>y</italic>) that maximizes
<disp-formula id="pcbi.1007347.e096"><alternatives><graphic id="pcbi.1007347.e096g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e096" xlink:type="simple"/><mml:math display="block" id="M96"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>,</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>p</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mo>ℓ</mml:mo></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>See <xref ref-type="fig" rid="pcbi.1007347.g016">Fig 16</xref>(left). Notice that we have assumed that <italic>p</italic> is a tree node; if <italic>p</italic> was a hybrid node, and this case is really exceptional because of the definition of feasible pair, then the computation above, and the one in the next item, should be adapted. If <italic>κ</italic>(<italic>y</italic>) = <italic>π</italic>(<italic>y</italic>) − <italic>P</italic><sub><italic>S</italic></sub>(<italic>s</italic>(<italic>p</italic>), <italic>s</italic>(<italic>y</italic>)) <inline-formula id="pcbi.1007347.e097"><alternatives><graphic id="pcbi.1007347.e097g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e097" xlink:type="simple"/><mml:math display="inline" id="M97"><mml:mrow><mml:msub><mml:mi>P</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn> <mml:mi>H</mml:mi></mml:msubsup> <mml:mo>,</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mo>ℓ</mml:mo></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is negative, we remove <italic>y</italic> from <italic>C</italic> since this means that the hypothesis of the existence of a hybridization just above <italic>y</italic> is less likely than its absence.</p>
</list-item>
<list-item>
<p>If <italic>k</italic> &gt; 1 or we opted for a type <italic>T</italic> augmentation, for each <italic>y</italic> ∈ <italic>C</italic> with parent <italic>p</italic>, we find a sequence <italic>σ</italic>(<italic>y</italic>) that maximizes
<disp-formula id="pcbi.1007347.e098"><alternatives><graphic id="pcbi.1007347.e098g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e098" xlink:type="simple"/><mml:math display="block" id="M98"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>H</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>p</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mi>s</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>S</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>y</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mo>ℓ</mml:mo></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where in case that <italic>k</italic> = 1 (and hence we opted for a type <italic>T</italic> augmentation), we let <italic>y</italic><sub>0</sub> = <italic>τ</italic><sub>1</sub>. See <xref ref-type="fig" rid="pcbi.1007347.g016">Fig 16</xref>(right). If <italic>κ</italic>(<italic>y</italic>) = <italic>π</italic>(<italic>y</italic>) − <italic>P</italic><sub><italic>S</italic></sub>(<italic>s</italic>(<italic>p</italic>), <italic>s</italic>(<italic>y</italic>))<italic>P</italic><sub><italic>S</italic></sub>(<italic>σ</italic>(<italic>y</italic><sub><italic>k</italic>−1</sub>), <italic>s</italic><sub><italic>ℓ</italic></sub>) is negative, we remove <italic>y</italic> from <italic>C</italic> as in the previous case.</p>
</list-item>
</list>
<p>Then, if <italic>C</italic> is empty we output the network <inline-formula id="pcbi.1007347.e099"><alternatives><graphic id="pcbi.1007347.e099g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e099" xlink:type="simple"/><mml:math display="inline" id="M99"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>R</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mo>ℓ</mml:mo> <mml:mo>;</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. Otherwise, let <italic>y</italic><sub><italic>k</italic></sub> the node that maximizes <italic>κ</italic>. Then, we create a new tree node <italic>u</italic><sub><italic>k</italic></sub> on the arc entering <italic>ℓ</italic> –associating the sequence <italic>σ</italic>(<italic>y</italic><sub><italic>k</italic></sub>) to it– and we subdivide the arc entering <italic>y</italic><sub><italic>k</italic></sub> by a new hybrid node with second parent <italic>u</italic><sub><italic>k</italic></sub>. The tree nodes in <italic>R</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic>−1</sub>, <italic>y</italic><sub><italic>k</italic></sub>)) that appeared in <italic>R</italic><sup>−1</sup>(<italic>N</italic>, <italic>ℓ</italic>; <italic>S</italic><sub>1</sub>, (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic>−1</sub>)) keep their associated sequence.</p>
</list-item>
</list>
<fig id="pcbi.1007347.g015" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g015</object-id>
<label>Fig 15</label>
<caption>
<title>A depiction of the notations used in the text to define the function <italic>π</italic> to maximize for finding <italic>τ</italic><sub>1</sub> (left, type <italic>T</italic> augmentation) and {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>} (right, type <italic>H</italic> augmentation).</title>
<p>Although in the figure <italic>p</italic>, <italic>p</italic><sub>1</sub> and <italic>p</italic><sub>2</sub> are depicted as tree nodes, they can as well be hybrid nodes.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g015" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007347.g016" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g016</object-id>
<label>Fig 16</label>
<caption>
<title>A depiction of the notations used in the text to define the function <italic>π</italic> to maximize for finding <italic>y</italic><sub><italic>k</italic></sub>, respectively for a type <italic>H</italic> augmentation (left) and a type <italic>T</italic> augmentation (right), assuming that <italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic>−1</sub> are already determined.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g016" xlink:type="simple"/>
</fig>
<p>We emphasize that we do not claim that the heuristic we present here gives a global optimum. In fact, usually a sequence of optimal choices does not lead to a global optimum. The analysis, and eventually improvement, of this method of reconstruction is left as future work.</p>
<p><bold>Example 1</bold>. We consider a simple model of evolution where:</p>
<list list-type="bullet">
<list-item>
<p>OTUs are represented by words of length 4 in the alphabet Σ = {A, B, C}.</p>
</list-item>
<list-item>
<p>For speciation we assume a simple Jukes-Cantor model of evolution on the characters A, B, C so that <italic>P</italic><sub><italic>S</italic></sub>(<italic>s</italic>, <italic>s</italic>′) = <italic>μ</italic><sup><italic>d</italic></sup>(1 − 2<italic>μ</italic>)<sup>4−<italic>d</italic></sup>, where <italic>d</italic> = <italic>d</italic>(<italic>s</italic>, <italic>s</italic>′) is the Hamming distance between <italic>s</italic> and <italic>s</italic>′ and <italic>μ</italic> &lt; 1/3 is a parameter of the model.</p>
</list-item>
<list-item>
<p>In this toy example, we model hybridizations as if they were plain recombinations where half of the hybrid sequence comes from one parent and the other half from the other. So, given two sequences <inline-formula id="pcbi.1007347.e100"><alternatives><graphic id="pcbi.1007347.e100g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e100" xlink:type="simple"/><mml:math display="inline" id="M100"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mn>1</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>1</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>3</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007347.e101"><alternatives><graphic id="pcbi.1007347.e101g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e101" xlink:type="simple"/><mml:math display="inline" id="M101"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>3</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, <italic>P</italic><sub><italic>H</italic></sub>(<italic>s</italic><sup>1</sup>, <italic>s</italic><sup>2</sup>, <italic>s</italic>′) = 1/2 if <inline-formula id="pcbi.1007347.e102"><alternatives><graphic id="pcbi.1007347.e102g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e102" xlink:type="simple"/><mml:math display="inline" id="M102"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>1</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>3</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> or <inline-formula id="pcbi.1007347.e103"><alternatives><graphic id="pcbi.1007347.e103g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e103" xlink:type="simple"/><mml:math display="inline" id="M103"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>3</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn> <mml:mn>1</mml:mn></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, and <italic>P</italic><sub><italic>H</italic></sub>(<italic>s</italic><sup>1</sup>, <italic>s</italic><sup>2</sup>, <italic>s</italic>′) = 0 otherwise.</p>
</list-item>
</list>
<p>We consider three species, with sequences
<disp-formula id="pcbi.1007347.e104"><alternatives><graphic id="pcbi.1007347.e104g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e104" xlink:type="simple"/><mml:math display="block" id="M104"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>s</mml:mi> <mml:mo>(</mml:mo> <mml:mi>α</mml:mi> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mtext>AAAC</mml:mtext> <mml:mo>,</mml:mo> <mml:mspace width="2.em"/><mml:mi>s</mml:mi> <mml:mo>(</mml:mo> <mml:mi>β</mml:mi> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mtext>BBCC</mml:mtext> <mml:mo>,</mml:mo> <mml:mspace width="2.em"/><mml:mi>s</mml:mi> <mml:mo>(</mml:mo> <mml:mi>γ</mml:mi> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mtext>BBBB</mml:mtext> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>The network <italic>N</italic> (which is in fact a tree) that fits these extant OTUs best, together with an optimal assignment of sequences to all nodes is shown in <xref ref-type="fig" rid="pcbi.1007347.g017">Fig 17</xref>(left).</p>
<fig id="pcbi.1007347.g017" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.g017</object-id>
<label>Fig 17</label>
<caption>
<title>The networks considered in Example 1.</title>
<p>We start with a tree on three leaves (left), chose a type <italic>T</italic> augmentation and find the best choice for <italic>τ</italic><sub>1</sub> (middle) and the best choice for the vector (<italic>y</italic><sub>1</sub>, …, <italic>y</italic><sub><italic>k</italic></sub>) (right, here <italic>k</italic> = 1).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.g017" xlink:type="simple"/>
</fig>
<p>Now, we wish to extend <italic>N</italic> in order to add a new OTU with sequence
<disp-formula id="pcbi.1007347.e105"><alternatives><graphic id="pcbi.1007347.e105g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e105" xlink:type="simple"/><mml:math display="block" id="M105"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>s</mml:mi> <mml:mo>(</mml:mo> <mml:mi>δ</mml:mi> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mtext>AACC</mml:mtext> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>We thus proceed as discussed in the previous pages:</p>
<list list-type="order">
<list-item>
<p>If we assume an augmentation of type <italic>T</italic>, it is not difficult to see that an optimal choice for <italic>τ</italic><sub>1</sub> and its corresponding sequence <italic>σ</italic><sup><italic>T</italic></sup> are respectively <italic>α</italic> and AAAC, with <italic>π</italic>(<italic>α</italic>) = <italic>μ</italic><sup>2</sup>(1 − 2<italic>μ</italic>)<sup>10</sup>.</p>
</list-item>
<list-item>
<p>If we explore the different possibilities for an augmentation of type <italic>H</italic>, we find that the best choice is {<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>} = {<italic>α</italic>, <italic>β</italic>} with sequences AAAB and BBCC and with value <italic>π</italic>({<italic>τ</italic><sub>1</sub>, <italic>τ</italic><sub>2</sub>}) = <italic>μ</italic><sup>3</sup>(1 − 2<italic>μ</italic>)<sup>13</sup>/2.</p>
</list-item>
<list-item>
<p>Since <italic>μ</italic> &lt; 1/3, we get that <italic>π</italic>(<italic>α</italic>) &gt; <italic>π</italic>({<italic>α</italic>, <italic>β</italic>}) and we opt for the augmentation <italic>N</italic><sub>0</sub> = <italic>T</italic><sup>−1</sup>(<italic>N</italic>, <italic>δ</italic>;{<italic>α</italic>}, ∅) shown in <xref ref-type="fig" rid="pcbi.1007347.g017">Fig 17</xref>(middle).</p>
</list-item>
<list-item>
<p>Now we want to find the right choice for <italic>y</italic><sub>1</sub>, if any. All nodes except the least common ancestor (in <italic>N</italic><sub>0</sub>) of <italic>α</italic> and <italic>δ</italic> are in <italic>C</italic>. Taking any node <italic>y</italic> ∈ <italic>C</italic> different from <italic>β</italic> we get that <italic>κ</italic>(<italic>y</italic>) &lt; 0 and hence they are not good candidates. If we take <italic>y</italic> = <italic>β</italic>, taking into account that <italic>μ</italic> &lt; 1/3, we find an optimal sequence <italic>σ</italic>(<italic>β</italic>) = AACC. The value of <italic>π</italic>(<italic>β</italic>) corresponds to three different evolution processes: two mutations, from AAAC to AACC and from AACC to AACC, and a hybridization of the sequences AACC and BBBB to BBCC, and hence we get <italic>π</italic>(<italic>β</italic>) = (1 − 2<italic>μ</italic>)<sup>7</sup> <italic>μ</italic>/2. Now, this value must be compared with the probability of evolution without this hybridization, i.e. the probability of speciations from BBBB to BBCC and from AAAC to AACC which is <italic>μ</italic><sup>3</sup>(1 − 2<italic>μ</italic>)<sup>5</sup>. Since (1 − 2<italic>μ</italic>)<sup>7</sup> <italic>μ</italic>/2 &gt; <italic>μ</italic><sup>3</sup>(1 − 2<italic>μ</italic>)<sup>5</sup> (assuming that <italic>μ</italic> &lt; 0.2928, which is a reasonable assumption) we conclude that the network <italic>N</italic><sub>1</sub> = <italic>T</italic><sup>−1</sup>(<italic>N</italic>, <italic>δ</italic>; {<italic>α</italic>}, (<italic>β</italic>)), depicted in <xref ref-type="fig" rid="pcbi.1007347.g017">Fig 17</xref>(right), is a better explanation than <italic>N</italic><sub>0</sub>. Hence, we let <italic>y</italic><sub>1</sub> = <italic>β</italic>.</p>
</list-item>
<list-item>
<p>If we repeat the procedure in the previous step, we find that no hybridization improves the probability of the sequences, giving as final result the network <inline-formula id="pcbi.1007347.e106"><alternatives><graphic id="pcbi.1007347.e106g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e106" xlink:type="simple"/><mml:math display="inline" id="M106"><mml:mrow><mml:mover accent="true"><mml:mi>N</mml:mi> <mml:mo>˜</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msup><mml:mi>T</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mi>δ</mml:mi> <mml:mo>;</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:mi>α</mml:mi> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>β</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> in <xref ref-type="fig" rid="pcbi.1007347.g017">Fig 17</xref>(right).</p>
</list-item>
</list>
</sec>
<sec id="sec012">
<title>Computational experiments</title>
<p>The algorithms in this paper have been implemented in python using the python library PhyloNetworks [<xref ref-type="bibr" rid="pcbi.1007347.ref028">28</xref>]. This implementation, together with the sources for the experiments that we comment in this subsection can be downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/bielcardona/TCGenerators" xlink:type="simple">https://github.com/bielcardona/TCGenerators</ext-link>.</p>
<sec id="sec013">
<title>Exhaustive and sequential construction of networks in <inline-formula id="pcbi.1007347.e107"><alternatives><graphic id="pcbi.1007347.e107g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e107" xlink:type="simple"/><mml:math display="inline" id="M107"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula></title>
<p>We have implemented both the exhaustive and sequential construction of BTC networks with <italic>n</italic> leaves. The number of such networks increases very rapidly, and hence the exhaustive construction is not feasible for <italic>n</italic> ≥ 8. For <italic>n</italic> ≤ 7 we generated all the networks in <inline-formula id="pcbi.1007347.e108"><alternatives><graphic id="pcbi.1007347.e108g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e108" xlink:type="simple"/><mml:math display="inline" id="M108"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>; see <xref ref-type="table" rid="pcbi.1007347.t001">Table 1</xref> for the number of such networks. For <italic>n</italic> = 8 we could not compute them all, since there are around twelve trillion of such networks: We took uniform samples of networks in <inline-formula id="pcbi.1007347.e109"><alternatives><graphic id="pcbi.1007347.e109g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e109" xlink:type="simple"/><mml:math display="inline" id="M109"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mn>7</mml:mn></mml:msub></mml:math></alternatives></inline-formula> and computed their respective offspring, and repeated this procedure until the average number of offsprings per network stabilized up to 4 digits; this allowed us to give the estimate for <inline-formula id="pcbi.1007347.e110"><alternatives><graphic id="pcbi.1007347.e110g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e110" xlink:type="simple"/><mml:math display="inline" id="M110"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mn>8</mml:mn></mml:msub> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<table-wrap id="pcbi.1007347.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007347.t001</object-id>
<label>Table 1</label>
<caption>
<title>Exact number of BTC networks over [<italic>n</italic>] for <italic>n</italic> = 1, …, 7, an estimate for <italic>n</italic> = 8, and their upper bounds for <italic>n</italic> ≤ 10.</title>
</caption>
<alternatives>
<graphic id="pcbi.1007347.t001g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007347.t001" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="right"><italic>n</italic></th>
<th align="right">
<inline-formula id="pcbi.1007347.e111">
<alternatives>
<graphic id="pcbi.1007347.e111g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e111" xlink:type="simple"/>
<mml:math display="inline" id="M111">
<mml:mrow>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
<mml:msub>
<mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow>
<mml:mi>n</mml:mi>
</mml:msub>
<mml:mrow>
<mml:mo>|</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula>
</th>
<th align="right">upper bound</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
<tr>
<td align="right">3</td>
<td align="right">66</td>
<td align="right">85</td>
</tr>
<tr>
<td align="right">4</td>
<td align="right">4,059</td>
<td align="right">7,442</td>
</tr>
<tr>
<td align="right">5</td>
<td align="right">496,710</td>
<td align="right">1,317,098</td>
</tr>
<tr>
<td align="right">6</td>
<td align="right">101,833,875</td>
<td align="right">387,405,870</td>
</tr>
<tr>
<td align="right">7</td>
<td align="right">31,538,916,360</td>
<td align="right">169,781,857,790</td>
</tr>
<tr>
<td align="right">8</td>
<td align="right">≃ 12,000,000,000,000</td>
<td align="right">103,409,407,515,286</td>
</tr>
<tr>
<td align="right">9</td>
<td align="right">?</td>
<td align="right">83,400,205,845,281,275</td>
</tr>
<tr>
<td align="right">10</td>
<td align="right">?</td>
<td align="right">85,947,517,732,640,544,027</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec014">
<title>Random construction of networks in <inline-formula id="pcbi.1007347.e112"><alternatives><graphic id="pcbi.1007347.e112g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e112" xlink:type="simple"/><mml:math display="inline" id="M112"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula></title>
<p>We have implemented the following construction, that does not generate networks uniformly, but is the closest we could get to it. We start with the network <italic>N</italic><sub>1</sub> with a single node labeled by 1. At each stage <italic>i</italic> = 1, …, <italic>n</italic> − 1, we explicitly find all feasible pairs inside <italic>N</italic><sub><italic>i</italic></sub> and choose at random and uniformly one of them to generate the network <italic>N</italic><sub><italic>i</italic>+1</sub>. This procedure generates all possible networks in <inline-formula id="pcbi.1007347.e113"><alternatives><graphic id="pcbi.1007347.e113g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e113" xlink:type="simple"/><mml:math display="inline" id="M113"><mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, but not uniformly, since different networks over the same set of taxa may have different numbers of feasible pairs.</p>
</sec>
<sec id="sec015">
<title>Computation of bounds for <inline-formula id="pcbi.1007347.e114"><alternatives><graphic id="pcbi.1007347.e114g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e114" xlink:type="simple"/><mml:math display="inline" id="M114"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></title>
<p>Finally, we have implemented the recursive computation for the upper bounds of <inline-formula id="pcbi.1007347.e115"><alternatives><graphic id="pcbi.1007347.e115g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007347.e115" xlink:type="simple"/><mml:math display="inline" id="M115"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mrow><mml:mi mathvariant="script">B</mml:mi><mml:mi mathvariant="script">T</mml:mi><mml:mi mathvariant="script">C</mml:mi></mml:mrow> <mml:mi>n</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> using the bounds for the offsprings of BTC networks found previously. The results for <italic>n</italic> up to 10 are given in <xref ref-type="table" rid="pcbi.1007347.t001">Table 1</xref>, where it is observed that, at least for small values of <italic>n</italic>, the true number of networks and the upper bounds have the same order of magnitude.</p>
</sec>
</sec>
</sec>
<sec id="sec016" sec-type="conclusions">
<title>Discussion</title>
<p>The main result of this paper is a systematic way of recursively generating, with unicity, all BTC networks with a given number of leaves. This procedure relies on a pair of reduction/augmentation operations that generalize analogous operations for phylogenetic trees. Indeed, given a (rooted, binary) phylogenetic tree over [<italic>n</italic>], we can obtain a phylogenetic tree over [<italic>n</italic> − 1] by deleting the leaf labeled by <italic>n</italic> and removing the elementary node that this deletion generates. Conversely, given a tree <italic>T</italic> over [<italic>n</italic> − 1] and one of its nodes <italic>u</italic>, we can construct a tree over [<italic>n</italic>] by simply hanging a pendant leaf labeled by <italic>n</italic> to the single incoming arc of <italic>u</italic>. Since different choices for <italic>T</italic> and <italic>u</italic> give different trees over [<italic>n</italic>], this gives a recursive procedure to generate, with unicity, all binary rooted phylogenetic trees over a given set of taxa: we start with the leaf labeled by 1, then we add the leaf labeled by 2, then the leaf labeled by 3 in all possible ways, and so on. Biologically, we can think of this procedure as follows: Once the evolutionary history of a given set of OTUs is correctly established (notice that, in practice, we can never be sure that we got the correct tree, but here we suppose we do) and modeled by a phylogenetic tree, extending this evolutionary history to consider a “new” OTU <italic>n</italic> consists in finding where to place <italic>n</italic> in the tree, i.e. finding the speciation event that leads to the diversification of <italic>n</italic>.</p>
<p>Unfortunately, when working with classes of phylogenetic networks, the removal of a single leaf (and of all elementary nodes created by this removal) does not necessarily give a phylogenetic network within the same class. In the case of BTC networks, we were able to find the minimal set of nodes that one must remove so that, after their deletion and that of all elementary nodes created by this removal, one gets a BTC network with one leaf less. As in the case of trees, given a BTC network over [<italic>n</italic> − 1] and some set of nodes with certain restrictions (i.e. the feasible pairs <italic>S</italic><sub>1</sub> and <italic>S</italic><sub>2</sub>) we can construct a BTC network over [<italic>n</italic>] leaves, in such a way that different choices for the BTC network or for the feasible pair give different BTC networks over [<italic>n</italic>]. Hence, we find a procedure to recursively generate all BTC networks over a given set of taxa. Biologically, we can think of this procedure as an extension of what can happen when adding a new OTU <italic>n</italic> to a phylogenetic tree: here the diversification of <italic>n</italic> can involve a reticulated event (when <italic>n</italic> is added as hybrid node) and the ancestors of <italic>n</italic> participate to |<italic>S</italic><sub>2</sub>| reticulated events, which were impossible to detect before the introduction of <italic>n</italic>.</p>
</sec>
</body>
<back>
<ref-list>
<title>References</title>
<ref id="pcbi.1007347.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Maddison</surname> <given-names>WP</given-names></name>. <article-title>Gene Trees in Species Trees</article-title>. <source>Systematic Biology</source>. <year>1997</year>;<volume>46</volume>(<issue>3</issue>):<fpage>523</fpage>–<lpage>536</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/sysbio/46.3.523" xlink:type="simple">10.1093/sysbio/46.3.523</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Scornavacca</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Huson</surname> <given-names>DH</given-names></name>. <article-title>A Survey of Combinatorial Methods for Phylogenetic Networks</article-title>. <source>Genome Biology and Evolution</source>. <year>2010</year>;<volume>3</volume>:<fpage>23</fpage>–<lpage>35</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/gbe/evq077" xlink:type="simple">10.1093/gbe/evq077</ext-link></comment> <object-id pub-id-type="pmid">21081312</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Semple</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Baroni</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Steel</surname> <given-names>M</given-names></name>. <article-title>Hybrids in Real Time</article-title>. <source>Systematic Biology</source>. <year>2006</year>;<volume>55</volume>(<issue>1</issue>):<fpage>46</fpage>–<lpage>56</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1080/10635150500431197" xlink:type="simple">10.1080/10635150500431197</ext-link></comment> <object-id pub-id-type="pmid">16507523</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Baroni</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Semple</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Steel</surname> <given-names>M</given-names></name>. <article-title>A Framework for Representing Reticulate Evolution</article-title>. <source>Annals of Combinatorics</source>. <year>2005</year>;<volume>8</volume>(<issue>4</issue>):<fpage>391</fpage>–<lpage>408</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00026-004-0228-0" xlink:type="simple">10.1007/s00026-004-0228-0</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref005">
<label>5</label>
<mixed-citation publication-type="other" xlink:type="simple">Erdos PL, Semple C, Steel M. A class of phylogenetic networks reconstructable from ancestral profiles; 2019. Available from: <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1901.04064v1" xlink:type="simple">https://arxiv.org/abs/1901.04064v1</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1007347.ref006">
<label>6</label>
<mixed-citation publication-type="other" xlink:type="simple">Gusfield D, Eddhu S, Langley C. Efficient Reconstruction of Phylogenetic Networks with Constrained Recombination. In: Proceedings of the IEEE Computer Society Conference on Bioinformatics. CSB’03. Washington, DC, USA: IEEE Computer Society; 2003. p. 363–. Available from: <ext-link ext-link-type="uri" xlink:href="http://dl.acm.org/citation.cfm?id=937976.938101" xlink:type="simple">http://dl.acm.org/citation.cfm?id=937976.938101</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1007347.ref007">
<label>7</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Huson</surname> <given-names>DH</given-names></name>, <name name-style="western"><surname>Klöpper</surname> <given-names>TH</given-names></name>. <chapter-title>Beyond Galled Trees—Decomposition and Computation of Galled Networks</chapter-title>. In: <name name-style="western"><surname>Speed</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Huang</surname> <given-names>H</given-names></name>, editors. <source>Research in Computational Molecular Biology</source>. <publisher-loc>Berlin, Heidelberg</publisher-loc>: <publisher-name>Springer Berlin Heidelberg</publisher-name>; <year>2007</year>. p. <fpage>211</fpage>–<lpage>225</lpage>. Available from: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/978-3-540-71681-5_15" xlink:type="simple">https://doi.org/10.1007/978-3-540-71681-5_15</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1007347.ref008">
<label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>van Iersel</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Kelk</surname> <given-names>S</given-names></name>. <article-title>Constructing the Simplest Possible Phylogenetic Network from Triplets</article-title>. <source>Algorithmica</source>. <year>2011</year>;<volume>60</volume>(<issue>2</issue>):<fpage>207</fpage>–<lpage>235</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00453-009-9333-0" xlink:type="simple">10.1007/s00453-009-9333-0</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref009">
<label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Cardona</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Rosselló</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Valiente</surname> <given-names>G</given-names></name>. <article-title>Comparison of Tree-Child Phylogenetic Networks</article-title>. <source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source>. <year>2009</year>;<volume>6</volume>(<issue>4</issue>):<fpage>552</fpage>–<lpage>569</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1109/TCBB.2007.70270" xlink:type="simple">10.1109/TCBB.2007.70270</ext-link></comment> <object-id pub-id-type="pmid">19875855</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Francis</surname> <given-names>AR</given-names></name>, <name name-style="western"><surname>Steel</surname> <given-names>M</given-names></name>. <article-title>Which phylogenetic networks are merely trees with additional arcs?</article-title> <source>Systematic biology</source>. <year>2015</year>;<volume>64</volume>(<issue>5</issue>):<fpage>768</fpage>–<lpage>777</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/sysbio/syv037" xlink:type="simple">10.1093/sysbio/syv037</ext-link></comment> <object-id pub-id-type="pmid">26070685</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Cardona</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Pons</surname> <given-names>JC</given-names></name>, <name name-style="western"><surname>Rosselló</surname> <given-names>F</given-names></name>. <article-title>A reconstruction problem for a class of phylogenetic networks with lateral gene transfers</article-title>. <source>Algorithms for Molecular Biology</source>. <year>2015</year>;<volume>10</volume>(<issue>1</issue>):<fpage>28</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1186/s13015-015-0059-z" xlink:type="simple">10.1186/s13015-015-0059-z</ext-link></comment> <object-id pub-id-type="pmid">26691555</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref012">
<label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>van Iersel</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Semple</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Steel</surname> <given-names>M</given-names></name>. <article-title>Locating a tree in a phylogenetic network</article-title>. <source>Information Processing Letters</source>. <year>2010</year>;<volume>110</volume>(<issue>23</issue>):<fpage>1037</fpage>–<lpage>1043</lpage>. <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.ipl.2010.07.027" xlink:type="simple">https://doi.org/10.1016/j.ipl.2010.07.027</ext-link></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref013">
<label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>van Iersel</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Moulton</surname> <given-names>V</given-names></name>. <article-title>Trinets encode tree-child and level-2 phylogenetic networks</article-title>. <source>Journal of Mathematical Biology</source>. <year>2014</year>;<volume>68</volume>(<issue>7</issue>):<fpage>1707</fpage>–<lpage>1729</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00285-013-0683-5" xlink:type="simple">10.1007/s00285-013-0683-5</ext-link></comment> <object-id pub-id-type="pmid">23680992</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Semple</surname> <given-names>C</given-names></name>. <article-title>Phylogenetic Networks with Every Embedded Phylogenetic Tree a Base Tree</article-title>. <source>Bulletin of Mathematical Biology</source>. <year>2016</year>;<volume>78</volume>(<issue>1</issue>):<fpage>132</fpage>–<lpage>137</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s11538-015-0132-2" xlink:type="simple">10.1007/s11538-015-0132-2</ext-link></comment> <object-id pub-id-type="pmid">26670315</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref015">
<label>15</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Bordewich</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Semple</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Tokac</surname> <given-names>N</given-names></name>. <article-title>Constructing Tree-Child Networks from Distance Matrices</article-title>. <source>Algorithmica</source>. <year>2018</year>;<volume>80</volume>(<issue>8</issue>):<fpage>2240</fpage>–<lpage>2259</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00453-017-0320-6" xlink:type="simple">10.1007/s00453-017-0320-6</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref016">
<label>16</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Gambette</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>van Iersel</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Jones</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Lafond</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Pardi</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Scornavacca</surname> <given-names>Celine</given-names></name>. <article-title>Rearrangement Moves on Rooted Phylogenetic Networks</article-title>. <source>PLoS Computational Biology</source> <year>2017</year>;<volume>8</volume>(<issue>13</issue>):<fpage>e1005611</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1005611" xlink:type="simple">10.1371/journal.pcbi.1005611</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref017">
<label>17</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Pardi</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Scornavacca</surname> <given-names>C</given-names></name>. <article-title>Reconstructible phylogenetic networks: do not distinguish the indistinguishable</article-title>. <source>PLoS computational biology</source>. <year>2015</year>;<volume>11</volume>(<issue>4</issue>):<fpage>e1004135</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1004135" xlink:type="simple">10.1371/journal.pcbi.1004135</ext-link></comment> <object-id pub-id-type="pmid">25849429</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref018">
<label>18</label>
<mixed-citation publication-type="other" xlink:type="simple">Gunawan AD, Rathin J, Zhang L. Counting and Enumerating Galled Networks. arXiv e-prints. 2018; p. arXiv:1812.08569.</mixed-citation>
</ref>
<ref id="pcbi.1007347.ref019">
<label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>McDiarmid</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Semple</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Welsh</surname> <given-names>D</given-names></name>. <article-title>Counting Phylogenetic Networks</article-title>. <source>Annals of Combinatorics</source>. <year>2015</year>;<volume>19</volume>(<issue>1</issue>):<fpage>205</fpage>–<lpage>224</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00026-015-0260-2" xlink:type="simple">10.1007/s00026-015-0260-2</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref020">
<label>20</label>
<mixed-citation publication-type="other" xlink:type="simple">Fuchs M, Gittenberger B, Mansouri M. Counting Phylogenetic Networks with Few Reticulation Vertices: Tree-Child and Normal Networks. arXiv e-prints. 2018; p. arXiv:1803.11325.</mixed-citation>
</ref>
<ref id="pcbi.1007347.ref021">
<label>21</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Cardona</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Llabrés</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Rosselló</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Valiente</surname> <given-names>G</given-names></name>. <article-title>A distance metric for a class of tree-sibling phylogenetic networks</article-title>. <source>Bioinformatics</source>. <year>2008</year>;<volume>24</volume>(<issue>13</issue>):<fpage>1481</fpage>–<lpage>1488</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/bioinformatics/btn231" xlink:type="simple">10.1093/bioinformatics/btn231</ext-link></comment> <object-id pub-id-type="pmid">18477576</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref022">
<label>22</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Cardona</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Llabrés</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Rosselló</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Valiente</surname> <given-names>G</given-names></name>. <article-title>Metrics for phylogenetic networks II: Nodal and triplets metrics</article-title>. <source>IEEE/ACM Transactions on Computational Biology and Bioinformatics</source>. <year>2009</year>;<volume>6</volume>(<issue>3</issue>):<fpage>454</fpage>–<lpage>469</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1109/TCBB.2008.127" xlink:type="simple">10.1109/TCBB.2008.127</ext-link></comment> <object-id pub-id-type="pmid">19644173</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref023">
<label>23</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Oldman</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Van Iersel</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Moulton</surname> <given-names>V</given-names></name>. <article-title>Trilonet: piecing together small networks to reconstruct reticulate evolutionary histories</article-title>. <source>Molecular biology and evolution</source>. <year>2016</year>;<volume>33</volume>(<issue>8</issue>):<fpage>2151</fpage>–<lpage>2162</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/molbev/msw068" xlink:type="simple">10.1093/molbev/msw068</ext-link></comment> <object-id pub-id-type="pmid">27189565</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref024">
<label>24</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Huber</surname> <given-names>KT</given-names></name>, <name name-style="western"><surname>Van Iersel</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Moulton</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Scornavacca</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>T</given-names></name>. <article-title>Reconstructing phylogenetic level-1 networks from nondense binet and trinet sets</article-title>. <source>Algorithmica</source>. <year>2017</year>;<volume>77</volume>(<issue>1</issue>):<fpage>173</fpage>–<lpage>200</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s00453-015-0069-8" xlink:type="simple">10.1007/s00453-015-0069-8</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref025">
<label>25</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Jin</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Nakhleh</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Snir</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Tuller</surname> <given-names>T</given-names></name>. <article-title>Maximum likelihood of phylogenetic networks</article-title>. <source>Bioinformatics</source>. <year>2006</year>;<volume>22</volume>(<issue>21</issue>):<fpage>2604</fpage>–<lpage>2611</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/bioinformatics/btl452" xlink:type="simple">10.1093/bioinformatics/btl452</ext-link></comment> <object-id pub-id-type="pmid">16928736</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref026">
<label>26</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Meng</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Kubatko</surname> <given-names>LS</given-names></name>. <article-title>Detecting hybrid speciation in the presence of incomplete lineage sorting using gene tree incongruence: a model</article-title>. <source>Theoretical population biology</source>. <year>2009</year>;<volume>75</volume>(<issue>1</issue>):<fpage>35</fpage>–<lpage>45</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.tpb.2008.10.004" xlink:type="simple">10.1016/j.tpb.2008.10.004</ext-link></comment> <object-id pub-id-type="pmid">19038278</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007347.ref027">
<label>27</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Gusfield</surname> <given-names>D</given-names></name>. <source>ReCombinatorics: the algorithmics of ancestral recombination graphs and explicit phylogenetic networks</source>. <publisher-name>MIT press</publisher-name>; <year>2014</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007347.ref028">
<label>28</label>
<mixed-citation publication-type="other" xlink:type="simple">Cardona G, Sánchez D. PhyloNetworks: A Python library for phylogenetic networks; 2012. Available from: <ext-link ext-link-type="uri" xlink:href="https://pypi.org/project/phylonetwork/" xlink:type="simple">https://pypi.org/project/phylonetwork/</ext-link>.</mixed-citation>
</ref>
</ref-list>
</back>
</article>