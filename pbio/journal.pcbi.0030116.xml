<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="discussion" dtd-version="3.0" xml:lang="EN">
	<front>
		<journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="publisher">pcbi</journal-id><journal-id journal-id-type="allenpress-id">plcb</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher>
				<publisher-name>Public Library of Science</publisher-name>
				<publisher-loc>San Francisco, USA</publisher-loc>
			</publisher></journal-meta>
		<article-meta><article-id pub-id-type="doi">10.1371/journal.pcbi.0030116</article-id><article-id pub-id-type="sici">plcb-03-06-17</article-id><article-categories>
				<subj-group subj-group-type="heading">
					<subject>Education</subject>
				</subj-group>
				<subj-group subj-group-type="Discipline">
					<subject>Computer Science</subject>
					<subject>Mathematics/Statistics</subject>
					<subject>Computational Biology/Genomics</subject>
				</subj-group>
			</article-categories><title-group><article-title>Machine Learning and Its Applications to Biology</article-title></title-group><contrib-group>
				<contrib contrib-type="author" xlink:type="simple">
					<name name-style="western">
						<surname>Tarca</surname>
						<given-names>Adi L</given-names>
					</name>
				</contrib>
				<contrib contrib-type="author" xlink:type="simple">
					<name name-style="western">
						<surname>Carey</surname>
						<given-names>Vincent J</given-names>
					</name>
				</contrib>
				<contrib contrib-type="author" xlink:type="simple">
					<name name-style="western">
						<surname>Chen</surname>
						<given-names>Xue-wen</given-names>
					</name>
				</contrib>
				<contrib contrib-type="author" xlink:type="simple">
					<name name-style="western">
						<surname>Romero</surname>
						<given-names>Roberto</given-names>
					</name>
				</contrib>
				<contrib contrib-type="author" xlink:type="simple">
					<name name-style="western">
						<surname>Drăghici</surname>
						<given-names>Sorin</given-names>
					</name>
					<xref ref-type="corresp" rid="cor1"><sup>*</sup></xref>
				</contrib>
			</contrib-group><contrib-group>
				<contrib contrib-type="editor" xlink:type="simple">
					<name name-style="western">
						<surname>Lewitter</surname>
						<given-names>Fran</given-names>
					</name>
					<role>Editor</role><xref ref-type="aff" rid="edit1"/>
				</contrib>
			</contrib-group><aff id="edit1">Whitehead Institute, United States of America</aff><author-notes>
			<fn fn-type="con" id="ack1">
				<p>ALT, VJC, XwC, RR, and SD wrote various sections of the paper. VJC and ALT wrote the sample R code.</p>
			</fn>			<fn fn-type="current-aff" id="n103">
				<p>Adi L. Tarca and Roberto Romero are with the Perinatology Research Branch, NICHD/NIH/DHHS, Detroit, Michigan, United States of America. Adi L. Tarca and Sorin Drăghici are with the Department of Computer Science, Wayne State University, Detroit, Michigan, United States of America. Vincent J. Carey is with the Harvard Medical School, Channing Laboratory, Boston, Massachusetts, United States of America. Xue-wen Chen is with the Bioinformatics and Computational Life Sciences Laboratory, Department of Electrical Engineering and Computer Science, University of Kansas, Lawrence, Kansas, United States of America.</p>
			</fn>				<corresp id="cor1">* To whom correspondence should be addressed. E-mail: <email xlink:type="simple">sorin@wayne.edu</email></corresp>
			<fn fn-type="conflict" id="ack3">
				<p> The authors have declared that no competing interests exist.</p>
			</fn></author-notes><pub-date pub-type="ppub">
				<month>6</month>
				<year>2007</year>
			</pub-date><pub-date pub-type="epub">
				<day>29</day>
				<month>6</month>
				<year>2007</year>
			</pub-date><volume>3</volume><issue>6</issue><elocation-id>e116</elocation-id><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2007</copyright-year><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Public Domain declaration which stipulates that, once placed in the public domain, this work may be freely reproduced, distributed, transmitted, modified, built upon, or otherwise used by anyone for any lawful purpose.</license-p></license></permissions><funding-group><funding-statement>The authors received no specific funding for this article.</funding-statement></funding-group><counts>
				<page-count count="11"/>
			</counts><!--===== Restructure custom-meta-wrap to custom-meta-group =====--><custom-meta-group>
				<custom-meta>
					<meta-name>citation</meta-name>
					<meta-value>Tarca AL, Carey VJ, Chen XW, Romero R, Drăghici S (2007) Machine learning and its applications to biology. PLoS Comput Biol 3(6): e116. doi:<ext-link ext-link-type="doi" xlink:href="http://dx.doi.org/10.1371/journal.pcbi.0030116" xlink:type="simple">10.1371/journal.pcbi.0030116</ext-link></meta-value>
				</custom-meta>
				<custom-meta>
					<meta-name>article-logo</meta-name>
					<meta-value>tutorial_logo.jpg</meta-value>
				</custom-meta>
			</custom-meta-group></article-meta>
	</front>
	<body>
		<p><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.tutorial_logo" xlink:type="simple"/></p>
		<sec id="s1">
			<title>Introduction</title>
			<p>The term <italic>machine learning</italic> refers to a set of topics dealing with the creation and evaluation of algorithms that facilitate pattern recognition, classification, and prediction, based on models derived from existing data. Two facets of mechanization should be acknowledged when considering machine learning in broad terms. Firstly, it is intended that the classification and prediction tasks can be accomplished by a suitably programmed computing machine. That is, the product of machine learning is a classifier that can be feasibly used on available hardware. Secondly, it is intended that the creation of the classifier should itself be highly mechanized, and should not involve too much human input. This second facet is inevitably vague, but the basic objective is that the use of automatic algorithm construction methods can minimize the possibility that human biases could affect the selection and performance of the algorithm. Both the creation of the algorithm and its operation to classify objects or predict events are to be based on concrete, observable data.</p>
			<p>The history of relations between biology and the field of machine learning is long and complex. An early technique [<xref ref-type="bibr" rid="pcbi-0030116-b001">1</xref>] for machine learning called the perceptron constituted an attempt to model actual neuronal behavior, and the field of artificial neural network (ANN) design emerged from this attempt. Early work on the analysis of translation initiation sequences [<xref ref-type="bibr" rid="pcbi-0030116-b002">2</xref>] employed the perceptron to define criteria for start sites in <named-content content-type="genus-species" xlink:type="simple">Escherichia coli</named-content>. Further artificial neural network architectures such as the adaptive resonance theory (ART) [<xref ref-type="bibr" rid="pcbi-0030116-b003">3</xref>] and neocognitron [<xref ref-type="bibr" rid="pcbi-0030116-b004">4</xref>] were inspired from the organization of the visual nervous system. In the intervening years, the flexibility of machine learning techniques has grown along with mathematical frameworks for measuring their reliability, and it is natural to hope that machine learning methods will improve the efficiency of discovery and understanding in the mounting volume and complexity of biological data.</p>
			<p>This tutorial is structured in four main components. Firstly, a brief section reviews definitions and mathematical prerequisites. Secondly, the field of supervised learning is described. Thirdly, methods of unsupervised learning are reviewed. Finally, a section reviews methods and examples as implemented in the open source data analysis and visualization language R (<ext-link ext-link-type="uri" xlink:href="http://www.r-project.org" xlink:type="simple">http://www.r-project.org</ext-link>).</p>
		</sec>
		<sec id="s2">
			<title>Main Concepts and Definitions</title>
			<p>Two main paradigms exist in the field of machine learning: <italic>supervised</italic> and <italic>unsupervised</italic> learning. Both have potential applications in biology.</p>
			<p>In supervised learning, objects in a given collection are classified using a set of attributes, or features. The result of the classification process is a set of rules that prescribe assignments of objects to classes based solely on values of features. In a biological context, examples of <italic>object</italic>-to-<italic>class</italic> mappings are tissue gene expression profiles to disease group, and protein sequences to their secondary structures. The features in these examples are the expression levels of individual genes measured in the tissue samples and the presence/absence of a given amino acid symbol at a given position in the protein sequence, respectively. The goal in supervised learning is to design a system able to accurately predict the class membership of new objects based on the available features. Besides predicting a categorical characteristic such as class label, (similar to classical <italic>discriminant analysis</italic>), supervised techniques can be applied as well to predict a continuous characteristic of the objects (similar to <italic>regression analysis</italic>). In any application of supervised learning, it would be useful for the classification algorithm to return a value of “doubt” (indicating that it is not clear which one of several possible classes the object should be assigned to) or “outlier” (indicating that the object is so unlike any previously observed object that the suitability of any decision on class membership is questionable).</p>
			<p>In contrast to the supervised framework, in unsupervised learning, no predefined class labels are available for the objects under study. In this case, the goal is to explore the data and discover similarities between objects. Similarities are used to define groups of objects, referred to as <italic>clusters</italic>. In other words, unsupervised learning is intended to unveil natural groupings in the data. Thus, the two paradigms may informally be contrasted as follows: in supervised learning, the data come with class labels, and we learn how to associate labeled data with classes; in unsupervised learning, all the data are unlabeled, and the learning procedure consists of both defining the labels and associating objects with them.</p>
			<p>In some applications, such as protein structure classification, only a few labeled samples (protein sequences with known structure class) are available, while many other samples (sequences) with unknown class are available as well. In such cases, <italic>semi-supervised</italic> techniques can be applied to obtain a better classifier than could be obtained if only the labeled samples were used [<xref ref-type="bibr" rid="pcbi-0030116-b005">5</xref>]. This is possible, for instance, by making the “cluster assumption,” i.e., that class labels can be reliably transferred from labeled to unlabeled objects that are “nearby” in feature space.</p>
			<p>Life science applications of unsupervised and/or supervised machine learning techniques abound in the literature. For instance, gene expression data was successfully used to classify patients in different clinical groups and to identify new disease groups [<xref ref-type="bibr" rid="pcbi-0030116-b006">6</xref>–<xref ref-type="bibr" rid="pcbi-0030116-b009">9</xref>], while genetic code allowed prediction of the protein secondary structure [<xref ref-type="bibr" rid="pcbi-0030116-b010">10</xref>]. Continuous variable prediction with machine learning algorithms was used to estimate bias in cDNA microarray data [<xref ref-type="bibr" rid="pcbi-0030116-b011">11</xref>].</p>
			<p>To support precise characterization of both supervised and unsupervised machine learning methods, we have adopted certain mathematical notations and concepts. In the next sections, we employ vector notation (<bold>x</bold> denotes an ordered <italic>p</italic>-tuple of numbers for some integer <italic>p</italic>), matrix notation (X denotes a rectangular array of numbers, where <italic>x<sub>ij</sub></italic> will denote the number in the <italic>i</italic>th row and <italic>j</italic>th column of X), conditional probability densities, and sufficient matrix algebra to define the multivariate normal density. Necessary formal background in algebra and probability can be found elsewhere [<xref ref-type="bibr" rid="pcbi-0030116-b012">12</xref>].</p>
		</sec>
		<sec id="s3">
			<title>Supervised Learning</title>
			<sec id="s3a"><title/>
				<sec id="s3a1">
					<title>General concepts.</title>
					<p>Let us consider the general case in which we want to classify a collection of objects <italic>i</italic> = 1, . . ., <italic>n</italic> into <italic>K</italic> predefined classes. For instance, if one wants to distinguish between different types of tumors based on gene expression values, then <italic>K</italic> would represent the number of known existing tumor types. Without loss of generality, data on features can be organized in an <italic>n</italic> × <italic>p</italic> matrix X = (<italic>x<sub>ij</sub></italic>), where <italic>x<sub>ij</sub></italic> represents the measured value of the variable (feature) <italic>j</italic> in the object (sample) <italic>i</italic>. Every row of the matrix X is therefore a vector <bold>x</bold><italic><sub>i</sub></italic> with <italic>p</italic> features to which a class label <italic>y<sub>i</sub></italic> is associated, <italic>y</italic> = 1,2,. . .,<italic>c</italic>,. . .,<italic>K</italic>. In such multiclass classification problems, a classifier <italic>C</italic>(<bold>x</bold>) may be viewed as a collection of <italic>K</italic> discriminant functions <italic>g<sub>c</sub></italic>(<bold>x</bold>) such that the object with feature vector <bold>x</bold> will be assigned to the class <italic>c</italic> for which <italic>g<sub>c</sub></italic>(<bold>x</bold>) is maximized over the class labels <italic>c</italic> ∈ {1,. . .,<italic>K</italic>}. The feature space <italic>X</italic> is thus partitioned by the classifier <italic>C</italic>(<bold>x</bold>) into <italic>K</italic> disjoint subsets.</p>
					<p>There are two main approaches to the identification of the discriminant functions <italic>g<sub>c</sub></italic>(<bold>x</bold>) [<xref ref-type="bibr" rid="pcbi-0030116-b013">13</xref>]. The first assumes knowledge of the underlying class-conditional probability density functions (the probability density function of <bold>x</bold> for a given class) and assigns <italic>g<sub>c</sub></italic>(<bold>x</bold>) = <italic>f</italic>(<italic>p</italic>(<bold>x</bold> | <italic>y</italic> = <italic>c</italic>)), where <italic>f</italic> is a monotonic increasing function, for example the logarithmic function. Intuitively, the resulting classifier will classify an object <bold>x</bold> in the class in which it has the highest membership probability. In practice, <italic>p</italic>(<bold>x</bold> | <italic>y</italic> = <italic>c</italic>) is unknown, and therefore needs to be estimated from a set of correctly classified samples named <italic>training</italic> or <italic>design</italic> set. Parametric and nonparametric methods for density estimation can be used for this end. From the parametric category, we will discuss linear and quadratic discriminants, while from the nonparametric one, we will describe the <italic>k</italic>-nearest neighbor (<italic>k</italic>-NN) decision rule. The second approach is to use data to estimate the class boundaries directly, without explicit calculation of the probability density functions. Examples of algorithms in this category include decision trees, neural networks, and support vector machines (SVM).</p>
				</sec>
				<sec id="s3a2">
					<title>Error estimation.</title>
					<p>Suppose the classifier <italic>C</italic>(<bold>x</bold>) was trained to classify input vectors <bold>x</bold> into two distinct classes, 1 and 2. The classification result on a collection of input objects <bold>x</bold><italic><sub>i</sub></italic>, <italic>i</italic> = 1,. . .,<italic>n</italic> can be summarized in a <italic>confusion matrix</italic>. The confusion matrix contrasts the predicted class labels of the objects <inline-formula id="pcbi-0030116-ex001"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030116.ex001" xlink:type="simple"/></inline-formula>
						 with the true (given) class labels <italic>y<sub>i</sub></italic>. An example confusion matrix computed for 100 objects is:
						<disp-formula id="pcbi-0030116-e001"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e001" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mo>1</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mo>2</mml:mo></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mo>1</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mrow><mml:mn>30</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mo>2</mml:mo></mml:mstyle></mml:mtd><mml:mtd><mml:mrow><mml:mn>20</mml:mn></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mn>40</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>The <italic>error rate</italic> (<italic>Err</italic>) of the classifier is defined as the average number of misclassified samples, i.e., the sum of off-diagonal elements of the confusion matrix, divided by the total number of objects. In the example above, <italic>Err</italic> = (10 + 20) / 100 = 30%. Conversely, the <italic>accuracy</italic> of the classifier can be defined as <italic>Acc</italic> = 1 − <italic>Err</italic> = 70% and represents the fraction of samples successfully classified.</p>
					<p>The goal behind developing classification models is to use them to predict the class membership of <italic>new samples</italic>. If the data used to build the classifier is also used to compute the error rate, then the resulting error estimate, called the <italic>resubstitution</italic> estimate, will be optimistically biased [<xref ref-type="bibr" rid="pcbi-0030116-b014">14</xref>]. A better way to assess the error is the <italic>hold-out</italic> procedure in which one splits the data into two equal parts. The first half is used to train the classifier (the <italic>training set</italic>), while the remaining half is used to assess the error (the <italic>test set</italic>). With biological data, this approach is rarely feasible due to the paucity of the data. A more appropriate alternative is the <italic>leave-one-out</italic> cross-validation method (LOO) which trains the classifier <italic>n</italic> times on (<italic>n</italic> − 1) samples, omitting each observation in turn for testing the classifier. The <italic>n</italic> test results obtained in this way can be arranged into a confusion matrix, and <italic>Err</italic> estimated by the proportion of off-diagonal elements. Although the estimate of the error obtained with the leave-one-out procedure gives low bias, it may show high variance [<xref ref-type="bibr" rid="pcbi-0030116-b015">15</xref>]. A good tradeoff between bias and variance may be obtained by using <italic>N-fold cross-validation</italic> in which the dataset is split into (<italic>n</italic> − <italic>m</italic>) training points and <italic>m</italic> test points (<italic>N</italic> = <italic>n/m</italic>). Using multiple resampling, one can obtain a mean, as well as a standard deviation, for the classifier error.</p>
				</sec>
				<sec id="s3a3">
					<title>Types of classifiers.</title>
					<p><italic>Quadratic and linear discriminants.</italic> A standard classification approach, applicable when the features are continuous variables (e.g., gene expression data), assumes that for each class <italic>c</italic>, <bold>x</bold> follows a multivariate normal distribution <italic>N</italic>(<bold>m</bold><italic><sub>c</sub></italic>,Σ<italic><sub>c</sub></italic>) having the mean <bold>m</bold><italic><sub>c</sub></italic> and covariance matrix Σ<italic><sub>c</sub>.</italic> The covariance matrix Σ is square with dimension <italic>p</italic> × <italic>p</italic>. The element <italic>i</italic>,<italic>j</italic> of this matrix is the covariance between the variables <italic>i</italic> and <italic>j</italic>.</p>
					<p>Using the multivariate-normal probability density function and replacing the true class means and covariance matrices with sample-derived estimates (<bold>m</bold><italic><sub>c</sub></italic> and <inline-formula id="pcbi-0030116-ex002"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030116.ex002" xlink:type="simple"/></inline-formula>
						<sub>c</sub>, respectively), the discriminant function for each class can be computed as:
						<disp-formula id="pcbi-0030116-e002"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e002" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo>&minus;</mml:mo><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&minus;</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>m</mml:mi></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy='false'>)</mml:mo><mml:msubsup><mml:mstyle displaystyle='true'><mml:mover accent='true'><mml:mi>&Sigma;</mml:mi><mml:mo>&circ;</mml:mo></mml:mover></mml:mstyle><mml:mi>c</mml:mi><mml:mrow><mml:mo>&minus;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&minus;</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>m</mml:mi></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mo>&minus;</mml:mo><mml:mtext>log</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mo>|</mml:mo><mml:msub><mml:mstyle displaystyle='true'><mml:mover accent='true'><mml:mi>&Sigma;</mml:mi><mml:mo>&circ;</mml:mo></mml:mover></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo stretchy='false'>)</mml:mo></mml:mrow></mml:math> --></disp-formula>where
						<disp-formula id="pcbi-0030116-e003"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e003" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>m</mml:mi></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:msubsup><mml:mi>&Sigma;</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math> --></disp-formula>and
						<disp-formula id="pcbi-0030116-e004"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e004" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mstyle displaystyle='true'><mml:mover accent='true'><mml:mi>&Sigma;</mml:mi><mml:mo>&circ;</mml:mo></mml:mover></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:msubsup><mml:mi>&Sigma;</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:msub></mml:mrow></mml:msubsup><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo>&minus;</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>m</mml:mi></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mo>&minus;</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>m</mml:mi></mml:mstyle><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mrow></mml:mrow></mml:msup></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>The discriminant functions are monotonically related to the densities <italic>p</italic>(<bold>x</bold> | <italic>y</italic> = <italic>c</italic>), yielding higher values for larger densities. The values of the discriminant functions will differ from one class to another only on the basis of the estimates of the class mean and covariance matrix. A new object <bold>z</bold> will be classified in the class for which the discriminant is the largest. This classification approach produces nonlinear (quadratic) class boundaries, giving the name of the classifier as <italic>quadratic discriminant</italic> rule or <named-content content-type="genus-species" xlink:type="simple">Gaussian classifier</named-content>.</p>
					<p>An alternative to this quadratic classifier is to assume that the class covariance matrices Σ<italic><sub>c</sub></italic>, <italic>c</italic> = 1,. . .,<italic>K</italic> are all the same. In this case, instead of using a different covariance matrix estimate for each class, a single pooled covariance matrix is used. This can be especially useful when the number of samples per class is low. In this case, calculating a covariance matrix from only a few samples may produce very unreliable estimates. Better results may be obtained by assuming a common variance and using all samples to estimate a single covariance matrix. The resulting classifier uses hyperplanes as class boundaries, hence the name <italic>normal-based linear discriminant</italic>.</p>
					<p>To cope with situations when the number of features is comparable with the number of samples, a further simplification can be made to the normal-based linear discriminant, by setting all off-diagonal elements in the covariance matrix to zero. This implies that between-features covariation is disregarded. Such a <italic>diagonal linear discriminant</italic> was found to outperform other types of classifiers on a variety of microarray analyses [<xref ref-type="bibr" rid="pcbi-0030116-b016">16</xref>].</p>
					<p>The above-presented classifiers work optimally when their underlying assumptions are met, such as the normality assumption. In many cases, some of the assumptions may not be met. However, (as pointed out by one of the anonymous reviewers) what matters in the end for a practical application is how close the estimated class boundaries are to the true class boundaries. This can be assessed through a cross-validation process.</p>
					<p>In very recent work, Guo and colleagues [<xref ref-type="bibr" rid="pcbi-0030116-b017">17</xref>] have presented a regularized linear discriminant analysis procedure useful when the number of features far exceeds the number of samples.</p>
					<p><italic>k-Nearest neighbor classifier.</italic> The <italic>k</italic>-NN classifier can be seen as a nonparametric method of density estimation [<xref ref-type="bibr" rid="pcbi-0030116-b013">13</xref>] and uses no assumption on the data distribution, except for the continuity of the feature variables. The <italic>k</italic>-NN classifier does not require model fitting but simply stores the training dataset with all available vector prototypes of each class. When a new object <bold>z</bold> needs to be classified, the first step in the algorithm is to compute the distance between <bold>z</bold> and all the available objects in the training set, <bold>x</bold><italic><sub>i</sub></italic>, <italic>i</italic> = 1,. . .,<italic>n</italic>. A popular choice of distance metric is the Euclidean distance: <inline-formula id="pcbi-0030116-ex003"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030116.ex003" xlink:type="simple"/></inline-formula>
						. A thorough discussion of distance functions with application to microarray analysis is given by Gentleman et al. [<xref ref-type="bibr" rid="pcbi-0030116-b018">18</xref>].
					</p>
					<p>The distances are ordered and the top <italic>k</italic> training samples (closest to the new object to be predicted) are retained. Let us denote with <italic>n<sub>c</sub></italic> the number of objects in the training dataset among the <italic>k</italic> ones which belong to the class <italic>c</italic>. The <italic>k</italic>-NN classification rule classifies the new object <bold>z</bold> in the class that maximizes <italic>n<sub>c</sub></italic>, i.e., the class that is most common among the closest <italic>k</italic> neighbors. The <italic>k</italic>-NN discriminant functions can be written as <italic>g<sub>c</sub></italic>(<bold>x</bold>) = <italic>n<sub>c</sub></italic>. When two or more classes are equally represented in the vicinity of the point <bold>z</bold>, the class whose prototypes have the smallest average distance to <bold>z</bold> may be chosen.</p>
					<p><italic>Decision trees.</italic> A special type of classifier is the decision tree [<xref ref-type="bibr" rid="pcbi-0030116-b019">19</xref>], which is trained by an iterative selection of individual features that are the most salient at each node in the tree. The input space <italic>X</italic> is repeatedly split into descendant subsets, starting with <italic>X</italic> itself. There are several heuristic methods for constructing decision-tree classifiers. They are usually constructed top-down, beginning at the root node and successively partitioning the feature space. The construction involves three main steps. 1) Selecting a splitting rule for each internal node, i.e., determining the feature together with a threshold that will be used to partition the dataset at each node. 2) Determining which nodes are terminal nodes. This means that for each node we must decide whether to continue splitting or to make the node terminal and assign to it a class label. 3) Assigning class labels to terminal nodes by minimizing the estimated error rate.</p>
					<p>The most commonly used decision tree classifiers are binary. They use a single feature at each node, resulting in decision boundaries that are parallel to the feature axes (see <xref ref-type="fig" rid="pcbi-0030116-g001">Figure 1</xref>). Although they are intrinsically suboptimal, the resulting classifier is easy to interpret.</p>
					<fig id="pcbi-0030116-g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g001</object-id>
						<label>Figure 1</label>
						<caption>
							<title>Binary Decision Tree</title>
							<p>The left panel shows the data for a two-class decision problem, with dimensionality <italic>p</italic> = 2. The points known to belong to classes 1 and 2 are displayed with filled circles and squares, respectively. The decision boundary is shown as the blue thick line in the left panel. The triangle designates a new point, <bold>z</bold>, to be classified. The right panel shows the decision tree derived for this dataset whereas the new point <bold>z</bold> is classified in class 2 (squares). The regions in the input space covered by nodes I and IV in the tree are represented by the dashed areas at the top and bottom of the left panel, respectively.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g001" xlink:type="simple"/>
					</fig>
					<p><italic>Neural networks.</italic> The most common neural network architecture used in classification problems is a fully connected, three-layered structure of nodes in which the signals are propagated from the input to the output layer via the hidden layer (see <xref ref-type="fig" rid="pcbi-0030116-g002">Figure 2</xref>). The input layer only feeds the values of the feature vector <bold>x</bold> to the hidden layer. Each hidden unit weights differently all outputs of the input layer, adds a bias term, and transforms the result using a nonlinear function, usually the logistic sigmoid:
						<disp-formula id="pcbi-0030116-e005"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e005" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mi>&sigma;</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mn>1</mml:mn><mml:mo>&plus;</mml:mo><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>p</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math> --></disp-formula>
					</p>
					<fig id="pcbi-0030116-g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g002</object-id>
						<label>Figure 2</label>
						<caption>
							<title>A Schematic Representation of a Feed-Forward Three-Layered Neural Network</title>
							<p>Two-dimensional data points (<italic>p =</italic> 2) are classified into <italic>K</italic> = 2 known classes. The sigmoid hidden and output units are shown as white circles containing an S-like red curve.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g002" xlink:type="simple"/>
					</fig>
					<p>Similarly to the hidden layer, the output layer processes the output of the hidden layer. Usually there is one output unit for each class. The discriminant function implemented by the <italic>k</italic>th output unit of such a neural network can be written as:
						<disp-formula id="pcbi-0030116-e006"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e006" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mi>g</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mi>&sigma;</mml:mi><mml:mo stretchy='false'>&lsqb;</mml:mo><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>J</mml:mi></mml:munderover></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msub><mml:mi>&alpha;</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mi>&sigma;</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:munderover></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>w</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&plus;</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mi>j</mml:mi><mml:mi>h</mml:mi></mml:msubsup><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo><mml:msubsup><mml:mi>b</mml:mi><mml:mi>k</mml:mi><mml:mi>o</mml:mi></mml:msubsup><mml:mo stretchy='false'>&rsqb;</mml:mo></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>In this equation, <italic>w<sub>i</sub></italic><sub>,<italic>j</italic></sub> is the weight from the <italic>i</italic>th input unit to the <italic>j</italic>th hidden node, <italic>α<sub>j</sub></italic><sub>,<italic>k</italic></sub> is the weight from the <italic>j</italic>th hidden unit to the <italic>k</italic>th output node, <inline-formula id="pcbi-0030116-ex004"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030116.ex004" xlink:type="simple"/></inline-formula>
						 is the bias term of the <italic>j</italic>th hidden unit, <inline-formula id="pcbi-0030116-ex005"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030116.ex005" xlink:type="simple"/></inline-formula>
						 is the bias term of the <italic>k</italic>th output unit. They all represent adjustable parameters and are estimated (learned) during the training process that minimizes a loss function. A commonly used loss function is the sum of squared errors between the predicted and expected signal at the output nodes, given a training dataset.
					</p>
					<p>Consider that <italic>N<sub>T</sub></italic> training samples are available to train a neural network with <italic>K</italic> output units. The error of the neural network on the training set can be computed as:
						<disp-formula id="pcbi-0030116-e007"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e007" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mi>E</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>&omega;</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>s</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:munderover></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msub><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>&omega;</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo></mml:mrow></mml:math> --></disp-formula>where <bold>ω</bold> represents all the adjustable parameters of the neural network (weights and biases) which are initialized with small random values, and <italic>e<sub>s</sub></italic> is the error obtained when the <italic>s</italic>th training sample is used as input into the network. The error <italic>e<sub>s</sub></italic> is defined as proportional to the sum of squared differences between the expected outputs of the network and the actual outputs, given the current values of the weights, i.e.,
						<disp-formula id="pcbi-0030116-e008"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e008" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>K</mml:mi></mml:munderover></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>&minus;</mml:mo><mml:msub><mml:mi>g</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>Here, <italic>g<sub>s</sub></italic><sub>,<italic>k</italic></sub> represents the actual output of the unit <italic>k</italic> for the sample <italic>s</italic>, while <italic>g<sub>s</sub></italic><sub>,<italic>k</italic></sub> is the desired (target) output value for the same sample. When a sample belongs to the class <italic>k</italic>, it is desired that the output unit <italic>k</italic> fires a value of 1, while all the other output units fire 0. The learning process is done by updating the parameters <bold>ω</bold> such that global error decreases in an iterative process. A popular update rule is the back-propagation rule [<xref ref-type="bibr" rid="pcbi-0030116-b020">20</xref>], in which the adjustable parameters <bold>ω</bold> are changed (increased or decreased) toward the direction in which the training error <italic>E</italic>(<bold>ω</bold>) decreases the most.</p>
					<p><xref ref-type="disp-formula" rid="pcbi-0030116-e006">Equation 6</xref> above can be modified in a way that the training process not only minimizes the sum of squared errors on the training set, but also the sum of squared weights of the network. This <italic>weights regularization</italic> enhances the generalization capability of the model by preventing small variations in the inputs to have excessive impact on the output. The underlying assumption of the weights regularization is that the boundaries between the classes are not sharp.</p>
					<p>For more details on theory and practical use of neural networks, please see Duda et al. [<xref ref-type="bibr" rid="pcbi-0030116-b012">12</xref>], Ripley [<xref ref-type="bibr" rid="pcbi-0030116-b021">21</xref>], Venables and Ripley [<xref ref-type="bibr" rid="pcbi-0030116-b022">22</xref>], and references therein.</p>
					<p><italic>Support vector machines.</italic> Consider a two-class, linearly separable classification problem, as shown in <xref ref-type="fig" rid="pcbi-0030116-g003">Figure 3</xref>, left panel. While many decision boundaries exist that are capable of separating all the training samples into two classes correctly, a natural question to ask is: are all the decision boundaries equally good? Here the goodness of decision boundaries is to be evaluated as described previously by cross-validation. Among these decision boundaries, SVMs find the one that achieves maximum margin between the two classes. From statistical learning theory, the decision functions derived by maximizing the margin minimize the theoretical upper bound on the expected risk and are thus expected to generalize well [<xref ref-type="bibr" rid="pcbi-0030116-b023">23</xref>]. The margin is defined as the distance between a planar decision surface that separates two classes and the closest training samples to the decision surface (see <xref ref-type="fig" rid="pcbi-0030116-g003">Figure 3</xref>, right panel). Let us denote with <inline-formula id="pcbi-0030116-ex006"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030116.ex006" xlink:type="simple"/></inline-formula>
						 the labeled training dataset where <bold>x</bold><italic><sub>i</sub></italic> ∈ ℜ<italic><sup>p</sup></italic>, <italic>y<sub>i</sub></italic> ∈ {−1,+1}. SVMs find an optimal hyperplane <bold>wx</bold><italic><sup>T</sup></italic> + <italic>b</italic> = 0, where <bold>w</bold> is the <italic>p</italic>-dimensional vector perpendicular to the hyperplane and <italic>b</italic> is the bias. The objective of training SVMs is to find <bold>w</bold> and <italic>b</italic> such that the hyperplane separates the data and maximizes the margin 1 / || <bold>w</bold> ||<sup>2</sup> (<xref ref-type="fig" rid="pcbi-0030116-g003">Figure 3</xref>, right panel). By introducing non-negative slack variables <italic>ξ<sub>i</sub></italic> and a penalty function measuring classification errors, the linear SVM problem is formulated as follows:
						<disp-formula id="pcbi-0030116-e009"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e009" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:munder><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>w</mml:mi></mml:mstyle></mml:munder><mml:mo stretchy='false'>(</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:mo>&Verbar;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>w</mml:mi></mml:mstyle><mml:msup><mml:mrow><mml:mo>&Verbar;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>&plus;</mml:mo><mml:mi>C</mml:mi><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>T</mml:mi></mml:msub></mml:mrow></mml:munderover></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msub><mml:mi>&xi;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy='false'>)</mml:mo></mml:mrow></mml:math> --></disp-formula>subject to constraints:
						<disp-formula id="pcbi-0030116-e010"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e010" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>w</mml:mi></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msubsup><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>i</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:mo>&plus;</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&minus;</mml:mo><mml:mn>1</mml:mn><mml:mo>&plus;</mml:mo><mml:msub><mml:mi>&xi;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&ge;</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>&forall;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math> --></disp-formula>where <italic>C</italic> is a parameter to be set by the user, which controls the penalty to errors. The optimization problem can be reduced to a dual problem with solutions given by solving a quadratic programming problem [<xref ref-type="bibr" rid="pcbi-0030116-b023">23</xref>]. The decision function is simply
						<disp-formula id="pcbi-0030116-e011"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e011" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>w</mml:mi></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msup><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mo>&plus;</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle displaystyle='true'><mml:munder><mml:mo>&sum;</mml:mo><mml:mi>i</mml:mi></mml:munder></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msub><mml:mi>&alpha;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>i</mml:mi></mml:msub><mml:mtext>&thinsp;</mml:mtext><mml:msup><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo><mml:mi>b</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:mrow></mml:math> --></disp-formula>where <italic>α<sub>i</sub></italic> are coefficients that can be solved through the dual problem. Data points with nonzero <italic>α<sub>i</sub></italic> are called support vectors (SVs) (e.g., <xref ref-type="fig" rid="pcbi-0030116-g003">Figure 3</xref>, right panel). In SVMs, only SVs contribute to the construction of the decision boundaries.
					</p>
					<fig id="pcbi-0030116-g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g003</object-id>
						<label>Figure 3</label>
						<caption>
							<title>Support Vector Machines Class Boundaries</title>
							<p>Two-dimensional data points belonging to two different classes (circles and squares) are shown in the left panel. The right panel shows the maximum-margin decision boundary implemented by the SVMs. Samples along the dashed lines are called SVs.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g003" xlink:type="simple"/>
					</fig>
					<p>The linear SVMs can be readily extended to nonlinear SVMs where more sophisticated decision boundaries are needed. This is done by applying a kernel transformation, i.e., simply replacing every matrix product (<bold>x</bold><italic><sub>i</sub></italic><bold>x</bold><italic><sup>T</sup></italic>) in linear SVMs with a nonlinear kernel function evaluation <italic>K</italic>(<bold>x</bold><italic><sub>i</sub></italic><bold>x</bold>). This is equivalent to transforming the original input space <italic>X</italic> nonlinearly into a high-dimensional feature space. The training data that are not linearly separable in the original feature space can be linearly separated in the transformed feature space. Consequently, the decision boundaries are linear in the projected high-dimensional feature space and nonlinear in the original input space. Two commonly used kernels include polynomial
						<disp-formula id="pcbi-0030116-e012"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e012" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mi>K</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msup><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mo>&plus;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mi>d</mml:mi></mml:msup></mml:mrow></mml:math> --></disp-formula>and radial basis function (RBF)
						<disp-formula id="pcbi-0030116-e013"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e013" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mi>K</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>p</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mo>&minus;</mml:mo><mml:mi>&gamma;</mml:mi><mml:mo>&Verbar;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&minus;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:msup><mml:mrow><mml:mo>&Verbar;</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>The kernel functions return larger values for arguments that are closer together in feature space.</p>
					<p>In constructing linear SVMs for classification, the only parameter to be selected is the penalty parameter <italic>C. C</italic> controls the tradeoff between errors of SVMs on training data and the margin. For nonlinear SVMs, the learning parameters include <italic>C</italic> and parameters associated with the kernels used, e.g., <italic>γ,</italic> in radial basis function (RBF) kernels. In practice, learning parameters are selected through cross-validation methods.</p>
					<p>To conclude, the key points with the SVMs are: a) one believes there is a representation of features in which classes can be discriminated by a single hyperplane (perhaps with only a few errors); b) one chooses the hyperplane that lies at the largest distance between sentinel cases near the class boundary (large margin); and c) one can use kernel transformations when data is not linearly separable in the original feature space, but it may be so in the transformed space.</p>
				</sec>
				<sec id="s3a4">
					<title>Dimensionality reduction.</title>
					<p>An important aspect of the classifier design is that in some applications, the dimensionality <italic>p</italic> of the input space is too high to allow a reliable estimation of the classifier's internal parameters with a limited number of samples (<italic>p</italic> ≫ <italic>n</italic>). In such situations, dimensionality reduction may be useful. There are two main categories of approaches to dimensionality reduction. The first one is to obtain a reduced number of new features by combining the existing ones, e.g., by computing a linear combination. <italic>Principal component analysis</italic> (PCA) is one particular method in this branch, in which new variables (principal directions) are identified and may be used instead of the original features. The second type of dimensionality reduction involves <italic>feature selection</italic> that seeks subsets of the original variables that are adequately predictive.</p>
					<p>A serious difficulty arises when <italic>p</italic> ≫ <italic>n</italic> is <italic>overfitting</italic>. Most of the procedures examined in this tutorial include a set of tunable parameters. The size of this set increases with <italic>p</italic>. When more tunable parameters are present, very complex relationships present in the sample can often be fit very well, particularly if <italic>n</italic> is small. Generalization error rates in such settings typically far exceed training set error rates. Reduction of the dimensionality of the feature space can help to reduce risks of overfitting. However, automated methods of dimension reduction must be employed with caution. The utility of a feature in a prediction problem may depend upon its relationships with several other features, and simple reduction methods that consider features in isolation may lead to loss of important information.</p>
					<p>The statistical pattern recognition literature classifies the approaches to feature selection into <italic>filter methods</italic> and <italic>wrapper methods</italic>. In the former category, a statistical measure (e.g., a <italic>t</italic>-test) of the marginal relevance of the features is used to filter out the features that appear irrelevant using an arbitrary threshold. For instance, marker genes for cancer prediction were chosen based on their correlation with the class distinction and then used as inputs in a classifier [<xref ref-type="bibr" rid="pcbi-0030116-b024">24</xref>].</p>
					<p>Although fast and easy to implement, such filter methods cannot take into account the joint contribution of the features. Wrapper methods use the accuracy of the resulting classifier to evaluate either each feature independently or multiple features at the same time. For instance, the accuracy of a <italic>k</italic>-NN classifier has been used to guide a genetic algorithm that searched an optimal subset of genes in a high combinatorial space [<xref ref-type="bibr" rid="pcbi-0030116-b025">25</xref>]. The main disadvantage of such methods trying to find optimal subsets of features is that they may be computationally demanding. Main advantages of wrapper methods include the ability to: a) identify the most suited features for the classifier that will be used in the end to make the decision, and b) detect eventual synergistic feature effects (joint relevance). More details on feature selection methods and classification can be found in the literature [<xref ref-type="bibr" rid="pcbi-0030116-b016">16</xref>,<xref ref-type="bibr" rid="pcbi-0030116-b026">26</xref>,<xref ref-type="bibr" rid="pcbi-0030116-b027">27</xref>].</p>
				</sec>
			</sec>
		</sec>
		<sec id="s4">
			<title>Unsupervised Learning / Cluster Analysis</title>
			<p>Clustering is a popular exploratory technique, especially with high dimensionality data such as microarray gene expression [<xref ref-type="bibr" rid="pcbi-0030116-b028">28</xref>,<xref ref-type="bibr" rid="pcbi-0030116-b029">29</xref>]. This section will introduce the main clustering approaches used with biological data.</p>
			<sec id="s4a"><title/>
				<sec id="s4a1">
					<title>Overview of clustering algorithms.</title>
					<p>Clustering aims at dividing objects into groups (clusters) using measures of similarity, such as one minus correlation or Euclidean distance. For instance, in a microarray experiment the objects can be different tissue samples that can be clustered based on <italic>p</italic>-tuples of gene expression values. Some of the most frequently used clustering techniques include <italic>hierarchical</italic> clustering and <italic>k-means</italic> clustering. Hierarchical clustering creates a hierarchical, tree-like structure of the data. A hierarchical clustering can be constructed using either a bottom-up or a top-down approach. In a bottom-up approach, each data point is initially considered a cluster per se. Subsequently, the clusters are iteratively grouped based on their similarity. In contrast, the top-down approach starts with a unique cluster containing all data points. This initial cluster is iteratively divided into smaller clusters until each cluster contains a single data point. The <italic>k</italic>-means clustering algorithm starts with a predefined number of cluster centers (<italic>k</italic>) specified by the user. Data points are assigned to these centers based on their distance from (similarity to) each center. Subsequently, an iterative process involves recalculating the position of the cluster centers based on the current membership of each cluster and reassigning the points to the <italic>k</italic> clusters. The algorithm continues until the clusters are stable, i.e., until there is no further change in the assignment of the data points.</p>
					<p>Another approach to clustering is called <italic>partitioning around medoids</italic> (PAM) [<xref ref-type="bibr" rid="pcbi-0030116-b030">30</xref>]. Similarly to <italic>k</italic>-means and hierarchical clustering, PAM starts with computing a dissimilarity matrix (<italic>n</italic> × <italic>n</italic>) from the original data structure (the <italic>n</italic> × <italic>p</italic> matrix of measurements).</p>
					<p>Any distance measure can be therefore used in conjunction with PAM. The algorithm maps the resulting distance matrix into a specified number of clusters. The medoids are representations of the cluster centers that are robust with respect to outliers. The robustness is particularly important in the common situation in which many elements do not have a clearcut membership to any specific cluster [<xref ref-type="bibr" rid="pcbi-0030116-b031">31</xref>]. A measure of cluster distinctness is the <italic>silhouette</italic> computed for each observation in a dataset, relative to a given partition of the dataset into clusters. The silhouette measure contrasts the average proximity of an observation to other observations in the partition to which it is assigned with the average proximity to observations in the nearest partition to which it is not assigned. This quantity tends to one for a “well-clustered” observation and can be negative if an observation seems to have been assigned to the wrong cluster.</p>
					<p>In many biological applications, it is desired to cluster both the features and the samples, i.e., both rows and columns of the data matrix X. For instance, with gene expression data one may be interested to cluster both the tissues samples and the genes at the same time. While <italic>k</italic>-means and hierarchical clustering methods can be used, for instance, to group genes that are co-expressed under all measured conditions, they fail to discover local expression patterns, i.e., genes co-expressed across a subset of conditions and independent under other conditions. <italic>Biclustering</italic> methods, on the other hand, allow simultaneous clustering of genes and experimental conditions and uncover local patterns in the data. Given an <italic>n</italic> × <italic>p</italic> matrix, a biclustering algorithm identifies biclusters—a subset of rows that show similar activity patterns across a subset of columns, or vice versa (see <xref ref-type="fig" rid="pcbi-0030116-g004">Figure 4</xref>).</p>
					<fig id="pcbi-0030116-g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g004</object-id>
						<label>Figure 4</label>
						<caption>
							<title>Heat Map of the ALL Data after Filtering</title>
							<p>Class membership is indicated by a magenta (NEG) or blue (BCR/ABL) stripe at the top of the plot region. Rows correspond to data features (genes), while columns correspond to data points (samples). Hierarchical clustering is applied simultaneously to both rows (genes) and columns (samples) of the expression matrix to organize the display.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g004" xlink:type="simple"/>
					</fig>
					<p><italic>Self-organizing feature maps</italic> (SOFM) [<xref ref-type="bibr" rid="pcbi-0030116-b032">32</xref>,<xref ref-type="bibr" rid="pcbi-0030116-b033">33</xref>] are produced by another popular algorithm used in unsupervised applications. Unlike the methods described above, this unsupervised neural network not only finds clusters in the data, but also allows visualization (projection) of the <italic>p</italic>-dimensional data points onto a layer of neurons (usually planar). The neurons are arranged in a rectangular or hexagonal grid and they learn to become prototypes for the training data points. Similar objects will be mapped on the same (or neighboring) neurons, while dissimilar ones will be mapped apart. Thus, the self-organizing feature maps (SOFMs) preserve the intrinsic relationship among the different clusters.</p>
				</sec>
				<sec id="s4X0X2">
					<title>Tuning parameters in clustering.</title>
					<p>In addition to the type of clustering (e.g., hierarchical, <italic>k</italic>-means, etc.), investigators need to make other choices when employing this technique, including: 1) <italic>distance metric;</italic> and 2) the type of <italic>linkage</italic> (if appropriate). The distance used by the clustering defines the desired notion of similarity between two data points. Distance metrics, i.e., measure of dissimilarity, that are often used, in addition to the <italic>Euclidean</italic> distance (defined in Section 2), are <italic>one minus correlation</italic> distance:
						<disp-formula id="pcbi-0030116-e014"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e014" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi></mml:mrow></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn><mml:mo>&minus;</mml:mo><mml:mi>r</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn><mml:mo>&minus;</mml:mo><mml:mfrac><mml:mrow><mml:mstyle displaystyle='true'><mml:msubsup><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:msubsup></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&minus;</mml:mo><mml:mover accent='true'><mml:mi>x</mml:mi><mml:mo>&macr;</mml:mo></mml:mover><mml:mo stretchy='false'>)</mml:mo><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&minus;</mml:mo><mml:mover accent='true'><mml:mi>z</mml:mi><mml:mo>&macr;</mml:mo></mml:mover><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mstyle displaystyle='true'><mml:msubsup><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:msubsup></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&minus;</mml:mo><mml:mover accent='true'><mml:mi>x</mml:mi><mml:mo>&macr;</mml:mo></mml:mover><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mstyle displaystyle='true'><mml:msubsup><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>p</mml:mi></mml:msubsup></mml:mstyle><mml:mtext>&thinsp;</mml:mtext><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi>z</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>&minus;</mml:mo><mml:mover accent='true'><mml:mi>z</mml:mi><mml:mo>&macr;</mml:mo></mml:mover><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:math> --></disp-formula>and <italic>Mahalanobis</italic> distance:
						<disp-formula id="pcbi-0030116-e015"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e015" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&minus;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:msup><mml:mi>&Sigma;</mml:mi><mml:mrow><mml:mo>&minus;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo>&minus;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>z</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mi>T</mml:mi></mml:msup></mml:mrow><mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>In <xref ref-type="disp-formula" rid="pcbi-0030116-e014">Equation 14</xref> the covariance matrix Σ can be replaced with the sample estimated covariance matrix defined in <xref ref-type="disp-formula" rid="pcbi-0030116-e003">Equation 3</xref>. Unlike the Euclidian and correlation distances, the Mahalanobis distance allows for situations in which the data may vary more in some directions than in others, and has a mechanism to scale the data so that each feature has the same weight in the distance calculation.</p>
					<p>The linkage defines the desired notion of similarity between two groups of measurements. For instance, the <italic>average linkage</italic> uses the mean of the distances between all possible pairs of measurements between the two groups. An extensive discussion of these issues, including the properties of each distance/linkage/clustering algorithm, common pitfalls, and recommendations can be found in Drăghici's monograph [<xref ref-type="bibr" rid="pcbi-0030116-b034">34</xref>] and references therein.</p>
				</sec>
			</sec>
		</sec>
		<sec id="s5">
			<title>Practicalities Using R</title>
			<p>The R language and environment for statistical computing (<ext-link ext-link-type="uri" xlink:href="http://www.r-project.org" xlink:type="simple">http://www.r-project.org</ext-link>) is a free open source system with which one can explore a variety of approaches to machine learning. For a comprehensive list of machine learning methods implemented in R, the reader is referred to the CRAN Task View on machine learning (<ext-link ext-link-type="uri" xlink:href="http://cran.r-project.org/src/contrib/Views/MachineLearning.html" xlink:type="simple">http://cran.r-project.org/src/contrib/Views/MachineLearning.html</ext-link>). In the following description, the bold fixed-width font designates a code segment that can be pasted directly into an R session, while nonbold fixed-width font designates names of packages, or R objects.</p>
			<p>The Bioconductor project (<ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org" xlink:type="simple">http://www.bioconductor.org</ext-link>) includes a software package called <monospace>MLInterfaces</monospace>, which aims to simplify the application of machine learning methods to high-throughput biological data such as gene expression microarrays. In this section, we will review some examples that can be carried out by the reader who has an installation of R 2.4.0 or later. First, the CRAN package <monospace>ctv</monospace> is installed and loaded. A rich collection of machine learning tools is obtained by executing:</p>
			<p><bold> <monospace>install.views("MachineLearning")</monospace></bold></p>
			<p>The <monospace>biocLite</monospace> function is then made available through:</p>
			<p><bold><monospace>source(</monospace><ext-link ext-link-type="uri" xlink:href="http://www.bioconductor.org/biocLite.R" xlink:type="simple"><monospace>"http://www.bioconductor.org/biocLite.R"</monospace></ext-link><monospace>)</monospace></bold></p>
			<p>followed by</p>
			<p><bold> <monospace>biocLite("MLInterfaces")</monospace></bold></p>
			<p>which installs a brokering interface to a substantial collection of machine learning functions, tailored to analysis of expression microarray datasets.</p>
			<sec id="s5a"><title/>
				<sec id="s5a1">
					<title>A leukemia dataset.</title>
					<p>After obtaining the <monospace>biocLite</monospace> function as described above, the command:</p>
					<p><bold><monospace>biocLite("ALL")</monospace></bold></p>
					<p>installs a data structure representing samples on 128 individuals with acute lymphocytic leukemia [<xref ref-type="bibr" rid="pcbi-0030116-b035">35</xref>]. The following dialogue with R will generate a subset that can be analyzed to understand the transcriptional distinction between B cell ALL cases in which the BCR and ABL genes have fused, and B cell ALL cases in which no such fusion is present:</p>
					<p><bold> <monospace>library(ALL)</monospace></bold></p>
					<p><bold> <monospace>data(ALL)</monospace></bold></p>
					<p><bold> <monospace># restrict to BCR/ABL or NEG</monospace></bold></p>
					<p><bold> <monospace>bio = which( ALL$mol.biol %in% c("BCR/ABL", “NEG"))</monospace></bold></p>
					<p><bold> <monospace><monospace># restrict to B-cell</monospace></monospace></bold></p>
					<p><bold> <monospace>isb = grep("ˆB", as.character(ALL$BT))</monospace></bold></p>
					<p><bold> <monospace>bfus = ALL[, intersect(bio,isb)]</monospace></bold></p>
					<p><bold> <monospace>bfus</monospace></bold></p>
					<p>There are 79 samples present, 37 of which present BCR/ABL fusion.</p>
				</sec>
				<sec id="s5a2">
					<title>Unsupervised methods.</title>
					<p>To illustrate simple approaches to unsupervised learning, we will filter the data severely, by focusing on the 50 genes that have the largest variability over all samples as measured by the median absolute deviation. The threshold 1.43 in the next command was determined by checking the data. We then invoke the R <monospace>heatmap</monospace> command, with variations on the color scheme, and sample coloring at the top, with magenta bars denoting negative samples (NEG) and blue bars denoting fusion samples (BCR/ABL):</p>
					<p><bold> <monospace>bfust = bfus[ apply(exprs(bfus),1,mad) &gt; 1.43, ]</monospace></bold></p>
					<p><bold> <monospace>#get rid of unused levels</monospace></bold></p>
					<p><bold> <monospace>bfust$mol.biol = factor(bfust$mol.biol)</monospace></bold></p>
					<p><bold> <monospace>mycols=ifelse(bfust$mol.biol == "NEG",</monospace></bold></p>
					<p><bold> <monospace>"magenta", "blue")</monospace></bold></p>
					<p><bold> <monospace>heatmap(exprs(bfust),</monospace></bold></p>
					<p><bold> <monospace>ColSideColors=mycols,</monospace></bold></p>
					<p><bold> <monospace>col=cm.colors(256), margins=c(9,9), cexRow=1.3)</monospace></bold></p>
					<p>The PAM algorithm can be applied to <monospace>bfust</monospace> of class ExpressionSet using the brokering code in the <monospace>MLInterfaces:</monospace></p>
					<p><bold> <monospace>library(MLInterfaces)</monospace></bold></p>
					<p><bold> <monospace>dopam = pamB(bfust, k=6)</monospace></bold></p>
					<p>The graphical output shown in <xref ref-type="fig" rid="pcbi-0030116-g005">Figure 5</xref> is obtained using the R command:</p>
					<fig id="pcbi-0030116-g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g005</object-id>
						<label>Figure 5</label>
						<caption>
							<title>Two Views of the Partition Obtained by PAM</title>
							<p>Left, PC display; right, silhouette display. The ellipses plotted on the left are cluster-specific minimum volume ellipsoids for the data projected into the PCs plane. These should be regarded as two-dimensional representations of the robust approximate variance–covariance matrix for the projected clusters. The silhouette display comprises a single horizontal segment for each observation, ordered by clusters and by object-specific silhouette value within a cluster. Large average silhouette values for a cluster indicate good separation of most cluster members from members of other clusters; negative silhouette values for objects indicate instances of indecisiveness or error of the given partition.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g005" xlink:type="simple"/>
					</fig>
					<p><bold><monospace>plot(RObject(dopam))</monospace></bold></p>
					<p>On the left panel of <xref ref-type="fig" rid="pcbi-0030116-g005">Figure 5</xref>, the smallest cluster-specific ellipsoids containing all the data in each cluster are displayed in a two-dimensional principal components (PCs) projection; on the right, the <italic>silhouette</italic> display (see Unsupervised Learning/Cluster Analysis) is presented. High silhouette values indicate “well-clustered” observations, while negative values indicate that an observation might have been assigned to the wrong cluster.</p>
					<p>A useful data visualization method, not necessarily related to machine learning, is to project the multidimensional data points onto two or three PCs which are the directions in the feature space showing the largest variability. The R packages <monospace>pcurve</monospace> and <monospace>lattice</monospace> are used here to compute the PCs and produce a plot of the 79 samples in <monospace>bfust</monospace> data (see <xref ref-type="fig" rid="pcbi-0030116-g006">Figure 6</xref>).</p>
					<fig id="pcbi-0030116-g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g006</object-id>
						<label>Figure 6</label>
						<caption>
							<title>A PCA Plot</title>
							<p>The 79 samples of the ALL dataset are projected on the first three PCs derived from the 50 original features. The blue and magenta colors are used to denote the known membership of the samples in the two classes, NEG and BCR/ABL, respectively. Note that PCA is an unsupervised data projection method, since the class membership is not required to compute the PCs.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g006" xlink:type="simple"/>
					</fig>
					<p><bold> <monospace>library(lattice);</monospace></bold></p>
					<p><bold> <monospace>library(pcurve)</monospace></bold></p>
					<p><bold> <monospace>pc = pca(t(exprs(bfust)))</monospace></bold></p>
					<p><bold> <monospace>cloud(pc$pcs[,3]∼</monospace> </bold></p>
					<p><bold> <monospace>pc$pcs[,1]+pc$pcs[,2],col=mycols,pch=19,xlab="PC1",</monospace> </bold></p>
					<p><bold> <monospace>ylab="PC2", zlab="PC3")</monospace></bold></p>
				</sec>
				<sec id="s5a3">
					<title>Supervised methods.</title>
					<p>Supervised methods of learning such as trees, neural networks, and SVMs will be illustrated in this section.</p>
					<p>The following example uses 50 random samples from <monospace>bfust</monospace> data to train a neural network model which is used to predict the class for the remaining 29 samples from bfust. The confusion matrix is computed to assess the classification accuracy. Indices of the training sample are supplied to the <monospace>trainInd</monospace> parameter of the <monospace>nnetB</monospace> interface of the <monospace>MLInterfaces</monospace> package. </p>
					<p><bold> <monospace>set.seed(1234) # repeatable random sample/nnet initialization</monospace></bold></p>
					<p><bold> <monospace>smp = sample(1:79, size = 50)</monospace></bold></p>
					<p><bold> <monospace>nn1 = nnetB(bfust, “mol.biol", trainInd=smp, size = 5, maxit = 1000, </monospace></bold></p>
					<p><bold><monospace>decay =</monospace> <monospace>0.01)</monospace></bold></p>
					<p><bold> <monospace>confuMat(nn1)</monospace></bold></p>
					<p>The last line in the code segment above displays the confusion matrix achieved by the neural network classifier on the test samples:
						<disp-formula id="pcbi-0030116-e016"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030116.e016" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>c</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>g</mml:mi><mml:mi>i</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>BCR/ABL</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>NEG</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>BCR/ABL</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mn>4</mml:mn></mml:mtd><mml:mtd><mml:mn>7</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mtext>NEG</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mn>2</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mn>16</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math> --></disp-formula>
					</p>
					<p>The <monospace>size</monospace> parameter in the function <monospace>nnetB</monospace> above specifies the number of units in the hidden layer of the neural network, and larger values of the <monospace>decay</monospace> parameter impose stronger regularization of the weights. The <monospace>maxit</monospace> parameter should be set to a relatively high number to increase the chance that the optimization algorithm converges to a solution. The confusion matrix is computed using the <monospace>confuMat</monospace> method on the 29 samples forming the complement of the training set specified by <monospace>smp</monospace>. This shows a misclassification rate of 31% = 9/29.</p>
					<p>A tree-structured classifier derived from the 50-gene extract from the ALL data is shown in <xref ref-type="fig" rid="pcbi-0030116-g007">Figure 7</xref>. The procedure defines a single split on a single gene (Kruppel-like factor 9), which does a reasonable job of separating the fusion cases—the estimated misclassification rate seems to be about 30%.</p>
					<fig id="pcbi-0030116-g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g007</object-id>
						<label>Figure 7</label>
						<caption>
							<title>Rendering of a Conditional Tree</title>
							<p>The figure is obtained with the <monospace>Ctree</monospace> function of the <monospace>party</monospace> package.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g007" xlink:type="simple"/>
					</fig>
					<p><xref ref-type="fig" rid="pcbi-0030116-g008">Figure 8</xref> depicts the decision regions after learning was carried out with training sets based on two randomly selected genes from ALL data. Qualitative aspects of the decision regions are clear: the tree-structured classifier delivers rectangular decision regions; the neural network fit leads to a smooth, curved decision boundary; the 3-NN fit is very jagged; and the SVM fit is similar to but more compact than the neural net. Of note: considerable interpolation and extrapolation is performed to generate the full decision region representation, and decisions are rendered for feature values for which data are very sparse. Boundaries are sharp, and there is no provision for declaring doubt (although one could be introduced with modest programming for those procedures that do return information on posterior probabilities of class membership.) Last, the fine structure of the regions provided by CART and 3-NN are probably artifacts of overfitting, as opposed to substantively interesting indications of gene interaction.</p>
					<fig id="pcbi-0030116-g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g008</object-id>
						<label>Figure 8</label>
						<caption>
							<title>Display of Four Two-Gene Classifiers</title>
							<p>Top left: CART with <monospace>minsplit</monospace> tuning parameter set to 4; top right: a single-layer feed-forward neural network with eight units; bottom left, <italic>k</italic> = 3 nearest neighbors; bottom right, the default SVM from the <monospace>e1071</monospace> package. The <monospace>planarPlot</monospace> function of the <monospace>MLInterfaces</monospace> package can be used to construct such displays. If the expression level of a given sample falls into the magenta-colored area, then the sample is predicted to have status NEG; if it falls into the blue-colored area, then the sample is predicted to have BCR/ABL status.</p>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g008" xlink:type="simple"/>
					</fig>
				</sec>
				<sec id="s5a4">
					<title>Variable importance displays.</title>
					<p>Several machine learning procedures include facilities for measuring relative contribution of features in successful classification events. The random forest [<xref ref-type="bibr" rid="pcbi-0030116-b036">36</xref>] and boosting [<xref ref-type="bibr" rid="pcbi-0030116-b037">37</xref>] methods involve iteration through random samples of variables and cases, and if accuracy degrades when a certain variable is excluded at random from classifier construction, the variable's importance measure is incremented. Code illustrating an application follows, and <xref ref-type="fig" rid="pcbi-0030116-g009">Figure 9</xref> shows the resulting importance measures. </p>
					<fig id="pcbi-0030116-g009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.0030116.g009</object-id>
						<label>Figure 9</label>
						<caption>
							<title>Display of Relative Variable Importance as Computed in a Gradient Boosting Machine Run</title>
						</caption>
						<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030116.g009" xlink:type="simple"/>
					</fig>
					<p><bold><monospace>ggg = gbmB(bfust, "mol.biol", 1:50)</monospace></bold></p>
					<p><bold><monospace>library(hgu95av2)</monospace></bold></p>
					<p><bold><monospace>par(las=2, mar=c(6,9,5,5))</monospace></bold></p>
					<p><bold><monospace>plot(getVarImp(ggg), resolveenv=hgu95av2SYMBOL )</monospace></bold></p>
				</sec>
				<sec id="s5a5">
					<title>Summary.</title>
					<p>The R system includes a large number of machine learning methods in easily installed and well-documented packages; the Bioconductor <monospace>MLInterfaces</monospace> brokering package simplifies application of these methods to microarray datasets. We have illustrated a number of methods with a demonstration dataset that was obtained by selecting a reduced number of features out of a few tens of thousands that are available in the ALL dataset. The features selected were those varying the most among the samples, regardless of their class membership. While convenient for the purpose of producing <xref ref-type="fig" rid="pcbi-0030116-g004">Figure 4</xref>, the filtering is not theoretically required by any of the unsupervised methods. However, for practical reasons, such as computer memory shortage, most of the implementations of the unsupervised techniques may not work with tens of thousands of features. For the purpose of developing supervised classification models, in addition to these practical limitations, there may not be enough degrees of freedom to estimate the parameters of the models. In such supervised applications, filtering should be used as described in the section Supervised Learning: Dimensionality Reduction. More details on machine learning applications with R can be found in the literature [<xref ref-type="bibr" rid="pcbi-0030116-b038">38</xref>].</p>
				</sec>
			</sec>
		</sec>
		<sec id="s6">
			<title>Conclusion</title>
			<p>Modern biology can benefit from the advancements made in the area of machine learning. Caution should be taken when judging the superiority of some machine learning approaches over other categories of methods. It is argued [<xref ref-type="bibr" rid="pcbi-0030116-b039">39</xref>] that the success or failure of machine learning approaches on a given problem is sometimes a matter of the quality indices used to evaluate the results, and these may vary strongly with the expertise of the user. Of special concern with supervised applications is that all steps involved in the classifier design (selection of input variables, model training, etc.) should be cross-validated to obtain an unbiased estimate for classifier accuracy. For instance, selecting the features using all available data and subsequently cross-validating the classifier training will produce an optimistically biased error estimate. Because of inadequate validation schemes, many studies published in the literature as successful have been shown to be overoptimistic [<xref ref-type="bibr" rid="pcbi-0030116-b040">40</xref>]. It should be clear from the narrative examples used in this tutorial that choice, tuning, and diagnosis of machine learning applications are far from mechanical. </p>
		</sec>
	</body>
	<back>
		<ack>
			<p>We express our gratitude to the two anonymous reviewers whose specific comments were very useful in improving this manuscript. ALT and RR were supported in part by the Division of Intramural Research of the National Institute of Child Health and Human Development. VJC was supported in part by National Institutes of Health (NIH) grant 1 P41 HG004059. XwC was supported in part by National Science Foundation (NSF) award IIS-0644366 and by NIH Grant P20 RR17708 from the IDeA Program of the National Center for Research Resources. SD is partially supported by the following grants: NSF DBI-0234806, CCF-0438970, 1R01HG003491-01A1, 1U01CA117478–01, 1R21CA100740–01, 1R01NS045207–01, 5R21EB000990–03, and 2P30 CA022453–24. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the NSF, the NIH, or any other funding agency.</p>
		</ack>
		
		<glossary>
			<title>Abbreviations</title>
			<def-list>
				<def-item>
					<term><italic>k</italic>-NN</term>
					<def>
						<p><italic>k</italic>-nearest neighbor</p>
					</def>
				</def-item>
				<def-item>
					<term>PAM</term>
					<def>
						<p>partitioning around medoids</p>
					</def>
				</def-item>
				<def-item>
					<term>PC</term>
					<def>
						<p>principal component</p>
					</def>
				</def-item>
				<def-item>
					<term>PCA</term>
					<def>
						<p>principal component analysis</p>
					</def>
				</def-item>
				<def-item>
					<term>SV</term>
					<def>
						<p>support vector</p>
					</def>
				</def-item>
				<def-item>
					<term>SVM</term>
					<def>
						<p>support vector machine</p>
					</def>
				</def-item>
				<def-item>
					<term><bold>x</bold></term>
					<def>
						<p>vector</p>
					</def>
				</def-item>
				<def-item>
					<term><italic>x</italic></term>
					<def>
						<p>scalar</p>
					</def>
				</def-item>
				<def-item>
					<term>X</term>
					<def>
						<p>matrix</p>
					</def>
				</def-item>
				<def-item>
					<term><italic>X</italic></term>
					<def>
						<p>feature space.</p>
					</def>
				</def-item>
			</def-list>
		</glossary>
		<ref-list>
			<title>References</title>
			<ref id="pcbi-0030116-b001">
<label>1</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Rosenblatt</surname>
							<given-names>F</given-names>
						</name>
					</person-group>
					<year>1958</year>
					<article-title>The perceptron: A probabilistic model for information storage and organization in the brain.</article-title>
					<source>Psychol Rev</source>
					<volume>65</volume>
					<fpage>386</fpage>
					<lpage>408</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b002">
<label>2</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Stormo</surname>
							<given-names>GD</given-names>
						</name>
						<name name-style="western">
							<surname>Schneider</surname>
							<given-names>TD</given-names>
						</name>
						<name name-style="western">
							<surname>Gold</surname>
							<given-names>L</given-names>
						</name>
						<name name-style="western">
							<surname>Ehrenfeuch</surname>
							<given-names>A</given-names>
						</name>
					</person-group>
					<year>1982</year>
					<article-title>Use of the perceptron algorithm to distinguish translation initiation sites in <named-content content-type="genus-species" xlink:type="simple">E. coli</named-content>.</article-title>
					<source>Nucleic Acids Res</source>
					<volume>10</volume>
					<fpage>2997</fpage>
					<lpage>3011</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b003">
<label>3</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Carpenter</surname>
							<given-names>GA</given-names>
						</name>
						<name name-style="western">
							<surname>Grossberg</surname>
							<given-names>S</given-names>
						</name>
					</person-group>
					<year>1988</year>
					<article-title>The art of adaptive pattern recognition by a self-organizing neural network.</article-title>
					<source>Computer</source>
					<volume>21</volume>
					<fpage>77</fpage>
					<lpage>88</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b004">
<label>4</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Fukushima</surname>
							<given-names>K</given-names>
						</name>
					</person-group>
					<year>1980</year>
					<article-title>Neocognitron: A self-organizing neural network model for a mechanism of pattern recognition unaffected by shift in position.</article-title>
					<source>Biol Cybern</source>
					<volume>36</volume>
					<fpage>193</fpage>
					<lpage>202</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b005">
<label>5</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Weston</surname>
							<given-names>J</given-names>
						</name>
						<name name-style="western">
							<surname>Leslie</surname>
							<given-names>C</given-names>
						</name>
						<name name-style="western">
							<surname>Ie</surname>
							<given-names>E</given-names>
						</name>
						<name name-style="western">
							<surname>Zhou</surname>
							<given-names>D</given-names>
						</name>
						<name name-style="western">
							<surname>Elisseeff</surname>
							<given-names>A</given-names>
						</name><etal/>
					</person-group>
					<year>2005</year>
					<article-title>Semi-supervised protein classification using cluster kernels.</article-title>
					<source>Bioinformatics</source>
					<volume>21</volume>
					<fpage>3241</fpage>
					<lpage>3247</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b006">
<label>6</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Alizadeh</surname>
							<given-names>AA</given-names>
						</name>
						<name name-style="western">
							<surname>Eisen</surname>
							<given-names>MB</given-names>
						</name>
						<name name-style="western">
							<surname>Davis</surname>
							<given-names>RE</given-names>
						</name>
						<name name-style="western">
							<surname>Ma</surname>
							<given-names>C</given-names>
						</name>
						<name name-style="western">
							<surname>Lossos</surname>
							<given-names>IS</given-names>
						</name><etal/>
					</person-group>
					<year>2000</year>
					<article-title>Distinct type of diffuse large B-cell lymphoma identified by gene expression profiling.</article-title>
					<source>Nature</source>
					<volume>403</volume>
					<fpage>503</fpage>
					<lpage>510</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b007">
<label>7</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Perou</surname>
							<given-names>CM</given-names>
						</name>
						<name name-style="western">
							<surname>Jeffrey</surname>
							<given-names>SS</given-names>
						</name>
						<name name-style="western">
							<surname>van der Rijn</surname>
							<given-names>M</given-names>
						</name>
						<name name-style="western">
							<surname>Rees</surname>
							<given-names>CA</given-names>
						</name>
						<name name-style="western">
							<surname>Eisen</surname>
							<given-names>MB</given-names>
						</name><etal/>
					</person-group>
					<year>1999</year>
					<article-title>Distinctive gene expression patterns in human mammary epithelial cells and breast cancers.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>96</volume>
					<fpage>9212</fpage>
					<lpage>9217</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b008">
<label>8</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Alon</surname>
							<given-names>U</given-names>
						</name>
						<name name-style="western">
							<surname>Barkai</surname>
							<given-names>N</given-names>
						</name>
						<name name-style="western">
							<surname>Notterman</surname>
							<given-names>DA</given-names>
						</name>
						<name name-style="western">
							<surname>Gish</surname>
							<given-names>K</given-names>
						</name>
						<name name-style="western">
							<surname>Ybarra</surname>
							<given-names>S</given-names>
						</name><etal/>
					</person-group>
					<year>1999</year>
					<article-title>Broad patterns of gene expression revealed by clustering of tumor and normal colon tissues probed by nucleotide arrays.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>96</volume>
					<fpage>6745</fpage>
					<lpage>6750</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b009">
<label>9</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Ross</surname>
							<given-names>DT</given-names>
						</name>
						<name name-style="western">
							<surname>Scherf</surname>
							<given-names>U</given-names>
						</name>
						<name name-style="western">
							<surname>Eisen</surname>
							<given-names>MB</given-names>
						</name>
						<name name-style="western">
							<surname>Perou</surname>
							<given-names>CM</given-names>
						</name>
						<name name-style="western">
							<surname>Rees</surname>
							<given-names>G</given-names>
						</name><etal/>
					</person-group>
					<year>2000</year>
					<article-title>Systematic variation in gene expression patterns in human cancer cell lines.</article-title>
					<source>Nat Genet</source>
					<volume>24</volume>
					<fpage>227</fpage>
					<lpage>235</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b010">
<label>10</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Rost</surname>
							<given-names>B</given-names>
						</name>
						<name name-style="western">
							<surname>Sander</surname>
							<given-names>C</given-names>
						</name>
					</person-group>
					<year>1994</year>
					<article-title>Combining evolutionary information and neural networks to predict protein secondary structure.</article-title>
					<source>Proteins</source>
					<volume>19</volume>
					<fpage>55</fpage>
					<lpage>72</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b011">
<label>11</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Tarca</surname>
							<given-names>AL</given-names>
						</name>
						<name name-style="western">
							<surname>Cooke</surname>
							<given-names>JE</given-names>
						</name>
						<name name-style="western">
							<surname>Mackay</surname>
							<given-names>J</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>A robust neural networks approach for spatial and intensity-dependent normalization of cDNA microarray data.</article-title>
					<source>Bioinformatics</source>
					<volume>21</volume>
					<fpage>2674</fpage>
					<lpage>2683</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b012">
<label>12</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Duda</surname>
							<given-names>RO</given-names>
						</name>
						<name name-style="western">
							<surname>Hart</surname>
							<given-names>PE</given-names>
						</name>
						<name name-style="western">
							<surname>Stork</surname>
							<given-names>DG</given-names>
						</name>
					</person-group>
					<year>2001</year>
					<source>Pattern classification. 2nd edition</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>John Wiley and Sons</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">654</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b013">
<label>13</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Webb</surname>
							<given-names>AR</given-names>
						</name>
					</person-group>
					<year>2002</year>
					<source>Statistical pattern recognition. 2nd edition</source>
					<publisher-loc>West Sussex (United Kingdom)</publisher-loc>
					<publisher-name>John Wiley and Sons</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">496</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b014">
<label>14</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Efron</surname>
							<given-names>B</given-names>
						</name>
					</person-group>
					<year>1983</year>
					<article-title>Estimating the error rate of a prediction rule: Improvement on cross-validation.</article-title>
					<source>J Am Stat Assoc</source>
					<volume>78</volume>
					<fpage>316</fpage>
					<lpage>331</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b015">
<label>15</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Hastie</surname>
							<given-names>T</given-names>
						</name>
						<name name-style="western">
							<surname>Tibshirani</surname>
							<given-names>R</given-names>
						</name>
						<name name-style="western">
							<surname>Friedman</surname>
							<given-names>J</given-names>
						</name>
					</person-group>
					<year>2001</year>
					<source>The elements of statistical learning: Data mining, inference, and prediction</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>Springer</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">533</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b016">
<label>16</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Dudoit</surname>
							<given-names>S</given-names>
						</name>
						<name name-style="western">
							<surname>Fridlyand</surname>
							<given-names>J</given-names>
						</name>
						<name name-style="western">
							<surname>Speed</surname>
							<given-names>T</given-names>
						</name>
					</person-group>
					<year>2002</year>
					<article-title>Comparison of discrimination methods for the classification of tumors using gene expression data.</article-title>
					<source>J Am Stat Assoc</source>
					<volume>97</volume>
					<fpage>77</fpage>
					<lpage>87</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b017">
<label>17</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Guo</surname>
							<given-names>Y</given-names>
						</name>
						<name name-style="western">
							<surname>Hastie</surname>
							<given-names>T</given-names>
						</name>
						<name name-style="western">
							<surname>Tibshirani</surname>
							<given-names>R</given-names>
						</name>
					</person-group>
					<year>2001</year>
					<article-title>Regularized linear discriminant analysis and its application in microarrays.</article-title>
					<source>Biostatistics</source>
					<volume>8</volume>
					<fpage>9</fpage>
					<lpage>31</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b018">
<label>18</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Gentleman</surname>
							<given-names>R</given-names>
						</name>
						<name name-style="western">
							<surname>Ding</surname>
							<given-names>B</given-names>
						</name>
						<name name-style="western">
							<surname>Dudoit</surname>
							<given-names>S</given-names>
						</name>
						<name name-style="western">
							<surname>Ibrahim</surname>
							<given-names>J</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>Distance measures in DNA microarray data analysis.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor">
						<name name-style="western">
							<surname>Gentlemen</surname>
							<given-names>R</given-names>
						</name>
						<name name-style="western">
							<surname>Carey</surname>
							<given-names>VJ</given-names>
						</name>
						<name name-style="western">
							<surname>Huber</surname>
							<given-names>W</given-names>
						</name>
						<name name-style="western">
							<surname>Irizarry</surname>
							<given-names>RA</given-names>
						</name>
						<name name-style="western">
							<surname>Dudoit</surname>
							<given-names>S</given-names>
						</name>
					</person-group>
					<source>Bioinformatics and computational biology solutions using R and Bioconductor</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>Springer</publisher-name>
					<fpage>189</fpage>
					<lpage>208</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b019">
<label>19</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Breiman</surname>
							<given-names>L</given-names>
						</name>
						<name name-style="western">
							<surname>Friedman</surname>
							<given-names>JH</given-names>
						</name>
						<name name-style="western">
							<surname>Olsen</surname>
							<given-names>RA</given-names>
						</name>
						<name name-style="western">
							<surname>Stone</surname>
							<given-names>CJ</given-names>
						</name>
					</person-group>
					<year>1984</year>
					<source>Classification and regression trees</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>Wadsworth and Brooks</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">368</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b020">
<label>20</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Rumelhart</surname>
							<given-names>DE</given-names>
						</name>
						<name name-style="western">
							<surname>Hinton</surname>
							<given-names>GE</given-names>
						</name>
						<name name-style="western">
							<surname>Williams</surname>
							<given-names>RJ</given-names>
						</name>
					</person-group>
					<year>1986</year>
					<article-title>Learning internal representations by error backpropagation.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor">
						<name name-style="western">
							<surname>Rumelhart</surname>
							<given-names>DE</given-names>
						</name>
						<name name-style="western">
							<surname>MeClelland</surname>
							<given-names>JL</given-names>
						</name>
						<collab xlink:type="simple">the PDP Research Group,</collab>
					</person-group>
					<source>Parallel distributed processing: Explorations in the microstructures of cognition</source>
					<publisher-loc>Boston</publisher-loc>
					<publisher-name>MIT Press/Bradford Books</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">576</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b021">
<label>21</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Ripley</surname>
							<given-names>B</given-names>
						</name>
					</person-group>
					<year>1996</year>
					<source>Pattern recognition and neural networks</source>
					<publisher-loc>Cambridge (United Kingdom)</publisher-loc>
					<publisher-name>Cambridge University Press</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">403</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b022">
<label>22</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Venables</surname>
							<given-names>B</given-names>
						</name>
						<name name-style="western">
							<surname>Ripley</surname>
							<given-names>B</given-names>
						</name>
					</person-group>
					<year>2002</year>
					<source>Modern applied statistics with S. 4th edition</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>Springer</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">495</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b023">
<label>23</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Vapnik</surname>
							<given-names>VN</given-names>
						</name>
					</person-group>
					<year>1998</year>
					<source>Statistical learning theory</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>Wiley</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">736</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b024">
<label>24</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Golub</surname>
							<given-names>TR</given-names>
						</name>
						<name name-style="western">
							<surname>Slonim</surname>
							<given-names>DK</given-names>
						</name>
						<name name-style="western">
							<surname>Tamayo</surname>
							<given-names>P</given-names>
						</name>
						<name name-style="western">
							<surname>Huard</surname>
							<given-names>C</given-names>
						</name>
						<name name-style="western">
							<surname>Gaasenbeek</surname>
							<given-names>M</given-names>
						</name><etal/>
					</person-group>
					<year>1999</year>
					<article-title>Molecular classification of cancer: Class discovery and class predication by gene expression monitoring.</article-title>
					<source>Science</source>
					<volume>286</volume>
					<fpage>531</fpage>
					<lpage>537</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b025">
<label>25</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Jirapech-Umpai</surname>
							<given-names>T</given-names>
						</name>
						<name name-style="western">
							<surname>Aitken</surname>
							<given-names>S</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>Feature selection and classification for microarray data analysis: Evolutionary methods for identifying predictive genes.</article-title>
					<source>BMC Bioinformatics</source>
					<volume>6</volume>
					<fpage>148</fpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b026">
<label>26</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Rogers</surname>
							<given-names>S</given-names>
						</name>
						<name name-style="western">
							<surname>Williams</surname>
							<given-names>R</given-names>
						</name>
						<name name-style="western">
							<surname>Campbell</surname>
							<given-names>C</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>Class prediction with microarray datasets.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor">
						<name name-style="western">
							<surname>Seiffert</surname>
							<given-names>U</given-names>
						</name>
						<name name-style="western">
							<surname>Jain</surname>
							<given-names>LC</given-names>
						</name>
						<name name-style="western">
							<surname>Schweizer</surname>
							<given-names>P</given-names>
						</name>
					</person-group>
					<source>Bioinformatics using computational intelligence paradigms</source>
					<publisher-loc>Berlin</publisher-loc>
					<publisher-name>Springer</publisher-name>
					<fpage>119</fpage>
					<lpage>141</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b027">
<label>27</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Tarca</surname>
							<given-names>AL</given-names>
						</name>
						<name name-style="western">
							<surname>Grandjean</surname>
							<given-names>BPA</given-names>
						</name>
						<name name-style="western">
							<surname>Larachi</surname>
							<given-names>F</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>Feature selection methods for multiphase reactors data classification.</article-title>
					<source>Ind Eng Chem Res</source>
					<volume>44</volume>
					<fpage>1073</fpage>
					<lpage>1084</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b028">
<label>28</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Aach</surname>
							<given-names>J</given-names>
						</name>
						<name name-style="western">
							<surname>Rindone</surname>
							<given-names>W</given-names>
						</name>
						<name name-style="western">
							<surname>Church</surname>
							<given-names>GM</given-names>
						</name>
					</person-group>
					<year>2000</year>
					<article-title>Systematic management and analysis of yeast gene expression data.</article-title>
					<source>Genome Res</source>
					<volume>10</volume>
					<fpage>431</fpage>
					<lpage>445</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b029">
<label>29</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Zhu</surname>
							<given-names>J</given-names>
						</name>
						<name name-style="western">
							<surname>Zhang</surname>
							<given-names>MQ</given-names>
						</name>
					</person-group>
					<year>2000</year>
					<article-title>Cluster, function and promoter: Analysis of yeast expression array.</article-title>
					<source>Pacific Symp Biocomput</source>
					<volume>5</volume>
					<fpage>476</fpage>
					<lpage>487</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b030">
<label>30</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Kaufman</surname>
							<given-names>L</given-names>
						</name>
						<name name-style="western">
							<surname>Rousseeuw</surname>
							<given-names>PJ</given-names>
						</name>
					</person-group>
					<year>1990</year>
					<source>Finding groups in data: An introduction to cluster analysis</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>John Wiley and Sons</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">342</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b031">
<label>31</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>van der Laan</surname>
							<given-names>MJ</given-names>
						</name>
						<name name-style="western">
							<surname>Pollard</surname>
							<given-names>KS</given-names>
						</name>
						<name name-style="western">
							<surname>Bryan</surname>
							<given-names>J</given-names>
						</name>
					</person-group>
					<year>2003</year>
					<article-title>A new partitioning around medoids algorithm.</article-title>
					<source>UC Berkeley Division of Biostatistics Working Paper Series</source>
					<comment>Available: <ext-link ext-link-type="uri" xlink:href="http://www.bepress.com/cgi/viewcontent.cgi?article=1003&amp;context=ucbbiostat" xlink:type="simple">http://www.bepress.com/cgi/viewcontent.cgi?article=1003&amp;context=ucbbiostat</ext-link>. Accessed 25 May 2007.</comment>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b032">
<label>32</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Kohonen</surname>
							<given-names>T</given-names>
						</name>
					</person-group>
					<year>1988</year>
					<article-title>Learning vector quantization.</article-title>
					<source>Neural Netw</source>
					<volume>1</volume>
					<fpage>303</fpage>
					<lpage>320</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b033">
<label>33</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Kohonen</surname>
							<given-names>T</given-names>
						</name>
					</person-group>
					<year>1995</year>
					<source>Self-organizing maps</source>
					<publisher-loc>Berlin</publisher-loc>
					<publisher-name>Springer</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">362</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b034">
<label>34</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Drăghici</surname>
							<given-names>S</given-names>
						</name>
					</person-group>
					<year>2003</year>
					<source>Data analysis tools for DNA microarrays</source>
					<publisher-loc>London</publisher-loc>
					<publisher-name>Chapman and Hall/CRC Press</publisher-name>
					<!--===== Restructure page-count as size[@units="page"] =====--><size units="page">512</size>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b035">
<label>35</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Chiaretti</surname>
							<given-names>S</given-names>
						</name>
						<name name-style="western">
							<surname>Li</surname>
							<given-names>X</given-names>
						</name>
						<name name-style="western">
							<surname>Gentleman</surname>
							<given-names>R</given-names>
						</name>
						<name name-style="western">
							<surname>Vitale</surname>
							<given-names>A</given-names>
						</name>
						<name name-style="western">
							<surname>Vignetti</surname>
							<given-names>M</given-names>
						</name><etal/>
					</person-group>
					<year>2004</year>
					<article-title>Gene expression profile of adult T-cell acute lymphocytic leukemia identifies distinct subsets of patients with different response to therapy and survival.</article-title>
					<source>Blood</source>
					<volume>103</volume>
					<fpage>2771</fpage>
					<lpage>2778</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b036">
<label>36</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Breiman</surname>
							<given-names>L</given-names>
						</name>
					</person-group>
					<year>2001</year>
					<article-title>Random forests.</article-title>
					<source>Mach Learn</source>
					<volume>45</volume>
					<fpage>5</fpage>
					<lpage>32</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b037">
<label>37</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Freung</surname>
							<given-names>Y</given-names>
						</name>
					</person-group>
					<year>1997</year>
					<article-title>A decision-theoretic generalization of on-line learning and an application to boosting.</article-title>
					<source>J Comput Syst Sci</source>
					<volume>55</volume>
					<fpage>119</fpage>
					<lpage>139</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b038">
<label>38</label>
				<element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Carey</surname>
							<given-names>VJ</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>Machine learning concepts and tools for statistical genomics.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor">
						<name name-style="western">
							<surname>Gentlemen</surname>
							<given-names>R</given-names>
						</name>
						<name name-style="western">
							<surname>Carey</surname>
							<given-names>VJ</given-names>
						</name>
						<name name-style="western">
							<surname>Huber</surname>
							<given-names>W</given-names>
						</name>
						<name name-style="western">
							<surname>Irizarry</surname>
							<given-names>RA</given-names>
						</name>
						<name name-style="western">
							<surname>Dudoit</surname>
							<given-names>S</given-names>
						</name>
					</person-group>
					<source>Bioinformatics and computational biology solutions using R and Bioconductor</source>
					<publisher-loc>New York</publisher-loc>
					<publisher-name>Springer</publisher-name>
					<fpage>273</fpage>
					<lpage>292</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b039">
<label>39</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Hand</surname>
							<given-names>DJ</given-names>
						</name>
					</person-group>
					<year>2006</year>
					<article-title>Classifier technology and the illusion of progress.</article-title>
					<source>Stat Sci</source>
					<volume>21</volume>
					<fpage>1</fpage>
					<lpage>14</lpage>
				</element-citation>
			</ref>
			<ref id="pcbi-0030116-b040">
<label>40</label>
				<element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author">
						<name name-style="western">
							<surname>Michiels</surname>
							<given-names>S</given-names>
						</name>
						<name name-style="western">
							<surname>Koscielny</surname>
							<given-names>S</given-names>
						</name>
						<name name-style="western">
							<surname>Hill</surname>
							<given-names>C</given-names>
						</name>
					</person-group>
					<year>2005</year>
					<article-title>Prediction of cancer outcome with microarrays: A multiple random validation strategy.</article-title>
					<source>Lancet</source>
					<volume>365</volume>
					<fpage>488</fpage>
					<lpage>492</lpage>
				</element-citation>
			</ref>
		</ref-list>
	</back>
</article>