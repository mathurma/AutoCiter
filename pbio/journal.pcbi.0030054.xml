<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN"><front><journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="publisher">pcbi</journal-id><journal-id journal-id-type="allenpress-id">plcb</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.1371/journal.pcbi.0030054</article-id><article-id pub-id-type="publisher-id">06-PLCB-RA-0338R2</article-id><article-id pub-id-type="sici">plcb-03-03-12</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline"><subject>Computational Biology</subject><subject>Genetics and Genomics</subject></subj-group><subj-group subj-group-type="System Taxonomy"><subject>Homo (human)</subject><subject>Mammals</subject><subject>Vertebrates</subject></subj-group></article-categories><title-group><article-title>Global Discriminative Learning for Higher-Accuracy Computational Gene Prediction</article-title><alt-title alt-title-type="running-head">Higher-Accuracy Computational Gene Prediction</alt-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Bernal</surname><given-names>Axel</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Crammer</surname><given-names>Koby</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Hatzigeorgiou</surname><given-names>Artemis</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Pereira</surname><given-names>Fernando</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref></contrib></contrib-group><aff id="aff1">
				<label>1</label><addr-line> Department of Computer and Information Science, University of Pennsylvania, Philadelphia, Pennsylvania, United States of America
			</addr-line></aff><aff id="aff2">
				<label>2</label><addr-line> Department of Genetics, University of Pennsylvania, Philadelphia, Pennsylvania, United States of America
			</addr-line></aff><contrib-group><contrib contrib-type="editor" xlink:type="simple"><name name-style="western"><surname>Haussler</surname><given-names>David</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">University of California Santa Cruz, United States of America</aff><author-notes><fn fn-type="con" id="ack1"><p>AB, AH, and FP conceived and designed the experiments. AB performed the experiments and analyzed the data. AB and FP wrote the paper. AB, KC, and FP contributed ideas to the model and algorithms and refined and implemented the algorithms. FP proposed the initial idea.</p></fn><corresp id="cor1">* To whom correspondence should be addressed. E-mail: <email xlink:type="simple">abernal@seas.upenn.edu</email></corresp><fn fn-type="conflict" id="ack3"><p> The authors have declared that no competing interests exist.</p></fn></author-notes><pub-date pub-type="ppub"><month>3</month><year>2007</year></pub-date><pub-date pub-type="epub"><day>16</day><month>3</month><year>2007</year></pub-date><pub-date pub-type="epreprint"><day>2</day><month>2</month><year>2007</year></pub-date><volume>3</volume><issue>3</issue><elocation-id>e54</elocation-id><history><date date-type="received"><day>16</day><month>8</month><year>2006</year></date><date date-type="accepted"><day>1</day><month>2</month><year>2007</year></date></history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2007</copyright-year><copyright-holder>Bernal et al</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract><p>Most ab initio gene predictors use a probabilistic sequence model, typically a hidden Markov model, to combine separately trained models of genomic signals and content. By combining separate models of relevant genomic features, such gene predictors can exploit small training sets and incomplete annotations, and can be trained fairly efficiently. However, that type of piecewise training does not optimize prediction accuracy and has difficulty in accounting for statistical dependencies among different parts of the gene model. With genomic information being created at an ever-increasing rate, it is worth investigating alternative approaches in which many different types of genomic evidence, with complex statistical dependencies, can be integrated by discriminative learning to maximize annotation accuracy. Among discriminative learning methods, large-margin classifiers have become prominent because of the success of support vector machines (SVM) in many classification tasks. We describe CRAIG, a new program for ab initio gene prediction based on a conditional random field model with semi-Markov structure that is trained with an online large-margin algorithm related to multiclass SVMs. Our experiments on benchmark vertebrate datasets and on regions from the ENCODE project show significant improvements in prediction accuracy over published gene predictors that use intrinsic features only, particularly at the gene level and on genes with long introns.</p></abstract><abstract abstract-type="summary"><title>Author Summary</title><sec id="st1"><title/><p>We describe a new approach to statistical learning for sequence data that is broadly applicable to computational biology problems and that has experimentally demonstrated advantages over current hidden Markov model (HMM)-based methods for sequence analysis. The methods we describe in this paper, implemented in the CRAIG program, allow researchers to modularly specify and train sequence analysis models that combine a wide range of weakly informative features into globally optimal predictions. Our results for the gene prediction problem show significant improvements over existing ab initio gene predictors on a variety of tests, including the specially challenging ENCODE regions. Such improved predictions, particularly on initial and single exons, could benefit researchers who are seeking more accurate means of recognizing such important features as signal peptides and regulatory regions. More generally, we believe that our method, by combining the structure-describing capabilities of HMMs with the accuracy of margin-based classification methods, provides a general tool for statistical learning in biological sequences that will replace HMMs in any sequence modeling task for which there is annotated training data.</p></sec></abstract><funding-group><funding-statement>This material is based on work funded by the US National Science Foundation under ITR grants EIA 0205456 and IIS 0428193 and Career grant 0238295.</funding-statement></funding-group><counts><page-count count="10"/></counts><!--===== Restructure custom-meta-wrap to custom-meta-group =====--><custom-meta-group><custom-meta><meta-name>citation</meta-name><meta-value>Bernal A, Crammer K, Hatzigeorgiou A, Pereira F (2007) Global discriminative learning for higher-accuracy computational gene prediction. PLoS Comput Biol 3(3): e54. doi:<ext-link ext-link-type="doi" xlink:href="http://dx.doi.org/10.1371/journal.pcbi.0030054" xlink:type="simple">10.1371/journal.pcbi.0030054</ext-link></meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1"><title>Introduction</title><p>Prediction of protein-coding genes in eukaryotes involves correctly identifying splice sites and translation initiation and stop signals in DNA sequences. There are two main gene prediction methods. Ab initio methods rely exclusively on intrinsic structural features of genes, such as frequent motifs in splice sites and content statistics in coding regions. Notable ab initio predictors include GenScan [<xref ref-type="bibr" rid="pcbi-0030054-b001">1</xref>], Augustus [<xref ref-type="bibr" rid="pcbi-0030054-b002">2</xref>], TigrScan/Genezilla [<xref ref-type="bibr" rid="pcbi-0030054-b003">3</xref>], HMMGene [<xref ref-type="bibr" rid="pcbi-0030054-b004">4</xref>], GRAPE [<xref ref-type="bibr" rid="pcbi-0030054-b005">5</xref>], MZEF [<xref ref-type="bibr" rid="pcbi-0030054-b006">6</xref>], and Genie [<xref ref-type="bibr" rid="pcbi-0030054-b007">7</xref>]. Homology-based methods exploit extrinsic features derived by comparative analysis. For instance, ProCrustes [<xref ref-type="bibr" rid="pcbi-0030054-b008">8</xref>], GeneWise, and GenomeWise [<xref ref-type="bibr" rid="pcbi-0030054-b009">9</xref>] exploit protein or cDNA alignments, while TwinScan [<xref ref-type="bibr" rid="pcbi-0030054-b010">10</xref>], DoubleScan [<xref ref-type="bibr" rid="pcbi-0030054-b011">11</xref>], and NScan [<xref ref-type="bibr" rid="pcbi-0030054-b012">12</xref>] rely on genomic DNA from related informant organisms. Extrinsic features improve the accuracy of predictions for genes with close homologs in related organisms. Krogh [<xref ref-type="bibr" rid="pcbi-0030054-b013">13</xref>] and Mathe et al. [<xref ref-type="bibr" rid="pcbi-0030054-b014">14</xref>] review current gene prediction methods.</p><p>GenScan was the first gene predictor to achieve about 80% exon sensitivity and specificity in several single-gene benchmark test sets. More recent predictors have improved on GenScan's results by focusing on specific aspects of gene prediction. For example, GenScan++ improves specificity for internal exons and Augustus improves prediction accuracy on very long DNA sequences. Despite these advances, overall accuracy on chromosomal DNA, particularly in regions with low gene density (low GC content), is not yet satisfactory [<xref ref-type="bibr" rid="pcbi-0030054-b015">15</xref>]. Gene-level accuracy, which is especially important for applications, is a major challenge.</p><p>Improvements at the gene level could have a positive impact on detecting gene-related biological features such as signal peptide regions, promoters, and even 3′ UTR microRNA targets. Genes with very long introns and intergenic regions represent more than 95% of the total number of genes in most vertebrate genomes, and even a small improvement on those could be significant in practice.</p><p>With the exception of MZEF, which uses a quadratic discriminant function to identify internal coding exons, all of the ab initio predictors mentioned above use hidden Markov models (HMMs) to combine sequence content and signal classifiers into a consistent gene structure. HMM parameters are relatively easy to interpret and to learn. Content and signal classifiers can be built effectively using a variety of machine learning and statistical sequence modeling methods. However, the combination of content and signal classifiers with the HMM gene structure model is not itself trained to maximize prediction accuracy, and the overall model does not fully account for the statistical dependencies among the features used by the various classifiers. Moreover, recent work on machine learning for structured prediction problems [<xref ref-type="bibr" rid="pcbi-0030054-b016">16</xref>,<xref ref-type="bibr" rid="pcbi-0030054-b017">17</xref>] suggests that global optimization of model parameters to minimize a suitable training criterion can achieve better results than separate training of the various components of a structured predictor.</p><p>To overcome the shortcomings outlined above, our gene predictor uses a linear structure model based on conditional random fields (CRFs) [<xref ref-type="bibr" rid="pcbi-0030054-b017">17</xref>], hence the name CRAIG (CRF-based ab initio genefinder). CRFs are discriminatively trained Markovian state models that learn how to combine many diverse, statistically correlated features of the input to achieve high accuracy in sequence tagging and segmentation problems. Our models are semi-Markov [<xref ref-type="bibr" rid="pcbi-0030054-b018">18</xref>] to model more accurately the length distributions of genomic regions. For training, instead of the original conditional maximum-likelihood training objective of CRFs, we use the online large-margin MIRA (Margin Infused Relaxed Algorithm) method [<xref ref-type="bibr" rid="pcbi-0030054-b019">19</xref>], allowing us to extend to gene prediction the advantages of large-margin learning methods such as support vector machines (SVMs) while efficiently handling very long training sequences. <xref ref-type="fig" rid="pcbi-0030054-g001">Figure 1</xref> presents schematically the differences in the learning process between our method and the most common generative approach for gene prediction.</p><fig id="pcbi-0030054-g001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.g001</object-id><label>Figure 1</label><caption><title>Learning Methods: Discriminative versus Generative</title><p>Schematic comparison of discriminative (A) and generative (B) learning methods. In the discriminative case, all model parameters were estimated simultaneously to predict a segmentation as similar as possible to the annotation. In contrast, for generative HMM models, signal features and state features were assumed to be independent and trained separately.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.g001" xlink:type="simple"/></fig><p>Our model and training method allow us to combine a rich variety of possibly overlapping genomic features and to find a global tradeoff among feature contributions that maximizes annotation accuracy. In particular, we model different types of introns according to their length, which would have been difficult to integrate in previous models. We were also able to include rich features for start and stop signals and globally balance their weights against the weights of all other model features. These advances led to significant overall improvements over the current best predictions for the most used benchmark test sets: sensitivity and specificity of initial and single exon predictions showed a relative mean increase [<xref ref-type="bibr" rid="pcbi-0030054-b002">2</xref>] of 25.5% and 19.6%, respectively; at the gene level, the relative mean improvement was 33.9%; the relative F-score improvement on the ENCODE regions was 16.05% at the exon level. These improvements were in good part due to the different treatment of intronic states within the model, which in turn increased structure prediction accuracy, particularly on genes with long introns.</p><p>Some previous gene predictors have used discriminative training to some extent. HMMGene uses a nongeneralized HMM model for gene structure, which does not include features associated with biological signals, but it is trained with the discriminative conditional maximum likelihood criterion [<xref ref-type="bibr" rid="pcbi-0030054-b020">20</xref>]. However, conditional maximum likelihood is more difficult to optimize than our training criterion because it is required to respect conditional independence and normalization for the underlying HMM. GRAPE takes a hybrid approach for learning. It first trains parameters of a generalized HMM (GHMM) to maximize generative likelihood, and then it selects a small set of parameters that are trained to maximize the percentage of correctly predicted nucleotides, exons, and whole genes used as surrogates of the conditional likelihood. This approach is commonly used when training data is limited, and it usually provides superior results only in those cases [<xref ref-type="bibr" rid="pcbi-0030054-b021">21</xref>]. However, the GRAPE learning method does not globally optimize the training criterion.</p></sec><sec id="s2"><title>Results</title><sec id="s2a"><title>Datasets</title><p>All the experiments reported in this paper use a gene model trained on a nonredundant set of 3,038 single-gene sequences. We built this set by combining the Augustus training set [<xref ref-type="bibr" rid="pcbi-0030054-b002">2</xref>], the GenScan training set, and 1,500 high-confidence CDSs from EnsMart Plus [<xref ref-type="bibr" rid="pcbi-0030054-b022">22</xref>], which are part of the Genezilla training set (<ext-link ext-link-type="uri" xlink:href="http://www.tigr.org/software/traindata.shtml" xlink:type="simple">http://www.tigr.org/software/traindata.shtml</ext-link>). We then appended simulated intergenic material to both ends of each training sequence to make up for the lack of realistic intergenic regions in the training material, as described in more detail in Methods.</p><p>We compared CRAIG with GenScan, TwinScan 2.03 (without homology features, also known as GenScan++), Genezilla (formerly known as TigrScan), and Augustus on several benchmark test sets. We also ran predictions with HMMGene, the only other publicly available genefinder to use a discriminative structure training method; we present some prediction results with it in Methods. All programs we compare with are based on similar GHMM models with similar sequence features. Augustus uses two types of length distributions for introns: short intron lengths are modeled with an explicit distribution, but other introns use the default geometric distribution. This difference made Augustus run many times slower than the other programs in all our experiments.</p><p>We evaluated the programs on the following benchmark test sets.</p><sec id="s2a1"><title>BGHM953.</title><p>This test set combines most of the available single-gene test sets in one single set. It includes the GeneParser I (27 genes) and II (34 genes) datasets [<xref ref-type="bibr" rid="pcbi-0030054-b023">23</xref>], 570 vertebrate sequences from Burset and Guigo [<xref ref-type="bibr" rid="pcbi-0030054-b024">24</xref>], 178 human sequences from Guigo et al. [<xref ref-type="bibr" rid="pcbi-0030054-b025">25</xref>], and 195 human, rat, and mouse sequences from Rogic et al. [<xref ref-type="bibr" rid="pcbi-0030054-b026">26</xref>]. Repeated entries were removed. We combined different sets to obtain more reliable evaluation statistics by smoothing out possible overfitting to particular sequence types.</p></sec><sec id="s2a2"><title>TIGR251.</title><p>This test set consists of 251 single-gene sequences, which are part of the TIGR human test dataset (<ext-link ext-link-type="uri" xlink:href="http://www.tigr.org/software/traindata.shtml" xlink:type="simple">http://www.tigr.org/software/traindata.shtml</ext-link>), and it is composed mostly of long-intron genes.</p></sec><sec id="s2a3"><title>ENCODE294.</title><p>This test set consists of 31 test regions from the ENCODE project [<xref ref-type="bibr" rid="pcbi-0030054-b027">27</xref>,<xref ref-type="bibr" rid="pcbi-0030054-b028">28</xref>], for a total of 21M bases, containing 294 carefully annotated alternatively spliced genes and 667 transcripts, after eliminating repeated entries and partial entries with coordinates outside the region's bounds. This is the only test set that was masked using RepeatMasker (<ext-link ext-link-type="uri" xlink:href="http://www.repeatmasker.org/" xlink:type="simple">http://www.repeatmasker.org/</ext-link>) before performing gene prediction. <xref ref-type="table" rid="pcbi-0030054-t001">Table 1</xref> gives summary statistics for the training set and the three test sets.</p><table-wrap content-type="1col" id="pcbi-0030054-t001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t001</object-id><label>Table 1</label><caption><p>Dataset Statistics</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t001" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb1col1" align="left" charoff="0" char=""/><col id="tb1col2" align="char" charoff="0" char="."/><col id="tb1col3" align="char" charoff="0" char="."/><col id="tb1col4" align="char" charoff="0" char="."/><col id="tb1col5" align="char" charoff="0" char="."/><col id="tb1col6" align="char" charoff="0" char="."/><col id="tb1col7" align="char" charoff="0" char="."/><col id="tb1col8" align="char" charoff="0" char="."/><col id="tb1col9" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left"><hr/>Dataset</td><td><hr/>Number of Exons</td><td><hr/>Number of Genes</td><td><hr/>Single Exon Genes</td><td><hr/>Coding (Percent)</td><td><hr/>Average Number of Exons</td><td><hr/>Average Coding Length (bp)</td><td><hr/>Average Transcript Length (bp)</td><td><hr/>Average Intron Length (bp)</td></tr></thead><tbody><tr><td>Training</td><td>17,875</td><td>3,038</td><td>721</td><td>6.8</td><td>6.27</td><td>1,213</td><td>17,683</td><td>3,119</td></tr><tr><td><bold>BGHM953</bold></td><td>4,544</td><td>953</td><td>84</td><td>24.9</td><td>4.77</td><td>860</td><td>3,453</td><td>687</td></tr><tr><td><bold>TIGR251</bold></td><td>1,496</td><td>251</td><td>43</td><td>5.8</td><td>5.96</td><td>1,044</td><td>17,857</td><td>3,389</td></tr><tr><td><bold>ENCODE294</bold></td><td>2,842</td><td>294</td><td>65</td><td>4.6</td><td>8.3</td><td>1,305</td><td>28,179</td><td>4,094</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt101"><p><bold>BGHM953</bold> is a standard benchmark set of single-gene sequences with high protein-coding content (&sim;23&percnt;), short average transcript length (&sim;3,000 bp), and short average intron length (&sim;700 bp). <bold>TIGR251</bold> is also a single-gene sequence set but transcripts and introns are longer; genes in this set resemble our training set the most. <bold>BGHM953</bold>, and to some extent <bold>TIGR251</bold>, are not representative of the whole human genome, because of their high relative frequencies of single-exon genes and coding loci. In contrast, <bold>ENCODE294</bold> is a highly curated dataset containing multiple-gene sequences with long intergenic regions and alternatively spliced genes with long introns. These characteristics more closely resemble real chromosomal DNA. Results on <bold>ENCODE294</bold> may thus be better estimates of performance on biologically interesting genomic sequences.</p></fn></table-wrap-foot> --></table-wrap><p>Predictions on all tests and for all programs—including CRAIG—allow partial genes, multiple genes per region, and genes on both strands. Alternative splicing and genes embedded within genes were not evaluated in this work. Any other program parameters were left at their default values. For each program, we used the human/vertebrate gene models provided with the software distributions. In all tests, sequences with noncanonical splice sites were filtered out. Accuracy numbers were computed with the eval package [<xref ref-type="bibr" rid="pcbi-0030054-b029">29</xref>], a standard and reliable way to compare different gene predictions.</p></sec></sec><sec id="s2b"><title>Prediction in Single-Gene Sequences</title><p><xref ref-type="table" rid="pcbi-0030054-t002">Table 2</xref> shows prediction results for all programs on <bold>BGHM957</bold>. CRAIG achieved better sensitivity and specificity than the other programs at all levels, except for somewhat lower base sensitivity but much higher base specificity than GenScan. The relative F-score improvement for initial and single exons over Genezilla, the second-best program overall for this set, was 14.6% and 5.8%, respectively. Single-exon genes were more difficult to predict for all programs, with specificity barely exceeding 50% for the best program, but CRAIG's relative improvement in sensitivity was nearly 25% over runner-up Genezilla. Terminal exon predictions were also improved over the nearest competitors, but less markedly so. The improved gene-level accuracy follows from these gains at the exon level. GenScan++ and Augustus predicted internal exons with similar accuracy and their F-scores were only slightly worse than CRAIG, but the overall gene-level accuracy for GenScan++ looks much worse because it missed many terminal and single exons. GenScan also did well in this set, but overall performance was somewhat worse than the other programs.</p><table-wrap content-type="1col" id="pcbi-0030054-t002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t002</object-id><label>Table 2</label><caption><p>Accuracy Results for <bold>BGHM953</bold></p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t002" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb2col1" align="left" charoff="0" char=""/><col id="tb2col2" align="left" charoff="0" char=""/><col id="tb2col3" align="left" charoff="0" char=""/><col id="tb2col4" align="left" charoff="0" char=""/><col id="tb2col5" align="left" charoff="0" char=""/><col id="tb2col6" align="left" charoff="0" char=""/><col id="tb2col7" align="left" charoff="0" char=""/><col id="tb2col8" align="left" charoff="0" char=""/><col id="tb2col9" align="left" charoff="0" char=""/><col id="tb2col10" align="left" charoff="0" char=""/><col id="tb2col11" align="left" charoff="0" char=""/><col id="tb2col12" align="left" charoff="0" char=""/></colgroup><thead><tr><td align="left" colspan="2" rowspan="2"><hr/>Level</td><td colspan="2"><hr/>GenScan</td><td colspan="2"><hr/>Genezilla</td><td colspan="2"><hr/>GenScan&plus;&plus;</td><td colspan="2"><hr/>Augustus</td><td colspan="2"><hr/>CRAIG</td></tr><tr><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td></tr></thead><tbody><tr><td><bold>Base</bold></td><td></td><td>95.8</td><td>88.3</td><td>93.2</td><td>91.8</td><td>90.0</td><td>92.7</td><td>92.0</td><td>91.4</td><td>93.9</td><td>93.1</td></tr><tr><td><bold>Exon</bold></td><td>All</td><td>80.5</td><td>77.8</td><td>78.9</td><td>80.7</td><td>68.9</td><td>75.9</td><td>79.3</td><td>81.7</td><td>82.0</td><td>86.3</td></tr><tr><td></td><td>Initial</td><td>62.5</td><td>62.6</td><td>65.3</td><td>66.8</td><td>62.5</td><td>70.5</td><td>60.3</td><td>66.6</td><td>73.4</td><td>78.2</td></tr><tr><td></td><td>Internal</td><td>89.1</td><td>83.9</td><td>84.6</td><td>87.1</td><td>86.5</td><td>88.1</td><td>86.1</td><td>88.5</td><td>84.8</td><td>91.3</td></tr><tr><td></td><td>Terminal</td><td>73.9</td><td>78.6</td><td>76.1</td><td>78.1</td><td>23.1</td><td>52.9</td><td>78.1</td><td>80.7</td><td>81.6</td><td>86.0</td></tr><tr><td></td><td>Single</td><td>59.5</td><td>47.9</td><td>67.9</td><td>52.8</td><td>38.1</td><td>39.3</td><td>66.7</td><td>49.6</td><td>83.3</td><td>49.3</td></tr><tr><td><bold>Gene</bold></td><td></td><td>40.7</td><td>37.7</td><td>47.2</td><td>47.0</td><td>13.9</td><td>13.7</td><td>45.1</td><td>44.1</td><td>57.1</td><td>56.1</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt201"><p>Sensitivity (Sn) and specificity (Sp) for each level and exon type.</p></fn></table-wrap-foot> --></table-wrap><p>Most of the genes in this set have short introns and the intergenic regions are truncated, so prediction was relatively easy and all programs did relatively well. The next section compares performance on datasets with long-intron genes and very long intergenic regions.</p></sec><sec id="s2c"><title>Prediction in Long DNA Sequences</title><p>As previously noted, <bold>TIGR251</bold> has many genes with very long introns, so it is expected to be harder to predict accurately. This was confirmed by the results in <xref ref-type="table" rid="pcbi-0030054-t003">Table 3</xref>. Performance was worse for all programs and levels when compared with the first set. However, CRAIG consistently outperformed the other programs with an even wider performance gap than in the first experiment. Here, base and internal-exon accuracies were also substantially improved. CRAIG's relative F-score improvement for bases and internal exons over Genezilla, the second-best program in both categories, was 5.4% and 7.1%, respectively, compared with approximately 1% for <bold>BGHM953</bold>. Other types of exons also improved, as in the first experiment. Because of these better base and exon-level predictions, the relative F-score improvement over runner-up Genezilla at the gene level was about 57%.</p><table-wrap content-type="1col" id="pcbi-0030054-t003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t003</object-id><label>Table 3</label><caption><p>Accuracy Results for <bold>TIGR251</bold></p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t003" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb3col1" align="left" charoff="0" char=""/><col id="tb3col2" align="left" charoff="0" char=""/><col id="tb3col3" align="left" charoff="0" char=""/><col id="tb3col4" align="left" charoff="0" char=""/><col id="tb3col5" align="left" charoff="0" char=""/><col id="tb3col6" align="left" charoff="0" char=""/><col id="tb3col7" align="left" charoff="0" char=""/><col id="tb3col8" align="left" charoff="0" char=""/><col id="tb3col9" align="left" charoff="0" char=""/><col id="tb3col10" align="left" charoff="0" char=""/><col id="tb3col11" align="left" charoff="0" char=""/><col id="tb3col12" align="left" charoff="0" char=""/></colgroup><thead><tr><td align="left" colspan="2" rowspan="2"><hr/>Level</td><td colspan="2"><hr/>GenScan</td><td colspan="2"><hr/>Genezilla</td><td colspan="2"><hr/>GenScan&plus;&plus;</td><td colspan="2"><hr/>Augustus</td><td colspan="2"><hr/>CRAIG</td></tr><tr><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td></tr></thead><tbody><tr><td><bold>Base</bold></td><td></td><td valign="middle">90.1</td><td valign="middle">70.1</td><td valign="middle">90.8</td><td valign="middle">78.1</td><td valign="middle">86.6</td><td valign="middle">77.1</td><td valign="middle">81.3</td><td valign="middle">77.9</td><td valign="middle">90.4</td><td valign="middle">86.8</td></tr><tr><td><bold>Exon</bold></td><td>All</td><td valign="middle">73.1</td><td valign="middle">59.5</td><td valign="middle">77.8</td><td valign="middle">69.6</td><td valign="middle">66.4</td><td valign="middle">66.1</td><td valign="middle">65.0</td><td valign="middle">67.0</td><td valign="middle">79.3</td><td valign="middle">82.1</td></tr><tr><td></td><td>Initial</td><td valign="middle">47.6</td><td valign="middle">34.5</td><td valign="middle">61.5</td><td valign="middle">52.1</td><td valign="middle">49.0</td><td valign="middle">47.7</td><td valign="middle">48.6</td><td valign="middle">41.0</td><td valign="middle">71.6</td><td valign="middle">69.6</td></tr><tr><td></td><td>Internal</td><td valign="middle">80.5</td><td valign="middle">68.9</td><td valign="middle">82.9</td><td valign="middle">75.9</td><td valign="middle">79.1</td><td valign="middle">77.4</td><td valign="middle">69.0</td><td valign="middle">80.5</td><td valign="middle">81.5</td><td valign="middle">88.4</td></tr><tr><td></td><td>Terminal</td><td valign="middle">68.3</td><td valign="middle">52.8</td><td valign="middle">71.6</td><td valign="middle">61.1</td><td valign="middle">30.8</td><td valign="middle">48.2</td><td valign="middle">64.4</td><td valign="middle">53.8</td><td valign="middle">76.4</td><td valign="middle">74.3</td></tr><tr><td></td><td>Single</td><td valign="middle">39.5</td><td valign="middle">27.7</td><td valign="middle">62.8</td><td valign="middle">52.9</td><td valign="middle">18.6</td><td valign="middle">17.4</td><td valign="middle">53.5</td><td valign="middle">33.8</td><td valign="middle">76.8</td><td valign="middle">54.1</td></tr><tr><td><bold>Gene</bold></td><td></td><td valign="middle">21.1</td><td valign="middle">14.9</td><td valign="middle">31.9</td><td valign="middle">27.1</td><td valign="middle">12.0</td><td valign="middle">10.5</td><td valign="middle">28.3</td><td valign="middle">22.4</td><td valign="middle">48.2</td><td valign="middle">44.0</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt301"><p>Sensitivity (Sn) and specificity (Sp) for each level and exon type.</p></fn></table-wrap-foot> --></table-wrap><p>Our final set of experiments was on <bold>ENCODE294</bold>. The results are shown in <xref ref-type="table" rid="pcbi-0030054-t004">Table 4</xref>. As previously mentioned, all sequences in this set were masked for low-complexity regions and repeated elements. Unlike previous sets, in which masking did not affect results significantly, prediction on unmasked sequences in this set was worse for all programs (unpublished data). In particular, exon and base specificity decreased an average of 8%.</p><table-wrap content-type="1col" id="pcbi-0030054-t004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t004</object-id><label>Table 4</label><caption><p>Accuracy Results for <bold>ENCODE294</bold></p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t004" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb4col1" align="left" charoff="0" char=""/><col id="tb4col2" align="left" charoff="0" char=""/><col id="tb4col3" align="char" charoff="0" char="."/><col id="tb4col4" align="char" charoff="0" char="."/><col id="tb4col5" align="char" charoff="0" char="."/><col id="tb4col6" align="char" charoff="0" char="."/><col id="tb4col7" align="char" charoff="0" char="."/><col id="tb4col8" align="char" charoff="0" char="."/><col id="tb4col9" align="char" charoff="0" char="."/><col id="tb4col10" align="char" charoff="0" char="."/><col id="tb4col11" align="char" charoff="0" char="."/><col id="tb4col12" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left" colspan="2" rowspan="2"><hr/>Level</td><td colspan="2"><hr/>GenScan</td><td colspan="2"><hr/>Genezilla</td><td colspan="2"><hr/>GenScan&plus;&plus;</td><td colspan="2"><hr/>Augustus</td><td colspan="2"><hr/>CRAIG</td></tr><tr><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td><td><hr/>Sn</td><td><hr/>Sp</td></tr></thead><tbody><tr><td><bold>Base</bold></td><td></td><td>84.0</td><td>62.1</td><td>87.6</td><td>50.9</td><td>76.7</td><td>79.3</td><td>76.9</td><td>76.1</td><td>84.4</td><td>80.8</td></tr><tr><td><bold>Exon</bold></td><td>All</td><td>59.6</td><td>47.7</td><td>62.5</td><td>50.5</td><td>51.6</td><td>64.8</td><td>52.1</td><td>63.6</td><td>60.8</td><td>72.7</td></tr><tr><td></td><td>Initial</td><td>28.0</td><td>23.5</td><td>36.4</td><td>25.0</td><td>25.5</td><td>47.8</td><td>34.7</td><td>38.1</td><td>37.3</td><td>55.2</td></tr><tr><td></td><td>Internal</td><td>72.6</td><td>54.3</td><td>73.9</td><td>63.2</td><td>68.0</td><td>62.8</td><td>59.1</td><td>74.7</td><td>71.7</td><td>81.2</td></tr><tr><td></td><td>Terminal</td><td>33.0</td><td>31.6</td><td>36.7</td><td>28.5</td><td>25.7</td><td>53.9</td><td>37.6</td><td>45.5</td><td>33.3</td><td>52.6</td></tr><tr><td></td><td>Single</td><td>28.1</td><td>31.0</td><td>44.1</td><td>14.5</td><td>35.0</td><td>45.7</td><td>43.9</td><td>25.5</td><td>55.9</td><td>26.4</td></tr><tr><td><bold>Transcript</bold></td><td></td><td>8.1</td><td>11.4</td><td>10.3</td><td>9.9</td><td>6.0</td><td>17.0</td><td>10.9</td><td>16.9</td><td>13.5</td><td>23.8</td></tr><tr><td><bold>Gene</bold></td><td></td><td>16.7</td><td>11.4</td><td>20.6</td><td>9.9</td><td>12.5</td><td>17.0</td><td>22.3</td><td>16.9</td><td>26.6</td><td>23.8</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt401"><p>Sensitivity (Sn) and specificity (Sp) results for each level and exon type.</p></fn></table-wrap-foot> --></table-wrap><p>We added a transcript-level prediction category to <xref ref-type="table" rid="pcbi-0030054-t004">Table 4</xref> to better evaluate predictions on alternatively spliced genes. We closely followed the evaluation guidelines and definitions by Guigo and Reese [<xref ref-type="bibr" rid="pcbi-0030054-b028">28</xref>]. There, transcript and gene-level predictions that are consistent with annotated incomplete transcripts are counted correct, even in cases where the predictions include additional exons. We relaxed this policy to also mark as correct those predictions that contained incomplete transcripts whose first (last) exon did not begin (end) with an acceptor (donor). The reason for this change is that no program can exactly predict both ends of such transcripts. We developed our own programs to evaluate single-exon, transcript, and gene-level predictions for incomplete transcripts. Evaluations for other categories and for complete transcripts were handled directly with eval.</p><p>To ensure consistency in the evaluation, we obtained all of the programs except for Genezilla from their authors and we ran them on the test set in our lab. Genezilla predictions for this set were obtained directly from the supplementary material provided by [<xref ref-type="bibr" rid="pcbi-0030054-b028">28</xref>] so that we could measure the potential differences between our evaluation method and that reported in [<xref ref-type="bibr" rid="pcbi-0030054-b028">28</xref>], particularly at the transcript and gene level, for which we expected different results.</p><p>Overall, our results for all programs agree with those of Guigo and Reese [<xref ref-type="bibr" rid="pcbi-0030054-b028">28</xref>]. Genezilla's base and exon-level results using our evaluation program closely matched the published values. Transcript and gene-level results computed by our method were 1% better than the published numbers, which roughly match the percentage of incomplete annotated transcripts with no splice signals on either end. Computed predictions for GenScan and Augustus were also somewhat different, but not substantially so, from those reported by Guigo and Reese [<xref ref-type="bibr" rid="pcbi-0030054-b028">28</xref>], presumably because of differences in program version and operating parameters.</p><p>Improvements in this set were similar to those obtained in our second experiment. The relative F-score improvements for individual bases and internal exons were 6% and 15.4% over GenScan++ and Augustus, the runner-ups in each respective category. Improvement in prediction accuracy on single, initial, and terminal exons is similar to that for the other test sets. Transcript and gene-level accuracies were, respectively, 30% and 30.6% better than Augustus, the second-best program overall. This means that our better accuracy results obtained in the first two single-gene sequence sets scale well to chromosomal regions with multiple, alternatively spliced genes.</p></sec><sec id="s2d"><title>Significance Testing</title><p>In all tests and at all levels, CRAIG achieved greater improvements in specificity than in sensitivity. We investigated whether the improvements in exon sensitivity achieved by CRAIG could be explained by chance. Any exon belonging to a particular test set is associated with two dependent Bernoulli random variables for whether it was correctly predicted by CRAIG and by another program. We computed <italic>p</italic>-values with McNemar's test for dependent, paired samples from CRAIG and each of the other programs over the three test sets, as shown in <xref ref-type="table" rid="pcbi-0030054-t005">Table 5</xref>. The null hypothesis was that CRAIG's advantage in exon predictions is due to chance. The <italic>p</italic>-values were &lt;0.05 for all entries, except for the <bold>TIGR251</bold> experiments against Genezilla and the <bold>ENCODE294</bold> experiments against Genezilla and GenScan; in general, these two genefinders proved to be very sensitive at the cost of predicting many more false positives. <italic>p</italic>-Values for the combined test sets were all below 0.001, showing that CRAIG's advantage was extremely unlikely to be a chance event.</p><table-wrap content-type="1col" id="pcbi-0030054-t005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t005</object-id><label>Table 5</label><caption><p>Significance Testing</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t005" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb5col1" align="left" charoff="0" char=""/><col id="tb5col2" align="char" charoff="0" char="."/><col id="tb5col3" align="char" charoff="0" char="."/><col id="tb5col4" align="char" charoff="0" char="."/><col id="tb5col5" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left"><hr/>Dataset</td><td><hr/>GenScan</td><td><hr/>Genezilla</td><td><hr/>GenScan&plus;&plus;</td><td><hr/>Augustus</td></tr></thead><tbody><tr><td>BGHM953</td><td>0.03</td><td align="left">1.66 &times; 10<sup>&minus;6</sup></td><td>5.2 &times; 10<sup>&minus;66</sup></td><td>1.3 &times; 10<sup>&minus;5</sup></td></tr><tr><td>TIGR251</td><td>2.2 &times; 3.1<sup>&minus;7</sup></td><td align="left">0.22</td><td>1.4 &times; 10<sup>&minus;23</sup></td><td>1.4 &times; 10<sup>&minus;25</sup></td></tr><tr><td>ENCODE294</td><td>0.17</td><td align="left">&ge;0.5</td><td>2.33 &times; 3<sup>&minus;22</sup></td><td>4.7 &times; 10<sup>&minus;16</sup></td></tr><tr><td>All</td><td align="left">5.7 &times; 10<sup>&minus;6</sup></td><td align="left">6.2 &times; 10<sup>&minus;4</sup></td><td>8.2 &times; 10<sup>&minus;105</sup></td><td>3.45 &times; 10<sup>&minus;35</sup></td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt501"><p>McNemar test results (<italic>p</italic>-value upper bounds) of paired exon sensitivity predictions between CRAIG and each of the other programs.</p></fn></table-wrap-foot> --></table-wrap><p>We also trained and tested an additional variant of CRAIG, in which we did not distinguish between short and long introns; this configuration corresponds closely to the state model representation used in most previous works. Following Stanke and Waack [<xref ref-type="bibr" rid="pcbi-0030054-b002">2</xref>], we used the relative mean improvement:
					<disp-formula id="pcbi-0030054-e001"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.e001" xlink:type="simple"/><!-- <mml:math display='block'><mml:mi>r</mml:mi><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mi>&Delta;</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>&plus;</mml:mo><mml:mi>&Delta;</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>&plus;</mml:mo><mml:mi>&Delta;</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo>&plus;</mml:mo><mml:mi>&Delta;</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>p</mml:mi><mml:mi>g</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mn>4</mml:mn></mml:mfrac></mml:math> --></disp-formula>as the measure of differences in prediction accuracy between the CRAIG variant and CRAIG itself. The term Δ<italic>Sn<sub>exon</sub></italic> denotes the mean increase in exon sensitivity and is defined as
					<disp-formula id="pcbi-0030054-eq001"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq001" xlink:type="simple"/><!-- <mml:math display='block'><mml:mi>&Delta;</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi></mml:msub><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mstyle displaystyle='true'><mml:msub><mml:mo>&sum;</mml:mo><mml:mi>t</mml:mi><mml:mo>&isin;</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:msub><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>&times;</mml:mo><mml:mi>&Delta;</mml:mi><mml:mi>S</mml:mi><mml:msubsup><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:msubsup></mml:mstyle><mml:mstyle displaystyle='true'><mml:msub><mml:mo>&sum;</mml:mo><mml:mi>t</mml:mi><mml:mo>&isin;</mml:mo><mml:mi>T</mml:mi></mml:msub><mml:msub><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mstyle></mml:mfrac></mml:math> --></disp-formula>where <italic>n<sub>t</sub></italic> is the number of annotated genes in dataset <italic>t, T</italic> = {<bold>BGHM953, TIGR251, ENCODE294</bold>}, and Δ<italic>Sn<sup>t</sup><sub>exon</sub></italic> is the difference in exon sensitivity between CRAIG and the CRAIG variant on dataset <italic>t</italic>. The other terms are defined similarly. The improvement obtained by CRAIG with respect to the variant was <italic>r</italic> = 3.6. This result was as expected: there was an improvement in accuracy from including the extra intron state in the gene model, but even the simpler variant was more than competitive with the best current genefinders.
				</p></sec></sec><sec id="s3"><title>Discussion</title><p>It is well-known that more gene prediction errors occur on regions with low GC content, which have higher intron and intergenic region density [<xref ref-type="bibr" rid="pcbi-0030054-b015">15</xref>]. This behavior can also be observed on our combined results, as shown in <xref ref-type="fig" rid="pcbi-0030054-g002">Figure 2</xref>A. It also can be noticed that CRAIG had the best F-score for all intron lengths. Except for CRAIG and HMMGene, the F-scores for all other predictors were very close for all lengths. CRAIG's advantage over its nearest competitors became more apparent as introns increased in length. However, all genefinders experience a significant drop in accuracy, at least 25% between 1,000 bp and 16,000 bp. For introns shorter than 1,000 bp, Augustus performs almost as well as CRAIG, in part because of its more complex, time-consuming model for short intron lengths.</p><fig id="pcbi-0030054-g002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.g002</object-id><label>Figure 2</label><caption><title>F-Score as a Function of Intron Length</title><p>Results for all sets combined (A) and for individual test sets shown in subfigures (B–D). The boxed number appearing directly above each marker represents the total number of introns associated with the marker's length. For example, there were 1,475 introns with lengths between 1,000 and 2,000 base pairs for all sets combined (A).</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.g002" xlink:type="simple"/></fig><p>Intron analysis of individual test sets, as shown in <xref ref-type="fig" rid="pcbi-0030054-g002">Figure 2</xref>B–<xref ref-type="fig" rid="pcbi-0030054-g002">2</xref>D, reveals that, except for <bold>ENCODE294</bold>, CRAIG consistently achieved an intron F-score above 75%, even for lengths more than 30,000 bp; in contrast, the F-scores of all other programs fell to lower than 65%, even for introns as short as 8,000 bp. The results show that CRAIG predicts genes with long introns much better than the other programs. This hypothesis was also confirmed with experiments on an edited version of <bold>ENCODE294</bold> in which the original 31 regions were split into 271 contig sequences and all of the intergenic material was deleted except for 2,000 bp on both sides of each gene. This edited version was further subdivided into subsets with—<bold>ALT_ENCODE155</bold>—and without—<bold>NOALT_ENCODE139</bold>—alternative splicing. <xref ref-type="fig" rid="pcbi-0030054-g003">Figure 3</xref> shows intron prediction results for this arrangement. It can be observed that intron prediction on <bold>NOALT_ENCODE139</bold>, a subset of 139 genes, has the same characteristics as either <bold>TIGR251</bold> or <bold>BGHM953</bold>, that is, a rather flat F-score curve as intron length increases. The same cannot be said about complementary subset <bold>ALT_ENCODE155</bold>, whose significant drop in accuracy for long introns can be explained by the presence of alternative splicing.</p><fig id="pcbi-0030054-g003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.g003</object-id><label>Figure 3</label><caption><title>F-Score versus Intron Length for the Encode Test Set</title><p>Results in subfigures (A) and (B) correspond to the subset of alternatively spliced genes and its complementary subset, respectively.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.g003" xlink:type="simple"/></fig><p>We claimed in the Introduction that a key aspect of our model and training method is the ability to combine various genomic features and to find a global tradeoff among their contributions so that accuracy is maximized. Being able to identify introns longer than 30,000 bp with prediction accuracy comparable to that achieved on smaller introns is evidence that our program does a better job of combining features to recognize structure. Another way to see how well features have been integrated into the structure model is to examine signal predictions. It is well-known that translation initiation sites (TIS) are surrounded by relatively poorly conserved sequences and are harder to predict than the highly conserved splice signals. Also, stop signals present almost no sequence conservation at all and their prediction depends solely upon how well the last acceptor (in multi-exon genes) or the TIS (in single-exon genes) was predicted. Therefore, a simple splice site classifier can perform fairly well using only local sequence information. In contrast, TIS and stop signal classifiers are known to be much less accurate. Given these observations, we expected CRAIG to improve the most on TIS signal prediction accuracy, as all other programs examined in this work use individual classifiers for signal prediction, whereas CRAIG uses global training to compute each signal's net contribution to the gene structure. <xref ref-type="fig" rid="pcbi-0030054-g004">Figure 4</xref> shows the improvement in signal prediction accuracy for CRAIG when compared with the second-best program in each case. CRAIG shows improvement for all types of signals, but the improvement was most marked for TIS, especially in specificity. It can also be observed that the improvement on stop signals follows from the co-occurring improvement on both acceptor and TIS signals. The final outcome is that CRAIG makes fewer mistakes in deciding where to start translation and stop translation, which is one of the main reasons for its significant improvement at the gene level.</p><fig id="pcbi-0030054-g004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.g004</object-id><label>Figure 4</label><caption><title>Signal Accuracy Improvements</title><p>CRAIG's relative improvements in prediction specificity (orange bar) and sensitivity (blue bar) by signal type. In each case, the second-best program was used for the comparison: Genezilla for starts, Augustus for stops, and GenScan++ for splice sites.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.g004" xlink:type="simple"/></fig><p>There is great potential for including additional informative features into the model without algorithm changes, for instance, features derived from comparative genomics. To facilitate such extensions, we designed CRAIG to allow model changes without recompiling the C++ training and test code. The finite-state model, the features, and their relationships to states and transitions are all specified in a configuration file that can be changed without recompiling the program. This flexibility could be useful for learning gene models on organisms that may require a different finite-state model or a different set of features.</p></sec><sec id="s4"><title>Materials and Methods</title><sec id="s4a"><title>Gene structures.</title><p>In what follows, a gene structure consists of either a single exon or a succession of alternating exons and introns, trimmed from both ends at the TIS and stop signals. We distinguish two different types of introns: short—980 bp or less—and long—more than 980 bp. <xref ref-type="fig" rid="pcbi-0030054-g005">Figure 5</xref> shows a gene finite-state model that implements these distinctions.</p><fig id="pcbi-0030054-g005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.g005</object-id><label>Figure 5</label><caption><title>Finite-State Model for Eukaryotic Genes</title><p>Variable-length genomic regions are represented by states, and biological signals are represented by transitions between states. Short and long introns are denoted by I<sup>S</sup> and I<sup>L</sup>, respectively.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.g005" xlink:type="simple"/></fig></sec><sec id="s4b"><title>Linear structure models.</title><p>In what follows, <bold><italic>x</italic></bold> <italic>= x</italic><sub>1</sub>…<italic>x<sub>P</sub></italic> is a sequence and <bold><italic>s</italic></bold> <italic>= s<sub>1</sub>…s<sub>Q</sub></italic> is a segmentation of <bold><italic>x</italic></bold>, where each segment <italic>s<sub>j</sub> =</italic> 〈<italic>p<sub>j</sub>,l<sub>j</sub>,y<sub>j</sub></italic>〉 starts at position pos(<italic>s<sub>j</sub></italic>) = <italic>p<sub>j</sub></italic>, has length len(<italic>s<sub>j</sub></italic>) = <italic>l<sub>j</sub></italic>, and state label lab(<italic>s<sub>j</sub></italic>) = <italic>y<sub>j</sub></italic>, with <italic>p<sub>j+1</sub></italic> = <italic>p<sub>j</sub></italic> + <italic>l<sub>j</sub></italic> ≤ <italic>P</italic> and 1 ≤ <italic>l<sub>j</sub></italic> ≤ <italic>B</italic> for some empirically determined upper bound <italic>B</italic>. The training data. <inline-formula id="pcbi-0030054-ex001"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030054.ex001" xlink:type="simple"/></inline-formula>
					 consists of pairs of a sequence and its preferred segmentation. For DNA sequences, <italic>x<sub>i</sub></italic> ∈ Σ<sub>DNA</sub> = {A, T, G, C}, and each label lab(<italic>s<sub>j</sub></italic>) is one of the states of the model (<xref ref-type="fig" rid="pcbi-0030054-g005">Figure 5</xref>). A segment is also referred to as a genomic region; that is, an exon, an intron, or an intergenic region.
				</p><p>A first-order Markovian linear structure model computes the score of a candidate segmentation <bold><italic>s</italic></bold> <italic>= s<sub>1</sub>…s<sub>Q</sub></italic> of a given input sequence <bold><italic>x</italic></bold> as a linear combination of terms for individual features of a candidate segment, the label of its predecessor, and the input sequence. More precisely, each proposed segment <italic>s<sub>j</sub></italic> is represented by a feature vector <bold><italic>f</italic></bold>(<italic>s<sub>j</sub>,</italic>lab(<italic>s<sub>j−1</sub></italic>),<bold><italic>x</italic></bold><italic>)</italic> ∈ ℜ<italic><sup>D</sup></italic> computed from the segment, the label of the previous segment, and the input sequence around position pos(<italic>s<sub>j</sub></italic>). A weight vector<italic><sub>,</sub></italic><bold> <italic>w</italic></bold> ∈ ℜ<italic><sup>D</sup></italic>, to be learned, represents the relative weights of the features. Then, the score of candidate segmentation <bold><italic>s</italic></bold> for sequence <bold><italic>x</italic></bold> is given by
					<disp-formula id="pcbi-0030054-e002"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.e002" xlink:type="simple"/><!-- <mml:math display='block'><mml:msub><mml:mi>S</mml:mi><mml:mi>w</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>x</mml:mi></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>s</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mi>j</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>1</mml:mn><mml:mi>Q</mml:mi></mml:munderover><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>w</mml:mi></mml:mstyle><mml:mo>&sdot;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>f</mml:mi></mml:mstyle><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi mathvariant='italic'>s</mml:mi><mml:mi mathvariant='italic'>j</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mtext>lab</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi mathvariant='italic'>s</mml:mi><mml:mi mathvariant='italic'>j</mml:mi><mml:mo>&minus;</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy='false'>)</mml:mo><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo></mml:mstyle></mml:math> --></disp-formula>
				</p><p>For gene prediction, we need to answer three basic questions. First, given a sequence, <bold><italic>x</italic></bold><italic>,</italic> we need to efficiently find its best-scoring segmentation. Second, given a training set <inline-formula id="pcbi-0030054-ex002"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030054.ex002" xlink:type="simple"/></inline-formula>
					, we need to learn weights <bold><italic>w</italic></bold> such that the best-scoring segmentation of <bold><italic>x</italic></bold><sup>(<italic>t</italic>)</sup> is close to <bold><italic>s</italic></bold><sup>(<italic>t</italic>)</sup>. Finally, we need to select a feature function <bold><italic>f</italic></bold> that is suitable for answering the first two questions while providing good generalization to unseen test sequences. The next three subsections answer these questions.
				</p></sec><sec id="s4c"><title>Inference for gene prediction.</title><p>Let <bold>GEN(<italic>x</italic>)</bold> be the set of all possible segmentations of <bold><italic>x</italic></bold>. The best segmentation of <bold><italic>x</italic></bold> for weight vector <bold><italic>w</italic></bold> is given by:
					<disp-formula id="pcbi-0030054-e003"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.e003" xlink:type="simple"/><!-- <mml:math display='block'><mml:mover accent='true'><mml:mi mathvariant='bold'>s</mml:mi><mml:mo mathvariant='bold'>&circ;</mml:mo></mml:mover><mml:mo>&equals;</mml:mo><mml:mi>arg</mml:mi><mml:mo></mml:mo><mml:munder><mml:mi>max</mml:mi><mml:mo></mml:mo><mml:mi>s</mml:mi><mml:mo>&isin;</mml:mo><mml:mtext fontweight='bold'>GEN</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:munder><mml:msub><mml:mi>S</mml:mi><mml:mi>w</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:math> --></disp-formula>
				</p><p>We can compute <bold>ŝ</bold> efficiently from <bold><italic>x</italic></bold> using the following Viterbi-like recurrence:
					<disp-formula id="pcbi-0030054-e004"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.e004" xlink:type="simple"/><!-- <mml:math display='block'><mml:mi>M</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo stretchy="true">&lcub;</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mtable columnalign='left'><mml:mtr><mml:mtd><mml:mtext> </mml:mtext><mml:msub><mml:mi>max</mml:mi><mml:mo></mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mo>&prime;</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>&le;</mml:mo><mml:mi>l</mml:mi><mml:mo>&le;</mml:mo><mml:mi>min</mml:mi><mml:mo></mml:mo><mml:mo>&lcub;</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>B</mml:mi><mml:mo>&rcub;</mml:mo></mml:msub><mml:mi>M</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>i</mml:mi><mml:mo>&minus;</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mo>&prime;</mml:mo></mml:msup><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext></mml:mtext><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>w</mml:mi></mml:mstyle><mml:mo>&sdot;</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>f</mml:mi></mml:mstyle><mml:mo stretchy='false'>(</mml:mo><mml:mo>&lang;</mml:mo><mml:mi>i</mml:mi><mml:mo>&minus;</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>l</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>&rang;</mml:mo><mml:mo>,</mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mo>&prime;</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&minus;</mml:mo><mml:mi>&infin;</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mtd><mml:mtd><mml:mtable columnalign='left'><mml:mtr><mml:mtd></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>if</mml:mtext><mml:mspace width='2pt'/><mml:mi>i</mml:mi><mml:mspace width='2pt'/><mml:mo>&gt;</mml:mo><mml:mspace width='2pt'/><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>if</mml:mtext><mml:mspace width='2pt'/><mml:mi>i</mml:mi><mml:mo>&equals;</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math> --></disp-formula>
				</p><p>It is easy to see that <inline-formula id="pcbi-0030054-ex003"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030054.ex003" xlink:type="simple"/></inline-formula>
					 where GEN<italic><sub>i,y</sub></italic>(<bold><italic>x</italic></bold>) is the set of all segmentations of <italic>x<sub>1</sub>…x<sub>i</sub></italic> that end with label <italic>y</italic>. Therefore, <italic>S<bold><sub>w</sub></bold></italic>(<bold><italic>x</italic></bold>,<bold><italic>ŝ</italic></bold>) <italic>= M</italic>(<italic>P</italic> + 1,END), where END is a special synchronization state inserted at position <italic>P</italic> + 1. The actual segmentations are easily obtained by keeping back-pointers from each state-position pair (<italic>y,i</italic>) to its optimal predecessor (<italic>y′,i−l</italic>). The complexity of this algorithm is <italic>O</italic>(<italic>PBm</italic><sup>2</sup>), where <italic>m</italic> is the number of distinct states and <italic>B</italic> is the upper bound on the segment length, because the runtime of <bold>w</bold> · <bold><italic>f</italic></bold> is independent of <italic>P, B,</italic> or <italic>m</italic>. To reduce the constant factor from these dot product computations, most <bold>w</bold> ·<bold> <italic>f</italic></bold> values are precomputed and cached. For introns and intergenic regions, the feature function <bold><italic>f</italic></bold> is a sum of per-nucleotide contributions, so the dynamic program in Equation 4 needs only to look at position <italic>i</italic> − 1 when <italic>y</italic> corresponds to such regions. Therefore, <italic>B</italic> needs to be only the upper bound for exon lengths, which was chosen following Stanke and Waack [<xref ref-type="bibr" rid="pcbi-0030054-b002">2</xref>]. For long sequences, the complexity of the inference algorithm is therefore dominated by the sequence length <italic>P</italic>.
				</p></sec><sec id="s4d"><title>Online large-margin training.</title><p>Online learning is a simple, scalable, and flexible framework for training linear structured models. Online algorithms process one training example at a time, updating the model weights to improve the model's accuracy on that example. Large-margin classifiers, such as the well-known SVMs, provide strong theoretical classification error bounds that hold well in practice for many learning tasks. MIRA [<xref ref-type="bibr" rid="pcbi-0030054-b030">30</xref>] is an online method for training large-margin classifiers that is easily extended to structured problems [<xref ref-type="bibr" rid="pcbi-0030054-b019">19</xref>]. Algorithm 1 shows the pseudocode for the MIRA-based training algorithm we used for our models. For each training sequence, <bold><italic>x</italic></bold><sup>(<italic>t</italic>)</sup>, the algorithm seeks to establish a margin between the score of the correct segmentation and the score of the best segmentation according to the current weight vector that is proportional to the mismatch between the candidate segmentation and the correct one. MIRA keeps the norm of the change in weight vector as small as possible while giving the current example (<bold><italic>x</italic></bold><sup>(<italic>t</italic>)</sup>,<bold><italic>s</italic></bold><sup>(<italic>t</italic>)</sup>) a score that exceeds that of the best-scoring incorrect segmentation by a margin given by the mismatch between the correct segmentation and the incorrect one. The quadratic program in line 5 of Algorithm 1 formalizes that objective, and has a straightforward closed-form solution for this version of the algorithm. Line 11 of the algorithm computes <bold><italic>w</italic></bold> as an average of the weight vectors obtained at each iteration, which has been shown to reduce weight overfitting [<xref ref-type="bibr" rid="pcbi-0030054-b031">31</xref>]. The training parameter <italic>N</italic> is determined empirically using an auxiliary development set.</p><p><bold>Algorithm 1.</bold> Online Training Algorithm.</p><p>Training data <inline-formula id="pcbi-0030054-ex004"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030054.ex004" xlink:type="simple"/></inline-formula>
					. <italic>L</italic>(<bold><italic>s</italic></bold><italic><sup>(t</sup></italic><sup>)</sup>,<bold><italic>ŝ</italic></bold>) is some nonnegative real-valued function that measures the mismatch between segmentation <bold><italic>ŝ</italic></bold> and the correct segmentation <bold><italic>s</italic></bold><italic><sup>(t</sup></italic><sup>)</sup><bold><italic>.</italic></bold> The number of rounds <italic>N</italic> is determined using a small development set.
				</p><list list-type="simple"><list-item><p>1: <bold><italic>w</italic></bold><sup>(0)</sup> = <bold>0</bold>; <bold><italic>v</italic></bold> = <bold>0</bold>; <italic>i =</italic> 0</p></list-item><list-item><p>2: <bold>for</bold> round = 1 to <italic>N</italic> <bold>do</bold></p></list-item><list-item><p>3: <bold>for</bold> <italic>t</italic> = 1 to <italic>T</italic> <bold>do</bold></p></list-item><list-item><p>4: <inline-formula id="pcbi-0030054-ex005"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030054.ex005" xlink:type="simple"/></inline-formula>
							
						</p></list-item><list-item><p>5: <inline-formula id="pcbi-0030054-ex006"><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.0030054.ex006" xlink:type="simple"/></inline-formula>
							
						</p></list-item><list-item><p>subject to <italic>S<bold><sub>w′</sub></bold></italic>(<bold><italic>x</italic></bold><sup>(<italic>t</italic>)</sup><italic>,</italic><bold><italic>s</italic></bold><sup>(<italic>t</italic>)</sup>) − <italic>S<bold><sub>w′</sub></bold></italic>(<bold><italic>x</italic></bold><sup>(<italic>t</italic>)</sup><italic>,</italic><bold><italic>ŝ</italic></bold>) ≥ <italic>L</italic>(<bold><italic>s</italic></bold><sup>(<italic>t</italic>)</sup><italic>,</italic><bold><italic>ŝ</italic></bold>)</p></list-item><list-item><p>6: <bold><italic>w</italic></bold><sup>(<italic>i</italic> + 1)</sup> ← <bold><italic>ŵ</italic></bold></p></list-item><list-item><p>7: <bold><italic>v</italic></bold> ← <bold><italic>v</italic></bold> + <bold><italic>w</italic></bold><sup>(<italic>i</italic> + 1)</sup></p></list-item><list-item><p>8: <italic>i</italic> ← <italic>i + 1</italic></p></list-item><list-item><p>9: <bold>end for</bold></p></list-item><list-item><p>10: <bold>end for</bold></p></list-item><list-item><p>11: <bold><italic>w</italic></bold> = <bold><italic>v</italic></bold> / (<italic>N*T</italic>)</p></list-item></list><p>Successful discriminative learning depends on having training data with statistics similar to the intended test data. However, this is not the case for gene training data. The main distribution mismatch is that reliable gene annotations available for training are for the most part for single-gene sequences with very small flanking intergenic regions.</p><p>To address this problem, we created long training sequences composed of actual genes separated by synthetic intergenic regions as follows. For each training sequence, we generated two extra intergenic regions and appended them to both sequence ends, making sure that the total length of both flanking intergenic regions followed geometric distributions with means 5,000, 10,000, 60,000, and 150,000 bp for each of four GC content classes, respectively [<xref ref-type="bibr" rid="pcbi-0030054-b003">3</xref>,<xref ref-type="bibr" rid="pcbi-0030054-b010">10</xref>]. The synthetic intergenic regions were generated by sampling from GC-dependent, fourth-order interpolated Markov models (IMMs), with the same form as the models we used to score the intergenic state.</p><p>Algorithm 1 also requires a loss function, <italic>L,</italic> and a small development set on which to estimate the number of rounds, <italic>N</italic>. As loss function, we used the correlation coefficient at the base level [<xref ref-type="bibr" rid="pcbi-0030054-b024">24</xref>], since it combines specificity and sensitivity into a single measure. The development set consisted of the 65 genes previously used in GenScan [<xref ref-type="bibr" rid="pcbi-0030054-b001">1</xref>] to cross-validate splice signal detectors.</p></sec><sec id="s4e"><title>Features.</title><p>The final ingredient of the CRAIG model is the feature function <bold><italic>f</italic></bold> used to score candidate segments based on properties of the input sequence. A typical feature relates a proposed segment to some property of the input around that segment, and possibly to the label of the previous segment.</p><p><italic>Properties.</italic> We started by introducing basic sequence properties that features are based on. These properties are real-valued functions of the input sequence around a particular position. Some properties represent tests, taking the binary values 1 for true and 0 for false. For any test <italic>P</italic>,‖<italic>P</italic>‖ denotes the function with value 1 if the test is true, 0 otherwise.</p><p>The tests
					<disp-formula id="pcbi-0030054-eq002"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq002" xlink:type="simple"/><!-- <mml:math display='block'><mml:msub><mml:mtext>sub</mml:mtext><mml:mi>u</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>&equals;</mml:mo><mml:mi>x</mml:mi><mml:mo>&lsqb;</mml:mo><mml:mi>i</mml:mi><mml:mo>:</mml:mo><mml:mi>i</mml:mi><mml:mo>&plus;</mml:mo><mml:mo>|</mml:mo><mml:mi>u</mml:mi><mml:mo>|</mml:mo><mml:mo>&minus;</mml:mo><mml:mn>1</mml:mn><mml:mo>&rsqb;</mml:mo><mml:mo>|</mml:mo><mml:mo>|</mml:mo></mml:math> --></disp-formula>check whether substring <bold><italic>u</italic></bold> occurs at position <italic>i</italic> ∈ <bold><italic>x</italic></bold>. For example, <bold><italic>x</italic></bold> = ATGGCGGA would have sub<sub>A</sub>(1,<bold><italic>x</italic></bold>) = 1, sub<sub>TA</sub>(2,<bold><italic>x</italic></bold>) = 0, and sub<sub>GGC</sub>(3,<bold><italic>x</italic></bold>) = 1.
				</p><p>The property score<italic><sub>y</sub></italic>(<italic>i,</italic><bold><italic>x</italic></bold>) computes the score of a content model for state <italic>y</italic> at position <italic>i</italic>. This score is the probability that nucleotide <italic>i</italic> has label <italic>y</italic> according to a <italic>k</italic>-order interpolated Markov model [<xref ref-type="bibr" rid="pcbi-0030054-b032">32</xref>], where <italic>k</italic> = 8 for coding states and <italic>k</italic> = 4 for noncoding states.</p><p>The property gcc(<italic>i,</italic><bold><italic>x</italic></bold>) calculates the GC composition for the region containing position <italic>i</italic>, averaged over a 10,000-bp window around position <italic>i</italic>.</p><p>Each feature associates a property to a particular model state or state transition.</p><p><italic>Binning.</italic> Properties with multimodal or sparse distributions, such as segment length, cannot be used directly in a linear model, because their predictive effect is typically a nonlinear function of their value. To address this problem, we binned each property by splitting its range into disjoint intervals or bins, and converting the property into a set of tests that checked whether the value of the property belonged to the corresponding interval. The effect of this transformation was to pass the property through a stepwise constant nonlinearity, each step corresponding to a bin, where the height of each step was learned as the weight of a binary feature associated to the appropriate test.</p><p>For example, following GenScan [<xref ref-type="bibr" rid="pcbi-0030054-b001">1</xref>], we mapped the GC content property gcc to four bins: &lt;43, 43–51, 51–57, and &gt;57. For other properties, we used regular bins with a property-specific bin width. For instance, exon length was mapped to 90 bp–wide bins.</p><p><italic>Test and feature combinations.</italic> We used Boolean combinations of tests and binary features to model complex dependencies on the input. Conjunctions can model nucleotide correlations, for example donors of the form G<sub>−1</sub>G<sub>5</sub>, that is, donors with G at positions −1 and 5. Likewise, disjunctions were used to model consensus sequences, for example, donors of the form U<sub>3</sub>, that is, donors with either an A or a G at position 3.</p><p>In general, for two binary functions <italic>f</italic> and <italic>g</italic>, we denoted their conjunction by <italic>f</italic> ∧ <italic>g</italic> and their disjunction by <italic>f</italic> ∨ <italic>g</italic>.</p></sec><sec id="s4f"><title>State features.</title><p>State features encode the content properties of the genomic regions associated to states: exons, introns, and intergenic regions. State features do not depend on the previous state, so we omitted the previous state argument in these feature definitions.</p><p><italic>Coding/noncoding potential.</italic> This feature corresponds to the log of the probability assigned to the region by the content scoring model:
					<disp-formula id="pcbi-0030054-eq003"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq003" xlink:type="simple"/><!-- <mml:math display='block'><mml:mtext>pot</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mtext>len</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:mfrac><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mi>k</mml:mi><mml:mo>&equals;</mml:mo><mml:mtext>pos</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mtext>pos</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo><mml:mtext>len</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:munderover><mml:mi>log</mml:mi><mml:mspace width="2pt"/><mml:msub><mml:mtext>score</mml:mtext><mml:mtext>lab</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&minus;</mml:mo><mml:msub><mml:mi>&mu;</mml:mi><mml:mtext>lab</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi mathvariant="italic">s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:msub></mml:mstyle></mml:math> --></disp-formula>where <italic>μ<sub>y</sub></italic> is the arithmetic mean of the distribution of log score<italic><sub>y</sub></italic> on the training data. For coding regions, the sum is computed over codon scores instead of base scores. Other features related to log score<italic><sub>y</sub></italic> also included in <bold><italic>f</italic></bold> are the coding differential and the score log-ratios between intronic and intergenic regions.
				</p><p><italic>Phase biases.</italic> Biases in intron and exon phase distributions have been found and analyzed by Fedorov et al. [<xref ref-type="bibr" rid="pcbi-0030054-b033">33</xref>]. We represented possible biases with the straightforward functions
					<disp-formula id="pcbi-0030054-eq004"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq004" xlink:type="simple"/><!-- <mml:math display='block'><mml:msub><mml:mtext>bias</mml:mtext><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo>&Verbar;</mml:mo><mml:mtext>lab</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:msub><mml:mtext>I</mml:mtext><mml:mi>p</mml:mi></mml:msub><mml:mo>&Verbar;</mml:mo></mml:math> --></disp-formula>where <italic>p</italic> = 0,1,2 is a phase and I<italic><sub>p</sub></italic> is the corresponding intronic state.
				</p><p><italic>Length distributions.</italic> The length distributions of exons and introns have been extensively studied. Raw exon lengths were binned to allow our linear model to learn the length histogram from the training data. For long introns, with length &gt;980, we used 980/len(<italic>s</italic>) as the length feature, whereas shorter introns used max {245/len(<italic>s</italic>),1}.</p><p>For each genomic region type, we also provided length-dependent default features whose weights expressed a bias for or against regions of that length and type. The value of these features is len(s)/<italic>λ<sub>y</sub></italic>, where <italic>λ<sub>y</sub></italic> is the average length of all <italic>y</italic>-labeled segments. For introns and intergenic regions, we used separate, always-on default features for the four classes of GC content discussed above.</p><p><italic>Coding composition.</italic> In addition to coding potential scores, which give broad, smoothed statistics for different genomic region types, we also defined count features for each 3-gram (codon) and 6-gram (bicodon) in an exon, and similar count features for the first 15 bases (five codons) of an initial exon. The 3-gram features were further split by GC content class. The general form of such a feature is
					<disp-formula id="pcbi-0030054-eq005"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq005" xlink:type="simple"/><!-- <mml:math display='block'><mml:mtable columnalign='left'><mml:mtr><mml:mtd><mml:msub><mml:mtext>count</mml:mtext><mml:mi>u</mml:mi><mml:mtext>,</mml:mtext><mml:mi>p</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo stretchy="true">&lcub;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"><mml:mstyle displaystyle='true'><mml:msubsup><mml:mo>&sum;</mml:mo><mml:mi>i</mml:mi><mml:mo>&equals;</mml:mo><mml:mtext>pos</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo><mml:mi>p</mml:mi><mml:mtext>pos</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mtext>)&plus;</mml:mtext><mml:mi>m</mml:mi></mml:msubsup><mml:msub><mml:mtext>sub</mml:mtext><mml:mi>u</mml:mi></mml:msub></mml:mstyle><mml:mo stretchy='false'>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mstyle mathvariant='bold' mathsize='normal'><mml:mi mathvariant='bold'>x</mml:mi></mml:mstyle><mml:mo stretchy='false'>)</mml:mo></mml:mtd><mml:mtd><mml:mtext>if lab</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:msub><mml:mtext>&equals;E</mml:mtext><mml:mi>p</mml:mi></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign='left'><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mtext>otherwise</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:math> --></disp-formula>where <italic>p</italic> = 0,1,2 is the phase, <italic>u</italic> is the n-gram, and <italic>m</italic> is the window size, which is len(<italic>s</italic>) for a general exon count, and min{len(<italic>s</italic>),15} for special initial exon features, which attempt to capture composition regularities right after the TIS.
				</p><p><italic>Masking.</italic> We represented the presence of tandem repeats and other low complexity regions in exonic segments by the function:
					<disp-formula id="pcbi-0030054-eq006"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq006" xlink:type="simple"/><!-- <mml:math display='block'><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>s</mml:mi><mml:mi>k</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo stretchy="false">|}</mml:mo><mml:mo stretchy="false">|</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:mfrac><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mi>k</mml:mi><mml:mo>&equals;</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:munderover><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:msub><mml:mi>b</mml:mi><mml:mtext>N</mml:mtext></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&gt;</mml:mo><mml:mn>0.5</mml:mn></mml:mstyle><mml:mo stretchy="false">|</mml:mo><mml:mo stretchy="false">|</mml:mo></mml:math> --></disp-formula>After training, this feature effectively penalizes any exon whose fraction of <italic>N</italic> occurrences exceeds 50% of its total length.
				</p><p><xref ref-type="table" rid="pcbi-0030054-t006">Table 6</xref> shows all the state features associated with each segment label.</p><table-wrap content-type="1col" id="pcbi-0030054-t006" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t006</object-id><label>Table 6</label><caption><p>State Features for Each Segment Label</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t006" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb6col1" align="left" charoff="0" char=""/><col id="tb6col2" align="left" charoff="0" char=""/><col id="tb6col3" align="left" charoff="0" char=""/></colgroup><thead><tr><td align="left"><hr/>Segment Label</td><td><hr/>Category</td><td><hr/>State Features</td></tr></thead><tbody><tr><td><bold>Intergenic</bold></td><td>Length</td><td>len(<italic>s</italic>)/<italic>&lambda;</italic><sub>y</sub></td></tr><tr><td></td><td>Score</td><td>pot(<italic>s,</italic><bold><italic>x</italic></bold>)</td></tr><tr><td><bold>Intron</bold></td><td>Short only</td><td>max&lcub;980/len(<italic>s</italic>),1&rcub; len(<italic>s</italic>)/<italic>&lambda;<sub>y</sub></italic></td></tr><tr><td></td><td>Long only</td><td>980/len(<italic>s</italic>)/<italic>&lambda;<sub>y</sub></italic> len(<italic>s</italic>)/<italic>&lambda;<sub>y</sub></italic></td></tr><tr><td></td><td>Phase</td><td>bias<sub><italic>p</italic></sub>(<italic>s,</italic><bold><italic>x</italic></bold>)</td></tr><tr><td></td><td>Score</td><td>pot(<italic>s,</italic><bold><italic>x</italic></bold>)</td></tr><tr><td><bold>Exon</bold></td><td>Length</td><td>bins len(<italic>s</italic>)<italic>&lambda;</italic><sub>y</sub></td></tr><tr><td></td><td>Content</td><td>mask(<italic>s,</italic><bold><italic>x</italic></bold>) count<sub><italic>u,p</italic></sub>(<italic>s,</italic><bold><italic>x</italic></bold>)</td></tr><tr><td></td><td>Score</td><td>pot(<italic>s,</italic><bold><italic>x</italic></bold>)</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt601"><p>This summary elides some dependencies of features on state labels. For example, the feature pot(<italic>s,</italic><bold><italic>x</italic></bold>) would behave differently depending on whether <italic>s</italic> is an intron, exon, or intergenic segment, as described in the text.</p></fn></table-wrap-foot> --></table-wrap></sec><sec id="s4g"><title>Transition features.</title><p>Transition features look at biological signals that indicate a switch in genomic region type. Features testing for those signals looked for combinations of particular motifs within a window centered at a given offset from the position where the transition occurs. Features of the following form, which test for motif occurrence, are the building blocks for the transition features:
					<disp-formula id="pcbi-0030054-eq007"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq007" xlink:type="simple"/><!-- <mml:math display='block'><mml:msub><mml:mtext>motif</mml:mtext><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:msub><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mo>&prime;</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mstyle displaystyle='true'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mi>d</mml:mi><mml:mo>&equals;</mml:mo><mml:mo>&minus;</mml:mo><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac><mml:mfrac><mml:mi>w</mml:mi><mml:mn>2</mml:mn></mml:mfrac></mml:munderover><mml:msub><mml:mtext>sub</mml:mtext><mml:mi>u</mml:mi></mml:msub></mml:mstyle><mml:mo stretchy='false'>(</mml:mo><mml:mtext>pos</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&plus;</mml:mo><mml:mi>p</mml:mi><mml:mo>&plus;</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo stretchy='false'>)</mml:mo></mml:math> --></disp-formula>where <italic>p</italic> is the offset, <italic>w</italic> is the window width, and <italic>u</italic> is the motif. This feature counts the number of occurrences of <italic>u</italic> within <italic>p</italic> ± <italic>w</italic>/2 bases of the start of segments.
				</p><p>In principle, all sequence positions are potential signal occurrences, but in practice one might filter out unlikely sites, using a sensitivity threshold proportional to level of signal conservation, thus decreasing decoding time.</p><p>Burge and Karlin [<xref ref-type="bibr" rid="pcbi-0030054-b001">1</xref>] model positional biases within signals with combinations of position weight matrices (PWMs) and their generalizations, weight array models (WAMs) and windowed weight array models (WWAMs), with very good results. It is straightforward to define these models as sets of features based on our motif<italic><sub>p,u,w</sub></italic> feature, as shown here in the WWAM case:
					<disp-formula id="pcbi-0030054-e005"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.e005" xlink:type="simple"/><!-- <mml:math display='block'><mml:msub><mml:mtext>WWAM</mml:mtext><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mo>&prime;</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo>)</mml:mo><mml:mo>&equals;</mml:mo><mml:mo>&lcub;</mml:mo><mml:msub><mml:mtext>motif</mml:mtext><mml:mi>p</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo><mml:mi>w</mml:mi></mml:msub><mml:mo>(</mml:mo><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:msup><mml:mi>y</mml:mi><mml:mo>&prime;</mml:mo></mml:msup><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo>)</mml:mo><mml:mo>:</mml:mo><mml:mi>u</mml:mi><mml:mo>&isin;</mml:mo><mml:mstyle displaystyle='false'><mml:munderover><mml:mo>&sum;</mml:mo><mml:mtext>DNA</mml:mtext><mml:mi>n</mml:mi></mml:munderover></mml:mstyle><mml:mo>,</mml:mo><mml:mi>q</mml:mi><mml:mo>&le;</mml:mo><mml:mi>p</mml:mi><mml:mo>&le;</mml:mo><mml:mi>r</mml:mi><mml:mo>&rcub;</mml:mo></mml:math> --></disp-formula>
				</p><p>PWMs and WAMs are special cases of WWAMs and can thus be defined by PWM<italic><sub>q,r</sub></italic> = WWAM<sub>1,1,<italic>q,r</italic></sub> and WAM<italic><sub>q,r</sub></italic> = WWAM<sub>1,2,<italic>q,r</italic></sub>. This means that we can use all of these techniques to model biological signals in CRAIG with the added advantage of having all signal model parameters trained as part of the gene structure.</p><p>Correlations between two positions within a signal are captured by conjunctions of motif features. For example, the feature conjunction
					<disp-formula id="pcbi-0030054-eq008"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0030054.eq008" xlink:type="simple"/><!-- <mml:math display='block'><mml:msub><mml:mtext>motif</mml:mtext><mml:mo>&minus;</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mtext>A</mml:mtext><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>(</mml:mo><mml:mo>&lang;</mml:mo><mml:mn>156</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mtext>I</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mo>&rang;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mtext>E</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant='bold'>x</mml:mi><mml:mo>)</mml:mo><mml:mo>&and;</mml:mo><mml:msub><mml:mtext>motif</mml:mtext><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mtext>T</mml:mtext><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:msub><mml:mo>(</mml:mo><mml:mo>&lang;</mml:mo><mml:mn>156</mml:mn><mml:mo>,</mml:mo><mml:mn>20</mml:mn><mml:mo>,</mml:mo><mml:msub><mml:mtext>I</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mo>&rang;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mtext>E</mml:mtext><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:math> --></disp-formula>would be 1 whenever there is an A in position −3 and a T in position 2 relative to a donor signal occurring at position 156 in <bold><italic>x</italic></bold>, and 0 otherwise.
				</p><p>We can also extend the feature conjunction operator to sets of features: if <italic>A</italic> and <italic>B</italic> are sets of features, such as the WWAM defined in Equation 5, we can define the set of features <italic>A</italic> ∧ <italic>B</italic> = {<italic>f</italic> ∧ <italic>g</italic> : <italic>f</italic> ∈ <italic>A, g</italic> ∈ <italic>B</italic>}<bold><italic>.</italic></bold></p><p>In Equation 5, if we use the amino acid alphabet ∑<sub>AA</sub> instead of ∑<sub>DNA</sub>, and work with codons instead of single nucleotides, we can model signal peptide regions. If we sum over disjunctions of motif features, we can easily model consensus sequences.</p><p><xref ref-type="table" rid="pcbi-0030054-t007">Table 7</xref> shows the motif feature sets for each biological signal. The parameters required by each feature type were either taken from the literature [<xref ref-type="bibr" rid="pcbi-0030054-b001">1</xref>] or by search on the development set.</p><table-wrap content-type="1col" id="pcbi-0030054-t007" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0030054.t007</object-id><label>Table 7</label><caption><p>Transition Features per Signal Type</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0030054.t007" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb7col1" align="left" charoff="0" char=""/><col id="tb7col2" align="left" charoff="0" char=""/><col id="tb7col3" align="left" charoff="0" char=""/></colgroup><thead><tr><td align="left" valign="middle"><hr/>Type</td><td valign="middle"><hr/>Region</td><td valign="middle"><hr/>Signal Features</td></tr></thead><tbody><tr><td><bold>Start</bold></td><td>Signal</td><td valign="middle">PWM<sub>&minus;4,7</sub>; PWM<sub>&minus;4,7</sub> &and; PWM<sub>&minus;4,7</sub>; ConsPWM<sub>&minus;4,7,CAMCATGSMSV</sub></td></tr><tr><td></td><td>Upstream</td><td valign="middle">WWAM<sub>5,3,&minus;20,&minus;6</sub></td></tr><tr><td></td><td>Peptide</td><td valign="middle">PepWWAM<sub>5,1,3,3</sub>; PepWWAM<sub>15,1,13,13</sub></td></tr><tr><td><bold>Stop</bold></td><td>Signal</td><td valign="middle">PWM<sub>&minus;5,5</sub>; WWAM<sub>5,3,6,20</sub></td></tr><tr><td><bold>Donor</bold></td><td>Signal</td><td valign="middle">PWM<sub>&minus;3,7</sub>; PWM<sub>&minus;3,7</sub> &and; PWM<sub>&minus;3,7</sub>; ConsPWM<sub>&minus;3,7,MAGGTRAGTG</sub> ConsPWM<sub>&minus;3,7,MAGGTRAGTG</sub> &and; PWM<sub>&minus;3,7</sub></td></tr><tr><td></td><td>Upstream</td><td valign="middle"><mml:math display='inline'><mml:msubsup><mml:mi>f</mml:mi><mml:mtext>phase</mml:mtext><mml:mn>2</mml:mn></mml:msubsup></mml:math>&and; WWAM<sub>5,3&ndash;6,&minus;5</sub></td></tr><tr><td></td><td>Downstream</td><td valign="middle"><sub>WWAM5,3,8,20</sub></td></tr><tr><td><bold>Acceptor</bold></td><td>Signal</td><td valign="middle">PWM<sub>&minus;7,3</sub>; PWM<sub>&minus;7,3</sub> &and; PWM<sub>&minus;7,3</sub>; ConsPWM<sub>&minus;7,4,YYYYYCYAGRB</sub>; ConsPWM<sub>&minus;7,4,YYYYYCYAGRB</sub> &and; PWM<sub>&minus;7,3</sub></td></tr><tr><td></td><td>Branch point</td><td valign="middle">WWAM<sub>5,3,&minus;36,&minus;20</sub></td></tr><tr><td></td><td>Pyrimidine region</td><td valign="middle">WWAM<sub>3,2,&minus;28,&minus;8</sub>; ConsPWM<sub>&minus;7,4,YYYYYCYAGRB</sub> &and; WWAM<sub>3,2,&minus;28,&minus;8</sub></td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt701"><p>PepWWAM is a WWAM defined at the amino-acid level, as described in the text. ConsPWM uses feature disjunctions to check whether the given consensus sequence appears at the given position. The feature set conjunction located in the donor's upstream region specifies a phase-dependent WWAM between positions &minus;6 and &minus;5.</p></fn></table-wrap-foot> --></table-wrap><p>We included an additional feature set, motivated by previous work [<xref ref-type="bibr" rid="pcbi-0030054-b002">2</xref>], to learn splice site information from sequences that only contain intron annotations. For any donor (acceptor), we first counted the number of similar donors (acceptors) in a given list of introns. A signal was considered to be similar to another if the Hamming distance between them was at most 1. The features were induced by a logarithmic binning function applied over the total number of similarity counts for Hamming distances 0 and 1.</p></sec></sec></body><back><ack><p>We thank Aaron Mackey for advice on evaluation methods, datasets, and software.</p></ack><glossary><title>Abbreviations</title><def-list><def-item><term>CRAIG</term><def><p>CRF-based ab initio genefinder</p></def></def-item><def-item><term>CRF</term><def><p>conditional random fields</p></def></def-item><def-item><term>HMM</term><def><p>hidden Markov model</p></def></def-item><def-item><term>MIRA</term><def><p>Margin Infused Relaxed Algorithm</p></def></def-item><def-item><term>PWM</term><def><p>position weight matrices</p></def></def-item><def-item><term>SVM</term><def><p>support vector machines</p></def></def-item><def-item><term>TIS</term><def><p>translation initiation site</p></def></def-item><def-item><term>WAM</term><def><p>weight array model</p></def></def-item><def-item><term>WWAM</term><def><p>windowed weight array model</p></def></def-item></def-list></glossary><ref-list><title>References</title><ref id="pcbi-0030054-b001"><label>1</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Burge</surname><given-names>CB</given-names></name><name name-style="western"><surname>Karlin</surname><given-names>S</given-names></name></person-group>
					<year>1998</year>
					<article-title>Finding the genes in genomic DNA.</article-title>
					<source>Curr Opin Struct Biol</source>
					<volume>8</volume>
					<fpage>346</fpage>
					<lpage>354</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b002"><label>2</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Stanke</surname><given-names>M</given-names></name><name name-style="western"><surname>Waack</surname><given-names>S</given-names></name></person-group>
					<year>2003</year>
					<article-title>Gene prediction with a hidden Markov model and a new intron submodel.</article-title>
					<source>Bioinformatics</source>
					<volume>19</volume>
					<issue>Supplement 2</issue>
					<fpage>II215</fpage>
					<lpage>II225</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b003"><label>3</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Majoros</surname><given-names>WH</given-names></name><name name-style="western"><surname>Pertea</surname><given-names>M</given-names></name><name name-style="western"><surname>Salzberg</surname><given-names>SL</given-names></name></person-group>
					<year>2004</year>
					<article-title>TigrScan and GlimmerHMM: Two open source ab initio eukaryotic genefinders.</article-title>
					<source>Bioinformatics</source>
					<volume>20</volume>
					<fpage>2878</fpage>
					<lpage>2879</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b004"><label>4</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Krogh</surname><given-names>A</given-names></name></person-group>
					<year>1997</year>
					<article-title>Two methods for improving performance of an HMM and their application for gene finding.</article-title>
					<source>Proc Int Conf Intell Syst Mol Biol</source>
					<volume>5</volume>
					<fpage>179</fpage>
					<lpage>186</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b005"><label>5</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Majoros</surname><given-names>WH</given-names></name><name name-style="western"><surname>Salzberg</surname><given-names>SL</given-names></name></person-group>
					<year>2004</year>
					<article-title>An empirical analysis of training protocols for probabilistic genefinders.</article-title>
					<source>BMC Bioinformatics</source>
					<volume>5</volume>
					<fpage>206</fpage>
				</element-citation></ref><ref id="pcbi-0030054-b006"><label>6</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Zhang</surname><given-names>MQ</given-names></name></person-group>
					<year>1997</year>
					<article-title>Identification of protein coding regions in the human genome by quadratic discriminant analysis.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>94</volume>
					<fpage>565</fpage>
					<lpage>568</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b007"><label>7</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kulp</surname><given-names>D</given-names></name><name name-style="western"><surname>Haussler</surname><given-names>D</given-names></name><name name-style="western"><surname>Reese</surname><given-names>MG</given-names></name><name name-style="western"><surname>Eeckman</surname><given-names>FH</given-names></name></person-group>
					<year>1996</year>
					<article-title>A generalized hidden Markov model for the recognition of human genes in DNA.</article-title>
					<source>Proc Int Conf Intell Syst Mol Biol</source>
					<volume>4</volume>
					<fpage>134</fpage>
					<lpage>142</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b008"><label>8</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Gelfand</surname><given-names>MS</given-names></name><name name-style="western"><surname>Mironov</surname><given-names>AA</given-names></name><name name-style="western"><surname>Pevzner</surname><given-names>PA</given-names></name></person-group>
					<year>1996</year>
					<article-title>Gene recognition via spliced sequence alignment.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>93</volume>
					<fpage>9061</fpage>
					<lpage>9066</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b009"><label>9</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Birney</surname><given-names>E</given-names></name><name name-style="western"><surname>Clamp</surname><given-names>M</given-names></name><name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name></person-group>
					<year>2004</year>
					<article-title>Genewise and genome wise.</article-title>
					<source>Genome Res</source>
					<volume>14</volume>
					<fpage>988</fpage>
					<lpage>995</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b010"><label>10</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Korf</surname><given-names>I</given-names></name><name name-style="western"><surname>Flicek</surname><given-names>P</given-names></name><name name-style="western"><surname>Duan</surname><given-names>D</given-names></name><name name-style="western"><surname>Brent</surname><given-names>MR</given-names></name></person-group>
					<year>2001</year>
					<article-title>Integrating genomic homology into gene structure.</article-title>
					<source>Bioinformatics</source>
					<volume>17</volume>
					<issue>Supplement 1</issue>
					<fpage>S140</fpage>
					<lpage>S148</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b011"><label>11</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Meyer</surname><given-names>IM</given-names></name><name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name></person-group>
					<year>2002</year>
					<article-title>Comparative ab initio prediction of gene structures using pair HMMs.</article-title>
					<source>Bioinformatics</source>
					<volume>18</volume>
					<fpage>1309</fpage>
					<lpage>1318</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b012"><label>12</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Gross</surname><given-names>SS</given-names></name><name name-style="western"><surname>Brent</surname><given-names>MR</given-names></name></person-group>
					<year>2005</year>
					<article-title>Using multiple alignments to improve gene prediction.</article-title>
					<source>J Comput Biol</source>
					<volume>13</volume>
					<fpage>379</fpage>
					<lpage>393</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b013"><label>13</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Krogh</surname><given-names>A</given-names></name></person-group>
					<year>1998</year>
					<article-title>Gene finding: Putting the parts together.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor"><name name-style="western"><surname>Bishop</surname><given-names>M</given-names></name></person-group>
					<source>Guide to human genome computing</source>
					<publisher-loc>San Diego</publisher-loc>
					<publisher-name>Academic Press</publisher-name>
					<comment>pp.</comment>
					<fpage>261</fpage>
					<lpage>274</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b014"><label>14</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Mathe</surname><given-names>C</given-names></name><name name-style="western"><surname>Sagot</surname><given-names>MF</given-names></name><name name-style="western"><surname>Schiex</surname><given-names>T</given-names></name><name name-style="western"><surname>Rouze</surname><given-names>P</given-names></name></person-group>
					<year>2002</year>
					<article-title>Current methods of gene prediction, their strengths and weaknesses.</article-title>
					<source>Nucleic Acids Res</source>
					<volume>30</volume>
					<fpage>4103</fpage>
					<lpage>4117</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b015"><label>15</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Flicek</surname><given-names>P</given-names></name><name name-style="western"><surname>Keibler</surname><given-names>E</given-names></name><name name-style="western"><surname>Hu</surname><given-names>P</given-names></name><name name-style="western"><surname>Korf</surname><given-names>I</given-names></name><name name-style="western"><surname>Brent</surname><given-names>MR</given-names></name></person-group>
					<year>2003</year>
					<article-title>Leveraging the mouse genome for gene prediction in human: From whole-genome shotgun reads to a global synteny map.</article-title>
					<source>Genome Res</source>
					<volume>13</volume>
					<fpage>46</fpage>
					<lpage>54</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b016"><label>16</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Rätsch</surname><given-names>G</given-names></name><name name-style="western"><surname>Sonnenburg</surname><given-names>S</given-names></name><name name-style="western"><surname>Srinivasan</surname><given-names>J</given-names></name><name name-style="western"><surname>Witte</surname><given-names>H</given-names></name><name name-style="western"><surname>Müller</surname><given-names>KR</given-names></name><etal/></person-group>
					<year>2007</year>
					<article-title>Improving the <named-content content-type="genus-species" xlink:type="simple">C. elegans</named-content> genome annotation using machine learning.</article-title>
					<source>PLoS Comput Biol</source>
					<volume>3</volume>
					<fpage>e20</fpage>
				</element-citation></ref><ref id="pcbi-0030054-b017"><label>17</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Lafferty</surname><given-names>J</given-names></name><name name-style="western"><surname>McCallum</surname><given-names>A</given-names></name><name name-style="western"><surname>Pereira</surname><given-names>F</given-names></name></person-group>
					<year>2001</year>
					<article-title>Conditional random fields: Probabilistic models for segmenting and labeling sequence data.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor"><name name-style="western"><surname>Danyluk</surname><given-names>A</given-names></name></person-group>
					<source>Proceedings of the Eighteenth International Conference on Machine Learning</source>
					<conf-date>28 June–1 July, 2001;</conf-date>
					<conf-loc>Williamsburg, Massachusetts, United States.</conf-loc>
					<comment>ICML '01.</comment>
					<publisher-loc>San Francisco</publisher-loc>
					<publisher-name>Morgan Kauffman</publisher-name>
					<comment>pp.</comment>
					<fpage>282</fpage>
					<lpage>289</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b018"><label>18</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Sarawagi</surname><given-names>S</given-names></name><name name-style="western"><surname>Cohen</surname><given-names>WW</given-names></name></person-group>
					<year>2005</year>
					<article-title>Semi-Markov conditional random fields for information extraction.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor"><name name-style="western"><surname>Saul</surname><given-names>LK</given-names></name><name name-style="western"><surname>Weiss</surname><given-names>Y</given-names></name><name name-style="western"><surname>Bottou</surname><given-names>L</given-names></name></person-group>
					<source>Adv in Neur Inf Proc Syst 17</source>
					<publisher-loc>Cambridge (Massachusetts)</publisher-loc>
					<publisher-name>MIT Press</publisher-name>
					<comment>pp.</comment>
					<fpage>1185</fpage>
					<lpage>1192</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b019"><label>19</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Crammer</surname><given-names>K</given-names></name><name name-style="western"><surname>Dekel</surname><given-names>O</given-names></name><name name-style="western"><surname>Keshet</surname><given-names>J</given-names></name><name name-style="western"><surname>Shalev-Shwartz</surname><given-names>S</given-names></name><name name-style="western"><surname>Singer</surname><given-names>Y</given-names></name></person-group>
					<year>2006</year>
					<article-title>Online passive–aggressive algorithms.</article-title>
					<source>J Machine Learning Res</source>
					<volume>7</volume>
					<fpage>551</fpage>
					<lpage>585</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b020"><label>20</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Juang</surname><given-names>B</given-names></name><name name-style="western"><surname>Rabiner</surname><given-names>L</given-names></name></person-group>
					<year>1990</year>
					<article-title>Hidden Markov models for speech recognition.</article-title>
					<source>Technometrics</source>
					<volume>33</volume>
					<fpage>251</fpage>
					<lpage>272</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b021"><label>21</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Raina</surname><given-names>R</given-names></name><name name-style="western"><surname>Shen</surname><given-names>Y</given-names></name><name name-style="western"><surname>Ng</surname><given-names>AY</given-names></name><name name-style="western"><surname>McCallum</surname><given-names>A</given-names></name></person-group>
					<year>2004</year>
					<article-title>Classification with hybrid generative/discriminative models.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor"><name name-style="western"><surname>Thrun</surname><given-names>S</given-names></name><name name-style="western"><surname>Saul</surname><given-names>LK</given-names></name><name name-style="western"><surname>Schölkopf</surname><given-names>B</given-names></name></person-group>
					<source>Adv in Neur Inf Proc Syst 16</source>
					<publisher-loc>Cambridge (Massachusetts)</publisher-loc>
					<publisher-name>MIT Press</publisher-name>
					<comment>pp.</comment>
					<fpage>545</fpage>
					<lpage>552</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b022"><label>22</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kasprzyk</surname><given-names>A</given-names></name><name name-style="western"><surname>Keefe</surname><given-names>D</given-names></name><name name-style="western"><surname>Smedley</surname><given-names>D</given-names></name><name name-style="western"><surname>London</surname><given-names>D</given-names></name><name name-style="western"><surname>Spooner</surname><given-names>W</given-names></name><etal/></person-group>
					<year>2004</year>
					<article-title>Ensmart: A generic system for fast and flexible access to biological data.</article-title>
					<source>Genome Res</source>
					<volume>14</volume>
					<fpage>160</fpage>
					<lpage>169</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b023"><label>23</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Snyder</surname><given-names>EE</given-names></name><name name-style="western"><surname>Stormo</surname><given-names>GD</given-names></name></person-group>
					<year>1995</year>
					<article-title>Identification of protein coding regions in genomic DNA.</article-title>
					<source>J Mol Biol</source>
					<volume>248</volume>
					<fpage>1</fpage>
					<lpage>18</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b024"><label>24</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Burset</surname><given-names>M</given-names></name><name name-style="western"><surname>Guigo</surname><given-names>R</given-names></name></person-group>
					<year>1996</year>
					<article-title>Evaluation of gene structure prediction programs.</article-title>
					<source>Genomics</source>
					<volume>34</volume>
					<fpage>353</fpage>
					<lpage>357</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b025"><label>25</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Guigo</surname><given-names>R</given-names></name><name name-style="western"><surname>Agarwal</surname><given-names>P</given-names></name><name name-style="western"><surname>Abril</surname><given-names>JF</given-names></name><name name-style="western"><surname>Burset</surname><given-names>M</given-names></name><name name-style="western"><surname>Fickett</surname><given-names>JW</given-names></name></person-group>
					<year>2000</year>
					<article-title>An assessment of gene prediction accuracy in large DNA sequences.</article-title>
					<source>Genome Res</source>
					<volume>10</volume>
					<fpage>1631</fpage>
					<lpage>1642</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b026"><label>26</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Rogic</surname><given-names>S</given-names></name><name name-style="western"><surname>Mackworth</surname><given-names>AK</given-names></name><name name-style="western"><surname>Ouellette</surname><given-names>FB</given-names></name></person-group>
					<year>2001</year>
					<article-title>Evaluation of gene-finding programs on mammalian sequences.</article-title>
					<source>Genome Res</source>
					<volume>11</volume>
					<fpage>817</fpage>
					<lpage>832</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b027"><label>27</label><element-citation publication-type="journal" xlink:type="simple">
					<collab xlink:type="simple">ENCODE Project Consortium</collab>
					<year>2004</year>
					<article-title>The ENCODE (Encyclopedia of DNA Elements) project.</article-title>
					<source>Science</source>
					<volume>306</volume>
					<fpage>636</fpage>
					<lpage>540</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b028"><label>28</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="editor"><name name-style="western"><surname>Guigo</surname><given-names>R</given-names></name><name name-style="western"><surname>Reese</surname><given-names>MG</given-names></name></person-group>
					<year>2006</year>
					<article-title>Egasp '05: Encode genome annotation assessment project.</article-title>
					<source>Genome Biology</source>
					<volume>7 Supplement 1</volume>
				</element-citation></ref><ref id="pcbi-0030054-b029"><label>29</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Keibler</surname><given-names>E</given-names></name><name name-style="western"><surname>Brent</surname><given-names>MR</given-names></name></person-group>
					<year>2003</year>
					<article-title>Eval: A software package for analysis of genome annotations.</article-title>
					<source>BMC Bioinformatics</source>
					<volume>4</volume>
					<fpage>50</fpage>
				</element-citation></ref><ref id="pcbi-0030054-b030"><label>30</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Crammer</surname><given-names>K</given-names></name></person-group>
					<year>2004</year>
					<source>Online learning of complex categorical problems</source>
					<comment>[Ph.D. thesis].</comment>
					<publisher-loc>Jerusalem</publisher-loc>
					<publisher-name>Hebrew University</publisher-name>
				</element-citation></ref><ref id="pcbi-0030054-b031"><label>31</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Collins</surname><given-names>M</given-names></name></person-group>
					<year>2002</year>
					<article-title>Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms.</article-title>
					<comment>In:</comment>
					<source>Proceedings of Conference on Empirical Methods in Natural Language Processing</source>
					<conf-date>6–7 July 2002;</conf-date>
					<conf-loc>Philadelphia, Pennsylvania, United States.</conf-loc>
					<publisher-name>EMNLP 2002</publisher-name>
					<comment>pp.</comment>
					<fpage>1</fpage>
					<lpage>8</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b032"><label>32</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Salzberg</surname><given-names>SL</given-names></name><name name-style="western"><surname>Delcher</surname><given-names>A</given-names></name><name name-style="western"><surname>Kasif</surname><given-names>S</given-names></name><name name-style="western"><surname>White</surname><given-names>O</given-names></name></person-group>
					<year>1998</year>
					<article-title>Microbial gene identification using interpolated Markov models.</article-title>
					<source>Nucleic Acids Res</source>
					<volume>26</volume>
					<fpage>544</fpage>
					<lpage>548</lpage>
				</element-citation></ref><ref id="pcbi-0030054-b033"><label>33</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Fedorov</surname><given-names>A</given-names></name><name name-style="western"><surname>Fedorova</surname><given-names>L</given-names></name><name name-style="western"><surname>Starshenko</surname><given-names>V</given-names></name><name name-style="western"><surname>Filatov</surname><given-names>V</given-names></name><name name-style="western"><surname>Grigor'ev</surname><given-names>E</given-names></name></person-group>
					<year>1998</year>
					<article-title>Influence of exon duplication on intron and exon phase distribution.</article-title>
					<source>J Mol Evol</source>
					<volume>46</volume>
					<fpage>263</fpage>
					<lpage>271</lpage>
				</element-citation></ref></ref-list></back></article>