<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN"><front><journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="publisher">pcbi</journal-id><journal-id journal-id-type="allenpress-id">plcb</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="doi">10.1371/journal.pcbi.0040010</article-id><article-id pub-id-type="publisher-id">07-PLCB-RA-0329R2</article-id><article-id pub-id-type="sici">plcb-04-01-07</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline"><subject>Computational Biology</subject><subject>Computational Biology</subject></subj-group><subj-group subj-group-type="System Taxonomy"><subject>None</subject></subj-group></article-categories><title-group><article-title>Matt: Local Flexibility Aids Protein Multiple Structure Alignment</article-title><alt-title alt-title-type="running-head">Flexible Multiple Structure Alignment</alt-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Menke</surname><given-names>Matthew</given-names></name><xref ref-type="aff" rid="aff1">
            <sup>
            <sup>1</sup>
          </sup>
          </xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Berger</surname><given-names>Bonnie</given-names></name><xref ref-type="aff" rid="aff1">
            <sup>
            <sup>1</sup>
          </sup>
          </xref><xref ref-type="aff" rid="aff2">
            <sup>2</sup>
          </xref><xref ref-type="corresp" rid="cor1">
            <sup>*</sup>
          </xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Cowen</surname><given-names>Lenore</given-names></name><xref ref-type="aff" rid="aff3">
            <sup>
            <sup>3</sup>
          </sup>
          </xref><xref ref-type="corresp" rid="cor1">
            <sup>*</sup>
          </xref></contrib></contrib-group><aff id="aff1">
        <label>1</label>
        <addr-line>
				 Computer Science and Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, Massachusetts, United States of America
			</addr-line>
      </aff><aff id="aff2">
        <label>2</label>
        <addr-line>
				 Department of Mathematics, Massachusetts Institute of Technology, Cambridge, Massachusetts, United States of America
			</addr-line>
      </aff><aff id="aff3">
        <label>3</label>
        <addr-line>
				 Department of Computer Science, Tufts University, Medford, Massachusetts, United States of America
			</addr-line>
      </aff><contrib-group><contrib contrib-type="editor" xlink:type="simple"><name name-style="western"><surname>Dunbrack</surname><given-names>Roland</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">Fox Chase Cancer Center, United States of America</aff><author-notes><corresp id="cor1">* To whom correspondence should be addressed. E-mail: <email xlink:type="simple">bab@csail.mit.edu</email> (BB); <email xlink:type="simple">cowen@cs.tufts.edu</email> (LC)</corresp><fn fn-type="con" id="ack1"><p> MM, BB, and LC conceived and designed the experiments. MM performed the experiments. MM and LC analyzed the data. LC wrote the paper.</p></fn><fn fn-type="conflict" id="ack3"><p> The authors have declared that no competing interests exist.</p></fn></author-notes><pub-date pub-type="ppub"><month>1</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>11</day><month>1</month><year>2008</year></pub-date><volume>4</volume><issue>1</issue><elocation-id>e10</elocation-id><history><date date-type="received"><day>12</day><month>6</month><year>2007</year></date><date date-type="accepted"><day>6</day><month>12</month><year>2007</year></date></history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2008</copyright-year><copyright-holder> Menke et al</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract><p>Even when there is agreement on what measure a protein multiple structure alignment should be optimizing, finding the optimal alignment is computationally prohibitive. One approach used by many previous methods is aligned fragment pair chaining, where short structural fragments from all the proteins are aligned against each other optimally, and the final alignment chains these together in geometrically consistent ways. Ye and Godzik have recently suggested that adding geometric flexibility may help better model protein structures in a variety of contexts. We introduce the program Matt (Multiple Alignment with Translations and Twists), an aligned fragment pair chaining algorithm that, in intermediate steps, allows local flexibility between fragments: small translations and rotations are temporarily allowed to bring sets of aligned fragments closer, even if they are physically impossible under rigid body transformations. After a dynamic programming assembly guided by these “bent” alignments, geometric consistency is restored in the final step before the alignment is output. Matt is tested against other recent multiple protein structure alignment programs on the popular Homstrad and SABmark benchmark datasets. Matt's global performance is competitive with the other programs on Homstrad, but outperforms the other programs on SABmark, a benchmark of multiple structure alignments of proteins with more distant homology. On both datasets, Matt demonstrates an ability to better align the ends of α-helices and β-strands, an important characteristic of any structure alignment program intended to help construct a structural template library for threading approaches to the inverse protein-folding problem. The related question of whether Matt alignments can be used to distinguish distantly homologous structure pairs from pairs of proteins that are not homologous is also considered. For this purpose, a <italic>p</italic>-value score based on the length of the common core and average root mean squared deviation (RMSD) of Matt alignments is shown to largely separate decoys from homologous protein structures in the SABmark benchmark dataset. We postulate that Matt's strong performance comes from its ability to model proteins in different conformational states and, perhaps even more important, its ability to model backbone distortions in more distantly related proteins.</p></abstract><abstract abstract-type="summary"><title>Author Summary</title><sec id="st1"><title/><p>Proteins fold into complicated highly asymmetrical 3-D shapes. When a protein is found to fold in a shape that is sufficiently similar to other proteins whose functional roles are known, this can significantly aid in predicting function in the new protein. In addition, the areas where structure is highly conserved in a set of such similar proteins may indicate functional or structural importance of the conserved region. Given a set of protein structures, the protein structural alignment problem is to determine the superimposition of the backbones of these protein structures that places as much of the structures as possible into close spatial alignment. We introduce an algorithm that allows local flexibility in the structures when it brings them into closer alignment. The algorithm performs as well as its competitors when the structures to be aligned are highly similar, and outperforms them by a larger and larger margin as similarity decreases. In addition, for the related classification problem that asks if the degree of structural similarity between two proteins implies if they likely evolved from a common ancestor, a scoring function assesses, based on the best alignment generated for each pair of protein structures, whether they should be declared sufficiently structurally similar or not. This score can be used to predict when two proteins have sufficiently similar shapes to likely share functional characteristics.</p></sec></abstract><funding-group><funding-statement> LC and BB were supported in part by National Science Foundation Information Technology Research for National Priorities grant (ASE+NHS)(dms)0428715. MM was supported in part by National Institutes of Health training grant T90 DK070069.</funding-statement></funding-group><counts><page-count count="12"/></counts><!--===== Restructure custom-meta-wrap to custom-meta-group =====--><custom-meta-group><custom-meta><meta-name>citation</meta-name><meta-value>Menke M, Berger B, Cowen L (2008) Matt: Local flexibility aids protein multiple structure alignment. PLoS Comput Biol 4(1): e10. doi:<ext-link ext-link-type="doi" xlink:href="http://dx.doi.org/10.1371/journal.pcbi.0040010" xlink:type="simple">10.1371/journal.pcbi.0040010</ext-link></meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="s1"><title>Introduction</title><p>The problem of constructing accurate protein multiple structure alignments has been studied in computational biology almost as long as the better-known multiple sequence alignment problem [<xref ref-type="bibr" rid="pcbi-0040010-b001">1</xref>]. The main goal for both problems is to provide an alignment of residue–residue correspondences in order to identify homologous residues. When applied to closely related proteins, sequence-based and structure-based alignments typically give consistent answers even though most sequence alignment methods are measuring statistical models of amino acid substitution rates, whereas most structure-based methods are seeking to superimpose C-alpha atoms from corresponding backbone 3-D coordinates while minimizing geometric distance. However, as has been known for some time [<xref ref-type="bibr" rid="pcbi-0040010-b002">2</xref>], these answers can diverge when aligning distantly related proteins; most relevant, it is still possible to find good structural alignments when sequence similarity has evolutionarily diverged into “the twilight zone” [<xref ref-type="bibr" rid="pcbi-0040010-b003">3</xref>]. In the twilight zone, distantly related proteins can still share a <italic>common core</italic> structure containing regions, including conserved secondary-structure elements and binding sites, in which the chain retains the topology of its folding pattern (see [<xref ref-type="bibr" rid="pcbi-0040010-b004">4</xref>] for a recent survey). Structural information can align the residues in this common core, even after the sequences have diverged too far for successful sequence-based alignment, because structural similarity is typically more evolutionarily conserved [<xref ref-type="bibr" rid="pcbi-0040010-b005">5</xref>–<xref ref-type="bibr" rid="pcbi-0040010-b007">7</xref>]. (While divergent sequence with conserved structure is the typical case and the one that structural alignment algorithms that respect backbone order such as Matt seek to handle, there are also well-known examples where structure has diverged more rapidly than sequence; see, for example, Kinch and Grishin [<xref ref-type="bibr" rid="pcbi-0040010-b008">8</xref>] and Grishin [<xref ref-type="bibr" rid="pcbi-0040010-b009">9</xref>].)</p><p>Applications of multiple structure alignment programs include understanding evolutionary conservation and divergence, functional prediction through the identification of structurally conserved <italic>active sites</italic> in homologous proteins [<xref ref-type="bibr" rid="pcbi-0040010-b010">10</xref>], construction of benchmark datasets on which to test multiple sequence alignment programs [<xref ref-type="bibr" rid="pcbi-0040010-b006">6</xref>], and automatic construction of profiles and threading templates for protein structure prediction [<xref ref-type="bibr" rid="pcbi-0040010-b004">4</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b011">11</xref>]. It has also recently been suggested that multiple structure alignment algorithms may soon become an important component in the best multiple sequence alignment programs. As more protein structures are solved, there is an ever-increasing chance that a given set of sequences to be aligned will contain a subset with structural information available. To date, however, only a handful of multiple sequence alignment programs are set up to take advantage of any available structural data [<xref ref-type="bibr" rid="pcbi-0040010-b006">6</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b012">12</xref>].</p><p>Pairwise structure alignment programs fall into three broad classes: the first class, to which Matt belongs, are aligned fragment pair (AFP) chaining methods [<xref ref-type="bibr" rid="pcbi-0040010-b013">13</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b014">14</xref>] which do an all-against-all best transformation of short protein fragments from one protein structure onto another, and assemble these in a geometrically consistent fashion. The second class (which includes the popular Dali [<xref ref-type="bibr" rid="pcbi-0040010-b015">15</xref>]), look at pairwise distances or contacts <italic>within</italic> each structure separately, then try to find a maximum set of corresponding residues that obey the same distance or contact relationships in pairs of structures—these are called <italic>distance matrix</italic> or <italic>contact map</italic> methods. The third class consists of everything else, from geometric hashing [<xref ref-type="bibr" rid="pcbi-0040010-b016">16</xref>] borrowed from computer vision to an abstraction of the problem to secondary structural elements [<xref ref-type="bibr" rid="pcbi-0040010-b017">17</xref>]. Some protein structure alignment programs are <italic>nonsequential;</italic> that is, they allow residue alignments that are inconsistent with the linear progression of the protein sequence [<xref ref-type="bibr" rid="pcbi-0040010-b018">18</xref>–<xref ref-type="bibr" rid="pcbi-0040010-b021">21</xref>]. Most enforce an alignment consistent with the sequential ordering of the residues along the backbone—Matt belongs to the class of sequential protein aligners. There are strengths to both approaches: most useful protein alignments are sequential; however, nonsequential protein aligners can handle cases where there is a reordering of domains, and circular permutations [<xref ref-type="bibr" rid="pcbi-0040010-b009">9</xref>].</p><p>Multiple structure alignment programs are typically built on top of pairwise structural alignment programs. Even simplified variants of structure alignment are known to be NP-hard [<xref ref-type="bibr" rid="pcbi-0040010-b022">22</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b023">23</xref>]; important progress has been recently been made in theoretically rigorous approximation guarantees [<xref ref-type="bibr" rid="pcbi-0040010-b024">24</xref>] for pairwise structural alignment using a class of single optimality criteria scores such as the Structal score [<xref ref-type="bibr" rid="pcbi-0040010-b001">1</xref>], and also in provably fast parameterized algorithms for the pairwise structural alignment problem in the nonsequential case [<xref ref-type="bibr" rid="pcbi-0040010-b020">20</xref>].</p><sec id="s1a"><title>Performance Metrics</title><p>There are two related problems that protein structure alignment programs are designed to address. The first we will call the <italic>alignment</italic> problem, where the input is a set of <italic>k</italic> proteins that have a conserved structural common core, where the common core is defined as in Eidhammer et al. [<xref ref-type="bibr" rid="pcbi-0040010-b025">25</xref>] as a set of residues that can be simultaneously superimposed with small structural variation. The desired output consists of a superimposition of the proteins in 3-D space, coupled with the list of which amino acid residues are declared to be in alignment and part of the core. The second problem, which we will call the <italic>discrimination</italic> problem, takes as input a pair of protein structures, and is supposed to output a yes/no answer (together with an associated score or confidence value) as to whether a good alignment can be found for these two protein structures or not. We discuss how to measure performance on the alignment problem first, and then on the discrimination problem below.</p><p>The classical geometric way to measure the quality of a protein structural alignment involves two parameters: the number of amino acid residue positions that are found to participate in the alignment (and are therefore found to be part of the conserved structural core), as well as the average pairwise root mean squared deviation (RMSD) (where RMSD is calculated from the best rigid body transformation using least squares minimization [<xref ref-type="bibr" rid="pcbi-0040010-b026">26</xref>]) between backbone atoms placed in alignment in the conserved core. Clearly, this is a bi-criteria optimization problem: the goal is to <italic>minimize</italic> the RMSD of the conserved core while <italic>maximizing</italic> the number of residues placed in the conserved core.</p><p>We first take a traditional geometric approach: reporting for all programs and all benchmark datasets, the average number of residues placed into the common core structure, alongside the average RMS of the pairwise RMSDs among all pairs of residues that participate in a multiple alignment of a set of structures. In addition, results are compared against Homstrad reference alignments. This approach follows Godzik and Ye's evaluation of their multiple structure alignment program, POSA [<xref ref-type="bibr" rid="pcbi-0040010-b027">27</xref>].</p><p>More sophisticated geometric scoring measures have also been suggested, some to collapse the bi-criteria optimization problem into a single score to be optimized [<xref ref-type="bibr" rid="pcbi-0040010-b028">28</xref>], such as the Structal score [<xref ref-type="bibr" rid="pcbi-0040010-b001">1</xref>], others to incorporate more environmental information into the similarity measure, such as secondary structure, or solvent accessibility [<xref ref-type="bibr" rid="pcbi-0040010-b029">29</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b030">30</xref>]. The <italic>p</italic>-value score that we develop to handle the discrimination problem, described below, is a collapse of the bi-criteria optimization problem into one score that provides a single lens on pairwise alignment quality.</p><p>An alternative approach to measuring the performance of a structure alignment algorithm comes from the discrimination problem directly. Here, the measure is typically ROC curves; looking for the ratio of true and false positives and negatives from a “gold-standard” classification for what is alignable or not, based either on decoy structures or a classification scheme such as SCOP or CATH. Indeed, a possible concern with adding flexibility to protein structure would be that the added flexibility in our alignment might lead to an inability to distinguish structures that should have good alignments from those that do not. We therefore test our ability to distinguish true alignable structures from decoys on the SABmark dataset (which comes with a ready-made set of decoy structures) as compared to competitor programs.</p></sec><sec id="s1b"><title>Our Contribution</title><p>We introduce the program Matt (Multiple Alignment with Translations and Twists), an AFP fragment chaining method for pairwise and multiple sequence alignment that outperforms existing popular multiple structure alignment methods when tested on standard benchmark datasets. At the heart of Matt is a relaxation of the traditional rigid protein backbone transformations for protein superimposition, which allows protein structures <italic>flexibility</italic> to bend or rotate in order to come into alignment. While flexibility has been introduced into the study of protein folding in the context of docking [<xref ref-type="bibr" rid="pcbi-0040010-b031">31</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b032">32</xref>], particularly for the modeling of ligand binding [<xref ref-type="bibr" rid="pcbi-0040010-b033">33</xref>], and more recently in decoy construction for ab initio folding algorithms [<xref ref-type="bibr" rid="pcbi-0040010-b034">34</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b035">35</xref>], it has only recently been incorporated into general-purpose pairwise [<xref ref-type="bibr" rid="pcbi-0040010-b014">14</xref>,<xref ref-type="bibr" rid="pcbi-0040010-b036">36</xref>] and multiple [<xref ref-type="bibr" rid="pcbi-0040010-b027">27</xref>] structure alignment programs. There are two reasons it makes sense to introduce flexibility into protein structure alignment. The first is the main reason that has been addressed in previous work, namely, aligning proteins that do not align well by means of rigid body transformations because their structures have been determined in different conformational states: a well-known example is that the fold of a protein will change depending on whether it is bound to a ligand or not [<xref ref-type="bibr" rid="pcbi-0040010-b033">33</xref>]. Matt is designed to also address the second reason to introduce flexibility into protein structure alignment, namely to handle structural distortions as we align proteins whose shape becomes increasingly divergent outside the conserved core.</p><p>We find that at each fixed value for number of aligned residues, Matt is competitive with other recent multiple structure alignment programs in average RMSD on the popular Homstrad [<xref ref-type="bibr" rid="pcbi-0040010-b037">37</xref>] and outperforms them on the SABmark [<xref ref-type="bibr" rid="pcbi-0040010-b038">38</xref>] benchmark datasets (see <xref ref-type="table" rid="pcbi-0040010-t001">Tables 1</xref>, <xref ref-type="table" rid="pcbi-0040010-t002">2</xref>, and <xref ref-type="table" rid="pcbi-0040010-t003">3</xref>). We emphasize again that this is an <italic>apples-to-apples</italic> comparison of the best (i.e., the standard least squares RMSD minimization) rigid body transformation for Matt's alignments, just as it is for the other programs—while Matt allows impossible bends and breaks in intermediate stages of the algorithm, it is stressed that the final Matt alignments and RMSD scores come from legal, allowable “unbent” rigid body transformations. We also present RMSD/alignment length tradeoffs for Matt performance on the same datasets. In the case of Homstrad, where a manually curated “correct” structural alignment is made available as part of the benchmark, Matt alignments are also measured against the reference alignments, where we are again competitive with or outperforming previous structure alignment programs (see <xref ref-type="table" rid="pcbi-0040010-t001">Table 1</xref>).</p><table-wrap content-type="2col" id="pcbi-0040010-t001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.t001</object-id><label>Table 1</label><caption><p>Homstrad Performance Comparison</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.t001" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb1col1" align="left" charoff="0" char=""/><col id="tb1col2" align="char" charoff="0" char="."/><col id="tb1col3" align="char" charoff="0" char="."/><col id="tb1col4" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left"><hr/>Program Name</td><td><hr/>Average Core Size</td><td><hr/>Average Normalized Correct Pairs</td><td><hr/>Average RMSD</td></tr></thead><tbody><tr><td>MultiProt</td><td>142.331</td><td>132.350</td><td>1.347</td></tr><tr><td>Mustang</td><td>171.363</td><td>155.932</td><td>2.669</td></tr><tr><td>POSA (unbent)</td><td>165.160</td><td>152.475</td><td>2.004</td></tr><tr><td>POSA (bent)</td><td>167.847</td><td>154.482</td><td>2.224</td></tr><tr><td><bold>Matt</bold></td><td><bold>172.276</bold></td><td><bold>155.352</bold></td><td><bold>2.044</bold></td></tr></tbody></table> --><!-- --></table-wrap><table-wrap content-type="2col" id="pcbi-0040010-t002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.t002</object-id><label>Table 2</label><caption><p>SABmark Superfamily Performance Comparison</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.t002" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb2col1" align="left" charoff="0" char=""/><col id="tb2col2" align="char" charoff="0" char="."/><col id="tb2col3" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left"><hr/>Program Name</td><td><hr/>Average Core Size</td><td><hr/>Average RMSD</td></tr></thead><tbody><tr><td>MultiProt</td><td>68.701</td><td>1.498</td></tr><tr><td>Mustang</td><td>104.162</td><td>4.146</td></tr><tr><td><bold>Matt</bold></td><td><bold>104.692</bold></td><td><bold>2.639</bold></td></tr></tbody></table> --><!-- --></table-wrap><table-wrap content-type="2col" id="pcbi-0040010-t003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.t003</object-id><label>Table 3</label><caption><p>SABmark Twilight Zone Performance Comparison</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.t003" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb3col1" align="left" charoff="0" char=""/><col id="tb3col2" align="left" charoff="0" char=""/><col id="tb3col3" align="left" charoff="0" char=""/></colgroup><thead><tr><td align="left"><hr/>Program Name</td><td><hr/>Average Core Size</td><td><hr/>Average RMSD</td></tr></thead><tbody><tr><td>MultiProt</td><td>36.354</td><td>1.536</td></tr><tr><td>Mustang</td><td>66.833</td><td>5.035</td></tr><tr><td><bold>Matt</bold></td><td><bold>66.967</bold></td><td><bold>2.916</bold></td></tr></tbody></table> --><!-- --></table-wrap><p>In addition, Matt's ability to distinguish truly alignable folds from decoy folds is tested with the standard benchmark SABmark set of alignments and decoys [<xref ref-type="bibr" rid="pcbi-0040010-b038">38</xref>]. The SABmark decoy set was constructed to contain, for each alignable subset, decoy structures that belong to a different SCOP superfamily, but whose sequences align reasonably well according to BLAST [<xref ref-type="bibr" rid="pcbi-0040010-b038">38</xref>]. Thus, they may be more similar at the local level to the true positive examples, and thus fool a structure alignment program better than a random structure. Here, we tested both the “unbent” Matt alignments described above, but also the “bent” Matt alignments, where the residues are aligned allowing the impossible bends and breaks. We test Matt's performance both against the decoy set and also against random structures taken from the Protein Data Bank (PDB; <ext-link ext-link-type="uri" xlink:href="http://www.rcsb.org/pdb" xlink:type="simple">http://www.rcsb.org/pdb</ext-link>). We use Matt's performance on the truly random structures to generate a <italic>p</italic>-value score for pairwise Matt alignments. Rather than choose from among the large number of competitor pairwise structural alignment programs, Matt was instead tested against other <italic>multiple</italic> structure aligners, in fact the same programs we used for measuring how well they aligned protein families known to have good alignments. The exception was that we also tested the FlexProt program [<xref ref-type="bibr" rid="pcbi-0040010-b036">36</xref>], a purely pairwise structure alignment program that was of special interest because it also claims to handle flexibility in protein structures.</p><p>We have made Matt along with its structural alignments available at <ext-link ext-link-type="uri" xlink:href="http://groups.csail.mit.edu/cb/matt" xlink:type="simple">http://groups.csail.mit.edu/cb/matt</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://matt.cs.tufts.edu" xlink:type="simple">http://matt.cs.tufts.edu</ext-link> so anyone can additionally compute any alternate alignment quality scores they favor.</p></sec><sec id="s1c"><title>Related Work</title><p>The only general protein structure alignment programs that previously tried to model flexibility are FlexProt [<xref ref-type="bibr" rid="pcbi-0040010-b036">36</xref>] and Ye and Godzik's Fatcat [<xref ref-type="bibr" rid="pcbi-0040010-b014">14</xref>] (both for pairwise alignment), and Fatcat's generalization to multiple structure alignment, POSA [<xref ref-type="bibr" rid="pcbi-0040010-b027">27</xref>]. Fatcat is also an AFP chaining algorithm, except it allows a globally minimized number of translations or bends in the structure if it improves the overall alignment. In this way, it is able to capture homologous proteins with hinges, or other discrete points of flexibility, due to conformational change. Our program Matt is fundamentally different: it instead allows flexibilities <italic>everywhere</italic> between short fragments—that is, it does not seek to globally minimize the number of bends, but rather allows continuous small local perturbations in order to better match the “bent” RMSD between structures. Because Matt allows these flexibilities, it can put strict tolerance limits on “bent” RMSD, so it only keeps fragments that locally have very tight alignments. Up until the last step, Matt allows the dynamic program to assemble fragments in ways that are structurally impossible—one chain may have to break or rotate beyond the physical constraints imposed by the backbone molecules in order to simultaneously fit the best transformation. This is repaired in a final step, when the <italic>residue to residue</italic> alignment produced by this unrealistic “bent” transformation is retained; the best rigid-body transformation that preserves that alignment is found, and then either output along with the residue–residue correspondences produced by the “bent” Matt alignment <italic>or</italic> extended to include as yet unaligned residues that fall within a user-settable maximum RMSD cutoff under the new rigid-body transformation to form the final Matt “unbent” alignment.</p></sec><sec id="s1d"><title>Matt Implementation</title><p>Matt accepts standard PDB files as input, and outputs alignment coordinates in PDB format as well. In addition, when only two structures are input, Matt outputs a <italic>p</italic>-value for whether or not Matt believes the structures are alignable (see below). There is an option to output the “bent” structures in PDB format. Matt also outputs the sequence alignment derived from the structural alignment in FASTA format and a Rasmol script to highlight aligned residues. Windows and Linux binaries and source code are available at <ext-link ext-link-type="uri" xlink:href="http://groups.csail.mit.edu/cb/matt" xlink:type="simple">http://groups.csail.mit.edu/cb/matt</ext-link> and <ext-link ext-link-type="uri" xlink:href="http://matt.cs.tufts.edu" xlink:type="simple">http://matt.cs.tufts.edu</ext-link>.</p></sec><sec id="s1e"><title>Algorithm Overview</title><p>The input to Matt is a set of <italic>g</italic> groups of already multiply aligned protein structures (at the beginning of the algorithm, each structure is placed by itself into its own group). The iterative portion of the Matt algorithm runs <italic>g</italic> − 1 times, each time reducing the number of separate groups by 1 as it merges two sets of aligned structures in a progressive alignment. As we discuss in detail below, the Matt alignments produced in the iterative portion are not geometrically realized by rigid body transformations: they allow local “bends” in the form of transpositions and rotations. Once there is only one group left, Matt enters a final pass, where it corrects the global alignment into an alignment that obeys a user-settable RMSD cutoff by means of geometrically realizably rigid-body transformations. A flowchart describing the stages of the Matt algorithm appears in <xref ref-type="fig" rid="pcbi-0040010-g001">Figure 1</xref>.</p><fig id="pcbi-0040010-g001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g001</object-id><label>Figure 1</label><caption><title>Overview of the Matt Algorithm</title></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g001" xlink:type="simple"/></fig><sec id="s1e1"><title>The iterative portion: fragment pairs.</title><p>There are three main phases to the iterative portion of the Matt algorithm. The first phase is similar to what is done by many existing AFP chaining residues: for simplicity, it is first described here for pairwise alignment (that is, when each group consists of a single structure). Matt considers fragments of five to nine adjacent amino acid residues. A fragment pair is a pair of fragments of equal length, one from each structure. For every fragment pair, between any pair of structures, an alignment score is calculated based on an estimated <italic>p</italic>-value of the minimum RMSD achievable by a rigid-body transformation of the C-alpha atoms of one fragment onto the other. <italic>p</italic>-values are estimated by generating a table of random RMSD alignments of the National Center for Biotechnology Information (NCBI) nonredundant PDB.</p><p>The generalization from aligning fragments from two structures to aligning fragments from two groups of multiple structure alignments is straightforward. The alignment score of a pair of fragments, one from each group alignment, is calculated based on a single rigid-body transformation acting on all of a group's structures together.</p></sec><sec id="s1e2"><title>Dynamic programming assembly with translations and twists.</title><p>Matt's main novel contribution involves how we assemble these short fragments into a global alignment. Note that Matt is an alignment program that respects the sequential order of residues along the backbone, so it only assembles aligned fragments that are consistently ordered.</p><p>Matt iteratively builds up longer and longer sets of aligned fragments using dynamic programming. When deciding whether to chain two sets of aligned fragments together, Matt uses a score based on the sum of the alignment scores of the individual aligned fragments together with a penalty based on the geometric consistency of the transformations associated with deforming the backbone of one set onto the other. Transformation consistency cutoffs were determined empirically using a fifth of the Homstrad benchmark dataset. The consistency score (specified exactly in <xref ref-type="sec" rid="s4">Methods</xref> below) is a function of both relative translation and relative rotation angles; the angles are calculated using quaternions for speed.</p><p>Matt finds the highest-scoring assembly for all pairs of groups of aligned structures that were input. It then chooses the pair of groups with the highest-scoring assembly, and uses that assembly to create a new multiple alignment that merges those two groups. If only one group remains, the algorithm proceeds to the final pass; otherwise, it enters the realign and extend phase before looping back to calculate all fragment pairs again.</p></sec><sec id="s1e3"><title>Realign and extend phase.</title><p>The realignment phase does not change the residue correspondences in the multiple alignment, but tries to find local transformations that tighten RMSD in the aligned fragments in the newly merged group. It is described in more detail in <xref ref-type="sec" rid="s4">Methods</xref>.</p><p>The extension phase is then called. The multiple alignment is extended greedily off both ends of all its fragments as long as average RMSD is below a cutoff (4 Å). Extended fragments are allowed to overlap for up to five residues in this phase (if this produces any inconsistencies in the alignment, note that they are fixed in the next dynamic programming iteration). When only one group of structures remains, the result is the <italic>bent</italic> Matt alignment. The algorithm enters the final pass to produce the <italic>rigid bent</italic> and <italic>unbent</italic> Matt alignments.</p></sec><sec id="s1e4"><title>Final pass.</title><p>The input to the final pass is simply which residues have been aligned with which in the final bent alignment; that is, the multiple sequence alignment derived by the bent multiple structure alignment Matt has generated. Once the mapping of <italic>which</italic> residues are to be aligned has been fixed, finding the associate transformation that optimizes RMSD of the aligned residues of one structure against a set of structures aligned to a reference structure is straightforward. We build up a single multiple structure alignment from such transformations using a similar method to that introduced by Barton and Sternberg [<xref ref-type="bibr" rid="pcbi-0040010-b039">39</xref>]. In particular, additional protein structures are added progressively to the overall alignment. Each time a new structure is added, all existing structures are “popped out” in turn, and realigned back to the new reference alignment. This brings the atoms into tighter and tighter alignment.</p><p>The resulting rigid RMSD Matt alignment leaves the sequence alignment from the bent step <italic>unchanged</italic>, and thus only includes sets with five or more contiguous residues. This alignment is what we call the <italic>rigid bent</italic> Matt alignment, below. We then do a final pass to add back shorter segments. In particular, now that we have a final global multiple structure alignment, we greedily add back in fragments of four or fewer residues that fall between already aligned fragments but whose RMSD is below a user-settable cutoff. That user-settable cutoff is entirely responsible for the different tradeoffs between average RMSD and number of aligned residues that we obtain (see <xref ref-type="fig" rid="pcbi-0040010-g002">Figures 2</xref> and <xref ref-type="fig" rid="pcbi-0040010-g003">3</xref>)—in the comparisons with other programs, the cutoff was uniformly set at 5 Å.</p><fig id="pcbi-0040010-g002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g002</object-id><label>Figure 2</label><caption><title>Matt Homstrad Performance Tradeoffs</title><p>Average pairwise RMSD versus average number of residue positions placed in the common core for the Homstrad multiple alignment benchmark.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g002" xlink:type="simple"/></fig><fig id="pcbi-0040010-g003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g003</object-id><label>Figure 3</label><caption><title>Matt SABmark Performance Tradeoffs</title><p>Average pairwise RMSD versus average number of residue positions placed in the common core for the SABmark superfamily benchmark.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g003" xlink:type="simple"/></fig></sec></sec></sec><sec id="s2"><title>Results</title><sec id="s2a"><title>The Benchmark Datasets</title><p>Perhaps the most popular dataset for testing protein structural alignment programs is Homstrad [<xref ref-type="bibr" rid="pcbi-0040010-b037">37</xref>], which is a manually curated set of 1,028 alignments, each of which contains between two and 41 structures. Homstrad contains highly homologous proteins, with similarity comparable to the <italic>family</italic> level of the hierarchical SCOP [<xref ref-type="bibr" rid="pcbi-0040010-b040">40</xref>] structural classification database. In this paper, in order to be comparable to the results for POSA presented in [<xref ref-type="bibr" rid="pcbi-0040010-b027">27</xref>], we test only on the 399 Homstrad alignments with more than two structures in the alignment (that is, Homstrad sets with between three and 41 structures that necessitate a multiple rather than a pairwise structure alignment program).</p><p>We also test Matt on the superfamily and twilight zone SABmark [<xref ref-type="bibr" rid="pcbi-0040010-b038">38</xref>] benchmark datasets. The superfamily set contains 3,645 domains sorted into 426 subsets representing structures at the superfamily level of the SCOP hierarchy, a set designed to be well-distributed in known protein space, and presumably containing more remote homologs than Homstrad. The twilight zone set contains 1,740 domains sorted into 209 subsets whose homology is even more remote than the superfamily set. Both the superfamily and twilight zone sets have subsets containing between three and 25 structures.</p><p>Since the “correct” alignments provided by SABmark are generated automatically from existing structure alignment programs, we do not report the percentage of “correctly” aligned residue pairs as we did for the manually curated Homstrad, but rather report only the objective geometric measures of alignment quality (number of residues placed in the conserved core, and average pairwise RMSD among residues placed in the combined core).</p><p>SABmark additionally provides a set of decoy structures for nearly all its 462 sets of alignable superfamily (and 209 alignable twilight zone) sets of structures. We constructed a <italic>decoy</italic> discrimination test suite as follows. Each SABmark superfamily (or twilight zone) test set comes with an equal number of decoy structures with high sequence similarity (see [<xref ref-type="bibr" rid="pcbi-0040010-b038">38</xref>]). For each test set, a random pair of structures in the positive set (that belong to the same SCOP superfamily and are supposed to align) and a random decoy were selected. Then a <italic>random</italic> discrimination test suite was similarly constructed, the only difference being that the decoy was chosen to be a random structure in a different SABmark set, not a decoy structure that was specifically chosen to have high sequence similarity to the positive set.</p></sec><sec id="s2b"><title>The Programs to Which Matt Is Compared</title><p>On Homstrad, we compare Matt to three recent multiple structure alignment programs: listed in alphabetical order, they are MultiProt [<xref ref-type="bibr" rid="pcbi-0040010-b041">41</xref>], Mustang [<xref ref-type="bibr" rid="pcbi-0040010-b042">42</xref>], and POSA [<xref ref-type="bibr" rid="pcbi-0040010-b027">27</xref>]. Note that MultiProt has both sequential and nonsequential alignment options; we compare against the option that, like Matt, respects sequence order. MultiProt is an AFP program that uses rigid body superimposition. Mustang uses a combination of short fragment alignment, contact maps, and consensus-based methods. We were particularly eager to test Matt against POSA, because it is the only other multiple structure alignment program that allows flexibility, though as discussed in the <xref ref-type="sec" rid="s1">Introduction</xref>, POSA's flexibility is more limited. POSA outputs two different structural alignments: one comes from the version of POSA that disallows bends, and the other from the version with limited bends allowed. We test both versions, and results appear in <xref ref-type="table" rid="pcbi-0040010-t001">Table 1</xref>.</p><p>We were not able to obtain POSA code. (Our statistics on Homstrad come from POSA alignments provided by the authors as supplementary data). Because we were not able to obtain POSA code, we were not able to test POSA on all of SABmark, but we do compare Mustang and MultiProt to Matt on the entire SABmark benchmark. On the other hand, we were able to submit individual sets of SABmark structures to the POSA online server; POSA sometimes did nearly as well as Matt on the examples we tested, but other times, it missed finding alignable structures entirely. We show both cases in two in-depth examples: <xref ref-type="fig" rid="pcbi-0040010-g004">Figure 4</xref> shows alignments of Matt, MultiProt, Mustang, and POSA on a seven-bladed β-propeller, and <xref ref-type="fig" rid="pcbi-0040010-g005">Figure 5</xref> shows alignments of the four programs on a set of left-handed β-helix structures. POSA and Matt are the only algorithms that successfully align all seven blades of the β-propeller. POSA, however, entirely misses the alignable regions in the β-helix fold.</p><fig id="pcbi-0040010-g004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g004</object-id><label>Figure 4</label><caption><title>Comparative β-Propeller Alignments</title><p>The four SABmark domains in the set Group 137, consisting of seven-bladed β-propellers as aligned by Posa, Mustang, MultiProt, and Matt. Backbone atoms that participate in the common core of the alignment show up colored as red (PDB ID d1nr0a1), green (PDB ID d1nr0a2), blue (PDB ID d1p22a2), and magenta (PDB ID d1tbga); residues in all four chains that are not placed into the alignment by the tested algorithm are shown in gray. These pictures were generated by the Swiss PDB Viewer (DeepView) [<xref ref-type="bibr" rid="pcbi-0040010-b043">43</xref>].</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g004" xlink:type="simple"/></fig><fig id="pcbi-0040010-g005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g005</object-id><label>Figure 5</label><caption><title>Comparative β-Helix Alignments</title><p>Aligned portions of the eight SABmark domains in the set Group 144, consisting of the left-handed β-helix fold as aligned by Posa, Mustang, MultiProt, and Matt. Backbone atoms that participate in the common core of the alignment show up colored as red (PDB ID d1hm9a1), green (PDB ID d1kk6a), blue (PDB ID d1krra), magenta (PDB ID d1lxa), yellow (PDB Is that are not placed into the alignment by the tested algorithm are shown in gray. These pictureD d1ocxa), orange (PDB ID d1qrea), cyan (PDB ID d1xat), and pink (PDB ID d3tdt); residues in all three chains were generated by the Swiss PDB Viewer (DeepView) [<xref ref-type="bibr" rid="pcbi-0040010-b043">43</xref>].</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g005" xlink:type="simple"/></fig><p>For the discrimination problem, Matt is compared against MultiProt and Mustang again, but also against FlexProt [<xref ref-type="bibr" rid="pcbi-0040010-b036">36</xref>]. FlexProt has an option to allow from zero to four bends in the aligned structure, which is specified at runtime. FlexProt scores each of these structures by length of the alignment found. On each structure, the alignment with the number of bends that produces the highest-scoring alignment is output. In the case of both POSA and FlexProt, the “bent” alignment outputs the (best rigid-body transformation) RMSD of the aligned structures with bends allowed, and the “unbent,” or regular, version outputs the RMSD of the best rigid-body transformation that places the same set of residues in alignment as the bent version.</p></sec><sec id="s2c"><title>Performance</title><p><xref ref-type="table" rid="pcbi-0040010-t001">Table 1</xref> shows the following quantities for each program on the 399 Homstrad reference alignments that contain at least three structures each (this is the identical set of reference alignments on which POSA was tested). The first field is the average number of residues placed in the common core. The second is “average normalized correct pairs” computed according to the Homstrad reference alignments. This quantity is computed as follows: for each set of structures, we look at every pair of aligned residues that also participate in a Homstrad correct alignment. Then, we normalize based on the number of structures in the set (so the alignments in the set of 41 structures do not weight more heavily than the alignments in the set of three structures), dividing by the number of pairs of distinct structures in the reference set. (Note that, as discussed in [<xref ref-type="bibr" rid="pcbi-0040010-b042">42</xref>], having additional pairs placed into alignment that Homstrad does not consider part of the “gold-standard” alignment is a positive, not a negative, if RMSD remains low. This is because declaring a pair of nearly aligned residues “aligned” or not is a judgment call that Homstrad makes partially based on older multiple structure alignment programs whose performance is weaker than the most recent programs.) The second column is the same “average RMSD” measure that POSA reports: the average RMS of the pairwise RMSDs among all pairs of residues that participate in a multiple alignment in a set of structures.</p><p>We downloaded and ran MultiProt and Mustang and computed RMSD statistics ourselves. POSA is not available for download, but is only accessible as a webserver; however, Homstrad alignments are available online at <ext-link ext-link-type="uri" xlink:href="http://fatcat.burnham.org/POSA/POSAvsHOM.html" xlink:type="simple">http://fatcat.burnham.org/POSA/POSAvsHOM.html</ext-link>. POSA's Web site provides two sets of multiple alignments: one derived from running their algorithm allowing geometrically impossible bends, and one running an unbent version of their algorithm. Note that for POSA's <italic>bent</italic> alignments, we had to recalculate RMSD from the multiple sequence alignment provided from their bent alignments, because unbent RMSD based on bent alignments was not provided on their Web site. It is of independent interest that, as expected, POSA's unbent version has better RMSD, while POSA's bent version finds more residues participating in the alignments overall.</p><p>Matt scores slightly better than POSA on Homstrad. Matt's average core size is comparable with that of Mustang, but Matt has a lower RMSD. The size of the alignments that MultiProt finds are much smaller than for the other programs (though its average RMSD is therefore much lower): this becomes even more pronounced on the more distant structures in SABmark (see <xref ref-type="fig" rid="pcbi-0040010-g003">Figure 3</xref>). Note that the core-size/RMSD tradeoff of Matt is very sensitive to cutoffs set in the last pass of the Matt algorithm, when it is decided what segments of less than five consecutive residues are added back into the alignment. Throughout this paper, the results reported in our tables come from setting the cutoff at 5 Å. By comparison, if the cutoff is set at 3.5 Å, Matt achieves 168.038 average core size, 153.362 average normalized pairs correct, and 1.862 average RMSD on Homstrad. Full tradeoff results on RMSD versus number of residues based on changing the last pass cutoff appear in <xref ref-type="fig" rid="pcbi-0040010-g002">Figure 2</xref>. Note that Matt's cutoffs for allowable bends were trained on a random 20% of the Homstrad dataset.</p><p>While Matt competes favorably with the other programs on Homstrad, Matt was designed for sets of more distantly related proteins than appear in the Homstrad benchmark. Thus, the best demonstration of the advantage of the Matt approach appears on the more distantly related proteins in the SABmark benchmark sets. Here, Matt is seen to do exactly what was hoped: by detouring through bent structures, it finds rigid RMSD alignments that place as many residues in the conserved alignment as Mustang does (and more than 50% more than MultiProt does) while reducing the average RMSD from that of Mustang by more than 1.4 Å (see <xref ref-type="table" rid="pcbi-0040010-t002">Tables 2</xref> and <xref ref-type="table" rid="pcbi-0040010-t003">3</xref>). It should again be emphasized that none of Matt's parameters were trained on SABmark.</p><p>Looking by hand through the alignments, MultiProt consistently aligns small subsets of residues correctly, but leaves large regions unaligned that both Mustang and Matt believe to be alignable. Mustang, on the other hand, frequently misaligns regions, particularly in the case when there are many α-helices tightly packed in the structure. On two of the twilight zone sets, Mustang fails to find anything in the common core. Altogether on the twilight zone set, there are four sets of structures for which Mustang fails to find at least three residues in the common core (and there is one set of structures in the superfamily set where Mustang also fails to find anything in the common core). Though the effect is negligible, these four sets are removed from Mustang's average RMSD calculation.</p><p>Although these tables show overall performance, it is also helpful to look at actual examples. We pulled two example reference sets out of the SABmark superfamily benchmark. <xref ref-type="fig" rid="pcbi-0040010-g004">Figure 4</xref> shows the Matt alignment versus MultiProt, POSA, and Mustang alignments of the SABmark structures in the set labeled Group 137 (β-propellers; PDB IDs d1nr0a1, d1nr0a2, d1p22a2, and d1tbga). POSA does second best to Matt here, and in fact, the overall alignment of the structures in POSA is most similar to Matt—the same propeller blades are overlaid in both alignments. Although it is hard to see in the picture, Mustang is superimposing the wrong blades, which accounts for the terrible RMSD. MultiProt makes a similar error, but then gets a low RMSD by aligning less of the structure. <xref ref-type="fig" rid="pcbi-0040010-g005">Figure 5</xref> shows a Matt alignment of the SABmark structures in the set labeled Group 144 (β-helices; PDB IDs d1hm9a1, d1kk6a, d1krra, d1lxa, d1ocxa, d1qrea, d1xat, and d3tdt). Here, POSA does very poorly, only finding a very small set of residues to align. MultiProt again aligns the portion that it declares in the common core very tightly (this is a theme throughout the SABmark dataset), but it only places five rungs in the common core. Both these figures were generated using the Swiss PDB Viewer (DeepView) [<xref ref-type="bibr" rid="pcbi-0040010-b043">43</xref>]. Core size and RMSD comparisons on both these reference sets appear in <xref ref-type="table" rid="pcbi-0040010-t004">Table 4</xref>.</p><table-wrap content-type="2col" id="pcbi-0040010-t004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.t004</object-id><label>Table 4</label><caption><p>Example of Multiple Structure Alignments in the Two Figures from the SABmark Benchmark Dataset</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.t004" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb4col1" align="left" charoff="0" char=""/><col id="tb4col2" align="char" charoff="0" char="."/><col id="tb4col3" align="char" charoff="0" char="."/><col id="tb4col4" align="char" charoff="0" char="."/><col id="tb4col5" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left"><hr/>Program Name</td><td><hr/>Propeller Core Size</td><td><hr/>Propeller RMSD</td><td><hr/>&beta;-Helix Core Size</td><td><hr/>&beta;-Helix RMSD</td></tr></thead><tbody><tr><td>MultiProt</td><td>180</td><td>1.73</td><td>79</td><td>1.01</td></tr><tr><td>Mustang</td><td>218</td><td>6.13</td><td>83</td><td>7.05</td></tr><tr><td>POSA</td><td>252</td><td>2.62</td><td>23</td><td>3.13</td></tr><tr><td><bold>Matt</bold></td><td><bold>261</bold></td><td><bold>2.35</bold></td><td><bold>98</bold></td><td><bold>2.42</bold></td></tr></tbody></table> --><!-- --></table-wrap><p>We then turn to the discrimination problem. Matt, FlexProt, Mustang, and MultiProt were tested on the SABmark superfamily and SABmark twilight zone decoy test suites described in the previous section. Using a method similar to what Gerstein and Levitt [<xref ref-type="bibr" rid="pcbi-0040010-b044">44</xref>] did to systematically assess structure alignment programs against a gold standard, length of alignment versus RMSD for the true positives and true negatives were plotted in the plane for all programs. <xref ref-type="fig" rid="pcbi-0040010-g006">Figure 6</xref> displays the results on the SABmark superfamily set versus SABmark decoys. The separating line marks where the true positive and true negative percentages are roughly equal.</p><fig id="pcbi-0040010-g006" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g006</object-id><label>Figure 6</label><caption><title>Distinguishing Alignable Structures from Decoys</title><p>Positive (blue) and SABmark decoy (red) pairwise alignments plotted by RMSD versus number of residues for Matt, FlexProt, MultiProt, and Mustang on the SABmark superfamily set.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g006" xlink:type="simple"/></fig><p>When comparing ROC curves over the four different programs, we find that Matt consistently dominates both FlexProt and MultiProt at almost every fixed true positive rate. Mustang does as well. Interestingly, Matt and Mustang are incomparable—on the Superfamily sets, Matt does better than Mustang when the true positive rate is fixed over 93% (90% for the random decoy set), and Mustang does better thereafter. For the twilight zone set, the situation is reversed: SABmark does better than Matt when the true positive rate is between 93% and 98%, but Matt does better between 70% and 92% true positives; then, performance reverses, and Mustang does better below 70% true positive rates. Sample percentages for the four programs near the line where the true positive and true negative percentages are roughly equal appear in <xref ref-type="table" rid="pcbi-0040010-t005">Tables 5</xref> and <xref ref-type="table" rid="pcbi-0040010-t006">6</xref> on the superfamily and twilight zone family sets, respectively.</p><table-wrap content-type="2col" id="pcbi-0040010-t005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.t005</object-id><label>Table 5</label><caption><p>Discrimination Performance on the SABmark Superfamily Set</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.t005" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb5col1" align="char" charoff="0" char="."/><col id="tb5col2" align="char" charoff="0" char="."/><col id="tb5col3" align="char" charoff="0" char="."/><col id="tb5col4" align="char" charoff="0" char="."/><col id="tb5col5" align="char" charoff="0" char="."/><col id="tb5col6" align="char" charoff="0" char="."/><col id="tb5col7" align="char" charoff="0" char="."/><col id="tb5col8" align="char" charoff="0" char="."/><col id="tb5col9" align="char" charoff="0" char="."/></colgroup><thead><tr><td align="left" rowspan="2"><hr/>True Positive</td><td colspan="2"><hr/>Matt True Negative</td><td colspan="2"><hr/>FlexProt True Negative</td><td colspan="2"><hr/>Mustang True Negative</td><td colspan="2"><hr/>MultiProt True Negative</td></tr><tr><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td></tr></thead><tbody><tr><td>95.04</td><td><bold>81.80</bold></td><td><bold>71.16</bold></td><td>49.88</td><td>47.28</td><td>74.94</td><td>71.63</td><td>64.30</td><td>46.81</td></tr><tr><td>94.09</td><td><bold>84.63</bold></td><td><bold>75.65</bold></td><td>60.99</td><td>56.03</td><td>76.36</td><td>73.29</td><td>72.10</td><td>54.14</td></tr><tr><td>93.14</td><td><bold>85.82</bold></td><td>77.30</td><td>70.45</td><td>65.72</td><td>82.51</td><td><bold>78.96</bold></td><td>78.01</td><td>62.65</td></tr><tr><td>92.20</td><td><bold>87.00</bold></td><td>79.20</td><td>76.83</td><td>72.58</td><td>85.82</td><td><bold>82.03</bold></td><td>81.80</td><td>68.79</td></tr><tr><td>91.02</td><td><bold>90.54</bold></td><td>82.74</td><td>81.56</td><td>79.20</td><td>89.60</td><td><bold>84.16</bold></td><td>87.71</td><td>75.89</td></tr><tr><td>90.07</td><td>92.43</td><td>86.52</td><td>84.16</td><td>82.74</td><td><bold>94.33</bold></td><td><bold>89.36</bold></td><td>90.78</td><td>78.82</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt501"><p>True negative percentage correct on the multiple structure alignment programs at a fixed true positive percentage rate in the range close to where the true positive and true negative rates are equal. Results in bold are the best at that fixed true positive rate.</p></fn></table-wrap-foot> --></table-wrap><table-wrap content-type="2col" id="pcbi-0040010-t006" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.t006</object-id><label>Table 6</label><caption><p>Discrimination Performance on the SABmark Twilight Zone Set</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.t006" xlink:type="simple"/><!-- <table frame="hsides" rules="none"><colgroup><col id="tb6col1" align="left" charoff="0" char=""/><col id="tb6col2" align="left" charoff="0" char=""/><col id="tb6col3" align="left" charoff="0" char=""/><col id="tb6col4" align="left" charoff="0" char=""/><col id="tb6col5" align="left" charoff="0" char=""/><col id="tb6col6" align="left" charoff="0" char=""/><col id="tb6col7" align="left" charoff="0" char=""/><col id="tb6col8" align="left" charoff="0" char=""/><col id="tb6col9" align="left" charoff="0" char=""/></colgroup><thead><tr><td align="left" rowspan="2"><hr/>True Positive</td><td colspan="2"><hr/>Matt True Negative</td><td colspan="2"><hr/>MultiProt True Negative</td><td colspan="2"><hr/>Mustang True Negative</td><td colspan="2"><hr/>FlexProt True Negative</td></tr><tr><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td><td><hr/>Random Decoy</td><td><hr/>SABmark Decoy</td></tr></thead><tbody><tr><td>85.17</td><td><bold>85.65</bold></td><td><bold>83.73</bold></td><td>71.29</td><td>70.81</td><td>77.99</td><td>77.03</td><td>78.47</td><td>67.94</td></tr><tr><td>84.21</td><td><bold>88.52</bold></td><td><bold>84.21</bold></td><td>74.16</td><td>73.68</td><td>78.95</td><td>77.51</td><td>80.38</td><td>69.86</td></tr><tr><td>83.25</td><td><bold>89.95</bold></td><td><bold>85.17</bold></td><td>74.64</td><td>74.16</td><td>80.86</td><td>78.47</td><td>80.86</td><td>70.33</td></tr><tr><td>82.30</td><td><bold>90.43</bold></td><td><bold>86.12</bold></td><td>76.08</td><td>75.12</td><td>81.34</td><td>78.95</td><td>81.82</td><td>72.73</td></tr><tr><td>81.34</td><td><bold>90.91</bold></td><td><bold>86.12</bold></td><td>77.03</td><td>75.60</td><td>82.30</td><td>80.38</td><td>82.30</td><td>73.68</td></tr><tr><td>80.38</td><td><bold>92.34</bold></td><td><bold>87.56</bold></td><td>77.03</td><td>76.56</td><td>84.69</td><td>81.82</td><td>82.30</td><td>73.68</td></tr></tbody></table> --><!-- <table-wrap-foot><fn id="nt601"><p>True negative percent correct on the multiple structure alignment programs on the more difficult SABmark twilight zone set at a fixed true positive percentage rate, in the range close to where the two rates are equal. Results in bold are the best at that fixed true positive rate. Matt is always the best in this range.</p></fn></table-wrap-foot> --></table-wrap><p>Unsurprisingly, for all four programs, the SABmark decoy set was more difficult to classify than the random decoy set. What was more surprising is how competitive Mustang is with Matt on the discrimination tasks—it is surprising because Mustang was uniformly worse at the alignment problem. In essence, Mustang produces alignments with very high RMSD, but consistently even higher RMSD on the decoy sets. We hypothesize that this may be due to Mustang's use of contact maps, a global measure of fold-fit that may be harder for decoys to match, whereas the decoys may have long regions of local similarity. Matt and Mustang both do qualitatively better at all discrimination tasks than either MultiProt or FlexProt.</p><p>Note that in <xref ref-type="fig" rid="pcbi-0040010-g006">Figure 6</xref> and in both <xref ref-type="table" rid="pcbi-0040010-t005">Tables 5</xref> and <xref ref-type="table" rid="pcbi-0040010-t006">6</xref> we have used the RMSD of the best rigid-body transformation that matches the <italic>bent</italic> Matt or FlexProt alignment. At first, we hypothesized that the bent RMSD values might give better discrimination; after all, the bent structures are the local pieces that align really well. However, giving credit for the lower bent RMSD values also greatly improved the RMSD values for the decoy structures, leading in every case to worse performance on the discrimination tasks. Thus, reporting an RMSD value for the rigid superimposition that minimized the RMSD of the residues placed into a bent alignment produced the best separation of true alignments from decoys.</p></sec><sec id="s2d"><title><italic>p</italic>-Value Calculation</title><p><italic>p</italic>-values for pairwise Matt alignments are calculated based on our 2-D alignment versus RMSD graphs. To calculate <italic>p</italic>-values, we find the slope <italic>m</italic> of a line in the alignment length versus RMSD graph that maximizes the number of elements from the random negative set on one side and has at least 90% of the SABmark positives on the other. This value was chosen because it allows roughly the same percentage of the negative set to be on the other side. These were then used to calculate <italic>z</italic>-scores of the distribution of RMSD —<italic>m</italic> × <italic>length</italic> of the random negative set. These are fit to a standard Gaussian distribution to calculate <italic>p</italic>-values for pairwise alignments.</p></sec></sec><sec id="s3"><title>Discussion</title><p>We introduced the program Matt, which showed that detouring through local flexibility in an AFP alignment algorithm could aid in protein multiple structure alignment. We suggest that looking at local bends in protein structure captures similarity well for fundamental biological as well as for mathematical reasons. In particular, Matt may be both capturing flexibility inherent naturally in some protein structures themselves and modeling structural distortions in the common core that arise as proteins become more evolutionarily distant.</p><p>Matt runs in <italic>O</italic>(<italic>k</italic><sup>2</sup><italic>n</italic><sup>3</sup> log <italic>n</italic>) time, where <italic>k</italic> is the number of sequences participating in the alignment and <italic>n</italic> is the length of the longest sequence in the alignment. Compared with Mustang and MultiProt, Matt takes about the same amount of time to complete running on the benchmark datasets. We find that Matt is typically several times slower on most sets of structures; however, there are a small percentage of sets of substructures in both benchmark datasets where both Mustang and MultiProt take orders of magnitude more time to complete their alignments than they do on the typical set of structures. Matt is saved in these difficult cases with lots of self-similar substructures by its implementation of the oct-trees, which allows for better pruning of the search space. Matt also supports a multithreaded implementation, which is faster still. Matt is sufficiently fast that it should be feasible to construct a set of reference alignments for similar fold classes based on Matt, covering the space of all known folds, which we intend to do.</p><p>Examining some of the Matt alignments by hand, the program seems to typically do a better job of aligning the ends of α-helices and β-strands than its competitors; we therefore suggest that Matt may be a useful tool for construction of better sequence profiles for protein structure prediction, and for the construction of better templates for protein threading libraries. For these applications, both Matt's rigid unbent alignments and the geometrically impossible bent alignments may be of interest.</p><p>Finally, looking at how Matt (or the other structure aligners) performs on the two SABmark benchmarks raises again the philosophical question of how far into the twilight zone it makes sense to align protein structures. Clearly at the superfamily level, there is typically substantial structural similarity. At the twilight zone level, there is much increased divergence. Examining these alignments in more details may help develop our intuition about the limits of comparative modeling for protein structure prediction as we go further into the twilight zone.</p></sec><sec id="s4" sec-type="methods"><title>Methods</title><sec id="s4a"><title>Pairwise alignment.</title><p>First, it is useful consider Matt's behavior on pairwise alignments. In what follows, we assume structures are sequentially ordered from their N terminal to their C terminal.</p><p><italic>Notation and definitions.</italic> A block denotes the C-alpha atoms of a set of five to nine adjacent amino acid residues in a protein structure. For block <italic>B</italic>, let <italic>b<sub>h</sub></italic> denote the first residue and <italic>b<sub>t</sub></italic> denote the last residue of the block. A block pair is a pair of blocks of equal length, one from each of a pair of structures. For block pair <italic>BC</italic>, define <italic>T<sub>CB</sub></italic> to be the minimum RMSD transformation that is applied to the second structure to align its C-alpha carbons against the first, and let <italic>RMS<sub>T</sub></italic> denote the RMSD of the two blocks under <italic>T</italic>. Minimum transformations are calculated using the standard classical singular value decomposition method of Kabsch [<xref ref-type="bibr" rid="pcbi-0040010-b026">26</xref>]. For block pair <italic>BC</italic>,
					<disp-formula id="pcbi-0040010-e001"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0040010.e001" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mi>S</mml:mi><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&equals;</mml:mo><mml:mo>&minus;</mml:mo><mml:mi>log</mml:mi><mml:mi>P</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>R</mml:mi><mml:mi>M</mml:mi><mml:mi>S</mml:mi><mml:msub><mml:mi>D</mml:mi><mml:mi>T</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>.</mml:mo></mml:mrow></mml:math> --></disp-formula>Here, <italic>p</italic>-values are estimated by generating a table of random five-residue RMSD alignments of the NCBI nonredundant PDB [<xref ref-type="bibr" rid="pcbi-0040010-b045">45</xref>] (update dated 7 May 2007) with a BLAST E-value cutoff of 10<sup>−7</sup>. For longer block pairs, negative log <italic>p</italic>-values for a given RMSD are assumed to increase linearly with respect to alignment length. (This assumption was verified empirically to be approximately true in the relevant range.) Let <italic>S</italic> be a set of block pairs. Two block pairs <italic>BC</italic> and <italic>DE</italic> are sequential if <italic>b<sub>t</sub></italic> precedes <italic>d<sub>h</sub></italic> (and <italic>c<sub>t</sub></italic> precedes <italic>e<sub>h</sub></italic>) and there is no block pair with any residue that lies between them in <italic>S</italic>. A set of block pairs is called an <italic>assembly</italic> if it consists of block pairs <italic>P</italic><sub>1</sub>, <italic>P</italic><sub>2</sub><italic>, …, P<sub>n</sub></italic> such that <italic>P<sub>i</sub> and P<sub>i</sub></italic><sub>+1</sub> are sequential. Note that the definition of sequential means that the <italic>P<sub>i</sub></italic> will be non-overlapping and seen in both structures in precisely this order; see <xref ref-type="fig" rid="pcbi-0040010-g007">Figure 7</xref>.
				</p><fig id="pcbi-0040010-g007" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.0040010.g007</object-id><label>Figure 7</label><caption><title>Two Sequential Block Pairs that Could Form Part of an Assembly</title><p>Block pair <italic>BC</italic> precedes block pair <italic>DE</italic> because <italic>B</italic> precedes <italic>D</italic> and <italic>C</italic> precedes <italic>E</italic> in their respective protein sequences.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.0040010.g007" xlink:type="simple"/></fig></sec><sec id="s4b"><title>Matt assembly.</title><p>A Matt pass uses dynamic programming to create an assembly of block pairs. A pass takes an assembly and three cutoff values as input and outputs a new assembly. The new assembly contains all the block pairs of the original assembly. The three cutoffs are a maximum block-pair RMSD cutoff and maximum values for the displacement and relative angles for each sequential pair of blocks (the “translations” and “twists,” respectively, of Matt's acronym). Using multiple passes and relaxing cutoffs in each successive pass results in favoring strongly conserved regions while still detecting more weakly conserved regions.</p><p>All Matt results in this paper use a three-pass algorithm. All three passes use a cutoff of 45° on the angle between the transformations of two sequential block pairs. The first pass is restricted to block pairs with a minimum negative log <italic>p</italic>-value of 2.0, and sequential block pairs must have a displacement no greater than 4. The second pass uses a minimum negative log <italic>p</italic>-value of 1.6 and a maximum displacement of sequential pairs of 5. The last pass uses cutoffs of 0.6 and 10, respectively. The values of these cutoffs were determined by training on a random 20% of the Homstrad benchmark dataset.</p><p>More formally, the score of a set of block pairs <italic>S</italic> is the sum of the alignment scores of the individual block pairs and a bonus based on how consistent the transformations associated with the two block pairs are. This score is used internally throughout the construction of the alignment, but is not used to determine the <italic>p</italic>-value, which is instead computed directly based on length and RMSD of the resulting alignments; see the section on calculating <italic>p</italic>-values at the end of the <xref ref-type="sec" rid="s1">Introduction</xref>.
					<disp-formula id="pcbi-0040010-e002"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0040010.e002" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd><mml:mtext>Score</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>S</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo>&equals;</mml:mo></mml:mtd></mml:mtr><mml:mtr columnalign='left'><mml:mtd columnalign='left'><mml:mrow><mml:mspace width="8pt"/><mml:msub><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>&isin;</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>&minus;</mml:mo><mml:mi>log</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mtext>Pvalue</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mtext>RMSD</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo stretchy='false'>)</mml:mo><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mo>&plus;</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign='left'><mml:mtd columnalign='left'><mml:mrow><mml:mspace width="8pt"/><mml:msub><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mi>E</mml:mi><mml:mspace width="3pt"/><mml:mtext>sequential in</mml:mtext><mml:mspace width="3pt"/><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>&minus;</mml:mo><mml:mi>log</mml:mi><mml:mo stretchy='false'>(</mml:mo><mml:mtext>SolidAngle</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mtext>Angle</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>C</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>E</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo stretchy='false'>)</mml:mo><mml:mo stretchy='false'>)</mml:mo><mml:mo stretchy='false'>)</mml:mo></mml:mrow><mml:mo>&plus;</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign='left'><mml:mtd columnalign='left'><mml:mrow><mml:mspace width="8pt"/><mml:msub><mml:mo>&sum;</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mi>E</mml:mi><mml:mspace width="3pt"/><mml:mtext>sequential in</mml:mtext><mml:mspace width="3pt"/><mml:mi>S</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy='false'>(</mml:mo><mml:mn>4</mml:mn><mml:mo>&minus;</mml:mo><mml:mtext>Displacement</mml:mtext><mml:mo stretchy='false'>(</mml:mo><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mi>E</mml:mi><mml:mo stretchy='false'>)</mml:mo><mml:mo stretchy='false'>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable><mml:mo>,</mml:mo></mml:mrow></mml:math> --></disp-formula>where
					<disp-formula id="pcbi-0040010-e003"><graphic mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.0040010.e003" xlink:type="simple"/><!-- <mml:math display='block'><mml:mrow><mml:mtable><mml:mtr columnalign="left"><mml:mtd><mml:mtext>Displacement</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>B</mml:mi><mml:mi>C</mml:mi><mml:mo>,</mml:mo><mml:mi>D</mml:mi><mml:mi>E</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&equals;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="8pt"/><mml:mtext>Length</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>C</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&minus;</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>E</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>c</mml:mi><mml:mi>t</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&plus;</mml:mo><mml:mtext>Length</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>C</mml:mi><mml:mi>B</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&minus;</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>E</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>e</mml:mi><mml:mi>t</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math> --></disp-formula>and Length is defined to be ordinary Euclidean distance, Angle is the angle of <italic>T<sub>CB</sub>T<sub>ED</sub></italic><sup>−1</sup> in axis-angle form, and SolidAngle is the solid angle associated with an angle, measured as a fraction of the sphere. SolidAngle(<italic>θ</italic>) ranges from 0 to 1 and is the probability of a given ray and a random point in 3-D space forming an angle less than <italic>θ</italic>. To prevent overflow, if Angle has a value below 0.1 radians, it is set to 0.1 radians.
				</p><p>We note that a naive implementation of dynamic programming would use <italic>O</italic>(<italic>n</italic><sup>4</sup>) time (where <italic>n</italic> is the length of the longer string), as there are <italic>O</italic>(<italic>n</italic><sup>2</sup>) block pairs. We reduce this to an <italic>O</italic>(<italic>n</italic><sup>3</sup> log <italic>n</italic>) algorithm by incorporating geometric knowledge of the structural transformations to reduce the search space. In particular, for each of structure two's C-alpha atoms, an oct-tree [<xref ref-type="bibr" rid="pcbi-0040010-b046">46</xref>] that partitions Euclidean space based on the transformed positions of that C-alpha atom is created. Each transformation comes from a previously considered block pair that ends with the C-alpha atom in question. When the dynamic program is assembling a block pair starting with the <italic>k</italic>th C-alpha atom in structure two, it searches the oct-trees for all of structure two's C-alpha atoms before <italic>k</italic> for compatible transformations (meaning the associated transformations of the atom are within the distance cutoff).</p></sec><sec id="s4c"><title>Final output.</title><p>The final output is an assembly <italic>A</italic>, a bent assembly <italic>A</italic>′ (only output with a command-line option), BentRMSD(<italic>A</italic>′), UnbentRMSD(<italic>A</italic>), and a <italic>p</italic>-value for the assembly.</p><p>The result of the dynamic programming algorithm described above gives the bent alignment <italic>A</italic>′, together with a set of local transformations (allowing translations and rotations) that produced the alignment. Its associated RMSD is BentRMSD(<italic>A</italic>′).</p><p>To produce the unbent alignment, the set of which residues are to be placed into alignment is retained from <italic>A</italic>′, and all geometric information is discarded. Then, the best global rigid-body transformation that minimizes the RMSD of this alignment is found using the classical SVD method of Kabsch [<xref ref-type="bibr" rid="pcbi-0040010-b026">26</xref>]. The result is the <italic>rigid-bent</italic> RMSD, which is not output explicitly, but implicitly forms the basis for the <italic>p</italic>-value calculation (as described in the <italic>p</italic>-value section at the end of the <xref ref-type="sec" rid="s1">Introduction</xref>). Note that so far the sequence alignment from the bent step is unchanged, and thus only includes sets of contiguous residues that are at least 5 Å in length. A final pass then greedily adds back shorter segments of four or fewer residues that fall between already aligned fragments but whose RMSD under the global transformation falls below a user-settable cutoff. The resulting alignment is <italic>A</italic>, with its associated <italic>unbent RMSD</italic>(<italic>A</italic>).</p></sec><sec id="s4d"><title>Multiple alignment.</title><p>In this subsection, we extend the definitions of assemblies to sets of more than two structures in the natural way. The input to each iteration of the Matt multiple alignment algorithm is the set of structures to be aligned that have been partitioned into sets, where the structures in each set are multiply aligned in an assembly. The output of the iteration leaves all but two sets unchanged; the structures in those two sets are merged into a single set with a new multiple alignment assembly. (The initial iteration of Matt places each structure into its own set and is equivalent to the pairwise alignment algorithm described above.)</p><p>Analogous to blocks, we define <italic>block-tuples</italic>. A <italic>block-tuple</italic> is an aligned set of already aligned equal-length blocks. A block-tuple pair is a set of two block-tuples, one from each of two sets of aligned structures.</p><p>At each iteration, for every pair of sets in the partition, Matt uses the merge procedure detailed below to combine the two assemblies into a single assembly and computes its score. It then chooses the best-scoring pair of sets to merge in that iteration. Matt terminates when all structures have been aligned into a single assembly, outputting the assembly, bent RMSD, and unbent RMSD.</p><p><italic>Merging.</italic> Here is a high-level description of the steps of the merge procedure. The merge procedure take as input two assemblies, each possibly containing multiple structures. Each step is explained in more detail. (1) Find the pair of structures, <italic>a</italic><sub>0</sub> from assembly <italic>A</italic> and <italic>b</italic><sub>0</sub> from assembly <italic>B</italic>, that have the highest-scoring pairwise structural alignment, according to the pairwise structural alignment algorithm of the previous section. (2) For each block <italic>β</italic> of <italic>a</italic><sub>0</sub>, let <italic>T<sub>β</sub></italic> denote the transformation of <italic>β</italic> back to its original atomic coordinates. Transform every block in the block-tuple associated with <italic>β</italic> in <italic>A</italic> by <italic>T<sub>β</sub></italic>. Do the same for each block of <italic>b</italic><sub>0</sub> and its associated block-tuple. (3) Within each <italic>A</italic> and <italic>B</italic> separately, realign all blocks within each block-tuple to reduce RMSD using the LocalOpt procedure (described below). (4) Still within each <italic>A</italic> and <italic>B</italic> separately, an extension step is performed than can lengthen block-tuples into unaligned regions or other block-tuples. Note that this step may temporarily produce overlapping blocks, but that this is corrected later, and only non-overlapping block-tuples are returned at the end of the merge procedure. (5) Taking the set of all aligned block-tuples of <italic>A</italic>, we consider all sets of five to nine adjacent residues entirely contained within one of these block-tuples by sliding a window of appropriate length. We do the same for the block-tuples of <italic>B</italic>. These become the building blocks of new block-tuple pairs in the merged assembly. Just as in the pairwise case, all equal-length building blocks, one each from <italic>A</italic> and <italic>B</italic>, are pairwise aligned and scored. Note that the RMSD algorithm easily generalizes to align sets of aligned residues by treating each aligned <italic>k</italic>-length set of <italic>m</italic> structures against <italic>n</italic> structures as a single RMSD alignment of <italic>kmn</italic> residues. Let <italic>T<sub>BA</sub></italic>(<italic>r</italic>,<italic>s</italic>) be the transformation that produces the lowest RMSD on the block-tuple pair <italic>r</italic> ∈ <italic>A</italic>, <italic>s</italic> ∈ <italic>B</italic>. (6) Dynamic programming is used to find the optimal assembly of pairs of new block-tuples. The dynamic programming algorithm in the multiple structural case has the same form as in the pairwise case. The angle penalty is calculated as before from <italic>T<sub>BA</sub></italic>(<italic>r</italic>,<italic>s</italic>). The displacement penalty is calculated slightly differently. In each residue position, an average C-alpha atom position is calculated for both <italic>A</italic> and <italic>B</italic>. The displacement is calculated using the averages as if they were positions of atoms of single structures in a pairwise alignment. Note that as in the pairwise case, this algorithm does not allow block-tuples to overlap, so the final set of block-tuples that are aligned by the merge procedure will be a legal assembly.</p><p>The merge procedure has now been specified except for LocalOpt and the extension procedure. We now explain both these steps in detail.</p><p><italic>LocalOpt.</italic> LocalOpt acts independently on <italic>A</italic> and <italic>B</italic>; therefore, it is described here only on <italic>A</italic>. The intuition for the LocalOpt step comes from merges in the previous iterations. The block-tuple alignment that an assembly inherits is the result of a global RMSD alignment of the block-tuple of potentially many protein structures. Therefore, while keeping the residue alignments fixed, it is often still possible to transform the coordinates of the C-alpha atoms to improve bent RMSD. LocalOpt acts separately on each block-tuple in the assembly. In particular, if <italic>a</italic><sub>0</sub>, <italic>a</italic><sub>1</sub>, …, <italic>a<sub>r</sub></italic> are the structures within a block-tuple (where <italic>a</italic><sub>0</sub> is the reference structure as defined by merge), each <italic>a<sub>i</sub></italic> is removed in turn and then realigned to minimize RMSD to the other <italic>r</italic> structures for each block-tuple.</p><p><italic>Extension phase.</italic> In the extension phase, both ends of block-tuples of five to nine residues are explored in order to determine if additional adjacent residues have a good multiple alignment. The LocalOpt transformations associated with each block-tuple in each structure are applied to the residues immediately before and after the block-tuple. If the average distance between all pairs of residues in all structures before or after a block-tuple is less than 5 Å, the residues are added to the block-tuple. This is done in a greedy fashion. Note that this allows block-tuples to be longer than nine residues or even to overlap (though in practice, we do not allow them to overlap by any more than five residues to bound computational time).</p><p><italic>Final output.</italic> When only one assembly remains, as in the pairwise case, this produces the bent alignment. As before, a final realignment and extension phase is done in which additional <italic>i</italic>-residue segments are greedily added to the common core, for <italic>i</italic> = 4 down to 1, provided their average RMSD lies below a (user-settable) cutoff. This cutoff is solely responsible for the size of common core/RMSD tradeoff found in <xref ref-type="fig" rid="pcbi-0040010-g002">Figures 2</xref> and <xref ref-type="fig" rid="pcbi-0040010-g003">3</xref>. All residues that were aligned in the iterative phase are kept in the final alignments. Block-tuples are not allowed to overlap in the final extension phase. A new RMSD alignment of the original unbent structures is done, aligning residues according to the extended block-tuples. This assembly, its RMSD, and the sets of aligned residues are the algorithm's unbent output. A <italic>p</italic>-value is not output when a group of more than two structures is to be aligned.</p></sec></sec></body><back><ack><p>We are grateful to the anonymous referees for many helpful comments that greatly improved the paper. The first author blames his coauthors for the name of our alignment program.</p></ack><glossary><title>Abbreviations</title><def-list><def-item><term>AFP</term><def><p>aligned fragment pair</p></def></def-item><def-item><term>RMSD</term><def><p>root mean squared deviation</p></def></def-item></def-list></glossary><ref-list><title>References</title><ref id="pcbi-0040010-b001"><label>1</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Levitt</surname><given-names>M</given-names></name><name name-style="western"><surname>Gerstein</surname><given-names>M</given-names></name></person-group>
					<year>1998</year>
					<article-title>A unified statistical framework for sequence comparison and structure comparison.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>95</volume>
					<fpage>5913</fpage>
					<lpage>5920</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b002"><label>2</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Chothia</surname><given-names>C</given-names></name><name name-style="western"><surname>Lesk</surname><given-names>A</given-names></name></person-group>
					<year>1986</year>
					<article-title>The relation between sequence and structure in proteins.</article-title>
					<source>EMBO J</source>
					<volume>5</volume>
					<fpage>823</fpage>
					<lpage>826</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b003"><label>3</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Rost</surname><given-names>B</given-names></name></person-group>
					<year>1999</year>
					<article-title>Twilight zone of protein sequence alignments.</article-title>
					<source>Protein Eng</source>
					<volume>12</volume>
					<fpage>85</fpage>
					<lpage>94</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b004"><label>4</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Dunbrack</surname><given-names>RL</given-names></name></person-group>
					<year>2006</year>
					<article-title>Sequence comparison and protein structure prediction.</article-title>
					<source>Curr Opin Struct Biol</source>
					<volume>16</volume>
					<fpage>274</fpage>
					<lpage>284</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b005"><label>5</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Abagyan</surname><given-names>RA</given-names></name><name name-style="western"><surname>Batalov</surname><given-names>S</given-names></name></person-group>
					<year>1997</year>
					<article-title>Do aligned sequences share the same fold?</article-title>
					<source>J Mol Biol</source>
					<volume>273</volume>
					<fpage>355</fpage>
					<lpage>368</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b006"><label>6</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Edgar</surname><given-names>R</given-names></name><name name-style="western"><surname>Batzoglou</surname><given-names>S</given-names></name></person-group>
					<year>2006</year>
					<article-title>Multiple sequence alignment.</article-title>
					<source>Curr Opin Struct Bio</source>
					<volume>16</volume>
					<fpage>368</fpage>
					<lpage>373</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b007"><label>7</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Whisstock</surname><given-names>JC</given-names></name><name name-style="western"><surname>Lesk</surname><given-names>AM</given-names></name></person-group>
					<year>2003</year>
					<article-title>Prediction of protein function from protein sequence and structure.</article-title>
					<source>Q Res Biophys</source>
					<volume>36</volume>
					<fpage>307</fpage>
					<lpage>340</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b008"><label>8</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kinch</surname><given-names>LN</given-names></name><name name-style="western"><surname>Grishin</surname><given-names>NV</given-names></name></person-group>
					<year>2002</year>
					<article-title>Evolution of protein structures and functions.</article-title>
					<source>Curr Opin Struct Biol</source>
					<volume>12</volume>
					<fpage>400</fpage>
					<lpage>408</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b009"><label>9</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Grishin</surname><given-names>NV</given-names></name></person-group>
					<year>2001</year>
					<article-title>Fold change in evolution of protein structures.</article-title>
					<source>J Struct Biol</source>
					<volume>134</volume>
					<fpage>167</fpage>
					<lpage>185</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b010"><label>10</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Irving</surname><given-names>JA</given-names></name><name name-style="western"><surname>Whisstock</surname><given-names>JC</given-names></name><name name-style="western"><surname>Lesk</surname><given-names>AM</given-names></name></person-group>
					<year>2001</year>
					<article-title>Protein structural alignments and functional genomics.</article-title>
					<source>Proteins</source>
					<volume>42</volume>
					<fpage>378</fpage>
					<lpage>382</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b011"><label>11</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Panchenko</surname><given-names>A</given-names></name><name name-style="western"><surname>Marchler-Bauer</surname><given-names>A</given-names></name><name name-style="western"><surname>Bryant</surname><given-names>SH</given-names></name></person-group>
					<year>1999</year>
					<article-title>Threading with explicit models for evolutionary conservation of structure and sequence.</article-title>
					<source>Proteins</source>
					<volume>(Supplement 3)</volume>
					<fpage>133</fpage>
					<lpage>140</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b012"><label>12</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>O'Sullivan</surname><given-names>O</given-names></name><name name-style="western"><surname>Suhre</surname><given-names>K</given-names></name><name name-style="western"><surname>Abergel</surname><given-names>C</given-names></name><name name-style="western"><surname>Higgins</surname><given-names>D</given-names></name><name name-style="western"><surname>Notredame</surname><given-names>C</given-names></name></person-group>
					<year>2004</year>
					<article-title>3DCoffee: Combining protein sequences and structures within multiple sequence alignments.</article-title>
					<source>J Mol Biol</source>
					<volume>340</volume>
					<fpage>385</fpage>
					<lpage>395</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b013"><label>13</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Shindyalov</surname><given-names>I</given-names></name><name name-style="western"><surname>Bourne</surname><given-names>P</given-names></name></person-group>
					<year>1998</year>
					<article-title>Protein structure alignment by incremental combinatorial extension (CE) of the optimal path.</article-title>
					<source>Protein Eng</source>
					<volume>11</volume>
					<fpage>739</fpage>
					<lpage>747</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b014"><label>14</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Ye</surname><given-names>Y</given-names></name><name name-style="western"><surname>Godzik</surname><given-names>A</given-names></name></person-group>
					<year>2003</year>
					<article-title>Flexible structure alignment by chaining aligned fragment pairs allowing twists.</article-title>
					<source>Bioinformatics</source>
					<volume>(Supplement 2)</volume>
					<fpage>II246</fpage>
					<lpage>II255</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b015"><label>15</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Holm</surname><given-names>L</given-names></name><name name-style="western"><surname>Park</surname><given-names>J</given-names></name></person-group>
					<year>2000</year>
					<article-title>DaliLite workbench for protein structure comparison.</article-title>
					<source>Bioinformatics</source>
					<volume>16</volume>
					<fpage>566</fpage>
					<lpage>567</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b016"><label>16</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Nussinov</surname><given-names>R</given-names></name><name name-style="western"><surname>Wolfson</surname><given-names>H</given-names></name></person-group>
					<year>1991</year>
					<article-title>Efficient detection of three-dimensional structural motifs in biological macromolecules by computer vision techniques.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>88</volume>
					<fpage>10495</fpage>
					<lpage>10499</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b017"><label>17</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Dror</surname><given-names>O</given-names></name><name name-style="western"><surname>Benyamini</surname><given-names>H</given-names></name><name name-style="western"><surname>Nussinov</surname><given-names>R</given-names></name><name name-style="western"><surname>Wolfson</surname><given-names>H</given-names></name></person-group>
					<year>2003</year>
					<article-title>MASS: Multiple structural alignment by secondary structures.</article-title>
					<source>Bioinformatics</source>
					<volume>19</volume>
					<fpage>95</fpage>
					<lpage>104</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b018"><label>18</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Dror</surname><given-names>O</given-names></name><name name-style="western"><surname>Benyamini</surname><given-names>H</given-names></name><name name-style="western"><surname>Nussinov</surname><given-names>R</given-names></name><name name-style="western"><surname>Wolfson</surname><given-names>H</given-names></name></person-group>
					<year>2003</year>
					<article-title>Multiple structure alignment by secondary structures: Algorithm and applications.</article-title>
					<source>Protein Sci</source>
					<volume>12</volume>
					<fpage>2492</fpage>
					<lpage>2507</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b019"><label>19</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kolbeck</surname><given-names>B</given-names></name><name name-style="western"><surname>May</surname><given-names>P</given-names></name><name name-style="western"><surname>Schmidt-Goenner</surname><given-names>T</given-names></name><name name-style="western"><surname>Steinke</surname><given-names>T</given-names></name><name name-style="western"><surname>Knapp1</surname><given-names>EW</given-names></name></person-group>
					<year>2006</year>
					<article-title>Connectivity independent protein-structure alignment: A hierarchical approach.</article-title>
					<source>BMC Bioinformatics</source>
					<volume>7</volume>
					<fpage>510</fpage>
				</element-citation></ref><ref id="pcbi-0040010-b020"><label>20</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Xu</surname><given-names>J</given-names></name><name name-style="western"><surname>Jiao</surname><given-names>F</given-names></name><name name-style="western"><surname>Berger</surname><given-names>B</given-names></name></person-group>
					<year>2007</year>
					<article-title>A parameterized algorithm for protein structure alignment.</article-title>
					<source>J Comput Biol</source>
					<volume>14</volume>
					<fpage>564</fpage>
					<lpage>577</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b021"><label>21</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Yuan</surname><given-names>X</given-names></name><name name-style="western"><surname>Bystroff</surname><given-names>C</given-names></name></person-group>
					<year>2005</year>
					<article-title>Non-sequential structure-based alignments reveal topology-independent core packing arrangements in proteins.</article-title>
					<source>Bioinformatics</source>
					<volume>21</volume>
					<fpage>1010</fpage>
					<lpage>1019</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b022"><label>22</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Goldman</surname><given-names>D</given-names></name><name name-style="western"><surname>Istrail</surname><given-names>S</given-names></name><name name-style="western"><surname>Papadimitriou</surname><given-names>CH</given-names></name></person-group>
					<year>1999</year>
					<article-title>Algorithmic aspects of protein structure similarity.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor"><name name-style="western"><surname>Beame</surname><given-names>P</given-names></name></person-group>
					<source>Proceedings of the 40th Annual Symposium on Foundations of Computer Science</source>
					<publisher-loc>Los Alamitos (California)</publisher-loc>
					<publisher-name>IEEE Computer Society</publisher-name>
					<fpage>512</fpage>
					<lpage>522</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b023"><label>23</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Wang</surname><given-names>L</given-names></name><name name-style="western"><surname>Jiang</surname><given-names>T</given-names></name></person-group>
					<year>1994</year>
					<article-title>On the complexity of multiple sequence alignment.</article-title>
					<source>J Comput Biol</source>
					<volume>1</volume>
					<fpage>512</fpage>
					<lpage>522</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b024"><label>24</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kolodny</surname><given-names>R</given-names></name><name name-style="western"><surname>Linial</surname><given-names>N</given-names></name></person-group>
					<year>2004</year>
					<article-title>Approximate protein structural alignment in polynomial time.</article-title>
					<source>Proc Natl Acad Sci U S A</source>
					<volume>101</volume>
					<fpage>12201</fpage>
					<lpage>12206</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b025"><label>25</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Eidhammer</surname><given-names>I</given-names></name><name name-style="western"><surname>Jonassen</surname><given-names>I</given-names></name><name name-style="western"><surname>Taylor</surname><given-names>WR</given-names></name></person-group>
					<year>2000</year>
					<article-title>Structure comparison and structure patterns.</article-title>
					<source>J Comput Biol</source>
					<volume>7</volume>
					<fpage>685</fpage>
					<lpage>716</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b026"><label>26</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kabsh</surname><given-names>W</given-names></name></person-group>
					<year>1978</year>
					<article-title>A discussion of the solution for the best rotation to relate two sets of vectors.</article-title>
					<source>Acta Crystallogr A</source>
					<volume>34</volume>
					<fpage>827</fpage>
					<lpage>828</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b027"><label>27</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Ye</surname><given-names>Y</given-names></name><name name-style="western"><surname>Godzik</surname><given-names>A</given-names></name></person-group>
					<year>2005</year>
					<article-title>Multiple flexible structure alignment using partial order graphs.</article-title>
					<source>Bioinformatics</source>
					<volume>21</volume>
					<fpage>2362</fpage>
					<lpage>2369</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b028"><label>28</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Kolodny</surname><given-names>R</given-names></name><name name-style="western"><surname>Koehl</surname><given-names>P</given-names></name><name name-style="western"><surname>Levitt</surname><given-names>M</given-names></name></person-group>
					<year>2005</year>
					<article-title>Comprehensive evaluation of protein structure alignment methods: Scoring by geometric measures.</article-title>
					<source>J Mol Biol</source>
					<volume>346</volume>
					<fpage>1173</fpage>
					<lpage>1188</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b029"><label>29</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Jung</surname><given-names>J</given-names></name><name name-style="western"><surname>Lee</surname><given-names>B</given-names></name></person-group>
					<year>2000</year>
					<article-title>Protein structure alignment using environmental profiles.</article-title>
					<source>Protein Eng</source>
					<volume>13</volume>
					<fpage>535</fpage>
					<lpage>543</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b030"><label>30</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Suyama</surname><given-names>M</given-names></name><name name-style="western"><surname>Matsuo</surname><given-names>Y</given-names></name><name name-style="western"><surname>Nishikawa</surname><given-names>K</given-names></name></person-group>
					<year>1997</year>
					<article-title>Comparison of protein structures using 3D profile alignment.</article-title>
					<source>J Mol Evol</source>
					<volume>44</volume>
					<issue>Supplement 1</issue>
					<fpage>S163</fpage>
					<lpage>S173</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b031"><label>31</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Bonvin</surname><given-names>A</given-names></name></person-group>
					<year>2006</year>
					<article-title>Flexible protein-protein docking.</article-title>
					<source>Curr Opin Struct Biol</source>
					<volume>16</volume>
					<fpage>194</fpage>
					<lpage>200</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b032"><label>32</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Echols</surname><given-names>N</given-names></name><name name-style="western"><surname>Milburn</surname><given-names>D</given-names></name><name name-style="western"><surname>Gerstein</surname><given-names>M</given-names></name></person-group>
					<year>2003</year>
					<article-title>MolMovDB: Analysis and visualization of conformational change and structural flexibility.</article-title>
					<source>Nucleic Acids Res</source>
					<volume>31</volume>
					<fpage>478</fpage>
					<lpage>482</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b033"><label>33</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Lemmen</surname><given-names>C</given-names></name><name name-style="western"><surname>Lengauer</surname><given-names>T</given-names></name><name name-style="western"><surname>Klebe</surname><given-names>G</given-names></name></person-group>
					<year>1998</year>
					<article-title>FlexS: A method for fast flexible ligand superposition.</article-title>
					<source>J Medicinal Chem</source>
					<volume>41</volume>
					<fpage>4502</fpage>
					<lpage>4520</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b034"><label>34</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Schueler-Furman</surname><given-names>O</given-names></name><name name-style="western"><surname>Wang</surname><given-names>C</given-names></name><name name-style="western"><surname>Bradley</surname><given-names>P</given-names></name><name name-style="western"><surname>Misura</surname><given-names>K</given-names></name><name name-style="western"><surname>Baker</surname><given-names>D</given-names></name></person-group>
					<year>2005</year>
					<article-title>Review: Progress in modeling of protein structures and interactions.</article-title>
					<source>Science</source>
					<volume>310</volume>
					<fpage>638</fpage>
					<lpage>642</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b035"><label>35</label><element-citation publication-type="other" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Singh</surname><given-names>R</given-names></name><name name-style="western"><surname>Berger</surname><given-names>B</given-names></name></person-group>
					<year>2005</year>
					<article-title>ChainTweak: Sampling from the neighbourhood of a protein conformation.</article-title>
					<comment>In:</comment>
					<person-group person-group-type="editor"><name name-style="western"><surname>Altman</surname><given-names>R</given-names></name><name name-style="western"><surname>Jung</surname><given-names>T</given-names></name><name name-style="western"><surname>Klein</surname><given-names>T</given-names></name><name name-style="western"><surname>Dunker</surname><given-names>K</given-names></name><name name-style="western"><surname>Hunter</surname><given-names>L</given-names></name></person-group>
					<source>Proceedings of the 2005 Pacific Symposium on Biocomputing</source>
					<publisher-loc>London</publisher-loc>
					<publisher-name>World Scientific Publishing</publisher-name>
					<fpage>54</fpage>
					<lpage>65</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b036"><label>36</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Shatsky</surname><given-names>M</given-names></name><name name-style="western"><surname>Nussinov</surname><given-names>R</given-names></name><name name-style="western"><surname>Wolfson</surname><given-names>H</given-names></name></person-group>
					<year>2002</year>
					<article-title>Flexible protein alignment and hinge detection.</article-title>
					<source>Proteins</source>
					<volume>48</volume>
					<fpage>242</fpage>
					<lpage>256</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b037"><label>37</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Mizuguchi</surname><given-names>K</given-names></name><name name-style="western"><surname>Deane</surname><given-names>C</given-names></name><name name-style="western"><surname>Blundell</surname><given-names>TL</given-names></name><name name-style="western"><surname>Overington</surname><given-names>J</given-names></name></person-group>
					<year>1998</year>
					<article-title>HOMSTRAD: A database of protein structure alignments for homologous families.</article-title>
					<source>Protein Sci</source>
					<volume>11</volume>
					<fpage>2469</fpage>
					<lpage>2471</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b038"><label>38</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>VanWalle</surname><given-names>I</given-names></name><name name-style="western"><surname>Lasters</surname><given-names>I</given-names></name><name name-style="western"><surname>Wyns</surname><given-names>L</given-names></name></person-group>
					<year>2005</year>
					<article-title>SABmark—A benchmark for sequence alignment that covers the entire known fold space.</article-title>
					<source>Bioinformatics</source>
					<volume>21</volume>
					<fpage>1267</fpage>
					<lpage>1268</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b039"><label>39</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Barton</surname><given-names>G</given-names></name><name name-style="western"><surname>Sternberg</surname><given-names>M</given-names></name></person-group>
					<year>1987</year>
					<article-title>A strategy for the rapid multiple alignment of protein sequences: Confidence levels from tertiary structure comparisons.</article-title>
					<source>J Mol Biol</source>
					<volume>198</volume>
					<fpage>327</fpage>
					<lpage>337</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b040"><label>40</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Murzin</surname><given-names>A</given-names></name><name name-style="western"><surname>Brenner</surname><given-names>S</given-names></name><name name-style="western"><surname>Hubbard</surname><given-names>T</given-names></name><name name-style="western"><surname>Chothia</surname><given-names>C</given-names></name></person-group>
					<year>1995</year>
					<article-title>SCOP: A structural classification of proteins database for the investigation of sequences and structures.</article-title>
					<source>J Mol Biol</source>
					<volume>297</volume>
					<fpage>536</fpage>
					<lpage>540</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b041"><label>41</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Shatsky</surname><given-names>M</given-names></name><name name-style="western"><surname>Nussinov</surname><given-names>R</given-names></name><name name-style="western"><surname>Wolfson</surname><given-names>H</given-names></name></person-group>
					<year>2004</year>
					<article-title>A method for simultaneous alignment of multiple protein structures.</article-title>
					<source>Proteins</source>
					<volume>56</volume>
					<fpage>143</fpage>
					<lpage>156</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b042"><label>42</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Konagurthu</surname><given-names>A</given-names></name><name name-style="western"><surname>Whisstock</surname><given-names>J</given-names></name><name name-style="western"><surname>Stuckey</surname><given-names>P</given-names></name><name name-style="western"><surname>Lesk</surname><given-names>A</given-names></name></person-group>
					<year>2006</year>
					<article-title>MUSTANG: A multiple structural alignment algorithm.</article-title>
					<source>Proteins</source>
					<volume>64</volume>
					<fpage>559</fpage>
					<lpage>574</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b043"><label>43</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Guex</surname><given-names>N</given-names></name><name name-style="western"><surname>Peitsch</surname><given-names>M</given-names></name></person-group>
					<year>1997</year>
					<article-title>SWISS-MODEL and the Swiss-PdbViewer: An environment for comparative protein modeling.</article-title>
					<source>Electrophoresis</source>
					<volume>18</volume>
					<fpage>2714</fpage>
					<lpage>2723</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b044"><label>44</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Gerstein</surname><given-names>M</given-names></name><name name-style="western"><surname>Levitt</surname><given-names>M</given-names></name></person-group>
					<year>1998</year>
					<article-title>Comprehensive assessment of automatic structural alignment against a manual standard, the SCOP classification of proteins.</article-title>
					<source>Prot Sci</source>
					<volume>7</volume>
					<fpage>445</fpage>
					<lpage>456</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b045"><label>45</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Hobohm</surname><given-names>U</given-names></name><name name-style="western"><surname>Sander</surname><given-names>C</given-names></name></person-group>
					<year>1994</year>
					<article-title>Enlarged representative set of protein structures.</article-title>
					<source>Protein Science</source>
					<volume>3</volume>
					<fpage>522</fpage>
					<lpage>524</lpage>
				</element-citation></ref><ref id="pcbi-0040010-b046"><label>46</label><element-citation publication-type="journal" xlink:type="simple">
					<person-group person-group-type="author"><name name-style="western"><surname>Jackins</surname><given-names>C</given-names></name><name name-style="western"><surname>Tanimoto</surname><given-names>S</given-names></name></person-group>
					<year>1983</year>
					<article-title>Quad-trees, Oct-trees, and K-trees: A generalized approach to recursive decomposition of euclidean space.</article-title>
					<source>IEEE Trans Pattern Anal Mach Intell</source>
					<volume>5</volume>
					<fpage>533</fpage>
					<lpage>539</lpage>
				</element-citation></ref></ref-list></back></article>