<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.1d3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-18-00132</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1006581</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject><subj-group><subject>Phylogenetic analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Taxonomy</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject><subj-group><subject>Phylogenetic analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Data management</subject><subj-group><subject>Taxonomy</subject><subj-group><subject>Evolutionary systematics</subject><subj-group><subject>Phylogenetics</subject><subj-group><subject>Phylogenetic analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Population genetics</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Population genetics</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Population biology</subject><subj-group><subject>Population genetics</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Organisms</subject><subj-group><subject>Eukaryota</subject><subj-group><subject>Plants</subject><subj-group><subject>Trees</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Population biology</subject><subj-group><subject>Population metrics</subject><subj-group><subject>Population size</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Evolutionary processes</subject><subj-group><subject>Natural selection</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Computational biology</subject><subj-group><subject>Genome analysis</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Genetics</subject><subj-group><subject>Genomics</subject><subj-group><subject>Genome analysis</subject></subj-group></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Efficient pedigree recording for fast population genetics simulation</article-title>
<alt-title alt-title-type="running-head">Pedigree recording for simulation</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-7894-5253</contrib-id>
<name name-style="western">
<surname>Kelleher</surname> <given-names>Jerome</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Project administration</role>
<role content-type="http://credit.casrai.org/">Resources</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-0743-4445</contrib-id>
<name name-style="western">
<surname>Thornton</surname> <given-names>Kevin R.</given-names></name>
<role content-type="http://credit.casrai.org/">Data curation</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Project administration</role>
<role content-type="http://credit.casrai.org/">Resources</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-1841-4768</contrib-id>
<name name-style="western">
<surname>Ashander</surname> <given-names>Jaime</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Data curation</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
</contrib>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-9459-6866</contrib-id>
<name name-style="western">
<surname>Ralph</surname> <given-names>Peter L.</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Project administration</role>
<role content-type="http://credit.casrai.org/">Resources</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff004"><sup>4</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
</contrib-group>
<aff id="aff001">
<label>1</label>
<addr-line>Big Data Institute, University of Oxford, Oxford, United Kingdom</addr-line>
</aff>
<aff id="aff002">
<label>2</label>
<addr-line>Ecology and Evolutionary Biology, University of California, Irvine, Irvine, California, United States of America</addr-line>
</aff>
<aff id="aff003">
<label>3</label>
<addr-line>Ecology and Evolutionary Biology, University of California, Los Angeles, Los Angeles, United States of America</addr-line>
</aff>
<aff id="aff004">
<label>4</label>
<addr-line>Institute for Ecology and Evolution, University of Oregon, Eugene, Oregon, United States of America</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Kosakovsky Pond</surname> <given-names>Sergei L.</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>Temple University, UNITED STATES</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">plr@uoregon.edu</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<month>11</month>
<year>2018</year>
</pub-date>
<pub-date pub-type="epub">
<day>1</day>
<month>11</month>
<year>2018</year>
</pub-date>
<volume>14</volume>
<issue>11</issue>
<elocation-id>e1006581</elocation-id>
<history>
<date date-type="received">
<day>26</day>
<month>1</month>
<year>2018</year>
</date>
<date date-type="accepted">
<day>8</day>
<month>10</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-year>2018</copyright-year>
<copyright-holder>Kelleher et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1006581"/>
<abstract>
<p>In this paper we describe how to efficiently record the entire genetic history of a population in forwards-time, individual-based population genetics simulations with arbitrary breeding models, population structure and demography. This approach dramatically reduces the computational burden of tracking individual genomes by allowing us to simulate only those loci that may affect reproduction (those having non-neutral variants). The genetic history of the population is recorded as a succinct tree sequence as introduced in the software package msprime, on which neutral mutations can be quickly placed afterwards. Recording the results of each breeding event requires storage that grows linearly with time, but there is a great deal of redundancy in this information. We solve this storage problem by providing an algorithm to quickly ‘simplify’ a tree sequence by removing this irrelevant history for a given set of genomes. By periodically simplifying the history with respect to the extant population, we show that the total storage space required is modest and overall large efficiency gains can be made over classical forward-time simulations. We implement a general-purpose framework for recording and simplifying genealogical data, which can be used to make simulations of any population model more efficient. We modify two popular forwards-time simulation frameworks to use this new approach and observe efficiency gains in large, whole-genome simulations of one to two orders of magnitude. In addition to speed, our method for recording pedigrees has several advantages: (1) All marginal genealogies of the simulated individuals are recorded, rather than just genotypes. (2) A population of <italic>N</italic> individuals with <italic>M</italic> polymorphic sites can be stored in <italic>O</italic>(<italic>N</italic> log <italic>N</italic> + <italic>M</italic>) space, making it feasible to store a simulation’s entire final generation as well as its history. (3) A simulation can easily be initialized with a more efficient coalescent simulation of deep history. The software for recording and processing tree sequences is named tskit.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author summary</title>
<p>Sexually reproducing organisms are related to the others in their species by the complex web of parent-offspring relationships that constitute the pedigree. In this paper, we describe a way to record all of these relationships, as well as how genetic material is passed down through the pedigree, during a forwards-time population genetic simulation. To make effective use of this information, we describe both efficient storage methods for this embellished pedigree as well as a way to remove all information that is irrelevant to the genetic history of a given set of individuals, which dramatically reduces the required amount of storage space. Storing this information allows us to produce whole-genome sequence from simulations of large populations in which we have not explicitly recorded new genomic mutations; we find that this results in computational run times of up to 50 times faster than simulations forced to explicitly carry along that information.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution>Alfred P. Sloan Foundation (US)</institution>
</funding-source>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-9459-6866</contrib-id>
<name name-style="western">
<surname>Ralph</surname> <given-names>Peter L.</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award002">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000001</institution-id>
<institution>National Science Foundation</institution>
</institution-wrap>
</funding-source>
<award-id>DBI-1262645</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-9459-6866</contrib-id>
<name name-style="western">
<surname>Ralph</surname> <given-names>Peter L.</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award003">
<funding-source>
<institution>Wellcome Trust (GB)</institution>
</funding-source>
<award-id>100956/Z/13/Z</award-id>
</award-group>
<award-group id="award004">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000002</institution-id>
<institution>National Institutes of Health</institution>
</institution-wrap>
</funding-source>
<award-id>R01GM115564</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-0743-4445</contrib-id>
<name name-style="western">
<surname>Thornton</surname> <given-names>Kevin R.</given-names></name>
</principal-award-recipient>
</award-group>
<funding-statement>Work on this project was supported by funding from the Sloan Foundation and the National Science Foundation (under DBI-1262645) to PLR; the Wellcome Trust (grant 100956/Z/13/Z) to Gil McVean; the NIH (R01GM115564) to KRT; and the USF&amp;WS to H. Bradley Shaffer. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="7"/>
<table-count count="0"/>
<page-count count="21"/>
</counts>
<custom-meta-group>
<custom-meta>
<meta-name>PLOS Publication Stage</meta-name>
<meta-value>vor-update-to-uncorrected-proof</meta-value>
</custom-meta>
<custom-meta>
<meta-name>Publication Update</meta-name>
<meta-value>2018-11-13</meta-value>
</custom-meta>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>The only relevant data is our computer code; the main tools are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/jeromekelleher/msprime" xlink:type="simple">https://github.com/jeromekelleher/msprime</ext-link> or <ext-link ext-link-type="uri" xlink:href="https://pypi.python.org/pypi/msprime" xlink:type="simple">https://pypi.python.org/pypi/msprime</ext-link> -- and other scripts used in the paper are available at <ext-link ext-link-type="uri" xlink:href="https://github.com/petrelharp/ftprime_ms" xlink:type="simple">https://github.com/petrelharp/ftprime_ms</ext-link>.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<disp-quote><p>This is a <italic>PLoS Computational Biology</italic> Methods paper.</p></disp-quote>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Since the 1980’s, coalescent theory has enabled computer simulation of the results of population genetics models identical to that which would be produced by large, randomly mating populations over long periods of time without actually requiring simulation of so many generations or meioses. Coalescent theory thus had three transformative effects on population genetics: first, giving researchers better conceptual tools to describe <italic>gene trees</italic> and thus bringing within-population trees into better focus; second, producing analytical methods to estimate parameters of interest from genetic data; and finally, providing a computationally feasible method to produce computer simulations of population genetics processes. However, these powerful advances came with substantial caveats: the backwards-in-time processes that are described by coalescent theory are only <italic>Markovian</italic>, and thus feasible to work with, under the following important assumptions: (a) random mating, (b) neutrality, (c) large population size, and (d) small sample size relative to the population size. The first two assumptions can be side-stepped to a limited extent [<xref ref-type="bibr" rid="pcbi.1006581.ref001">1</xref>, <xref ref-type="bibr" rid="pcbi.1006581.ref002">2</xref>], but it remains a challenge to map results of coalescent models onto species that are distributed across continuous geographical space [<xref ref-type="bibr" rid="pcbi.1006581.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1006581.ref004">4</xref>] and/or have large numbers of loci under various sorts of selection. Usually, the relationship between the life history of a species—fecundity and mortality schedules, density-dependent effects on fitness, and demographic fluctuations—are all absorbed into a single compound parameter, the coalescence rate. More mechanistic models are possible using “forwards–backwards” simulations, that first simulate population size changes forwards in time and then thread a coalescent backwards [<xref ref-type="bibr" rid="pcbi.1006581.ref005">5</xref>], but these still require the assumptions above to be met for each subpopulation. The last assumption is no longer safe, either—for example, a recent study [<xref ref-type="bibr" rid="pcbi.1006581.ref006">6</xref>] simulated 600,000 samples of human chromosome 20 to examine biases in GWAS. Several studies have now shown that in samples approaching the size of the population, genealogical properties may be distorted relative to the coalescent expectation [<xref ref-type="bibr" rid="pcbi.1006581.ref007">7</xref>–<xref ref-type="bibr" rid="pcbi.1006581.ref009">9</xref>]. These considerations, and increasing computational power, have led to a resurgence of interest in large forwards-time, individual-based simulations. For instance, Harris and Nielsen [<xref ref-type="bibr" rid="pcbi.1006581.ref010">10</xref>] used SLiM [<xref ref-type="bibr" rid="pcbi.1006581.ref011">11</xref>] to simulate ten thousand human exomes to assess the impact of genetic load and Neanderthal introgression on human genetic diversity. Sanjak et al. [<xref ref-type="bibr" rid="pcbi.1006581.ref012">12</xref>] used <monospace>fwdpp</monospace> [<xref ref-type="bibr" rid="pcbi.1006581.ref013">13</xref>] to simulate a series of models of quantitative traits under mutation-selection balance with population sizes of 2 × 10<sup>4</sup> diploids in stable populations and populations growing up to around 5 × 10<sup>5</sup> individuals, using the output to explore the relationship between the genotype/phenotype model and GWAS outcomes.</p>
<p>Modern computing power easily allows simulations of birth, death and reproduction in a population having even hundreds of millions of individuals. However, if our interest lies in the resulting genetic patterns of variation—and often, the point of such simulations is to compare to real data—then such simulations must record each individual’s genome. As samples of most species’ genomes harbor tens or hundreds of millions of variant sites, carrying full genotypes for even modest numbers of individuals through a simulation can quickly become prohibitive. To make matters worse, a population of size <italic>N</italic> must be simulated across many multiples of <italic>N</italic> generations to produce stable genetic patterns [<xref ref-type="bibr" rid="pcbi.1006581.ref014">14</xref>, <xref ref-type="bibr" rid="pcbi.1006581.ref015">15</xref>]. Because of this computational burden, even the fastest simulation frameworks such as SLiM 2 [<xref ref-type="bibr" rid="pcbi.1006581.ref016">16</xref>] and fwdpp [<xref ref-type="bibr" rid="pcbi.1006581.ref013">13</xref>] can “only” simulate tens of megabases of sequence in tens of thousands of individuals for tens of thousands of generations. In practice, current state-of-the-art simulation software may take on the order of weeks to simulate models of large genomic regions without selection [<xref ref-type="bibr" rid="pcbi.1006581.ref013">13</xref>, <xref ref-type="bibr" rid="pcbi.1006581.ref017">17</xref>], and existing simulation engines differ in how efficiently they calculate fitnesses in models with selection [<xref ref-type="bibr" rid="pcbi.1006581.ref013">13</xref>]. These population and region sizes are still substantially short of whole genomes (hundreds to thousands of megabases) for many biological population sizes of interest.</p>
<p>However, it is thought that most genetic variation is selectively neutral (or nearly so). By definition, neutral alleles carried by individuals in a population do not affect the population process. For this reason, if one records the entire genealogical history of a population over the course of a simulation, simply laying down neutral mutations on top of that history afterwards is equivalent to having generated them during the simulation: it does not matter if we generate each generation’s mutations during the simulation, or afterwards. To add mutations after the fact, we need to know the genealogical trees relating all sampled individuals at each position along the genome. Combined with ancestral genotypes and the origins of new mutations, these trees completely specify the genomic sequence of any individual in the population at any time. To obtain this information, we record from forward simulation the <italic>population pedigree</italic>—the complete history of parent-offspring relationships of an entire population going back to a remote time—and the genetic outcomes of each ancestral meiosis, periodically discarding all information irrelevant to the genetic history of the extant population. The information in this embellished pedigree is stored as a <italic>succinct tree sequence</italic> (or, for brevity, “tree sequence”), which contains all the information necessary to construct the genealogical tree that relates each individual to every other at each position on the genome.</p>
<p>The idea of storing genealogical information to speed up simulations is not new. It was implemented in AnA-FiTS [<xref ref-type="bibr" rid="pcbi.1006581.ref018">18</xref>], but without the critical step of discarding irrelevant genealogical information. Padhukasahasram et al. [<xref ref-type="bibr" rid="pcbi.1006581.ref019">19</xref>] obtained impressive speedups for a Wright–Fisher simulation by keeping track of genealogies over the preceding 8 generations and only tracking neutral genotypes for those segments having descendants across this window. Our approach is similar, but uses genealogies across the entire duration of the simulation. The embellished pedigree is equivalent to the <italic>ancestral recombination graph</italic>, or ARG [<xref ref-type="bibr" rid="pcbi.1006581.ref020">20</xref>, <xref ref-type="bibr" rid="pcbi.1006581.ref021">21</xref>], which has been the subject of substantial study [<xref ref-type="bibr" rid="pcbi.1006581.ref022">22</xref>–<xref ref-type="bibr" rid="pcbi.1006581.ref025">25</xref>]. However, it is unclear if an ARG-based approach would share the computational advantages of the data structures we use here [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>].</p>
<p>In this paper, we describe a storage method for <italic>succinct tree sequences</italic> (and hence, genome sequence) as well as an algorithm for simplifying these. The data structure is <italic>succinct</italic> in the sense that its space usage is close to optimal, while still allowing efficient retrieval of information (see, e.g., [<xref ref-type="bibr" rid="pcbi.1006581.ref027">27</xref>]). We also describe how these tools can efficiently record, and later process, the embellished population pedigree from a forwards-time simulation. While providing substantial savings in computational time and space, our methods provide in principle much more information than simply simulating the genomes—the tree sequence encodes all marginal genealogies of individuals living at the end of the simulation. These marginal genealogies enable fast data storage and processing, but also provide additional information that can be used to better understand the notoriously complex dynamics of population genetics. Although we were motivated by a need for more efficient genomic simulations, these tools may prove more widely useful. This work originated as improvements to the algorithmic tools and data structures in the coalescent simulator <monospace>msprime</monospace>. The software tools described here for working with tree sequences are referred to as <monospace>tskit</monospace>; they are currently bundled with the Python package <monospace>msprime</monospace>, but will soon be separately available as a Python API and an embeddable C library.</p>
</sec>
<sec id="sec002" sec-type="results">
<title>Results</title>
<p>The strategy described above is only of interest if it is computationally feasible. Therefore, we begin by benchmarking the performance improvement achieved by this method, implemented using the forwards-time simulation library <monospace>fwdpp</monospace> [<xref ref-type="bibr" rid="pcbi.1006581.ref013">13</xref>] and tree sequence tools implemented in <monospace>tskit</monospace>. Then, we describe the conceptual and algorithmic foundations for the method: (a) a format, implemented in the <monospace>tskit</monospace> Python API, for recording tree sequences efficiently in several <italic>tables</italic>; (b) an algorithm to record these tables during a forwards-time simulation; and (c) an algorithm to <italic>simplify</italic> a tree sequence, i.e., remove redundant information. Finally, we analyze the run time and space complexity of our general-purpose method.</p>
<sec id="sec003">
<title>Simulation benchmarks</title>
<p>To measure the performance gains from recording the pedigree we ran simulations both with and without recording. (Although we record more than just the parent–offspring relationships of the pedigree, for brevity we refer to the method as “pedigree recording”). All simulations used <monospace>fwdpp</monospace> to implement a discrete-time Wright-Fisher population of <italic>N</italic> diploid individuals, simulated for 10<italic>N</italic> generations (details below). Simulations without pedigree recording introduced neutral mutations at a rate equal to the recombination rate, so <italic>μ</italic> = <italic>r</italic>, where <italic>μ</italic> and <italic>r</italic> are the expected per-generation number of mutations per gamete and recombination breakpoints per diploid, respectively. Simulations with pedigree recording introduced neutral mutations at the same rate retrospectively, as described below, resulting in statistically identical simulation results. We ran simulations with different values of <italic>N</italic> and varied the size of the genomic region according to the scaled recombination parameter <italic>ρ</italic> = 4<italic>Nr</italic>.</p>
<p>Deleterious mutations were introduced at rate <italic>ρ</italic>/100 per generation, drawing scaled selection coefficients (2<italic>Ns</italic>) from a Gamma distribution with a mean of -5 and a shape parameter of 1. This distribution of fitness effects results in thousands of weakly-deleterious mutations segregating in the population, many of which drift to intermediate frequencies. The case of many mutations with selection is a non-trivial violation of exchangeability assumptions of the coalescent [<xref ref-type="bibr" rid="pcbi.1006581.ref002">2</xref>]. Therefore, these selected mutations must be explicitly tracked in our forward simulation and the time savings due to pedigree recording come from not having to record <italic>neutral</italic> mutations.</p>
<p>Pedigree tracking dramatically reduced runtimes, as shown in <xref ref-type="fig" rid="pcbi.1006581.g001">Fig 1</xref>, producing a relative speedup of up to around 50 fold relative to standard simulations that track neutral mutations (<xref ref-type="fig" rid="pcbi.1006581.g002">Fig 2</xref>). Pedigree tracking results in greater relative speedups for larger <italic>N</italic> and we observe increasing relative speedups as 4<italic>Nr</italic> increases for a given <italic>N</italic> (<xref ref-type="fig" rid="pcbi.1006581.g002">Fig 2</xref>). Importantly, runtimes are approximately linear in region size <italic>ρ</italic> when pedigree tracking (partially obscured by the log scale of the horizontal axis in <xref ref-type="fig" rid="pcbi.1006581.g001">Fig 1</xref>). In a more limited set of neutral simulations we found the same qualitative behavior, and a numerically larger speedup by using pedigree tracking (see <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>).</p>
<fig id="pcbi.1006581.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Total run time per single simulation replicate as a function of region length.</title>
<p>Line color represents different diploid population sizes (<italic>N</italic>). The left figure shows run times for standard simulations including neutral mutations. The right column shows run times of simulations that recorded the pedigree and added neutral mutations afterwards. The dashed line in the right panel shows results for an implementation using <monospace>fwdpy11</monospace> where the pedigree simplification steps were handled in a separate thread of execution and fitness calculations were parallelized across four cores. Simulations with <italic>N</italic> = 5 × 10<sup>4</sup> timed out for region sizes larger than 10<sup>3</sup>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g001" xlink:type="simple"/>
</fig>
<fig id="pcbi.1006581.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Relative speedup of simulations due to pedigree recording.</title>
<p>Each line shows the ratio of total run times of standard simulations to those of simulations with pedigree recording. Data points are taken from <xref ref-type="fig" rid="pcbi.1006581.g001">Fig 1</xref> for simulations that ran to completion in both cases.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g002" xlink:type="simple"/>
</fig>
<p>In our implementation, simulations with pedigree recording used substantially more RAM than simple forward simulations (see <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>). This is unsurprising: unsimplified tree sequences grow quickly, and so storing history can use arbitrarily much memory. However, this is not a requirement of the method, only a straightforwards consequence of a speed–memory tradeoff: the amount of required memory is mostly determined by the interval between simplification steps, but less frequent simplification reduces overall computation time (see <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>). In fact, our method could in some situations <italic>reduce</italic> the amount of memory required, if memory usage in the forwards simulation was dominated by the cost of maintaining neutral genetic variants.</p>
</sec>
<sec id="sec004">
<title>Tables for succinct tree sequences</title>
<p>We now explain what we actually did to achieve this 50× speedup. The “pedigree recording” simulations above recorded information about each new individual in a collection of tables that together define a <italic>succinct tree sequence</italic> (or, simply “tree sequence”). A tree sequence is an encoding for a sequence of correlated trees, such as those describing the history of a sexual population. Tree sequences are efficient because branches that are shared by adjacent trees are stored once, rather than repeatedly for each tree. The topology of a tree sequence is defined via its <italic>nodes</italic> and <italic>edges</italic>, while information about variants is recorded as <italic>sites</italic> and <italic>mutations</italic>; we give an example in <xref ref-type="fig" rid="pcbi.1006581.g003">Fig 3</xref>. This formulation is derived from the “coalescence records” encoding of tree sequences [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>], normalised to remove redundancy and generalised to include a more general class of tree topologies.</p>
<fig id="pcbi.1006581.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g003</object-id>
<label>Fig 3</label>
<caption>
<title>An example tree sequence with three samples over a chromosome of length 10.</title>
<p>The leftmost panels show the tree sequence pictorially in two different ways: (top) a sequence of tree topologies; the first tree extends from genomic position 0 to 5, and the second from 5 to 10; and (bottom) the edges that define these topologies, displayed over their corresponding genomic segment (for instance, the edge from node 2 to node 4 is present only on the interval from 0 to 5). The remaining panels show the specific encoding of this tree sequence in the four tables (nodes, edges, sites and mutations).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g003" xlink:type="simple"/>
</fig>
<p>The <italic>nodes</italic> of a tree sequence correspond to the vertices in the individual genealogies along the sequence. Each node refers to a specific, distinct ancestor, and so has a unique “time”, thought of as the node’s birth time, which determines the height of any vertices the node is associated with. (Note that since each node time is equal to the amount of time since the birth of the corresponding parent, time is measured in clock time, not in meioses). The example of <xref ref-type="fig" rid="pcbi.1006581.g003">Fig 3</xref> has five nodes: nodes 0, 1 and 2 occur at time 0 and are the <italic>samples</italic>, while nodes 3 and 4 represent those ancestors necessary to record their genealogy, who were born one and two units of time in the past, respectively.</p>
<p>The <italic>edges</italic> define how nodes relate to each other over specific genomic intervals. Each edge records the endpoints [<italic>ℓ</italic>, <italic>r</italic>) of the half-open genomic interval defining the spatial extent of the edge; and the identities <italic>p</italic> and <italic>c</italic> of the parent and child nodes of a single branch that occurs in all trees in this interval. The spatial extent of the edges defining the topology of <xref ref-type="fig" rid="pcbi.1006581.g003">Fig 3</xref> are shown in the bottom left panel. For example, the branch joining nodes 1 to 3 appears in both trees, and so is recorded as a single edge extending over the whole chromosome. It is this method of capturing the shared structure between adjacent trees that makes the tree sequence encoding compact and algorithmically efficient.</p>
<p>Recovering the sequence of trees from this information is straightforward: each point along the genome at which the tree topology changes is accompanied by the end of some edges and the beginning of others. Since each edge records the genomic interval over which a given node inherits from a particular ancestor, to construct the tree at a certain point in the genome we need only retrieve all edges overlapping that point and construct the corresponding tree. To modify the tree to reflect the genealogy at a nearby location, we simply remove those edges whose intervals do not overlap that location, and add those new edges whose intervals do. Incidentally, this property that edges naturally encode <italic>differences</italic> between nearby trees (e.g., as “subtree prune and regraft” moves) allows for efficient algorithms to compute statistics of the genome sequence that take advantage of the highly correlated nature of nearby trees [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>].</p>
<p>Given the topology defined by the nodes and edges, <italic>sites</italic> and <italic>mutations</italic> encode the sequence information for each sample in an efficient way. Each site records two things: its position on the genome and an ancestral state. For example, in <xref ref-type="fig" rid="pcbi.1006581.g003">Fig 3</xref> we have two sites, one at position 2.5 with ancestral state ‘A’ and the other at position 7.5 with ancestral state ‘G’. If no mutations occur at a given site, all nodes inherit the ancestral state. Each mutation records three things: the site at which it occurs, the first node to inherit the mutation, and the derived state. Thus, all nodes below the mutation’s node in the tree will inherit this state, unless further mutations are encountered. Three mutations are shown in <xref ref-type="fig" rid="pcbi.1006581.g003">Fig 3</xref>, illustrated by red stars. The first site, in the left-hand tree, has a single mutation, which results in node 2 inheriting the state ‘T’. The second site, in the right hand tree, has two mutations: one occurring over node 3 changing the state to ‘C’, and a back mutation over node 1 changing the state to ‘G’.</p>
<p>This encoding of a sequence of trees and accompanying mutational information is very concise. To illustrate this, we used <monospace>msprime</monospace> to simulate 500,000 samples of a 200 megabase chromosome with human-like parameters: <italic>N</italic><sub><italic>e</italic></sub> = 10<sup>4</sup> and per-base mutation and recombination rates of 10<sup>−8</sup> per generation. This resulted in about 1 million distinct marginal trees and 1.1 million infinite-sites mutations. The HDF5 file encoding the node, edge, site and mutation tables (as described above) for this simulation consumed 157MiB of storage space. Using the <monospace>tskit</monospace> Python API, the time required to load this file into memory was around 1.5 seconds, and the time required to iterate over all 1 million trees was 2.7 seconds. In contrast, recording the topological information in Newick format would require around 20 TiB and storing the genotype information in VCF would require about 1 TiB (giving a compression factor of 144,000 in this instance). Working with either the Newick or VCF encoding of this dataset would likely require several days of CPU time just to read the information into memory.</p>
<sec id="sec005">
<title>Validity of a set of tables</title>
<p>Given a set of node and edge tables as described above, there are only two requirements that ensure the tables describe a valid tree sequence. These are:</p>
<list list-type="order">
<list-item>
<p>Offspring must be born after their parents (and hence, no loops).</p>
</list-item>
<list-item>
<p>The set of intervals on which each individual is a child must be disjoint.</p>
</list-item>
</list>
<p specific-use="continuation">A pair of node and edge tables that satisfy these two requirements is guaranteed to uniquely describe at each point on the genome a collection of directed, acyclic graphs—in other words, a forest of trees. For some applications it is necessary to check that at every point there is only a <italic>single</italic> tree. Checking this is more difficult, but is implemented in <monospace>tskit</monospace>’s API. For efficiency, <monospace>tskit</monospace> makes several other sortedness requirements on the tables, that are not necessarily satisfied by tables emitted by a forwards-time simulation. <monospace>tskit</monospace>’s API includes tools to rectify this by first sorting and then using the <monospace>simplify</monospace> algorithm described below, which works on sorted tables and is guaranteed to produce a valid, <monospace>tskit</monospace>-ready tree sequence.</p>
</sec>
</sec>
<sec id="sec006">
<title>The <monospace>tskit</monospace> Tables API</title>
<p>The facilities for working with succinct tree sequences are implemented as part of the <monospace>tskit</monospace> Python API, which provides a powerful platform for processing tree topology and mutation data. The portions of <monospace>tskit</monospace> that we discuss here are dedicated to tree sequence input and output using simple tables of data, as described above, so we refer to this as the “Tables API”.</p>
<p>The Tables API is primarily designed to facilitate efficient interchange of data between programs or between different modules of the same program. We adopted a ‘columnar’ design, where all the values for a particular column are stored in adjacent memory locations. There are many advantages to columnar storage—for example, since adjacent values in memory are from the same column, they tend to compress well, and suitable encodings can be chosen on a per-column basis [<xref ref-type="bibr" rid="pcbi.1006581.ref028">28</xref>]. A particular advantage of this approach is that it enables very efficient copying of data, and in principle zero-copy data access (where a data consumer reads directly from the memory of a producer). Our implementation efficiently copies data from Python as a NumPy array [<xref ref-type="bibr" rid="pcbi.1006581.ref029">29</xref>] into the low-level C library used to manipulate tree sequences. This architecture allows for data transfer rates of gigabytes per second (impossible under any text-based approach), while retaining excellent portability. NumPy’s array interface provides a great deal of flexibility and efficiency, and makes it straightforward to transfer data from sources such as HDF5 [<xref ref-type="bibr" rid="pcbi.1006581.ref030">30</xref>] or Dask [<xref ref-type="bibr" rid="pcbi.1006581.ref031">31</xref>]. For small scale data and debugging purposes, a simple text based format is also supported.</p>
<p>The <monospace>tskit</monospace> Python Tables API provides a general purpose toolkit for importing and processing succinct tree sequences, and a collection of tutorials are being developed at <ext-link ext-link-type="uri" xlink:href="https://github.com/tskit-dev/tutorials" xlink:type="simple">https://github.com/tskit-dev/tutorials</ext-link>. Interoperation with Python simulators is then straightforward. The implementation we benchmark here uses <monospace>pybind11</monospace> (<ext-link ext-link-type="uri" xlink:href="https://github.com/pybind/pybind11/" xlink:type="simple">https://github.com/pybind/pybind11/</ext-link>) to interface with the <monospace>fwdpp</monospace> <monospace>C++</monospace> API [<xref ref-type="bibr" rid="pcbi.1006581.ref013">13</xref>]. No modifications were required to the <monospace>fwdpp</monospace> code base; rather, we simply need to bookkeep parent/offspring labels, and perform simple processing of the recombination breakpoints from each mating event to generate node and edge data. This information is then periodically copied to the <monospace>tskit</monospace> Tables API, where it is sorted and simplified.</p>
<sec id="sec007">
<title>Flexibility</title>
<p>To demonstrate the flexibility provided by the Tables API and provide an implementation that decouples forward simulation internals from transfer of data to <monospace>tskit</monospace>, we also implemented a version of the simulations described in “Simulation benchmarks” separately in Python, described in <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>. In this proof-of-concept implementation, the simulation engine (we use <monospace>simuPOP</monospace>, [<xref ref-type="bibr" rid="pcbi.1006581.ref032">32</xref>]) invokes callbacks at critical points of the simulation, and we infer nodes and edges from the information that is provided. Rows are appended to the tables one-by-one, and the tables are periodically sorted and simplified to control memory usage. Benchmarking results from this implementation are shown (alongside results from <monospace>fwdpp</monospace>) for simulations without selection in <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>: a relatively modest speedup of around 5× is achieved, likely due to increased overhead.</p>
</sec>
</sec>
<sec id="sec008">
<title>Recording the pedigree in forwards time</title>
<p>To record the genealogical history of a forwards time simulation, we need to record two things for each new chromosome: the birth time; and the endpoints and parental IDs of each distinctly inherited segment. These are naturally stored as the <italic>nodes</italic> and <italic>edges</italic> of a tree sequence. To demonstrate the idea, we write out in pseudocode how to run a neutral Wright–Fisher simulation that records genealogical history in this way. The simulation will run for <italic>T</italic> generations, and has <italic>N</italic> haploid individuals, each carrying a single chromosome of length <italic>L</italic>. For simplicity, we sample exactly one crossover per generation. Note that the <italic>table recording</italic> portion of the algorithm does not depend on the Wright–Fisher nature of the population simulation; next we will describe how to record tables from <italic>any</italic> simulation.</p>
<p>We use <inline-formula id="pcbi.1006581.e001"><alternatives><graphic id="pcbi.1006581.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e001" xlink:type="simple"/><mml:math display="inline" id="M1"><mml:mrow><mml:msub><mml:mi mathvariant="script">R</mml:mi> <mml:mi>U</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>A</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> to denote an element of the set <italic>A</italic> chosen uniformly at random (and all such instances are independent). Given a node table <inline-formula id="pcbi.1006581.e002"><alternatives><graphic id="pcbi.1006581.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e002" xlink:type="simple"/><mml:math display="inline" id="M2"><mml:mi mathvariant="script">N</mml:mi></mml:math></alternatives></inline-formula>, the function <inline-formula id="pcbi.1006581.e003"><alternatives><graphic id="pcbi.1006581.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e003" xlink:type="simple"/><mml:math display="inline" id="M3"><mml:mrow><mml:mi mathvariant="script">N</mml:mi> <mml:mo>.</mml:mo> <mml:mtext mathvariant="bold">addrow</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> adds a new node to the table <inline-formula id="pcbi.1006581.e004"><alternatives><graphic id="pcbi.1006581.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:mi mathvariant="script">N</mml:mi></mml:math></alternatives></inline-formula> with time <italic>t</italic> and returns the ID of this new node. Similarly, the function <inline-formula id="pcbi.1006581.e005"><alternatives><graphic id="pcbi.1006581.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e005" xlink:type="simple"/><mml:math display="inline" id="M5"><mml:mrow><mml:mi mathvariant="script">E</mml:mi> <mml:mo>.</mml:mo> <mml:mtext mathvariant="bold">addrow</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>ℓ</mml:mi> <mml:mo>,</mml:mo> <mml:mi>r</mml:mi> <mml:mo>,</mml:mo> <mml:mi>p</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> adds a new edge (<italic>ℓ</italic>eft, <italic>r</italic>ight, <italic>p</italic>arent, <italic>c</italic>hild) to the edge table <inline-formula id="pcbi.1006581.e006"><alternatives><graphic id="pcbi.1006581.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e006" xlink:type="simple"/><mml:math display="inline" id="M6"><mml:mi mathvariant="script">E</mml:mi></mml:math></alternatives></inline-formula>. The function <inline-formula id="pcbi.1006581.e007"><alternatives><graphic id="pcbi.1006581.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e007" xlink:type="simple"/><mml:math display="inline" id="M7"><mml:mrow><mml:mtext mathvariant="bold">simplify</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>P</mml:mi> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">E</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> (described below) simplifies the history stored in the tables <inline-formula id="pcbi.1006581.e008"><alternatives><graphic id="pcbi.1006581.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e008" xlink:type="simple"/><mml:math display="inline" id="M8"><mml:mi mathvariant="script">N</mml:mi></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1006581.e009"><alternatives><graphic id="pcbi.1006581.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e009" xlink:type="simple"/><mml:math display="inline" id="M9"><mml:mi mathvariant="script">E</mml:mi></mml:math></alternatives></inline-formula> to the minimal information required to represent the genealogies of the list of node IDs <italic>P</italic>; after simplification the nodes appearing in <italic>P</italic> are relabeled (0, 1, …, |<italic>P</italic>| − 1). A step-by-step explanation follows the pseudocode.</p>
<sec id="sec009">
<title>Algorithm W. (<italic>Forwards-time tree sequence</italic>)</title>
<p>Simulates a randomly mating population of <italic>N</italic> haploid individuals with chromosome of length <italic>L</italic> for <italic>T</italic> generations, and returns the node and edge tables (<inline-formula id="pcbi.1006581.e010"><alternatives><graphic id="pcbi.1006581.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:mi mathvariant="script">N</mml:mi></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1006581.e011"><alternatives><graphic id="pcbi.1006581.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:mi mathvariant="script">E</mml:mi></mml:math></alternatives></inline-formula>) recording the simulated history. In each generation, the current population is stored in <italic>P</italic>, while produced offspring are placed in <italic>P</italic>′. The tables are simplified every <italic>s</italic> generations, removing genealogical information from <inline-formula id="pcbi.1006581.e012"><alternatives><graphic id="pcbi.1006581.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e012" xlink:type="simple"/><mml:math display="inline" id="M12"><mml:mi mathvariant="script">N</mml:mi></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1006581.e013"><alternatives><graphic id="pcbi.1006581.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e013" xlink:type="simple"/><mml:math display="inline" id="M13"><mml:mi mathvariant="script">E</mml:mi></mml:math></alternatives></inline-formula> irrelevant to the current population.</p>
<list list-type="simple">
<list-item>
<label>W1</label>
<p>[Initialisation.] Set <inline-formula id="pcbi.1006581.e014"><alternatives><graphic id="pcbi.1006581.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e014" xlink:type="simple"/><mml:math display="inline" id="M14"><mml:mrow><mml:mi mathvariant="script">N</mml:mi> <mml:mo>←</mml:mo> <mml:mtext mathvariant="bold">NodeTable</mml:mtext> <mml:mo>(</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1006581.e015"><alternatives><graphic id="pcbi.1006581.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e015" xlink:type="simple"/><mml:math display="inline" id="M15"><mml:mrow><mml:mi mathvariant="script">E</mml:mi> <mml:mo>←</mml:mo> <mml:mtext mathvariant="bold">EdgeTable</mml:mtext> <mml:mo>(</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <italic>t</italic> ← <italic>T</italic>, and <italic>j</italic> ← 0. For 0 ≤ <italic>k</italic> &lt; <italic>N</italic>, set <inline-formula id="pcbi.1006581.e016"><alternatives><graphic id="pcbi.1006581.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e016" xlink:type="simple"/><mml:math display="inline" id="M16"><mml:mrow><mml:msub><mml:mi>P</mml:mi> <mml:mi>k</mml:mi></mml:msub> <mml:mo>←</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>.</mml:mo> <mml:mtext mathvariant="bold">addrow</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>T</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<label>W2</label>
<p>[Generation loop head: new node.] Set <inline-formula id="pcbi.1006581.e017"><alternatives><graphic id="pcbi.1006581.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e017" xlink:type="simple"/><mml:math display="inline" id="M17"><mml:mrow><mml:mi>u</mml:mi> <mml:mo>←</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>.</mml:mo> <mml:mtext mathvariant="bold">addrow</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1006581.e018"><alternatives><graphic id="pcbi.1006581.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e018" xlink:type="simple"/><mml:math display="inline" id="M18"><mml:mrow><mml:msubsup><mml:mi>P</mml:mi> <mml:mi>j</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>←</mml:mo> <mml:mi>u</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<label>W3</label>
<p>[Choose parents.] Set <inline-formula id="pcbi.1006581.e019"><alternatives><graphic id="pcbi.1006581.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e019" xlink:type="simple"/><mml:math display="inline" id="M19"><mml:mrow><mml:mi>a</mml:mi> <mml:mo>←</mml:mo> <mml:msub><mml:mi mathvariant="script">R</mml:mi> <mml:mi>U</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1006581.e020"><alternatives><graphic id="pcbi.1006581.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e020" xlink:type="simple"/><mml:math display="inline" id="M20"><mml:mrow><mml:mi>b</mml:mi> <mml:mo>←</mml:mo> <mml:msub><mml:mi mathvariant="script">R</mml:mi> <mml:mi>U</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1006581.e021"><alternatives><graphic id="pcbi.1006581.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e021" xlink:type="simple"/><mml:math display="inline" id="M21"><mml:mrow><mml:mi>x</mml:mi> <mml:mo>←</mml:mo> <mml:msub><mml:mi mathvariant="script">R</mml:mi> <mml:mi>U</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mi>L</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<label>W4</label>
<p>[Record edges.] Call <inline-formula id="pcbi.1006581.e022"><alternatives><graphic id="pcbi.1006581.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e022" xlink:type="simple"/><mml:math display="inline" id="M22"><mml:mrow><mml:mi mathvariant="script">E</mml:mi> <mml:mo>.</mml:mo> <mml:mtext mathvariant="bold">addrow</mml:mtext> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mi>x</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>a</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mi>u</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1006581.e023"><alternatives><graphic id="pcbi.1006581.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e023" xlink:type="simple"/><mml:math display="inline" id="M23"><mml:mrow><mml:mi mathvariant="script">E</mml:mi> <mml:mo>.</mml:mo> <mml:mtext mathvariant="bold">addrow</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>x</mml:mi> <mml:mo>,</mml:mo> <mml:mi>L</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mi>b</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mi>u</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<label>W5</label>
<p>[Individual loop.] Set <italic>j</italic> ← <italic>j</italic> + 1. If <italic>j</italic> &lt; <italic>N</italic> go to W2. Otherwise, if <italic>t</italic> mod <italic>s</italic> ≠ 0 go to W7.</p>
</list-item>
<list-item>
<label>W6</label>
<p>[Simplify.] Call <inline-formula id="pcbi.1006581.e024"><alternatives><graphic id="pcbi.1006581.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e024" xlink:type="simple"/><mml:math display="inline" id="M24"><mml:mrow><mml:mtext mathvariant="bold">simplify</mml:mtext> <mml:mo>(</mml:mo> <mml:msup><mml:mi>P</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">E</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, and set <inline-formula id="pcbi.1006581.e025"><alternatives><graphic id="pcbi.1006581.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e025" xlink:type="simple"/><mml:math display="inline" id="M25"><mml:mrow><mml:msubsup><mml:mi>P</mml:mi> <mml:mi>k</mml:mi> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>←</mml:mo> <mml:mi>k</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> for 0 ≤ <italic>k</italic> &lt; <italic>N</italic>.</p>
</list-item>
<list-item>
<label>W7</label>
<p>[Generation loop.] Set <italic>t</italic> ← <italic>t</italic> − 1. If <italic>t</italic> = 0 terminate. Set <italic>P</italic> ← <italic>P</italic>′, <italic>j</italic> ← 0, and go to W2.</p>
</list-item>
</list>
<p>We begin in W1 by creating new node and edge tables, and setting our population <italic>P</italic> (a vector of <italic>N</italic> node IDs) to the initial population. This initial population is a set of <italic>N</italic> nodes with birth time <italic>T</italic> generations ago. We also initialise our generation clock <italic>t</italic> and individual index <italic>j</italic>. Step W2 replaces the <italic>j</italic><sup>th</sup> individual (with node ID <italic>P</italic><sub><italic>j</italic></sub>) by creating a new node with birth time <italic>t</italic> (and ID <italic>u</italic>). In step W3 we determine the new node’s ancestry by choosing two indexes <italic>a</italic> and <italic>b</italic> uniformly, giving us parental IDs <italic>P</italic><sub><italic>a</italic></sub> and <italic>P</italic><sub><italic>b</italic></sub>, and choose a chromosomal breakpoint <italic>x</italic>. We record the effects of this event by storing two new edges: one recording that the parent of node <italic>u</italic> from 0 to <italic>x</italic> is <italic>P</italic><sub><italic>a</italic></sub>, and another recording that the parent of <italic>u</italic> from <italic>x</italic> to <italic>L</italic> is <italic>P</italic><sub><italic>b</italic></sub>. Step W5 then iterates these steps for each of the <italic>N</italic> individuals for each generation. At the end of a generation, we then check if we need to simplify (done every <italic>s</italic> generations). If simplification is required, we do this in step W6 by calling the simplify function on the node and edge tables with the current set of population IDs <italic>P</italic>′ as the samples. This updates the tables in-place to remove all redundant information, and remaps the specified sample IDs to 0, …, <italic>N</italic> − 1 in the updated tables. Hence, we set our current population IDs to 0, …<italic>N</italic> − 1 after simplify has completed. Step W7 loops these steps until the required number of generations have been simulated.</p>
<p>This algorithm records only topological information about the simulated genealogies, but it is straightforward to add mutational information. Mutations that occur during the simulation can be recorded by simply storing the node in which they first occur, the derived state, and (if not already present) the genomic position of the site at which it occurs. This allows selected mutations, that the forwards time simulation must generate, to be recorded in the tree sequence. Neutral mutations can be generated after the simulation has completed, thus avoiding the cost of generating the many mutations that are lost in the population. This is straightforward to do because we have access to the marginal genealogies.</p>
<p>
<xref ref-type="fig" rid="pcbi.1006581.g004">Fig 4</xref> shows an example of a marginal genealogy produced by a forwards-time Wright–Fisher process like Algorithm W. On the left is the tree showing all the edges output by the simulation, while on the right is the minimal tree representing the ancestry of the current set of samples. Clearly there is a great deal of redundancy in the topological information output by the simulation. This redundancy comes from two sources. First, there are a large number of nodes in the tree that have only one child. In Algorithm W we do not attempt to identify coalescence events, but simply record all parent-child relationships in the history of the population. As such, many of these edges will record the simple passing of genealogical information from parent to child and only some small subset will correspond to coalescences within the marginal trees. The second source of redundancy in the (unsimplified) output of Algorithm W is due to the fact that lineages die out: a large number of individuals in the simulation leave no descendants in the present day population. Node 26 in <xref ref-type="fig" rid="pcbi.1006581.g004">Fig 4a</xref>, for example, leaves no ancestors in the current population, and so the entire path tracing back to its common ancestor with 27 is redundant.</p>
<fig id="pcbi.1006581.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g004</object-id>
<label>Fig 4</label>
<caption>
<title>An example of a marginal genealogy from a Wright-Fisher simulation with <italic>N</italic> = 5.</title>
<p><bold>(A)</bold> the original tree including all intermediate nodes and dead-ends, and <bold>(B)</bold> the minimal tree relating all of the currently-alive individuals (27–31).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g004" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec010">
<title>Essential steps in tree sequence recording</title>
<p>Since a tree sequence can record the history of genetic inheritance in any situation (requiring only unambiguous inheritance and no time travel), any individual-based population genetics simulator can maintain a tree sequence with only a little bookkeeping. We have furthermore provided several tools to minimize this bookkeeping, only requiring one-way output at the birth of each new individual. Concretely, to record a tree sequence, including mutations, a simulator must record for each new genome (so, twice for each new diploid individual):</p>
<list list-type="bullet">
<list-item>
<p>the birth time of the genome in the Node Table,</p>
</list-item>
<list-item>
<p>the segments the genome inherits from its parental genomes in the Edge Table,</p>
</list-item>
<list-item>
<p>the locations of any new mutations in the Site Table,</p>
</list-item>
<list-item>
<p>and the derived state of these new mutations in the Mutation Table (as well as the identity of this genome the mutations appeared in).</p>
</list-item>
</list>
<p specific-use="continuation">Each of these can be simply appended to the ends of the respective tables. Besides this, simplification should be run every once in a while (e.g., every 100 generations). Before simplification, time in the Node Table must be translated to “time ago” if it is not already. (This was avoided in Algorithm W since there <italic>t</italic> denoted “time until the end of the simulation”). There are also several “cleaning” steps, for which we provide functions in the Tables API: <italic>sorting</italic> according to several criteria for algorithmic efficiency; and removing any duplicate sites from the Site Table. After simplification, since <inline-formula id="pcbi.1006581.e026"><alternatives><graphic id="pcbi.1006581.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e026" xlink:type="simple"/><mml:math display="inline" id="M26"><mml:mrow><mml:mtext mathvariant="bold">simplify</mml:mtext> <mml:mo>(</mml:mo> <mml:msup><mml:mi>P</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">E</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> results in the <italic>N</italic> individuals in <italic>P</italic>′ being relabeled in <monospace>tskit</monospace>’s tables as 0, 1, …, <italic>N</italic> − 1, there must be bookkeeping that keeps in sync the individual IDs as recorded by the simulator with the node IDs recorded in the tables.</p>
<p>In other words, to record a tree sequence, a simulation needs only to know (a) which genomes recombined to produce each new genome, and how; (b) the locations and results of any new mutations on each genome; and (c) the identities of every currently alive individual at each time simplification occurs.</p>
</sec>
<sec id="sec011">
<title>Storing metadata</title>
<p>Applications may also want to store more information not fitting into an existing column of the tables, such as the selection coefficient of a mutation, or the sex of an individual. This (and, indeed, arbitrary information) can be stored in the <monospace>metadata</monospace> columns present in Node, Site, and Mutation tables.</p>
</sec>
</sec>
<sec id="sec012">
<title>Tree sequence simplification</title>
<p>It is desirable for many reasons to remove redundant information from a tree sequence. To formalize this: suppose that we are only interested in a subset of the nodes of a tree sequence (which we refer to as our ‘samples’), and wish to reduce this input tree sequence to the smallest one that still completely describes the history of the specified samples, having the following properties:</p>
<list list-type="order">
<list-item>
<p>All marginal trees must match the subtree of the corresponding tree in the input tree sequence that is induced by the samples.</p>
</list-item>
<list-item>
<p>Within the marginal trees, all non-sample vertices must have at least two children (i.e., unary tree vertices are removed).</p>
</list-item>
<list-item>
<p>Any nodes and edges not ancestral to any of the sampled nodes are removed.</p>
</list-item>
<list-item>
<p>There are no adjacent redundant edges, i.e., pairs of edges (<italic>ℓ</italic>, <italic>x</italic>, <italic>p</italic>, <italic>c</italic>) and (<italic>x</italic>, <italic>r</italic>, <italic>p</italic>, <italic>c</italic>) which can be represented with a single edge (<italic>ℓ</italic>, <italic>r</italic>, <italic>p</italic>, <italic>c</italic>).</p>
</list-item>
</list>
<p>Simplification is essential not only for keeping the information recorded by forwards simulation manageable, but also is useful for extracting subsets of a tree sequence representing a very large dataset.</p>
<p>We implement simplification by starting at the end of the simulation, and moving back up through history, recording in the new tree sequence only that information necessary to construct the tree sequence of the specified individuals. This process of tracing ancestry back through time in a pedigree was the motivation for Hudson’s coalescent simulation algorithm [<xref ref-type="bibr" rid="pcbi.1006581.ref033">33</xref>], so it is unsurprising that simplification uses many of the same tools as the implementation of Hudson’s algorithm in <monospace>msprime</monospace> [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>]. The main difference is that events in a coalescent simulation are random, while in our simplification algorithm they are predetermined by history. An implementation in pseudocode is provided in <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>, and a python implementation as supplementary information.</p>
<p>Conceptually, this works by (a) beginning by painting the chromosome in each sample a distinct color; (b) moving back through history, copying the colors of each chromosome to the portions of its parental chromosomes from which it was inherited; (c) each time we would paint two colors in the same spot (a coalescence), record that information as an edge and instead paint a brand-new color; and (d) once all colors have coalesced on a given segment, stop propagating it. This “paint pot” description misses some details—for instance, we must ensure that all coalescing segments in a given individual are assigned the <italic>same</italic> new color—but is reasonably close. <xref ref-type="fig" rid="pcbi.1006581.g005">Fig 5</xref> shows an example tree sequence, before and after simplification, and <xref ref-type="fig" rid="pcbi.1006581.g006">Fig 6</xref> depicts the “paint pot” state of the algorithm during the process of simplifying this tree sequence. Since the method begins with the samples and moves back through time, in the output tree sequence, the <italic>n</italic> samples will be numbered 0, 1, …, <italic>n</italic> − 1 and subsequent nodes will be ordered by time since birth. This is seen in the red labels of <xref ref-type="fig" rid="pcbi.1006581.g005">Fig 5</xref>.</p>
<fig id="pcbi.1006581.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g005</object-id>
<label>Fig 5</label>
<caption>
<title>An example of tree sequence simplification.</title>
<p><bold>(A)</bold> The augmented pedigree diagram on the left relates the ten homologous chromosomes of five diploid individuals (BC, DE, FG, HI, and JK) to each other and to a common ancestral chromosome (A); dotted lines connect the two chromosomes of each individual, and solid lines lead to the products of their meioses. The corresponding tables (right) have 11 node records (one for each chromosome) and 15 edge records (one for each distinctly inherited segment). Blue numbers denote crossing over locations—for instance, <italic>D</italic> and <italic>E</italic> were parents to <italic>G</italic>, who inherited the left 70% of the chromosome from <italic>E</italic> and the remainder from <italic>D</italic>. <italic>B</italic>, <italic>C</italic>, <italic>D</italic>, and <italic>E</italic> inherit clonally from <italic>A</italic>. <bold>(B)</bold> The five distinct trees found across the chromosome (blue numbers denote locations on the chromosome). Labels after simplification are shown in red (see text). <bold>(C)</bold> Tables recording the tree sequence after simplification with nodes <italic>J</italic> and <italic>K</italic> as samples. The mapping from labels in the forwards time simulation to nodes in the tree sequence is shown in red.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g005" xlink:type="simple"/>
</fig>
<fig id="pcbi.1006581.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g006</object-id>
<label>Fig 6</label>
<caption>
<title>A depiction of each state of the simplification algorithm as it moves up through the embellished pedigree in the example of <xref ref-type="fig" rid="pcbi.1006581.g005">Fig 5A</xref>.</title>
<p>Following the “paint pot” description in the text, we begin by coloring J and K’s genomes in red and blue respectively, then trace how these colors were inherited back up through the pedigree until they coalesce. To aid in this, the smaller colored chromosomes on either side of each solid arrow show the bits inherited from each of the two parental chromosomes, with genomic position 0.0 on the bottom and 1.0 at the top. Each time a red and a blue segment overlap, a coalescence occurs, two edges are output, and we stop propagating that segment. For instance, both J and K inherit from H between 0.5 and 0.9, which resulted in the first two edges of the simplified table of <xref ref-type="fig" rid="pcbi.1006581.g005">Fig 5C</xref>. Later, both inherit from E between 0.2 and 0.5, along the paths J-H-G-E and K-I-E respectively, resulting in the next two edges.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g006" xlink:type="simple"/>
</fig>
<p>More concretely, the algorithm works by moving back through time, processing each parent in the input tree sequence in chronological order. The main state of the algorithm at each point in time is a set of ancestral lineages, and each lineage is a linked list of ancestral segments. An ancestral segment (<italic>ℓ</italic>, <italic>r</italic>, <italic>u</italic>) is found in a lineage if the output node <italic>u</italic> inherits the genomic interval [<italic>ℓ</italic>, <italic>r</italic>) from that lineage (and so <italic>u</italic> corresponds to a “color” in the description above). We also maintain a map from input nodes to lineages. Crucially, the time required to run the algorithm is linear in the number of edges of the input tree sequence.</p>
<sec id="sec013">
<title>Sequential simplification and prior history</title>
<p>Any simulation scheme that records data into tables, as Algorithm W does, has its genealogical history available at any time as a tree sequence. This has two additional advantages: First, simplification can be run periodically through the simulation, if we take the set of samples to be the entire currently alive population. This is important in practice as it keeps memory usage from growing linearly (and quickly) with time. Second, the simulation can be <italic>begun</italic> with a tree sequence produced by some other method—for instance, by a coalescent simulation with <monospace>msprime</monospace>, providing an easy, efficient way to specify prior history. A natural question is now: how often should simplification occur? Limited testing (described in <xref ref-type="supplementary-material" rid="pcbi.1006581.s001">S1 Text</xref>) found that different simplification intervals affect run times by approximately 25%, with the lowest run time occurring when simplifying every 10<sup>3</sup> generations. Thus, there is a memory-versus-speed tradeoff—simplifying more often would keep fewer extinct nodes and edges in memory.</p>
</sec>
<sec id="sec014">
<title>Computational complexity</title>
<p>Figs <xref ref-type="fig" rid="pcbi.1006581.g001">1</xref> and <xref ref-type="fig" rid="pcbi.1006581.g002">2</xref> show that this method can dramatically improve simulation performance in practice—but, how does it perform in theory? Both computational time and storage space are depend mostly on the number of <italic>mutations</italic> and <italic>edges</italic> in the tree sequence. The key quantity to understand for this will be the total “area” of the tree sequence, which is the sum of the lengths of all ancestral genomic segments that some, but not all, of the present population has inherited. It can be found by summing the product of segment length (left minus right coordinates) and edge length (difference in birth times between parent and child), across all edges. This area is also equal to the sum of the total lengths of all marginal trees (i.e., the trees describing inheritance at each position on the genome), so can be computed as the sequence length multiplied by the mean marginal tree length. Since we analyze tree sequences arising from a Wright–Fisher model, statistical properties of a marginal tree are fairly well-described by coalescent theory. Similar arguments to those below go back at least to Watterson [<xref ref-type="bibr" rid="pcbi.1006581.ref034">34</xref>], who also explicitly computed smaller order corrections relevant to whole-population genealogies of the Wright–Fisher model. The arguments below are mostly self-contained, but for an introduction to coalescent theory, including the basic facts used below, see [<xref ref-type="bibr" rid="pcbi.1006581.ref015">15</xref>].</p>
<p>First: how much memory do simplified tree sequences require? Consider a simulation of a Wright–Fisher population of <italic>N</italic> haploid individuals using Algorithm W for <italic>T</italic> generations. Since every chromosome inherits material from both parents, without simplification this would produce tables of <italic>NT</italic> nodes and 2<italic>NT</italic> edges. After simplification, we are left with the tree sequence describing the history of only the current generation of <italic>N</italic> individuals, back to either <italic>T</italic> generations ago, or their common ancestor, whichever comes first. The tree sequence must store edges describing the leftmost marginal tree, which requires at most 2<italic>N</italic> − 2 edges. Then, each time the marginal tree changes along the sequence, four edges end and four new edges begin (except for changes affecting the root, which require fewer; see [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>]). Suppose that <inline-formula id="pcbi.1006581.e027"><alternatives><graphic id="pcbi.1006581.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e027" xlink:type="simple"/><mml:math display="inline" id="M27"><mml:msub><mml:mi mathvariant="script">T</mml:mi> <mml:mi>x</mml:mi></mml:msub></mml:math></alternatives></inline-formula> is the marginal tree at genomic position <italic>x</italic>, and write <inline-formula id="pcbi.1006581.e028"><alternatives><graphic id="pcbi.1006581.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e028" xlink:type="simple"/><mml:math display="inline" id="M28"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mi mathvariant="script">T</mml:mi> <mml:mi>x</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> for the total length of the tree. For the tree at nearby position <italic>x</italic> + <italic>dx</italic> to be different, there must have been a crossing-over between <italic>x</italic> and <italic>x</italic> + <italic>dx</italic> in one of the <inline-formula id="pcbi.1006581.e029"><alternatives><graphic id="pcbi.1006581.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e029" xlink:type="simple"/><mml:math display="inline" id="M29"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mi mathvariant="script">T</mml:mi> <mml:mi>x</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> meioses that gave birth to those individuals. (Recall that these “individuals” are haploid). Since we measure distance along the genome so that length is equal to the expected number of crossing-overs per generation, the expected distance until the next crossing-over is <inline-formula id="pcbi.1006581.e030"><alternatives><graphic id="pcbi.1006581.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e030" xlink:type="simple"/><mml:math display="inline" id="M30"><mml:mrow><mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mo>|</mml:mo></mml:mrow> <mml:msub><mml:mi mathvariant="script">T</mml:mi> <mml:mi>x</mml:mi></mml:msub> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. If every crossing-over changed the marginal tree, then this would imply, for consistency, that the expected total number of times that the marginal tree changes along the genome is equal to the total area of the tree sequence (as defined above). Not every such crossing-over changes the marginal tree, but most do, so the total area of the tree sequence, multiplied by four, gives an upper bound on the expected number of edges in the tree sequence beyond those describing the leftmost tree. Since we are considering a chromosome of length 1, the expected total area is equal to the mean marginal tree length, as above.</p>
<p>If <italic>T</italic> is large relative to <italic>N</italic>, so that all marginal trees have a single root with high probability, then coalescent theory tells us that the expected total length of the branches of a marginal tree back to the most recent common ancestor is approximately 2<italic>N</italic> log(<italic>N</italic>). Therefore, the tree sequence describing the entire population is expected to need no more than 2<italic>N</italic> + 8<italic>N</italic> log(<italic>N</italic>) edges. Not every new edge derives from a never-before-seen node, but the number of nodes is at most equal to the number of edges plus the sample size. Therefore, we would need <italic>O</italic>(<italic>N</italic><sup>2</sup>) space to store the complete history of the simulation, but only <italic>O</italic>(<italic>N</italic> log <italic>N</italic>) to store the history that is relevant to the extant population.</p>
<p>What if <italic>T</italic> is smaller: how many of the resulting 2<italic>NT</italic> edges are required after simplification? In other words, how fast does the information in the pedigree become irrelevant? Now, we need to compute the expected total length of all branches in a coalescent tree up until time <italic>T</italic> (or the common ancestor, whichever comes first). Again, coalescent theory tells us that the expected length of time for which a coalescent tree has <italic>k</italic> lineages is 2<italic>N</italic>/(<italic>k</italic>(<italic>k</italic> − 1)) = 2<italic>N</italic>(1/(<italic>k</italic> − 1) − 1/<italic>k</italic>) generations. Since the tree has <italic>k</italic> branches over this period, it is expected to contribute 2<italic>N</italic>/(<italic>k</italic> − 1) to the total tree length. By summing over <italic>n</italic> &lt; <italic>k</italic> ≤ <italic>N</italic>, the <italic>N</italic> tips of a tree are expected to descend from only <italic>n</italic> lineages around 2(<italic>N</italic>/<italic>n</italic> − 1) generations ago. Inverting this relationship between time and number of roots implies that a marginal tree cut <italic>T</italic> units of time ago is expected to have around <italic>r</italic>(<italic>T</italic>) roots, where <italic>r</italic>(<italic>T</italic>) = 2<italic>N</italic>/(<italic>T</italic> + 2). The total tree length over this time is <inline-formula id="pcbi.1006581.e031"><alternatives><graphic id="pcbi.1006581.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e031" xlink:type="simple"/><mml:math display="inline" id="M31"><mml:mrow><mml:mn>2</mml:mn> <mml:mi>N</mml:mi> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mi>r</mml:mi> <mml:mo>(</mml:mo> <mml:mi>T</mml:mi> <mml:mo>)</mml:mo> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>N</mml:mi></mml:msubsup> <mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≈</mml:mo> <mml:mn>2</mml:mn> <mml:mi>N</mml:mi> <mml:mo form="prefix">log</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>/</mml:mo> <mml:mi>r</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>T</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, since <inline-formula id="pcbi.1006581.e032"><alternatives><graphic id="pcbi.1006581.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e032" xlink:type="simple"/><mml:math display="inline" id="M32"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>x</mml:mi></mml:msubsup> <mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mi>k</mml:mi> <mml:mo>≈</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>x</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mi>γ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. This is a crude estimate for several reasons: first, we should not count the branch leading to the root of the tree (i.e., when <italic>r</italic>(<italic>T</italic>) = 1), and second, this does not account for the discrete nature of the Wright–Fisher model. Nonetheless, this leads as above to an upper bound on the number of edges of
<disp-formula id="pcbi.1006581.e033"><alternatives><graphic id="pcbi.1006581.e033g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006581.e033" xlink:type="simple"/><mml:math display="block" id="M33"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mn>2</mml:mn> <mml:mi>N</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mn>4</mml:mn> <mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>,</mml:mo> <mml:mfrac><mml:mrow><mml:mi>T</mml:mi> <mml:mo>+</mml:mo> <mml:mn>2</mml:mn></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(1)</label></disp-formula>
This implies that the number of edges required to store the last <italic>T</italic> generations of history for the entire chromosome of a population of size <italic>N</italic> grows as <italic>O</italic>(<italic>N</italic> log <italic>T</italic>)—proportionally to <italic>N</italic> at first but rapidly tapering off. The bound holds up reasonably well in practice, as shown in <xref ref-type="fig" rid="pcbi.1006581.g007">Fig 7</xref>.</p>
<fig id="pcbi.1006581.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006581.g007</object-id>
<label>Fig 7</label>
<caption>
<title>Time and space complexity of simplify.</title>
<p><bold>(A)</bold> Number of edges in the simplified tree sequence for 10 replicate Wright–Fisher simulations with <italic>N</italic> = 100 as a function of number of generations. Each line is one simulation, the heavy blue line gives the average, and the dashed line is the upper bound of <xref ref-type="disp-formula" rid="pcbi.1006581.e033">Eq (1)</xref>. <bold>(B)</bold> Time required to simplify the first <italic>k</italic> edges of a large (4.2GiB) unsimplified tree sequence produced by a forwards-time simulation plotted against <italic>k</italic>. The time scales linearly with the number of input edges. <bold>(C)</bold> Time required to simplify the tree sequence resulting from a coalescent simulation of 500,000 samples of a 200 megabase human chromosome to a random subsample of <italic>n</italic> samples, plotted against <italic>n</italic> (note the log scale; the time scales logarithmically with <italic>n</italic>).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.g007" xlink:type="simple"/>
</fig>
<p>What about mutations? Forwards-time generation of infinite-sites mutations with total mutation rate per generation <italic>μ</italic> would produce around <italic>μNT</italic> mutations (and the same number of sites), simply because there was a total of <italic>NT</italic> meioses. Since mutations that are retained after simplification are precisely those that fall on the marginal trees, the number of mutations is proportional to the total area of the tree sequence. By the same argument as for the number of edges, this will result in around <italic>μ</italic>2<italic>N</italic> log(<italic>N</italic>) mutations. With <italic>N</italic> = 2 × 10<sup>4</sup> and <italic>T</italic> = 10<italic>N</italic>, this implies that adding neutral mutations to the simplified tree sequence reduces the number of mutations that must be generated by a factor of 10,000. This could result in substantial time savings, even without considering the computational burden of propagating mutations forwards across generations.</p>
<p>Since each mutation is stored only as a single row in the mutation table, and at most one row in the site table, the space required for <italic>M</italic> mutations is <italic>O</italic>(<italic>M</italic>); combined with the <italic>O</italic>(<italic>N</italic> log <italic>N</italic>) storage for edges and nodes of a simplified tree sequence, this implies that the full results of a simulation of <italic>N</italic> individuals having <italic>M</italic> mutations can be stored in <italic>O</italic>(<italic>N</italic> log <italic>N</italic> + <italic>M</italic>) space. In simulations of whole chromosomes, there are typically a small, bounded number of mutations per chromosome per generation, so <italic>M</italic> will be <italic>O</italic>(<italic>N</italic> log <italic>N</italic>) as well.</p>
<p>How does the computation <italic>time</italic> required for simplification scale? Simply because it must process each edge, the simplification algorithm is at least linear in the number of edges of the input tree sequence. Empirically the algorithm is exactly linear, as seen in <xref ref-type="fig" rid="pcbi.1006581.g007">Fig 7B</xref>, which shows the time required to simplify increasingly large subsets of a large tree sequence. When simplifying the result of a forwards-time sequence, the number of edges is the main contributing factor. Suppose on the other hand we want to simplify an already-minimal but large tree sequence with <italic>N</italic> nodes to a subsample of size <italic>n</italic>. How does the required time scale with <italic>n</italic>? In this case, the computation is dominated by the size of the output tree sequence, which grows with log(<italic>n</italic>), as shown in <xref ref-type="fig" rid="pcbi.1006581.g007">Fig 7C</xref>.</p>
</sec>
</sec>
</sec>
<sec id="sec015" sec-type="conclusions">
<title>Discussion</title>
<p>In this paper, we have shown that storing pedigrees and associated recombination events in a forwards-time simulation not only results in having available a great deal more information about the simulated population, but also can speed up the simulation by orders of magnitude. To make this feasible, we have described how to efficiently store this information in numerical tables, and have described a fundamental algorithm for simplification of tree sequences. Conceptually, recording of genealogical and recombination events can happen independently of the details of simulation; for this reason, we provide a well-defined and well-tested API in Python for use in other code bases (a C API is also planned).</p>
<p>The tree sequences produced by default by this method are very compact, storing genotype <italic>and</italic> genealogical information in a small fraction of the space taken by a compressed VCF file. The format also allows highly efficient processing for downstream analysis. Efficient processing is possible because many statistics of interest for population genetics are naturally expressed in terms of tree topologies, and so can be quickly computed from the trees underlying the tree sequence format. For example, pairwise nucleotide diversity <italic>π</italic>, is the average density of differences between sequences in the sample. To compute this directly from sequence data at <italic>m</italic> sites in <italic>n</italic> samples requires computing allele frequencies, taking <italic>O</italic>(<italic>nm</italic>) operations. By using the locations of the mutations on the marginal trees, and the fact that these are correlated, sequential tree algorithms similar to those in [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>] can do this in roughly <italic>O</italic>(<italic>n</italic> + <italic>m</italic> + <italic>t</italic> log <italic>n</italic>) operations, where <italic>t</italic> is the number of distinct trees. The <monospace>tskit</monospace> API provides a method to compute <italic>π</italic> among arbitrary subsets of the samples in a tree sequence, which took about 0.7 seconds when applied to an example simulation of 100 megabases of human-like sequence for 200,000 samples (about 500K sites). The corresponding numeric genotype matrix required about 95GiB of RAM, and calculating <italic>π</italic> took about 66 seconds with NumPy.</p>
<p>Another attractive feature of this set of tools is that it makes it easy to incorporate <italic>prior history</italic>, simply by seeding the simulation with a (relatively inexpensive) coalescent simulation. This allows for incorporation of deep-time history beyond the reach of individual-based simulations. This may not even negatively affect realism, since geographic structure from times longer ago than the mixing time of migration across the range has limited effect on modern genealogies [<xref ref-type="bibr" rid="pcbi.1006581.ref035">35</xref>], other than possibly changing effective population size [<xref ref-type="bibr" rid="pcbi.1006581.ref036">36</xref>, <xref ref-type="bibr" rid="pcbi.1006581.ref037">37</xref>].</p>
<sec id="sec016">
<title>Other applications</title>
<p>The methods described here for efficiently storing tree sequences may prove useful in other fields. We have focused on the interpretation of tree sequences as the outcome of the process of recombination, but in principle, we can efficiently encode any sequence of trees which differ by subtree-prune-and-regraft operations. Since each such operation requires a constant amount of space to encode, the total space required is <italic>O</italic>(<italic>n</italic> + <italic>t</italic>) for <italic>t</italic> trees with <italic>n</italic> leaves [<xref ref-type="bibr" rid="pcbi.1006581.ref026">26</xref>]. For instance, the large numbers of large, correlated trees produced by MCMC samplers used in Bayesian phylogenetics (e.g., [<xref ref-type="bibr" rid="pcbi.1006581.ref038">38</xref>]) might be compactly stored as a tree sequence, which would then allow highly efficient computation of properties of the posterior distribution.</p>
<p>In this article, we applied our methods for storing trees to the problem of pedigree recording in a forward-time simulation. However, the method applies to any simulation scheme generating nodes and edges. For example, one could use the methods described here to generate succinct tree sequences under coalescent processes not currently implemented in <monospace>msprime</monospace>, such as the coalescent with gene conversion [<xref ref-type="bibr" rid="pcbi.1006581.ref039">39</xref>], using the structured coalescent to model various forms of natural selection [<xref ref-type="bibr" rid="pcbi.1006581.ref040">40</xref>–<xref ref-type="bibr" rid="pcbi.1006581.ref042">42</xref>], or the coalescent within a known pedigree. For such models, one could in principle generate tables of nodes and edges to be simplified in <monospace>tskit</monospace>. The resulting succinct tree sequence object would be in the same format as those generated by <monospace>msprime</monospace>’s simulate function, and therefore compatible with existing methods for downstream analyses.</p>
<p>Another application of our methods would be the case of simulating coalescent histories conditional on known pedigrees. The standard description of the Wright-Fisher coalescent averages over pedigrees. However, conditional on a realized pedigree, the distribution of coalescent times in the recent past differs from that of the unconditional coalescent [<xref ref-type="bibr" rid="pcbi.1006581.ref043">43</xref>]. For populations with known pedigrees (e.g., [<xref ref-type="bibr" rid="pcbi.1006581.ref044">44</xref>]), it may be of use to simulate transmission along such pedigrees for the purpose of inference.</p>
</sec>
<sec id="sec017">
<title>A final note</title>
<p>In preparing this manuscript, we debated a number of possible terms for the embellished pedigree, i.e., the “pedigree with ancestral recombination information”, the object through which each tree of a tree sequence is threaded. Etymological consensus [<xref ref-type="bibr" rid="pcbi.1006581.ref045">45</xref>] has “pedigree” derived from the french “pied de grue” for the foot of a crane (whose branching pattern resembles the bifurcation of a single parent-offspring relationship). An analogous term for the embellished pedigree might then be <italic>nedigree</italic>, from “nid de grue”, as the nest of a crane is a large jumble of (forking) branches. We thought it would be confusing to use this term throughout the manuscript, but perhaps it will prove useful elsewhere.</p>
</sec>
</sec>
<sec id="sec018" sec-type="materials|methods">
<title>Methods</title>
<p>We implemented simulations and the connection to <monospace>tskit</monospace> in <monospace>C++</monospace>, using <monospace>fwdpp</monospace> library functions and interface code using a continuum-sites model for both mutation and recombination. Simulations were run using <monospace>fwdpy11</monospace> (version 0.13.a0), a Python package based on <monospace>fwdpp</monospace> (version 0.5.7). The majority of results are presented based on a single-threaded implementation. However, we also implemented a parallelized version using Python’s <monospace>queue.Queue</monospace> to run the simplification step in a separate Python thread. Our implementation allows a maximum of four simplification intervals to be in the queue at once. This parallelized version also performed fitness calculation in parallel using two threads of execution in C++.</p>
<p>Code for all simulations and figures is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/petrelharp/ftprime_ms" xlink:type="simple">https://github.com/petrelharp/ftprime_ms</ext-link>. These made use of the GNU Scientific Library (version 1.16, [<xref ref-type="bibr" rid="pcbi.1006581.ref046">46</xref>]), pybind11 (version 2.2.1, [<xref ref-type="bibr" rid="pcbi.1006581.ref047">47</xref>]), and GCC (version 4.8.5). We ran all benchmarks on an Ubuntu Linux (version 16.04) system with two 2.6 GHz Intel E5-2650 CPU with hyperthreading enabled. We ran one simulation at a time and the machine was under minimal load otherwise. We used GNU parallel [<xref ref-type="bibr" rid="pcbi.1006581.ref048">48</xref>] to kill any simulation that did not finish within 72 hours, and the Linux <monospace>time</monospace> command to record run time and peak memory usage of each replicate.</p>
</sec>
<sec id="sec019">
<title>Supporting information</title>
<supplementary-material id="pcbi.1006581.s001" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006581.s001" xlink:type="simple">
<label>S1 Text</label>
<caption>
<title>Additional benchmarks and algorithm listings.</title>
<p>The supplementary text contains (A) benchmarking of run time and memory usage on simulations without selection; (B) benchmarking of memory usage with selection; (C) an analysis of the effect of simplification interval on run times; (D) details for the <monospace>simuPOP</monospace> implementation; and (E) more details, and a listing, of the simplification algorithm.</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ack>
<p>Thanks to Gil McVean, Jared Galloway, Brad Shaffer, and Evan McCartney–Melstad for useful discussions.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1006581.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hudson</surname> <given-names>RR</given-names></name>. <article-title>Gene genealogies and the coalescent process</article-title>. <source>Oxford surveys in evolutionary biology</source>. <year>1990</year>;<volume>7</volume>(<issue>1</issue>):<fpage>44</fpage>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Neuhauser</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Krone</surname> <given-names>SM</given-names></name>. <article-title>The genealogy of samples in models with selection</article-title>. <source>Genetics</source>. <year>1997</year>;<volume>145</volume>(<issue>2</issue>):<fpage>519</fpage>–<lpage>534</lpage>. <object-id pub-id-type="pmid">9071604</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Barton</surname> <given-names>NH</given-names></name>, <name name-style="western"><surname>Kelleher</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Etheridge</surname> <given-names>AM</given-names></name>. <article-title>A new model for extinction and recolonization in two dimensions: quantifying phylogeography</article-title>. <source>Evolution</source>. <year>2010</year>;<volume>64</volume>(<issue>9</issue>):<fpage>2701</fpage>–<lpage>2715</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1111/j.1558-5646.2010.01019.x" xlink:type="simple">10.1111/j.1558-5646.2010.01019.x</ext-link></comment> <object-id pub-id-type="pmid">20408876</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kelleher</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Etheridge</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Barton</surname> <given-names>N</given-names></name>. <article-title>Coalescent simulation in continuous space: Algorithms for large neighbourhood size</article-title>. <source>Theoretical population biology</source>. <year>2014</year>;<volume>95</volume>:<fpage>13</fpage>–<lpage>23</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.tpb.2014.05.001" xlink:type="simple">10.1016/j.tpb.2014.05.001</ext-link></comment> <object-id pub-id-type="pmid">24910324</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref005">
<label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Ray</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Currat</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Foll</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Excoffier</surname> <given-names>L</given-names></name>. <article-title>SPLATCHE2: a spatially explicit simulation framework for complex demography, genetic admixture and recombination</article-title>. <source>Bioinformatics</source>. <year>2010</year>;<volume>26</volume>(<issue>23</issue>):<fpage>2993</fpage>–<lpage>2994</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/bioinformatics/btq579" xlink:type="simple">10.1093/bioinformatics/btq579</ext-link></comment> <object-id pub-id-type="pmid">20956243</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref006">
<label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Martin</surname> <given-names>AR</given-names></name>, <name name-style="western"><surname>Gignoux</surname> <given-names>CR</given-names></name>, <name name-style="western"><surname>Walters</surname> <given-names>RK</given-names></name>, <name name-style="western"><surname>Wojcik</surname> <given-names>GL</given-names></name>, <name name-style="western"><surname>Neale</surname> <given-names>BM</given-names></name>, <name name-style="western"><surname>Gravel</surname> <given-names>S</given-names></name>, <etal>et al</etal>. <article-title>Human demographic history impacts genetic risk prediction across diverse populations</article-title>. <source>The American Journal of Human Genetics</source>. <year>2017</year>;<volume>100</volume>(<issue>4</issue>):<fpage>635</fpage>–<lpage>649</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.ajhg.2017.03.004" xlink:type="simple">10.1016/j.ajhg.2017.03.004</ext-link></comment> <object-id pub-id-type="pmid">28366442</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref007">
<label>7</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wakeley</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Takahashi</surname> <given-names>T</given-names></name>. <article-title>Gene genealogies when the sample size exceeds the effective size of the population</article-title>. <source>Mol Biol Evol</source>. <year>2003</year>;<volume>20</volume>(<issue>2</issue>):<fpage>208</fpage>–<lpage>213</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/molbev/msg024" xlink:type="simple">10.1093/molbev/msg024</ext-link></comment> <object-id pub-id-type="pmid">12598687</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref008">
<label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Maruvka</surname> <given-names>YE</given-names></name>, <name name-style="western"><surname>Shnerb</surname> <given-names>NM</given-names></name>, <name name-style="western"><surname>Bar-Yam</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Wakeley</surname> <given-names>J</given-names></name>. <article-title>Recovering population parameters from a single gene genealogy: an unbiased estimator of the growth rate</article-title>. <source>Mol Biol Evol</source>. <year>2011</year>;<volume>28</volume>(<issue>5</issue>):<fpage>1617</fpage>–<lpage>1631</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/molbev/msq331" xlink:type="simple">10.1093/molbev/msq331</ext-link></comment> <object-id pub-id-type="pmid">21172828</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref009">
<label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Bhaskar</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Clark</surname> <given-names>AG</given-names></name>, <name name-style="western"><surname>Song</surname> <given-names>YS</given-names></name>. <article-title>Distortion of genealogical properties when the sample is very large</article-title>. <source>Proc Natl Acad Sci USA</source>. <year>2014</year>;<volume>111</volume>(<issue>6</issue>):<fpage>2385</fpage>–<lpage>2390</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1073/pnas.1322709111" xlink:type="simple">10.1073/pnas.1322709111</ext-link></comment> <object-id pub-id-type="pmid">24469801</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Harris</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Nielsen</surname> <given-names>R</given-names></name>. <article-title>The Genetic Cost of Neanderthal Introgression</article-title>. <source>Genetics</source>. <year>2016</year>;<volume>203</volume>(<issue>2</issue>):<fpage>881</fpage>–<lpage>891</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.116.186890" xlink:type="simple">10.1534/genetics.116.186890</ext-link></comment> <object-id pub-id-type="pmid">27038113</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Messer</surname> <given-names>PW</given-names></name>. <article-title>SLiM: simulating evolution with selection and linkage</article-title>. <source>Genetics</source>. <year>2013</year>;<volume>194</volume>(<issue>4</issue>):<fpage>1037</fpage>–<lpage>1039</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.113.152181" xlink:type="simple">10.1534/genetics.113.152181</ext-link></comment> <object-id pub-id-type="pmid">23709637</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref012">
<label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Sanjak</surname> <given-names>JS</given-names></name>, <name name-style="western"><surname>Long</surname> <given-names>AD</given-names></name>, <name name-style="western"><surname>Thornton</surname> <given-names>KR</given-names></name>. <article-title>A Model of Compound Heterozygous, Loss-of-Function Alleles Is Broadly Consistent with Observations from Complex-Disease GWAS Datasets</article-title>. <source>PLoS Genet</source>. <year>2017</year>;<volume>13</volume>(<issue>1</issue>):<fpage>e1006573</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pgen.1006573" xlink:type="simple">10.1371/journal.pgen.1006573</ext-link></comment> <object-id pub-id-type="pmid">28103232</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref013">
<label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Thornton</surname> <given-names>KR</given-names></name>. <article-title>A C++ template library for efficient forward-time population genetic simulation of large populations</article-title>. <source>Genetics</source>. <year>2014</year>;<volume>198</volume>(<issue>1</issue>):<fpage>157</fpage>–<lpage>166</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.114.165019" xlink:type="simple">10.1534/genetics.114.165019</ext-link></comment> <object-id pub-id-type="pmid">24950894</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wright</surname> <given-names>S</given-names></name>. <article-title>Evolution in Mendelian populations</article-title>. <source>Genetics</source>. <year>1931</year>;<volume>16</volume>(<issue>2</issue>):<fpage>97</fpage>–<lpage>159</lpage>. <object-id pub-id-type="pmid">17246615</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref015">
<label>15</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Wakeley</surname> <given-names>J</given-names></name>. <source>Coalescent Theory, an Introduction</source>. <publisher-loc>Greenwood Village, CO</publisher-loc>: <publisher-name>Roberts and Company</publisher-name>; <year>2005</year>. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.coalescentheory.com/" xlink:type="simple">http://www.coalescentheory.com/</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref016">
<label>16</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Haller</surname> <given-names>BC</given-names></name>, <name name-style="western"><surname>Messer</surname> <given-names>PW</given-names></name>. <article-title>SLiM 2: Flexible, Interactive Forward Genetic Simulations</article-title>. <source>Molecular Biology and Evolution</source>. <year>2017</year>;<volume>34</volume>(<issue>1</issue>):<fpage>230</fpage>–<lpage>240</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/molbev/msw211" xlink:type="simple">10.1093/molbev/msw211</ext-link></comment> <object-id pub-id-type="pmid">27702775</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref017">
<label>17</label>
<mixed-citation publication-type="other" xlink:type="simple">Hernandez RD, Uricchio LH. SFS_CODE: More Efficient and Flexible Forward Simulations; 2015.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref018">
<label>18</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Aberer</surname> <given-names>AJ</given-names></name>, <name name-style="western"><surname>Stamatakis</surname> <given-names>A</given-names></name>. <article-title>Rapid forward-in-time simulation at the chromosome and genome level</article-title>. <source>BMC Bioinformatics</source>. <year>2013</year>;<volume>14</volume>(<issue>1</issue>):<fpage>216</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1186/1471-2105-14-216" xlink:type="simple">10.1186/1471-2105-14-216</ext-link></comment> <object-id pub-id-type="pmid">23834340</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref019">
<label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Padhukasahasram</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Marjoram</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Wall</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Bustamante</surname> <given-names>CD</given-names></name>, <name name-style="western"><surname>Nordborg</surname> <given-names>M</given-names></name>. <article-title>Exploring Population Genetic Models With Recombination Using Efficient Forward-Time Simulations</article-title>. <source>Genetics</source>. <year>2008</year>;<volume>178</volume>(<issue>4</issue>):<fpage>2417</fpage>–<lpage>2427</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.107.085332" xlink:type="simple">10.1534/genetics.107.085332</ext-link></comment> <object-id pub-id-type="pmid">18430959</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref020">
<label>20</label>
<mixed-citation publication-type="other" xlink:type="simple">Griffiths RC. The two-locus ancestral graph. In: Selected Proceedings of the Sheffield Symposium on Applied Probability. vol. 18; 1991. p. 100–117.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref021">
<label>21</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Griffiths</surname> <given-names>RC</given-names></name>, <name name-style="western"><surname>Marjoram</surname> <given-names>P</given-names></name>. <chapter-title>An ancestral recombination graph</chapter-title>. In: <source>Progress in population genetics and human evolution (Minneapolis, MN, 1994)</source>. <volume>vol. 87</volume> of IMA Vol. Math. Appl. <publisher-loc>New York</publisher-loc>: <publisher-name>Springer</publisher-name>; <year>1997</year>. p. <fpage>257</fpage>–<lpage>270</lpage>. Available from: <ext-link ext-link-type="uri" xlink:href="http://www.math.canterbury.ac.nz/~r.sainudiin/recomb/ima.pdf" xlink:type="simple">http://www.math.canterbury.ac.nz/~r.sainudiin/recomb/ima.pdf</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref022">
<label>22</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wiuf</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Hein</surname> <given-names>J</given-names></name>. <article-title>On the number of ancestors to a DNA sequence</article-title>. <source>Genetics</source>. <year>1997</year>;<volume>147</volume>(<issue>3</issue>):<fpage>1459</fpage>–<lpage>1468</lpage>. <object-id pub-id-type="pmid">9383085</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref023">
<label>23</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wiuf</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Hein</surname> <given-names>J</given-names></name>. <article-title>The ancestry of a sample of sequences subject to recombination</article-title>. <source>Genetics</source>. <year>1999</year>;<volume>151</volume>(<issue>3</issue>):<fpage>1217</fpage>–<lpage>1228</lpage>. <object-id pub-id-type="pmid">10049937</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref024">
<label>24</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Marjoram</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Wall</surname> <given-names>JD</given-names></name>. <article-title>Fast “coalescent” simulation</article-title>. <source>BMC Genet</source>. <year>2006</year>;<volume>7</volume>:<fpage>16</fpage>–<lpage>16</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1186/1471-2156-7-16" xlink:type="simple">10.1186/1471-2156-7-16</ext-link></comment> <object-id pub-id-type="pmid">16539698</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref025">
<label>25</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wilton</surname> <given-names>PR</given-names></name>, <name name-style="western"><surname>Carmi</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Hobolth</surname> <given-names>A</given-names></name>. <article-title>The SMC’ Is a Highly Accurate Approximation to the Ancestral Recombination Graph</article-title>. <source>Genetics</source>. <year>2015</year>;<volume>200</volume>(<issue>1</issue>):<fpage>343</fpage>–<lpage>355</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.114.173898" xlink:type="simple">10.1534/genetics.114.173898</ext-link></comment> <object-id pub-id-type="pmid">25786855</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref026">
<label>26</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kelleher</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Etheridge</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>McVean</surname> <given-names>G</given-names></name>. <article-title>Efficient coalescent simulation and genealogical analysis for large sample sizes</article-title>. <source>PLoS computational biology</source>. <year>2016</year>;<volume>12</volume>(<issue>5</issue>):<fpage>e1004842</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1004842" xlink:type="simple">10.1371/journal.pcbi.1004842</ext-link></comment> <object-id pub-id-type="pmid">27145223</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref027">
<label>27</label>
<mixed-citation publication-type="other" xlink:type="simple">Gog S, Beller T, Moffat A, Petri M. From theory to practice: Plug and play with succinct data structures. In: International Symposium on Experimental Algorithms. Springer; 2014. p. 326–337.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref028">
<label>28</label>
<mixed-citation publication-type="other" xlink:type="simple">Abadi D, Madden S, Ferreira M. Integrating compression and execution in column-oriented database systems. In: Proceedings of the 2006 ACM SIGMOD international conference on Management of data. ACM; 2006. p. 671–682.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref029">
<label>29</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Walt</surname> <given-names>Svd</given-names></name>, <name name-style="western"><surname>Colbert</surname> <given-names>SC</given-names></name>, <name name-style="western"><surname>Varoquaux</surname> <given-names>G</given-names></name>. <article-title>The NumPy array: a structure for efficient numerical computation</article-title>. <source>Computing in Science &amp; Engineering</source>. <year>2011</year>;<volume>13</volume>(<issue>2</issue>):<fpage>22</fpage>–<lpage>30</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1109/MCSE.2011.37" xlink:type="simple">10.1109/MCSE.2011.37</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref030">
<label>30</label>
<mixed-citation publication-type="other" xlink:type="simple">The HDF Group. Hierarchical Data Format, version 5; 1997-2018.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref031">
<label>31</label>
<mixed-citation publication-type="other" xlink:type="simple">Dask Development Team. Dask: Library for dynamic task scheduling; 2016. Available from: <ext-link ext-link-type="uri" xlink:href="http://dask.pydata.org" xlink:type="simple">http://dask.pydata.org</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref032">
<label>32</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Peng</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Kimmel</surname> <given-names>M</given-names></name>. <article-title>simuPOP: a forward-time population genetics simulation environment</article-title>. <source>Bioinformatics</source>. <year>2005</year>;<volume>21</volume>(<issue>18</issue>):<fpage>3686</fpage>–<lpage>3687</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/bioinformatics/bti584" xlink:type="simple">10.1093/bioinformatics/bti584</ext-link></comment> <object-id pub-id-type="pmid">16020469</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref033">
<label>33</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hudson</surname> <given-names>RR</given-names></name>. <article-title>Properties of a neutral allele model with intragenic recombination</article-title>. <source>Theor Popul Biol</source>. <year>1983</year>;<volume>23</volume>:<fpage>183</fpage>–<lpage>201</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/0040-5809(83)90013-8" xlink:type="simple">10.1016/0040-5809(83)90013-8</ext-link></comment> <object-id pub-id-type="pmid">6612631</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref034">
<label>34</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Watterson</surname> <given-names>GA</given-names></name>. <article-title>On the number of segregating sites in genetical models without recombination</article-title>. <source>Theor Popul Biol</source>. <year>1975</year>;<volume>7</volume>(<issue>2</issue>):<fpage>256</fpage>–<lpage>276</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/0040-5809(75)90020-9" xlink:type="simple">10.1016/0040-5809(75)90020-9</ext-link></comment> <object-id pub-id-type="pmid">1145509</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref035">
<label>35</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wilkins</surname> <given-names>JF</given-names></name>. <article-title>A Separation-of-Timescales Approach to the Coalescent in a Continuous Population</article-title>. <source>Genetics</source>. <year>2004</year>;<volume>168</volume>(<issue>4</issue>):<fpage>2227</fpage>–<lpage>2244</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.103.022830" xlink:type="simple">10.1534/genetics.103.022830</ext-link></comment> <object-id pub-id-type="pmid">15611188</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref036">
<label>36</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Barton</surname> <given-names>NH</given-names></name>, <name name-style="western"><surname>Depaulis</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Etheridge</surname> <given-names>AM</given-names></name>. <article-title>Neutral Evolution in Spatially Continuous Populations</article-title>. <source>Theoretical Population Biology</source>. <year>2002</year>;<volume>61</volume>(<issue>1</issue>):<fpage>31</fpage>–<lpage>48</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1006/tpbi.2001.1557" xlink:type="simple">10.1006/tpbi.2001.1557</ext-link></comment> <object-id pub-id-type="pmid">11895381</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref037">
<label>37</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Cox</surname> <given-names>JT</given-names></name>, <name name-style="western"><surname>Durrett</surname> <given-names>R</given-names></name>. <article-title>The stepping stone model: New formulas expose old myths</article-title>. <source>Ann Appl Probab</source>. <year>2002</year>;<volume>12</volume>(<issue>4</issue>):<fpage>1348</fpage>–<lpage>1377</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1214/aoap/1037125866" xlink:type="simple">10.1214/aoap/1037125866</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref038">
<label>38</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Drummond</surname> <given-names>AJ</given-names></name>, <name name-style="western"><surname>Suchard</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>Xie</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Rambaut</surname> <given-names>A</given-names></name>. <article-title>Bayesian phylogenetics with BEAUti and the BEAST 1.7</article-title>. <source>Mol Biol Evol</source>. <year>2012</year>;<volume>29</volume>(<issue>8</issue>):<fpage>1969</fpage>–<lpage>1973</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/molbev/mss075" xlink:type="simple">10.1093/molbev/mss075</ext-link></comment> <object-id pub-id-type="pmid">22367748</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref039">
<label>39</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wiuf</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Hein</surname> <given-names>J</given-names></name>. <article-title>The Coalescent With Gene Conversion</article-title>. <source>Genetics</source>. <year>2000</year>;<volume>155</volume>(<issue>1</issue>):<fpage>451</fpage>–<lpage>462</lpage>. <object-id pub-id-type="pmid">10790416</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref040">
<label>40</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kaplan</surname> <given-names>NL</given-names></name>, <name name-style="western"><surname>Darden</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Hudson</surname> <given-names>RR</given-names></name>. <article-title>The coalescent process in models with selection</article-title>. <source>Genetics</source>. <year>1988</year>;<volume>120</volume>(<issue>3</issue>):<fpage>819</fpage>–<lpage>829</lpage>. <object-id pub-id-type="pmid">3066685</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref041">
<label>41</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kaplan</surname> <given-names>NL</given-names></name>, <name name-style="western"><surname>Hudson</surname> <given-names>RR</given-names></name>, <name name-style="western"><surname>Langley</surname> <given-names>CH</given-names></name>. <article-title>The “hitchhiking effect” revisited</article-title>. <source>Genetics</source>. <year>1989</year>;<volume>123</volume>(<issue>4</issue>):<fpage>887</fpage>–<lpage>899</lpage>. <object-id pub-id-type="pmid">2612899</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref042">
<label>42</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Braverman</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Hudson</surname> <given-names>RR</given-names></name>, <name name-style="western"><surname>Kaplan</surname> <given-names>NL</given-names></name>, <name name-style="western"><surname>Langley</surname> <given-names>CH</given-names></name>, <name name-style="western"><surname>Stephan</surname> <given-names>W</given-names></name>. <article-title>The hitchhiking effect on the site frequency spectrum of DNA polymorphisms</article-title>. <source>Genetics</source>. <year>1995</year>;<volume>140</volume>(<issue>2</issue>):<fpage>783</fpage>–<lpage>796</lpage>. <object-id pub-id-type="pmid">7498754</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref043">
<label>43</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wakeley</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>King</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Low</surname> <given-names>BS</given-names></name>, <name name-style="western"><surname>Ramachandran</surname> <given-names>S</given-names></name>. <article-title>Gene genealogies within a fixed pedigree, and the robustness of Kingman’s coalescent</article-title>. <source>Genetics</source>. <year>2012</year>;<volume>190</volume>(<issue>4</issue>):<fpage>1433</fpage>–<lpage>1445</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1534/genetics.111.135574" xlink:type="simple">10.1534/genetics.111.135574</ext-link></comment> <object-id pub-id-type="pmid">22234858</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref044">
<label>44</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Aguillon</surname> <given-names>SM</given-names></name>, <name name-style="western"><surname>Fitzpatrick</surname> <given-names>JW</given-names></name>, <name name-style="western"><surname>Bowman</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Schoech</surname> <given-names>SJ</given-names></name>, <name name-style="western"><surname>Clark</surname> <given-names>AG</given-names></name>, <name name-style="western"><surname>Coop</surname> <given-names>G</given-names></name>, <etal>et al</etal>. <article-title>Deconstructing isolation-by-distance: The genomic consequences of limited dispersal</article-title>. <source>PLoS Genet</source>. <year>2017</year>;<volume>13</volume>(<issue>8</issue>):<fpage>e1006911</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pgen.1006911" xlink:type="simple">10.1371/journal.pgen.1006911</ext-link></comment> <object-id pub-id-type="pmid">28771477</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006581.ref045">
<label>45</label>
<mixed-citation publication-type="other" xlink:type="simple">Liberman A. Little triumphs of etymology: “pedigree”; 2014. <ext-link ext-link-type="uri" xlink:href="https://blog.oup.com/2014/05/pedigree-etymology-word-origin/" xlink:type="simple">https://blog.oup.com/2014/05/pedigree-etymology-word-origin/</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref046">
<label>46</label>
<mixed-citation publication-type="other" xlink:type="simple">Galassi et al M. GNU Scientific Library Reference Manual; 2018. Available from: <ext-link ext-link-type="uri" xlink:href="https://www.gnu.org/software/gsl/" xlink:type="simple">https://www.gnu.org/software/gsl/</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref047">
<label>47</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Jakob</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Rhinelander</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Moldovan</surname> <given-names>D</given-names></name>. <source>pybind11—Seamless operability between C++11 and Python</source>; <year>2016</year>.</mixed-citation>
</ref>
<ref id="pcbi.1006581.ref048">
<label>48</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Tange</surname> <given-names>O</given-names></name>. <article-title>GNU Parallel—The Command-Line Power Tool</article-title>. <source>;login: The USENIX Magazine</source>. <year>2011</year>;<volume>36</volume>(<issue>1</issue>):<fpage>42</fpage>–<lpage>47</lpage>.</mixed-citation>
</ref>
</ref-list>
</back>
</article>