<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id><journal-title-group>
<journal-title>PLoS Computational Biology</journal-title></journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, USA</publisher-loc></publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-13-01886</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1003502</article-id>
<article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline-v2"><subject>Biology and life sciences</subject><subj-group><subject>Evolutionary biology</subject><subj-group><subject>Population genetics</subject><subj-group><subject>Haplotypes</subject></subj-group></subj-group></subj-group><subj-group><subject>Computational biology</subject></subj-group></subj-group></article-categories>
<title-group>
<article-title>HapTree: A Novel Bayesian Framework for Single Individual Polyplotyping Using NGS Data</article-title>
<alt-title alt-title-type="running-head">Individual Genome Phasing Using NGS Data</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Berger</surname><given-names>Emily</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="aff" rid="aff3"><sup>3</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Yorukoglu</surname><given-names>Deniz</given-names></name><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Peng</surname><given-names>Jian</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib>
<contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Berger</surname><given-names>Bonnie</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib>
</contrib-group>
<aff id="aff1"><label>1</label><addr-line>Department of Mathematics, MIT, Cambridge, Massachusetts, United States of America</addr-line></aff>
<aff id="aff2"><label>2</label><addr-line>Computer Science and Artificial Intelligence Laboratory, MIT, Cambridge, Massachusetts, United States of America</addr-line></aff>
<aff id="aff3"><label>3</label><addr-line>Department of Mathematics, UC Berkeley, Berkeley, California, United States of America</addr-line></aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple"><name name-style="western"><surname>Rigoutsos</surname><given-names>Isidore</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/></contrib>
</contrib-group>
<aff id="edit1"><addr-line>Thomas Jefferson University, United States of America</addr-line></aff>
<author-notes>
<corresp id="cor1">* E-mail: <email xlink:type="simple">denizy@mit.edu</email> (DY); <email xlink:type="simple">bab@csail.mit.edu</email> (BB)</corresp>
<fn fn-type="conflict"><p>The authors have declared that no competing interests exist.</p></fn>
<fn fn-type="con"><p>Conceived and designed the experiments: EB DY BB. Performed the experiments: EB. Analyzed the data: EB DY JP BB. Wrote the paper: EB DY JP BB. Designed and guided the study: DY BB. Designed the method: EB.</p></fn>
</author-notes>
<pub-date pub-type="collection"><month>3</month><year>2014</year></pub-date>
<pub-date pub-type="epub"><day>27</day><month>3</month><year>2014</year></pub-date>
<volume>10</volume>
<issue>3</issue>
<elocation-id>e1003502</elocation-id>
<history>
<date date-type="received"><day>29</day><month>10</month><year>2013</year></date>
<date date-type="accepted"><day>14</day><month>1</month><year>2014</year></date>
</history>
<permissions>
<copyright-year>2014</copyright-year>
<copyright-holder>Berger et al</copyright-holder><license xlink:type="simple"><license-p>This is an open-access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><related-article id="RA1" related-article-type="companion" ext-link-type="uri" page="e1002972" xlink:type="simple" xlink:href="info:doi/10.1371/journal.pcbi.1002972"> <article-title>New Methods Section in PLOS Computational Biology</article-title></related-article><related-article id="RA2" related-article-type="companion" ext-link-type="uri" page="e1003503" xlink:type="simple" xlink:href="info:doi/10.1371/journal.pcbi.1003503"> <article-title>Modeling Mutual Exclusivity of Cancer Mutations</article-title></related-article><related-article id="RA3" related-article-type="companion" ext-link-type="uri" page="e1003501" xlink:type="simple" xlink:href="info:doi/10.1371/journal.pcbi.1003501"> <article-title>An Integrated Model of Multiple-Condition ChIP-seq Data Reveals Predeterminants of Cdx2 Binding</article-title></related-article><related-article id="RA4" related-article-type="companion" ext-link-type="uri" page="e1003500" xlink:type="simple" xlink:href="info:doi/10.1371/journal.pcbi.1003500"> <article-title>MRFalign: Protein Homology Detection through Alignment of Markov Random Fields</article-title></related-article><related-article id="RA5" related-article-type="companion" ext-link-type="uri" page="e1003515" xlink:type="simple" xlink:href="info:doi/10.1371/journal.pcbi.1003515"> <article-title>Viral Quasispecies Assembly Via Maximal Clique Enumeration</article-title></related-article>
<abstract>
<p>As the more recent next-generation sequencing (NGS) technologies provide longer read sequences, the use of sequencing datasets for complete haplotype phasing is fast becoming a reality, allowing haplotype reconstruction of a single sequenced genome. Nearly all previous haplotype reconstruction studies have focused on diploid genomes and are rarely scalable to genomes with higher ploidy. Yet computational investigations into polyploid genomes carry great importance, impacting plant, yeast and fish genomics, as well as the studies of the evolution of modern-day eukaryotes and (epi)genetic interactions between copies of genes. In this paper, we describe a novel maximum-likelihood estimation framework, HapTree, for polyploid haplotype assembly of an individual genome using NGS read datasets. We evaluate the performance of HapTree on simulated polyploid sequencing read data modeled after Illumina sequencing technologies. For triploid and higher ploidy genomes, we demonstrate that HapTree substantially improves haplotype assembly accuracy and efficiency over the state-of-the-art; moreover, HapTree is the first scalable polyplotyping method for higher ploidy. As a proof of concept, we also test our method on real sequencing data from NA12878 (1000 Genomes Project) and evaluate the quality of assembled haplotypes with respect to trio-based diplotype annotation as the ground truth. The results indicate that HapTree significantly improves the switch accuracy within phased haplotype blocks as compared to existing haplotype assembly methods, while producing comparable minimum error correction (MEC) values. A summary of this paper appears in the proceedings of the RECOMB 2014 conference, April 2–5.</p>
</abstract>
<abstract abstract-type="summary"><title>Author Summary</title>
<p>While human and other eukaryotic genomes typically contain two copies of every chromosome, plants, yeast and fish such as salmon can have strictly more than two copies of each chromosome. By running standard genotype calling tools, it is possible to accurately identify the number of “wild type” and “mutant” alleles (A, C, G, or T) for each single-nucleotide polymorphism (SNP) site. However, in the case of two heterozygous SNP sites, genotype calling tools cannot determine whether “mutant” alleles from different SNP loci are on the same or different chromosomes. While the former would be healthy, in many cases the latter can cause loss of function; it is therefore necessary to identify the phase—the copies of a chromosome on which the mutant alleles occur—in addition to the genotype. This necessitates efficient algorithms to obtain accurate and comprehensive phase information directly from the next-generation-sequencing read data in higher ploidy species. We introduce an efficient statistical method for this task and show that our method significantly outperforms previous ones, in both accuracy and speed, for phasing triploid and higher ploidy genomes. Our method performs well on human diploid genomes as well, as demonstrated by our improved phasing of the well known NA12878 (1000 Genomes Project).</p>
</abstract>
<funding-group><funding-statement>This work is supported by NSF/NIH BIGDATA Grant R01GM108348-01, the Simons Foundation, and an NSF graduate research fellowship. The funder had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts><page-count count="10"/></counts></article-meta>
</front>
<body><sec id="s1">
<title/>
<disp-quote>
<p>This Methods article is associated with RECOMB 2014.</p>
</disp-quote></sec><sec id="s2">
<title>Introduction</title>
<p>While human and other eukaryotic genomes typically contain two copies of every chromosome, plants, yeast and fish such as salmon can have strictly more than two copies of each chromosome. By running standard genotype calling tools, it is possible to accurately identify the number of “wild type” and “mutant” alleles (A, C, G, or T) for each single-nucleotide polymorphism (SNP) site. However, in the case of two heterozygous SNP sites, genotype calling tools cannot determine whether “mutant” alleles from different SNP loci are on the same or different chromosomes (i.e. compound heterozygote). While the former would be healthy, in many cases the latter can cause loss of function; it is therefore necessary to identify the phase (<italic>phasing</italic>) —the copies of a chromosome on which the mutant alleles occur—in addition to the genotype (<xref ref-type="fig" rid="pcbi-1003502-g001">Figure 1</xref>). This necessitates efficient algorithms to obtain accurate and comprehensive phase information directly from the next-generation-sequencing read data in higher ploidy species.</p>
<fig id="pcbi-1003502-g001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.g001</object-id><label>Figure 1</label><caption>
<title>Loss of function in different polyplotypes of a sample pentaploid genome.</title>
<p>As the loss of function is often determined by whether a healthy copy of a gene exists, knowing the genotype vector is sufficient if there is a single SNP site. In the case of two SNP sites however, the genotype vector cannot be used to unambiguously determine loss of function, and phasing is required.</p>
</caption><graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.g001" position="float" xlink:type="simple"/></fig>
<p>Various sources of information can be utilized for the computational identification of an individual's diplotype/polyplotype: pedigree (e.g. trio-based phasing) <xref ref-type="bibr" rid="pcbi.1003502-Williams1">[1]</xref>–<xref ref-type="bibr" rid="pcbi.1003502-Browning1">[3]</xref>, population structure of variants (e.g. phasing by linkage disequilibrium) <xref ref-type="bibr" rid="pcbi.1003502-Browning1">[3]</xref>–<xref ref-type="bibr" rid="pcbi.1003502-Delaneau1">[6]</xref> and more recently by identity-by-descent in unrelated individuals <xref ref-type="bibr" rid="pcbi.1003502-Browning2">[7]</xref>, <xref ref-type="bibr" rid="pcbi.1003502-Aguiar1">[8]</xref>, as well as sequencing read datasets <xref ref-type="bibr" rid="pcbi.1003502-Bansal1">[9]</xref>–<xref ref-type="bibr" rid="pcbi.1003502-Efros1">[13]</xref>. Among these approaches, methods for sequence-based haplotype phasing are the only viable approach for haplotype phasing on a single individual member of a species (assuming homologous chromosomes are sequenced together), as other approaches either require family members or a population. For an individual diploid genome, the problem of reconstructing the diplotype using sequence information, the diploid phasing problem, is equivalent to the identification of the sequence of alleles on either parental haplotype. If this sequence is correctly inferred, then the other haplotype will automatically carry the corresponding opposite alleles (reference or alternative). Solving an error-free version of the diploid haplotype reconstruction problem is straightforward: the haplotype of each connected (by reads) component of heterozygous SNPs can be obtained by propagating allele information within reads. In reality, however, sequencing errors as well as false read mappings cause conflicts within sequence information, requiring a mathematical formulation of the haplotype reconstruction problem. Among various formulations suggested for this problem, the most commonly used is an NP-hard minimum error correction (MEC) definition <xref ref-type="bibr" rid="pcbi.1003502-Lancia1">[14]</xref>, <xref ref-type="bibr" rid="pcbi.1003502-Lippert1">[15]</xref>, which aims to identify the smallest set of nucleotide changes required within mapped fragments that would allow a conflict-free separation of reads into two separate homologous chromosomes (or a bipartite separation of the fragment conflict graph). Some of the solutions proposed for this problem include: HapCUT<xref ref-type="bibr" rid="pcbi.1003502-Bansal1">[9]</xref>, an algorithm for optimizing MEC score based on computing max-cuts of the fragment graph; Fast Hare <xref ref-type="bibr" rid="pcbi.1003502-Panconesi1">[16]</xref>, a heuristic that clusters reads into two sets in a greedy fashion, and HapCompass <xref ref-type="bibr" rid="pcbi.1003502-Aguiar2">[10]</xref>, a spanning tree based approach for minimizing fragment conflicts.</p>
<p>Unlike diploid genomes, computational identification of common chromosomal variants in polyploid genomes using sequencing data has received little attention, except in the pioneering work of Aguiar &amp; Istrail <xref ref-type="bibr" rid="pcbi.1003502-Aguiar1">[8]</xref>. Polyploidy studies are of importance as they allow a comprehensive investigation of variants within plant, fish, and yeast genomes and help understand mechanisms of eukaryotic evolution. However, haplotype reconstruction in polyploid genomes is fundamentally more complex, even in the error-free version of the problem (without sequencing errors or false read mappings). Due to the newness of the NGS-based biological research in polyploid genomes, the mathematical foundations of the polyploid phasing problem have not yet been established. The solution proposed by Aguiar &amp; Istrail for single individual polyplotyping problem is based on phasing all possible SNP loci pairs independently while further consolidating this information in a separate stage in order to infer a set of haplotypes.</p>
<p>Diploid phasing methods focus on a given list of heterozygous variants that are guaranteed to contain a single reference allele, as well as an alternative allele (assuming all heterozygous loci are bi-allelic). In contrast, in the polyploid phasing problem, there is no such guarantee of a single type of heterozygous SNP. Each heterozygous locus for a <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e001" xlink:type="simple"/></inline-formula>-ploid chromosome can potentially contain from <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e002" xlink:type="simple"/></inline-formula> up to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e003" xlink:type="simple"/></inline-formula> alternative alleles within the heterozygous loci, significantly increasing the complexity of the phasing problem in comparison to the diploid case. Furthermore, in a diploid phasing setting, there are always two possible options for phasing a pair of SNP loci, regardless of what other SNPs they are phased with. These two options can be thought as parallel (alternative allele pairs and reference allele pairs are matched within themselves) or switched (each alternative allele is matched with the other reference allele). These two options are no longer relevant when the genome contains more than two copies of each chromosome, due to the fact that there are up to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e004" xlink:type="simple"/></inline-formula> options when merging a phased haplotype block with another.</p>
<p>In this paper, we introduce a maximum-likelihood formulation of the polyploid full haplotype reconstruction problem and present a haplotype assembly algorithm, HapTree, which concurrently performs SNP-pair phasing and full haplotype assembly based on a probabilistic framework. We observe that, on simulated polyploid data, HapTree substantially improves the phasing capabilities and performance of any existing program. Because real polyploid data is hard to come by, we also evaluate HapTree on real human diploid data and find that, when compared to the more accurate trio-based data as the ground truth <xref ref-type="bibr" rid="pcbi.1003502-Abecasis1">[17]</xref>, HapTree significantly reduces the number of switch errors, while remaining on par in terms of MEC score over existing single-individual haplotype assembly methods for diploid genomes. We also introduce a relative likelihood (RL) score definition for annotation-free evaluation of phasing quality for polyploid haplotype assembly as an alternative to MEC score. Using simulated polyploid sequencing datasets, we demonstrate that RL-score performs significantly better at capturing haplotype assembly quality than MEC-score as ploidy increases.</p>
</sec><sec id="s3" sec-type="methods">
<title>Method</title>
<sec id="s3a">
<title>Overview of HapTree</title>
<p>The HapTree pipeline is designed to perform phasing and full haplotype assembly of a single genome. The key component of HapTree is a relative likelihood function which measures the concordance between the aligned read data and a given haplotype phase under a probabilistic model that also accounts for possible sequencing errors. To identify a phasing solution of maximal likelihood, HapTree finds a collection of high-likelihood solutions for phases of the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e005" xlink:type="simple"/></inline-formula> SNP loci and extends those to high likelihood phases of the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e006" xlink:type="simple"/></inline-formula> SNP loci, for each incremental <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e007" xlink:type="simple"/></inline-formula>. In each step, HapTree maintains only the set of likely partial phases to be extended in next steps. Finally, a phase of maximal likelihood for all loci is obtained after the extension of the last SNP locus.</p>
<p>Broadly speaking, HapTree aims to discover the best, or <italic>maximum likelihood</italic>, haplotype based on the read data available. Theoretically, one could enumerate all possible haplotypes, compute the likelihood of each being the true haplotype (using formulas described below), and choose the most likely one; in most cases this approach is intractable as there are exponentially many possible haplotypes. HapTree therefore has a variety of ways of trimming down the solution set from all possible haplotypes to a much smaller set of more likely solutions, making the problem tractable. It does so by taking an inductive approach, generating a collection of <italic>likely</italic> phasing solutions for the first two SNPs in the genome, and then extending those to phasing solutions of the first three SNPs, and those to the first four SNPs, and so on. When extending any particular solution, HapTree chooses (based on computing likelihoods) how the alleles of the newly added SNP may be assigned to chromosomes; it includes only those assignments that are sufficiently likely. Additionally, if HapTree finds after extending all solutions to include the next SNP that there are too many <italic>likely</italic> solutions, it throws the worst (<italic>least likely</italic>) solutions away. Upon including all SNPs to be phased, HapTree randomly chooses a solution of maximum likelihood from amongst the solutions it has found.</p>
</sec><sec id="s3b">
<title>Availability</title>
<p>An implementation of our method, HapTree, is available for download at: <ext-link ext-link-type="uri" xlink:href="http://groups.csail.mit.edu/cb/haptree/" xlink:type="simple">http://groups.csail.mit.edu/cb/haptree/</ext-link></p>
</sec><sec id="s3c">
<title>Definitions and Notation</title>
<p>We describe below the problem of sequence-based polyploid haplotype assembly and provide basic technical notation that will be useful for describing our method. We assume for now that each SNP locus to be phased is bi-allelic (i.e. contains only two possible alleles, one being the reference allele). We further assume that for each SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e008" xlink:type="simple"/></inline-formula>, the genotype of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e009" xlink:type="simple"/></inline-formula> is known and is defined to be the number of chromosomes carrying the alternative allele (denoted by <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e010" xlink:type="simple"/></inline-formula>). If <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e011" xlink:type="simple"/></inline-formula> denotes the ploidy, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e012" xlink:type="simple"/></inline-formula> can range from <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e013" xlink:type="simple"/></inline-formula> to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e014" xlink:type="simple"/></inline-formula> for heterozygous loci <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e015" xlink:type="simple"/></inline-formula>. At this point, we would like to note that these two assumptions are made for the sake of simplicity of method description and implementation, though the genotype information does tend to be available. After describing our method we also describe the changes needed to our original approach to accommodate multi-allelic and genotype-oblivious polyploid haplotype assembly. At this time our implementation accommodates the aforementioned simpler case of bi-allelic SNPs and known genotypes; it is simple to extend this implementation to the more general case, and we describe such an extension in <bold>Discussion</bold>.</p>
<p>We denote the sequence of observed nucleotides of a fragment simply as a “read” (independent from single/paired-end reads and sub-reads of a strobe read structure). The set of all reads is denoted as <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e016" xlink:type="simple"/></inline-formula>. We define a read <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e017" xlink:type="simple"/></inline-formula> as a vector with entries <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e018" xlink:type="simple"/></inline-formula> where a <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e019" xlink:type="simple"/></inline-formula> denotes the reference allele, a <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e020" xlink:type="simple"/></inline-formula> the alternative allele, and a <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e021" xlink:type="simple"/></inline-formula> indicates one of two possibilities: First, that the read does not overlap with the corresponding SNP locus, or second, that neither the reference nor alternative allele is present and hence there must be a read error. A read <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e022" xlink:type="simple"/></inline-formula> <italic>contains</italic> a SNP <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e023" xlink:type="simple"/></inline-formula> if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e024" xlink:type="simple"/></inline-formula>. A read can also be represented as a dictionary or mapping with keys the positions (from amongst the SNPs to be phased) of SNP loci it contains and values of either reference allele or alternative allele, represented by 0 and 1 respectively (e.g. <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e025" xlink:type="simple"/></inline-formula>). As current sequencing technologies generate read data with a certain rate of sequencing errors, some of the positions within a read likely contain false nucleotide information. Among these erroneous bases, unless they are located at SNP loci and contain opposite allele information, we ignore them by representing them with <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e026" xlink:type="simple"/></inline-formula>, and thus keep only confounding sequencing errors that can affect phased haplotype results. For each read <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e027" xlink:type="simple"/></inline-formula> and for each SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e028" xlink:type="simple"/></inline-formula>, we assume an error rate of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e029" xlink:type="simple"/></inline-formula> and a probability of opposite false allele information <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e030" xlink:type="simple"/></inline-formula> is equal to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e031" xlink:type="simple"/></inline-formula>. We modify this error rate by a factor of two-thirds because conditional on there being an error, we model the error as equally likely to be any of the three other alleles. Two of the three of these alleles are neither the reference nor the alternative allele and thus we know that an error has been made in this case. Therefore, two-thirds of the time the erroneous alleles produced are known as such and may be thrown out, leaving a true error only one-third of the time. We represent these error rates as matrices <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e032" xlink:type="simple"/></inline-formula>. At this time our method assumes uniform error rates with respect to the SNP position; the error rate is supplied by the user and ought to depend on the read sequencing technologies used.</p>
<p>Upon the set of SNP loci <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e033" xlink:type="simple"/></inline-formula> and read set <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e034" xlink:type="simple"/></inline-formula>; we define a <italic>Read Graph</italic>, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e035" xlink:type="simple"/></inline-formula>, such that there is a vertex for each SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e036" xlink:type="simple"/></inline-formula> and an edge between any two vertices <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e037" xlink:type="simple"/></inline-formula> if there is some read containing both <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e038" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e039" xlink:type="simple"/></inline-formula>; equivalently if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e040" xlink:type="simple"/></inline-formula>. Without loss of generality, we assume that <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e041" xlink:type="simple"/></inline-formula> is connected; otherwise each connected component can be processed independently.</p>
<sec id="s3c1">
<title>Vector set</title>
<p>A <italic>k-ploidy phase</italic> of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e042" xlink:type="simple"/></inline-formula> SNPs with genotypes <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e043" xlink:type="simple"/></inline-formula> is a tuple of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e044" xlink:type="simple"/></inline-formula> vectors (not necessarily distinct) <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e045" xlink:type="simple"/></inline-formula> satisfying the genotype allele counts property, that is: <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e046" xlink:type="simple"/></inline-formula> for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e047" xlink:type="simple"/></inline-formula>. We will refer to this collection as a <italic>vector set</italic> and we think of each vector as a row vector.</p>
<p>We can build a phase by selecting a permutation of the alleles present for each SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e048" xlink:type="simple"/></inline-formula>. Note that the number of distinct permutations, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e049" xlink:type="simple"/></inline-formula>, is strictly dependent on the genotype of the SNP and in the diploid bi-allelic case is equivalent to selecting the chromosomes containing the alternative alleles, hence<disp-formula id="pcbi.1003502.e050"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e050" xlink:type="simple"/></disp-formula></p>
<p>For example, let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e051" xlink:type="simple"/></inline-formula>, then <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e052" xlink:type="simple"/></inline-formula>. We enumerate the possible permutations below and include an example tetraploid genome.<disp-formula id="pcbi.1003502.e053"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e053" xlink:type="simple"/></disp-formula></p>
<p><disp-formula id="pcbi.1003502.e054"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e054" xlink:type="simple"/></disp-formula></p>
<p>The sample tetraploid genome featured above on the right has a genotype vector: <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e055" xlink:type="simple"/></inline-formula>; recall this counts the number of alternative alleles present at each SNP site. For any SNP <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e056" xlink:type="simple"/></inline-formula>, let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e057" xlink:type="simple"/></inline-formula> denote the set of distinct allele permutations at SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e058" xlink:type="simple"/></inline-formula>. Throughout we are indifferent to the order of each chromosome, with this in mind we can see that the total number of phases is bounded below by <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e059" xlink:type="simple"/></inline-formula>.</p>
</sec><sec id="s3c2">
<title>Likelihood of a phase</title>
<p>We formulate the haplotype reconstruction problem as identifying the most likely phase(s) given the read data <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e060" xlink:type="simple"/></inline-formula>, all SNP loci <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e061" xlink:type="simple"/></inline-formula>, as well as their genotypes, and sequencing error rates <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e062" xlink:type="simple"/></inline-formula>. We assume the sequencing errors are independent of each other, that is for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e063" xlink:type="simple"/></inline-formula> and all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e064" xlink:type="simple"/></inline-formula>, that <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e065" xlink:type="simple"/></inline-formula> are independently correct with probabilities (<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e066" xlink:type="simple"/></inline-formula>) and incorrect with probabilities <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e067" xlink:type="simple"/></inline-formula>. Let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e068" xlink:type="simple"/></inline-formula> be a matrix containing all of these probabilities: <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e069" xlink:type="simple"/></inline-formula>. Given a vector set, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e070" xlink:type="simple"/></inline-formula>, corresponding to a phase, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e071" xlink:type="simple"/></inline-formula>, and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e072" xlink:type="simple"/></inline-formula>; the likelihood of the phase is determined by:<disp-formula id="pcbi.1003502.e073"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e073" xlink:type="simple"/><label>(1)</label></disp-formula></p>
<p>As <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e074" xlink:type="simple"/></inline-formula> depends only on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e075" xlink:type="simple"/></inline-formula> and the read set <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e076" xlink:type="simple"/></inline-formula>, it is therefore the same across all vector sets. Hence, we define a <italic>relative likelihood</italic> measure (RL) as<disp-formula id="pcbi.1003502.e077"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e077" xlink:type="simple"/></disp-formula></p>
<p>As for <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e078" xlink:type="simple"/></inline-formula>, there are several ways this can be modeled depending on the situation. For polyploid simulated data, we can assume that <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e079" xlink:type="simple"/></inline-formula> is equal for almost all vector sets, excluding ones containing duplicate vectors. Let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e080" xlink:type="simple"/></inline-formula> be the set of the multiplicities in <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e081" xlink:type="simple"/></inline-formula>; for example, if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e082" xlink:type="simple"/></inline-formula> then <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e083" xlink:type="simple"/></inline-formula>. The probabilities <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e084" xlink:type="simple"/></inline-formula> will differ multiplicatively by multinomial coefficients <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e085" xlink:type="simple"/></inline-formula>. Specifically:<disp-formula id="pcbi.1003502.e086"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e086" xlink:type="simple"/></disp-formula></p>
<p>For real diploid data, there will never be duplicate vectors. To model <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e087" xlink:type="simple"/></inline-formula>, we might assume that since mutations tend to occur together, adjacent SNP sites are more likely to be phased in parallel <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e088" xlink:type="simple"/></inline-formula> or <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e089" xlink:type="simple"/></inline-formula> than switched <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e090" xlink:type="simple"/></inline-formula> or <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e091" xlink:type="simple"/></inline-formula>. Let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e092" xlink:type="simple"/></inline-formula> and let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e093" xlink:type="simple"/></inline-formula> denote the number of adjacent SNPs that are parallel in <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e094" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e095" xlink:type="simple"/></inline-formula> the number of adjacent SNPs that are switched in <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e096" xlink:type="simple"/></inline-formula> (we must only consider <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e097" xlink:type="simple"/></inline-formula> as it determines <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e098" xlink:type="simple"/></inline-formula>). For example, if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e099" xlink:type="simple"/></inline-formula>, then <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e100" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e101" xlink:type="simple"/></inline-formula>. For some <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e102" xlink:type="simple"/></inline-formula> (denoted as <italic>parallel bias</italic>) and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e103" xlink:type="simple"/></inline-formula>, we model this vector set probability as<disp-formula id="pcbi.1003502.e104"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e104" xlink:type="simple"/></disp-formula></p>
<p>Finally, we consider <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e105" xlink:type="simple"/></inline-formula>. For a given <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e106" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e107" xlink:type="simple"/></inline-formula>, let <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e108" xlink:type="simple"/></inline-formula> denote the positions of SNP loci where <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e109" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e110" xlink:type="simple"/></inline-formula> agree and disagree respectively. For example, if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e111" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e112" xlink:type="simple"/></inline-formula>, then <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e113" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e114" xlink:type="simple"/></inline-formula> We may now compute the desired probability, that is:<disp-formula id="pcbi.1003502.e115"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e115" xlink:type="simple"/></disp-formula></p>
<p>The goal of our haplotype reconstruction problem is to find the vector set(s) maximizing the product <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e116" xlink:type="simple"/></inline-formula>, equivalently <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e117" xlink:type="simple"/></inline-formula>. However, as the number of possible phases is on the order <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e118" xlink:type="simple"/></inline-formula>, checking all of these is intractable. Our solution is based on finding high likelihood phases for the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e119" xlink:type="simple"/></inline-formula> SNPs, conditioned on a collection of high likelihood phases for the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e120" xlink:type="simple"/></inline-formula> SNPs.</p>
</sec><sec id="s3c3">
<title>Semi-reads and sub-reads</title>
<p>To properly describe our method we must first define the <italic>semi-reads</italic> of a SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e121" xlink:type="simple"/></inline-formula> and the <italic>sub-reads</italic> of a subset <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e122" xlink:type="simple"/></inline-formula>. </p>
<p><underline>Semi-reads</underline>. To form the set of <italic>semi-reads</italic> of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e123" xlink:type="simple"/></inline-formula>, denoted <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e124" xlink:type="simple"/></inline-formula>, include each read <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e125" xlink:type="simple"/></inline-formula> that contains both <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e126" xlink:type="simple"/></inline-formula> and some <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e127" xlink:type="simple"/></inline-formula> (<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e128" xlink:type="simple"/></inline-formula> is upstream of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e129" xlink:type="simple"/></inline-formula>) and ignore all information from <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e130" xlink:type="simple"/></inline-formula> on SNPs <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e131" xlink:type="simple"/></inline-formula> (<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e132" xlink:type="simple"/></inline-formula> is downstream of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e133" xlink:type="simple"/></inline-formula>). Suppose the set of reads is:</p>
<p>{1∶1, 2∶1, 3∶1, 4∶1} {3∶1, 4∶1, 5∶0, 6∶0} {4∶0, 5∶1, 6∶1} {4∶0, 5∶1, 6∶1, 7∶0} {5∶0, 6∶0, 7∶1} {5∶1, 6∶1, 7∶0}</p>
<p>The corresponding semi-reads for each SNP locus would be:</p>
<p><inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e134" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e135" xlink:type="simple"/></inline-formula> None <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e136" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e137" xlink:type="simple"/></inline-formula> {1∶1, 2∶1} <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e138" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e139" xlink:type="simple"/></inline-formula> {1∶1, 2∶1, 3∶1} <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e140" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e141" xlink:type="simple"/></inline-formula> {1∶1, 2∶1, 3∶1, 4∶1} {3∶1, 4∶1}</p>
<p><inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e142" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e143" xlink:type="simple"/></inline-formula> {3∶1, 4∶1, 5∶0} {4∶0, 5∶1} {4∶0, 5∶1}</p>
<p><inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e144" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e145" xlink:type="simple"/></inline-formula> {3∶1, 4∶1, 5∶0, 6∶0} {4∶0, 5∶1, 6∶1} {4∶0, 5∶1, 6∶1} {5∶0, 6∶0} {5∶1, 6∶1}</p>
<p><inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e146" xlink:type="simple"/></inline-formula> <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e147" xlink:type="simple"/></inline-formula> {4∶0, 5∶1, 6∶1, 7∶0} {5∶0, 6∶0, 7∶1} {5∶1, 6∶1, 7∶0}</p>
<p><underline>Sub-reads</underline>. The <italic>sub-reads</italic> of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e148" xlink:type="simple"/></inline-formula>, denoted <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e149" xlink:type="simple"/></inline-formula>, are obtained by, for each <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e150" xlink:type="simple"/></inline-formula>, removing all keys <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e151" xlink:type="simple"/></inline-formula> to form <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e152" xlink:type="simple"/></inline-formula>, and then adding <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e153" xlink:type="simple"/></inline-formula> to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e154" xlink:type="simple"/></inline-formula> if the length of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e155" xlink:type="simple"/></inline-formula> is at least 2. Alternatively, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e156" xlink:type="simple"/></inline-formula> corresponds to the set of reads relevant to the problem of only phasing <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e157" xlink:type="simple"/></inline-formula>. Continuing with the example above, if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e158" xlink:type="simple"/></inline-formula>, then<disp-formula id="pcbi.1003502.e159"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e159" xlink:type="simple"/></disp-formula></p>
</sec></sec><sec id="s3d">
<title>HapTree</title>
<p>Our main approach to solving the single individual polyploid haplotype assembly problem is by finding highly probable solutions on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e160" xlink:type="simple"/></inline-formula> SNPs and extending those to highly probable solutions on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e161" xlink:type="simple"/></inline-formula> SNPs. Our algorithm has two fundamental parts: branching and pruning. For each connected component of the <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e162" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e163" xlink:type="simple"/></inline-formula>, we inductively generate a collection of high likelihood phases on the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e164" xlink:type="simple"/></inline-formula> SNPs. For each of these phases, we branch them to phases on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e165" xlink:type="simple"/></inline-formula> SNPs by considering all possible orderings of alleles for position <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e166" xlink:type="simple"/></inline-formula> and including branches for those which occur with probability above a certain threshold. After doing so, we prune the tree of phases by removing all leaves that occur with probability sufficiently less than the most probable leaf. We discuss both parts in more detail below. We note that although a dynamic programming algorithm can be directly applied to infer the best solutions under HapTree's likelihood model, we instead developed HapTree, which is substantially faster than exact dynamic programming but with nearly identical empirical performance.</p>
<sec id="s3d1">
<title>Extension</title>
<p>We first describe how to extend an existing a haplotype assembly <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e167" xlink:type="simple"/></inline-formula> on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e168" xlink:type="simple"/></inline-formula> SNPs onto the <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e169" xlink:type="simple"/></inline-formula> SNP <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e170" xlink:type="simple"/></inline-formula>. Recall the set of permutations of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e171" xlink:type="simple"/></inline-formula> is denoted <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e172" xlink:type="simple"/></inline-formula> and one particular permutation as <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e173" xlink:type="simple"/></inline-formula>. An extension <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e174" xlink:type="simple"/></inline-formula> of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e175" xlink:type="simple"/></inline-formula> onto SNP locus <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e176" xlink:type="simple"/></inline-formula> can be defined by appending some permutation <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e177" xlink:type="simple"/></inline-formula> of alleles to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e178" xlink:type="simple"/></inline-formula>; <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e179" xlink:type="simple"/></inline-formula>. Note that it is possible for two distinct permutations to result in the same <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e180" xlink:type="simple"/></inline-formula>: <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e181" xlink:type="simple"/></inline-formula>. In these cases we do not include duplicates, as they are equivalent. Observe that if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e182" xlink:type="simple"/></inline-formula> is empty, all allele permutations are the same as vector sets; we therefore include only one. For any <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e183" xlink:type="simple"/></inline-formula>, we can compute the probability of it being the correct haplotype (for the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e184" xlink:type="simple"/></inline-formula> SNPs) conditioning on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e185" xlink:type="simple"/></inline-formula> being correct (for the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e186" xlink:type="simple"/></inline-formula> SNPs), as well as the semi-read data <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e187" xlink:type="simple"/></inline-formula> and error rate <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e188" xlink:type="simple"/></inline-formula>. We express this below:<disp-formula id="pcbi.1003502.e189"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e189" xlink:type="simple"/><label>(2)</label></disp-formula></p>
<p>This computation is similar to those done above in <xref ref-type="disp-formula" rid="pcbi.1003502.e073">equation (1</xref>). The EXTEND algorithm (Algorithm 1) is given below, which returns a list of all extensions <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e190" xlink:type="simple"/></inline-formula> of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e191" xlink:type="simple"/></inline-formula> that occur with probability above a certain threshold, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e192" xlink:type="simple"/></inline-formula>, given haplotype <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e193" xlink:type="simple"/></inline-formula>.</p>
</sec><sec id="s3d2">
<title>Branching</title>
<p>Here we define <italic>branching</italic> a collection of haplotypes <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e194" xlink:type="simple"/></inline-formula> with threshold <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e195" xlink:type="simple"/></inline-formula> to SNP <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e196" xlink:type="simple"/></inline-formula>: BRANCH(<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e197" xlink:type="simple"/></inline-formula>) (Algorithm 2). We assume all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e198" xlink:type="simple"/></inline-formula> phase the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e199" xlink:type="simple"/></inline-formula> SNPs and that SNP <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e200" xlink:type="simple"/></inline-formula> is the <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e201" xlink:type="simple"/></inline-formula> SNP. The act of branching <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e202" xlink:type="simple"/></inline-formula> returns <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e203" xlink:type="simple"/></inline-formula>: a list of all extensions generated by EXTEND with threshold <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e204" xlink:type="simple"/></inline-formula> for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e205" xlink:type="simple"/></inline-formula> in <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e206" xlink:type="simple"/></inline-formula>. To initialize BRANCH we EXTEND the empty vector set to an arbitrary permutation of the alleles of the first SNP, as all permutations are equivalent as vector sets.</p>
</sec><sec id="s3d3">
<title>Pruning</title>
<p>For a collection of haplotypes <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e207" xlink:type="simple"/></inline-formula> of SNPs <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e208" xlink:type="simple"/></inline-formula>, we can compute the relative likelihood of each haplotype conditioned on the sub-reads <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e209" xlink:type="simple"/></inline-formula> and error rate <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e210" xlink:type="simple"/></inline-formula>; we write this as <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e211" xlink:type="simple"/></inline-formula>. The same computation as performed in <xref ref-type="disp-formula" rid="pcbi.1003502.e073">equation 1</xref> yields:<disp-formula id="pcbi.1003502.e212"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e212" xlink:type="simple"/></disp-formula></p>
<p>Since <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e213" xlink:type="simple"/></inline-formula> does not depend on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e214" xlink:type="simple"/></inline-formula>:<disp-formula id="pcbi.1003502.e215"><graphic position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1003502.e215" xlink:type="simple"/><label>(3)</label></disp-formula></p>
<p>The goal of PRUNE(<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e216" xlink:type="simple"/></inline-formula>) (Algorithm 3) is to return a subset <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e217" xlink:type="simple"/></inline-formula> containing only sufficiently probable haplotypes. It does so by computing the relative likelihood of the most probable <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e218" xlink:type="simple"/></inline-formula>, that is <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e219" xlink:type="simple"/></inline-formula>, and adding <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e220" xlink:type="simple"/></inline-formula> to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e221" xlink:type="simple"/></inline-formula> if <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e222" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e223" xlink:type="simple"/></inline-formula> is between <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e224" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e225" xlink:type="simple"/></inline-formula>. We note that that one can compute <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e226" xlink:type="simple"/></inline-formula> from <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e227" xlink:type="simple"/></inline-formula> by only looking at the semi-reads <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e228" xlink:type="simple"/></inline-formula>: we store the relative likelihood values for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e229" xlink:type="simple"/></inline-formula> and update them when branching to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e230" xlink:type="simple"/></inline-formula>; PRUNE is therefore no more costly than BRANCH.</p>
</sec><sec id="s3d4">
<title>Main algorithm</title>
<p>Here we give a high-level description of our overall haplotype assembly method HapTree(<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e231" xlink:type="simple"/></inline-formula>) (Algorithm 4) using the EXTEND, BRANCH, and PRUNE algorithms. We generate high likelihood phases for the first <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e232" xlink:type="simple"/></inline-formula> SNPs, BRANCH those phases to include <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e233" xlink:type="simple"/></inline-formula> (the <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e234" xlink:type="simple"/></inline-formula> SNP), then PRUNE the resulting phases, and repeat for <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e235" xlink:type="simple"/></inline-formula>. We begin with an arbitrary permutation of the first SNP, since all orderings result in the same vector set. For the final step, we PRUNE with <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e236" xlink:type="simple"/></inline-formula>, and therefore return only the maximally probable phases that we have found; if this set is of size greater than one, we choose a phasing from within it randomly. More generally, below we take <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e237" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e238" xlink:type="simple"/></inline-formula> to be vectors, as <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e239" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e240" xlink:type="simple"/></inline-formula> may depend on <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e241" xlink:type="simple"/></inline-formula>, the size of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e242" xlink:type="simple"/></inline-formula> or other user-specified variables.</p>
</sec></sec></sec><sec id="s4">
<title>Results</title>
<sec id="s4a">
<title>Scoring and Evaluation</title>
<p>Determining the quality of a phasing solution depends on whether the true phase is known. When no such information is avaliable, the Minimum Error Correction (MEC) score <xref ref-type="bibr" rid="pcbi.1003502-Lippert1">[15]</xref> is a widely used scoring function to measure the quality of phasing solutions. The MEC score is defined as the minimum (amongst chromosomes) number of mismatches between a phase <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e243" xlink:type="simple"/></inline-formula> and the read set <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e244" xlink:type="simple"/></inline-formula>. A number of existing programs, including HapCut <xref ref-type="bibr" rid="pcbi.1003502-Bansal1">[9]</xref>, find phasing solutions by optimizing the MEC score in diploid cases. For higher ploidy the MEC score can no longer be reliably used because unlike in the diploid case, the phase of any one chromosome does not determine the phases of the others. Moreover, the MEC score does not distinguish between two separate phases of a pair of SNP loci with different non-zero counts of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e245" xlink:type="simple"/></inline-formula> in their vector sets. Finally, unlike in the diploid case, a phase of a pair of SNP loci containing a set of parallel alleles does not prevent it from containing a set of switched alleles as well. To demonstrate these issues, consider two possible vector sets corresponding to phases of a pair of triploid SNPs both with genotype 2: <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e246" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e247" xlink:type="simple"/></inline-formula>. If the read data is <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e248" xlink:type="simple"/></inline-formula>, it is clear from a probabilistic standpoint that phase <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e249" xlink:type="simple"/></inline-formula> is a better fit, but both <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e250" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e251" xlink:type="simple"/></inline-formula> have equal MEC scores. This effect is exaggerated as <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e252" xlink:type="simple"/></inline-formula> increases.</p>
<p>When a true phase is available, there are a variety ways to evaluate how accurate any predicted phase is. A widely used measure in diploid phasing is switch error, which is calculated as the number of positions where the two chromosomes of a proposed phase must be switched in order to agree with the true phase. For polyploid phasing, we generalize switch error to <italic>vector error</italic>. In higher ploidy cases, at any SNP locus, it is possible for no chromosomes in a proposed phase to require a switch or anywhere from <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e253" xlink:type="simple"/></inline-formula> to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e254" xlink:type="simple"/></inline-formula> chromosomes to require switches, in order for a proposed phase to agree with the true phase. We do not wish to penalize a solution where only two vectors must be switched at a given position with the same penalty to be used for a solution in which all vectors must be switched. The <italic>vector error</italic> of a proposed phase (with respect to the true phase) is defined by the minimum number of segments on all chromosomes for which a switch must occur; for the diploid case this score is exactly twice the switch error. One may also think of the vector error as the minimum number of segments a proposed phase and the true phase have in common, less the ploidy. Even for triploid genomes, the vector error is more discriminative than switch error. Consider the following example in <xref ref-type="fig" rid="pcbi-1003502-g002">Figure 2:</xref></p>
<fig id="pcbi-1003502-g002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.g002</object-id><label>Figure 2</label><caption>
<title>Examples of <italic>Vector Error</italic> in a sample tetraploid genome; the true phase is on the left and examples with two, three, and four vector errors are on the right.</title>
</caption><graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.g002" position="float" xlink:type="simple"/></fig>
<p>In <xref ref-type="fig" rid="pcbi-1003502-g002">Figure 2</xref> phase (i) is a more accurate phase than (ii), and phase (ii) more accurate than phase (iii). The segments are broken up by row and color: phase (i) having five segments, phase (ii) having six, and phase (iii) having seven. Note that there may be several ways to break a vector set into a minimal number of segments; phase (ii) is such an example. Finally, we remark that vector error can be computed in time <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e255" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e256" xlink:type="simple"/></inline-formula> is the ploidy and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e257" xlink:type="simple"/></inline-formula> the block size.</p>
</sec><sec id="s4b">
<title>Results for Simulated Polyploid Data</title>
<sec id="s4b1">
<title>Relative Likelihood (RL) objective function vs. MEC score for polyploid genomes</title>
<p>We assessed the effectiveness of our RL score by comparison to MEC score on simulated data. To do so, we simulated reads with error rate <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e258" xlink:type="simple"/></inline-formula> from a pair of phased <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e259" xlink:type="simple"/></inline-formula>-ploid SNP loci for different coverages (5×, 10×, 20×, 100×) and for <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e260" xlink:type="simple"/></inline-formula>. All possible phases were exhaustively enumerated, and phases of the maximal relative likelihood (RL) and phases of the minimal MEC score chosen. We computed the proportion of perfectly phased SNP pairs in both cases (perfect solution rate). Even with two SNP loci, RL significantly outperforms MEC for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e261" xlink:type="simple"/></inline-formula> (<xref ref-type="fig" rid="pcbi-1003502-g003">Figure 3A</xref>). It is also worth noting that MEC (in comparison to RL) deteriorates more seriously in accuracy as ploidy <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e262" xlink:type="simple"/></inline-formula> increases (<xref ref-type="fig" rid="pcbi-1003502-g003">Figure 3A</xref>). In addition, we also compared the vector error rate in both cases; for a pair of SNPs, this rate is the number of vectors from the proposed solution that cannot be matched with vectors from the true solution (<xref ref-type="fig" rid="pcbi-1003502-g003">Figure 3B</xref>).</p>
<fig id="pcbi-1003502-g003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.g003</object-id><label>Figure 3</label><caption>
<title>Proportion of perfectly phased SNP pairs and vector error rate for RL (solid line) and MEC (dashed line) optimization in 10000 trials over 5×, 10×, 20× and 100× coverage.</title>
</caption><graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.g003" position="float" xlink:type="simple"/></fig>
<p>The results demonstrate that the higher the ploidy, the better the relative likelihood (RL) score performs in comparison to MEC score for phasing a pair of SNPs (<xref ref-type="fig" rid="pcbi-1003502-g003">Figure 3</xref>). In fact, in simulations where <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e263" xlink:type="simple"/></inline-formula>, RL with 5× the coverage already outperforms MEC with 100× coverage. For the same coverage, RL always outperforms MEC for <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e264" xlink:type="simple"/></inline-formula>, and they are equivalent in the diploid case <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e265" xlink:type="simple"/></inline-formula>.</p>
</sec><sec id="s4b2">
<title>Comparisons of HapTree and HapCompass</title>
<p>To evaluate the phasing capabilities of HapTree, we compare it with HapCompass <xref ref-type="bibr" rid="pcbi.1003502-Aguiar1">[8]</xref> (latest version available at: <ext-link ext-link-type="uri" xlink:href="http://www.brown.edu/Research/Istrail_Lab/hapcompass.php" xlink:type="simple">www.brown.edu/Research/Istrail_Lab/hapcompass.php</ext-link>), to our knowledge the only other existing program that directly addresses polyploid haplotype assembly, over multiple depth coverage values and component sizes for triploid and tetraploid simulated genomes. We simulated triploid and tetraploid genomes with different block lengths (10, 20 or 40 SNP loci), different coverages (5×, 10×, 20× and 40×), SNP positions, and SNP densities. Throughout the simulations for both the triploid and tetraploid cases, our EXTEND module is run with threshold <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e266" xlink:type="simple"/></inline-formula> and PRUNE primarily with threshold <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e267" xlink:type="simple"/></inline-formula>. When the current number of haplotype options generated is above <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e268" xlink:type="simple"/></inline-formula>, we prune more aggressively with <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e269" xlink:type="simple"/></inline-formula> and when above <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e270" xlink:type="simple"/></inline-formula>, with <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e271" xlink:type="simple"/></inline-formula>. These parameters are chosen to ensure the efficiency of HapTree by only keep a tractable collection of promising solutions in each step. We also simulate a read set with uniform error rate and size dependent on coverage.</p>
<p>For the triploid case, we observed that HapTree finds a perfect solution at a rate independent of the number of SNPs used in the simulation; in contrast, HapCompass declines in performance the larger the block size (<xref ref-type="fig" rid="pcbi-1003502-g004">Figure 4</xref>). While both HapTree and HapCompass improve steadily the higher the coverage, in every case HapTree significantly outperforms HapCompass; the least significant improvement of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e272" xlink:type="simple"/></inline-formula> occurs in the case of 10 SNP loci and 10× coverage, whereas the most significant improvement occurs in the case of 40 SNP loci and 40× coverage. For both vector error rate and likelihood of perfect solution, we find that HapTree substantially outperforms HapCompass.</p>
<fig id="pcbi-1003502-g004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.g004</object-id><label>Figure 4</label><caption>
<title>HapTree (solid lines) and HapCompass (dashed lines) on simulated triploid genomes: Likelihood of Perfect Solution and Vector Error Rates, 1000 Trials, Block lengths: 10, 20, and 40.</title>
</caption><graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.g004" position="float" xlink:type="simple"/></fig>
<p>For tetraploid simulations, HapTree significantly outperforms HapCompass with block length of 10 SNP loci (<xref ref-type="fig" rid="pcbi-1003502-g005">Figure 5</xref>). For larger block lengths HapCompass arrives at the perfect solution at a rate of less than <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e273" xlink:type="simple"/></inline-formula>; HapTree however does so at a rate between <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e274" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e275" xlink:type="simple"/></inline-formula> depending on block size and coverage at least 20×.</p>
<fig id="pcbi-1003502-g005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.g005</object-id><label>Figure 5</label><caption>
<title>HapTree (solid line) and HapCompass (dashed line) on simulated tetraploid genomes: Likelihood of Perfect Solution and Vector Error Rates, 1000 Trials, Block length: 10.</title>
</caption><graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.g005" position="float" xlink:type="simple"/></fig>
<p>We varied the allele error rates (<inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e276" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e277" xlink:type="simple"/></inline-formula>) and observed decreases in accuracy that vary approximately linearly with the (uniform) allele error rates (<xref ref-type="fig" rid="pcbi-1003502-g006">Figure 6</xref>). The allele error rate is the likelihood of the sequencing technology to report the incorrect allele for a given position in one read. We ran 10000 trials for simulated triploid genomes of block size 10, with coverages 10×, 20×, and 40×.</p>
<fig id="pcbi-1003502-g006" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.g006</object-id><label>Figure 6</label><caption>
<title>HapTree performance over varied error rates (.001, .02, .05, .1) and coverages (10×, 20×, 40×) on simulated triploid genomes: Likelihood of Perfect Solution and Vector Error Rates, 10000 Trials, Block length: 10.</title>
</caption><graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.g006" position="float" xlink:type="simple"/></fig>
<p>For the simulations above in <xref ref-type="fig" rid="pcbi-1003502-g006">Figure 6</xref>, we modeled our read data on Illumina sequencing technologies; for more details, please see section <bold>Simulated polyploid data generation</bold> below. We also ran simulations on longer read data, modeled after 454 sequencing technologies and found almost identical results.</p>
<p>The primary reasons for HapTree's superior performance are, first, that HapTree's relative likelihood is more effective than HapCompass's MEC score (see <bold>Relative likelihood vs MEC</bold>); and second, that HapTree's inference algorithm is more accurate than the approximation algorithm used by HapCompass.</p>
</sec></sec></sec><sec id="s5">
<title>Discussion</title>
<sec id="s5a">
<title>Run-Time Evaluation</title>
<p>Not only does HapTree outperform HapCompass on phasing quality, it is also significantly faster, especially for longer block length. The median runtimes for block length 10 and 10× coverage were <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e278" xlink:type="simple"/></inline-formula> seconds for HapTree and HapCompass, respectively; for block length of 40 and 40× coverage, they were <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e279" xlink:type="simple"/></inline-formula> seconds, respectively.</p>
</sec><sec id="s5b">
<title>Results on Real Diploid Data</title>
<p>As seen in the results of Geraci et al. <xref ref-type="bibr" rid="pcbi.1003502-Geraci1">[18]</xref>, there is no perfect solution for diploid phasing. HapCUT is one of the methods reported that consistently performs best or close-to-best for a variety of experiments. For a proof of concept of how HapTree would perform on real data, we ran HapTree and HapCUT using 454 and Illumina sequencing data of the well-studied NA12878 genome (1000 Genomes Project Phase 1) <xref ref-type="bibr" rid="pcbi.1003502-Abecasis1">[17]</xref>, and compared MEC scores as well as switch errors to a trio phasing annotation accepted as ground truth; we present these results in <xref ref-type="table" rid="pcbi-1003502-t001">Table 1</xref>. The trio phasing annotation represents a high quality diplotype of NA12878 for all SNP sites where either parent (NA12891 or NA12892) is homozygous <xref ref-type="bibr" rid="pcbi.1003502-Abecasis1">[17]</xref>. Note that we computed the number of switch errors within connected SNP components only, against SNPs whose phase has been determined by the trio-based phasing; we then sum over components. In this case, HapTree was run with a uniform error rate of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e280" xlink:type="simple"/></inline-formula>, an EXTEND threshold <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e281" xlink:type="simple"/></inline-formula>, and primarily with a PRUNE threshold of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e282" xlink:type="simple"/></inline-formula>. We begin to prune more aggressively when we have at least <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e283" xlink:type="simple"/></inline-formula> or <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e284" xlink:type="simple"/></inline-formula> possible haplotypes with thresholds of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e285" xlink:type="simple"/></inline-formula> respectively. For the vector set prior, from examining the read data, we ran HapTree with parallel bias <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e286" xlink:type="simple"/></inline-formula>.</p>
<table-wrap id="pcbi-1003502-t001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1003502.t001</object-id><label>Table 1</label><caption>
<title>Results of switch error (switch) and MEC score for HapTree and HapCUT of whole-genome phasing using 454 and Illumina data.</title>
</caption><alternatives><graphic id="pcbi-1003502-t001-1" position="float" mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1003502.t001" xlink:type="simple"/>
<table><colgroup span="1"><col align="left" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/><col align="center" span="1"/></colgroup>
<thead>
<tr>
<td align="left" rowspan="1" colspan="1">Results</td>
<td colspan="2" align="left" rowspan="1">454</td>
<td colspan="2" align="left" rowspan="1">Illumina</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Method</td>
<td align="left" rowspan="1" colspan="1">MEC</td>
<td align="left" rowspan="1" colspan="1">Switch</td>
<td align="left" rowspan="1" colspan="1">MEC</td>
<td align="left" rowspan="1" colspan="1">Switch</td>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">HapTree</td>
<td align="left" rowspan="1" colspan="1">32818</td>
<td align="left" rowspan="1" colspan="1"><bold>2978</bold></td>
<td align="left" rowspan="1" colspan="1">20339</td>
<td align="left" rowspan="1" colspan="1"><bold>1888</bold></td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">HapCUT</td>
<td align="left" rowspan="1" colspan="1">32781</td>
<td align="left" rowspan="1" colspan="1">3192</td>
<td align="left" rowspan="1" colspan="1">20290</td>
<td align="left" rowspan="1" colspan="1">1933</td>
</tr>
</tbody>
</table>
</alternatives></table-wrap>
<p>We found that HapTree and HapCUT perform almost identically in MEC scores, with HapCUT having marginally smaller scores for both 454 and Illumina data sets. It is worth noting that HapCUT optimizes MEC score, and MEC score measures only the consistency between a phasing solution and read data, not with the true phase.</p>
<p>Notably, when comparing to the ground-truth phase as determined by trio-based phasing, we found HapTree significantly outperforms HapCut in terms of switch error rate for the phasing experiments on the NA12878 genome for 454 and Illumina datasets. Although our method is not primarily designed for phasing diploid genomes, it is still able to achieve better phasing results, when compared to the state-of-the-art diploid method. Again, the results on real-world read datasets showed the superiority of our likelihood function over MEC score for NGS-based phasing.</p>
</sec><sec id="s5c">
<title>Simulated Polyploid Data Generation</title>
<sec id="s5c1">
<title>Reads</title>
<p>To generate a paired-end read, we uniformly choose a starting point on the genome (we make sure the genome starts sufficiently before the first SNP and ends at the last). We fix the read-end length (read_len) to be 150. The fragment length (frag_len) is normally distributed with a mean of 550 and standard deviation of 30, but with min and max lengths of 500 and 600 respectively. The insert length (insert_len) is determined by the fragment length and read-end length, that is, insert_len  =  frag_len - 2read_len. Once we know the start and fragment length, we must choose from which chromosome to read; we do so uniformly from the <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e287" xlink:type="simple"/></inline-formula> chromosomes. Finally, we add uniform error to the read; we choose a rate of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e288" xlink:type="simple"/></inline-formula>, based on the reported error rate of Illumina sequencing technologies. For every SNP that the read covers, independently with probability <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e289" xlink:type="simple"/></inline-formula> we flip the allele to any other allele; two-thirds of the time when we have this error, we can see that the allele present is neither the reference nor the alternative, and therefore we delete it. Hence, conditional on seeing a SNP in a read, it is incorrect with probability <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e290" xlink:type="simple"/></inline-formula> and correct with probability <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e291" xlink:type="simple"/></inline-formula>.</p>
</sec><sec id="s5c2">
<title>Genomes</title>
<p>To simulate a genome, we fix a ploidy <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e292" xlink:type="simple"/></inline-formula> and the number of SNPs <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e293" xlink:type="simple"/></inline-formula>. We determine the positions for the SNPs by randomly generating the distance between each pair of adjacent SNPs. We do so using a geometric random variable with parameter <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e294" xlink:type="simple"/></inline-formula> (SNP density); this choice is equivalent to assuming that any position is a SNP independently with probability <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e295" xlink:type="simple"/></inline-formula>. For phasing purposes, once one has generated the reads, the exact genomic positions are no longer relevant; they were only needed to simulate more accurate read data. We therefore refer to SNPs by their position amongst the SNPs, not their position in the genome. For each SNP, we randomly generate its haplotype, assuming for each chromosome, that the alternative and reference alleles are equally likely; if we generate a homozygous SNP, we try again. This procedure results in the likelihood of genotype <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e296" xlink:type="simple"/></inline-formula> equal to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e297" xlink:type="simple"/></inline-formula>, and all orderings <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e298" xlink:type="simple"/></inline-formula> being equally likely. For the simulations discussed we use this model. Note, however, that HapTree is not dependent on this model. When running HapTree on real data, different assumptions ought to be made regarding the distributions of vector sets.</p>
</sec><sec id="s5c3">
<title>Coverage</title>
<p>For any genome, to generate a read set with <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e299" xlink:type="simple"/></inline-formula>x coverage we need each base pair to be on average covered by <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e300" xlink:type="simple"/></inline-formula> reads. To determine the number of reads to generate, we must know the length of the genome and the read length (read_len). The expected length of the genome is <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e301" xlink:type="simple"/></inline-formula> for SNP density <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e302" xlink:type="simple"/></inline-formula>, and the read_len is 150 for each end (of which there are two); therefore we simulate <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e303" xlink:type="simple"/></inline-formula> reads for <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e304" xlink:type="simple"/></inline-formula>x coverage. Note that many of these reads will see only zero or one SNP(s), thus for <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e305" xlink:type="simple"/></inline-formula>x coverage the number of useful reads for any SNP will be less than <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e306" xlink:type="simple"/></inline-formula>.</p>
</sec></sec></sec><sec id="s6">
<title>Discussion</title>
<p>We have presented a scalable algorithm, HapTree, for polyplotyping using NGS sequencing data and a new metric for measuring accuracy in this context. We have described an efficient algorithm to identify phases that maximize our RL metric, a relative likelihood function which measures the quality of a given phase according to the read dataset. We have demonstrated the advantages of such a likelihood formulation over the existing MEC score in phasing both polyploid and diploid genomes. HapTree not only substantially improves the efficiency and phasing accuracy of the state-of-the-art in polyploid phasing, but also produces more accurate phased haplotype blocks for diploid genomes, as compared to HapCUT, which is designed for diploid phasing by MEC score optimization. Our results indicate that HapTree can be used in phasing individual triploid and tetraploid genomes, as well as improving phasing of real diploid genomes. HapTree also easily scales to genomes of higher ploidy.</p>
<p>Our algorithm can be easily extended to phase data with multi-allelic SNPs and with unknown genotype information as well. With unknown genotype information and multi-allelic SNPs, instead of <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e307" xlink:type="simple"/></inline-formula> allele permutations, there are <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e308" xlink:type="simple"/></inline-formula> possibilities, since all 4 alleles (A,C,G,T) are possible for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e309" xlink:type="simple"/></inline-formula> chromosomes. For bi-allelic SNPs with unknown genotypes, there are <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e310" xlink:type="simple"/></inline-formula>, as all possible reference and alliterative allele permutations are allowable. Finally, when the genotype is known but a SNP is multi-allelic, we may use multinomial coefficients to compute the number of allele permutations allowable: <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e311" xlink:type="simple"/></inline-formula>, where <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e312" xlink:type="simple"/></inline-formula> denotes the number of alleles <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e313" xlink:type="simple"/></inline-formula> according to the genotype, where <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e314" xlink:type="simple"/></inline-formula>. The only change to HapTree in these cases is that at each EXTEND step, we allow all allele permutation possibilities as dictated by whatever genotypic is available: we compute the probabilities for all <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e315" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e316" xlink:type="simple"/></inline-formula>, or <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e317" xlink:type="simple"/></inline-formula> possibilities (depending on the situation) as opposed to <inline-formula><inline-graphic xlink:href="info:doi/10.1371/journal.pcbi.1003502.e318" xlink:type="simple"/></inline-formula> and EXTEND accordingly. Moreover, the type of information available does not need to be the same for all SNPs, since it only determines which allele permutations we introduce at the EXTEND step.</p>
<p>A future application of HapTree is genotype imputation, which can predict missing genotype from phasing results. As polyploid sequencing data becomes available, HapTree will be useful for the investigation of the role of heterozygosity in plant, fish, and other species. Moreover, accurate individual phases of diploid haplotypes can be assembled without the use of pedigree or population information.</p>
<p>A summary of this paper appears in the proceedings of the RECOMB 2014 conference, April 2–5 [19].</p>
</sec></body>
<back>
<ack>
<p>The authors would like to thank Madars Virza and Lenore Cowen for helpful conversations, as well as Leslie Gaffney for help with the striking image. As well, we thank the reviewers for their insightful comments.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1003502-Williams1"><label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Williams</surname><given-names>A</given-names></name>, <name name-style="western"><surname>Housman</surname><given-names>D</given-names></name>, <name name-style="western"><surname>Rinard</surname><given-names>M</given-names></name>, <name name-style="western"><surname>Gifford</surname><given-names>D</given-names></name> (<year>2010</year>) <article-title>Rapid haplotype inference for nuclear families</article-title>. <source>Genome biology</source> <volume>11</volume>: <fpage>R108</fpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Zhang1"><label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Zhang</surname><given-names>K</given-names></name>, <name name-style="western"><surname>Sun</surname><given-names>F</given-names></name>, <name name-style="western"><surname>Zhao</surname><given-names>H</given-names></name> (<year>2005</year>) <article-title>Haplore: a program for haplotype reconstruction in general pedigrees without recombination</article-title>. <source>Bioinformatics</source> <volume>21</volume>: <fpage>90</fpage>–<lpage>103</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Browning1"><label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Browning</surname><given-names>BL</given-names></name>, <name name-style="western"><surname>Browning</surname><given-names>SR</given-names></name> (<year>2009</year>) <article-title>A unified approach to genotype imputation and haplotype-phase inference for large data sets of trios and unrelated individuals</article-title>. <source>The American Journal of Human Genetics</source> <volume>84</volume>: <fpage>210</fpage>–<lpage>223</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Stephens1"><label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Stephens</surname><given-names>M</given-names></name>, <name name-style="western"><surname>Smith</surname><given-names>NJ</given-names></name>, <name name-style="western"><surname>Donnelly</surname><given-names>P</given-names></name> (<year>2001</year>) <article-title>A new statistical method for haplotype reconstruction from population data</article-title>. <source>The American Journal of Human Genetics</source> <volume>68</volume>: <fpage>978</fpage>–<lpage>989</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Scheet1"><label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Scheet</surname><given-names>P</given-names></name>, <name name-style="western"><surname>Stephens</surname><given-names>M</given-names></name> (<year>2006</year>) <article-title>A fast and exible statistical model for large-scale population genotype data: applications to inferring missing genotypes and haplotypic phase</article-title>. <source>The American Journal of Human Genetics</source> <volume>78</volume>: <fpage>629</fpage>–<lpage>644</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Delaneau1"><label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Delaneau</surname><given-names>O</given-names></name>, <name name-style="western"><surname>Coulonges</surname><given-names>C</given-names></name>, <name name-style="western"><surname>Zagury</surname><given-names>JF</given-names></name> (<year>2008</year>) <article-title>Shape-it: new rapid and accurate algorithm for haplotype inference</article-title>. <source>BMC bioinformatics</source> <volume>9</volume>: <fpage>540</fpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Browning2"><label>7</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Browning</surname><given-names>SR</given-names></name>, <name name-style="western"><surname>Browning</surname><given-names>BL</given-names></name> (<year>2010</year>) <article-title>High-resolution detection of identity by descent in unrelated individuals</article-title>. <source>The American Journal of Human Genetics</source> <volume>86</volume>: <fpage>526</fpage>–<lpage>539</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Aguiar1"><label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Aguiar</surname><given-names>D</given-names></name>, <name name-style="western"><surname>Istrail</surname><given-names>S</given-names></name> (<year>2013</year>) <article-title>Haplotype assembly in polyploid genomes and identical by descent shared tracts</article-title>. <source>Bioinformatics</source> <volume>29</volume>: <fpage>i352</fpage>–<lpage>i360</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Bansal1"><label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Bansal</surname><given-names>V</given-names></name>, <name name-style="western"><surname>Bafna</surname><given-names>V</given-names></name> (<year>2008</year>) <article-title>Hapcut: an efficient and accurate algorithm for the haplotype assembly problem</article-title>. <source>Bioinformatics</source> <volume>24</volume>: <fpage>i153</fpage>–<lpage>i159</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Aguiar2"><label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Aguiar</surname><given-names>D</given-names></name>, <name name-style="western"><surname>Istrail</surname><given-names>S</given-names></name> (<year>2012</year>) <article-title>Hapcompass: a fast cycle basis algorithm for accurate haplotype assembly of sequence data</article-title>. <source>Journal of Computational Biology</source> <volume>19</volume>: <fpage>577</fpage>–<lpage>590</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-He1"><label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>He</surname><given-names>D</given-names></name>, <name name-style="western"><surname>Choi</surname><given-names>A</given-names></name>, <name name-style="western"><surname>Pipatsrisawat</surname><given-names>K</given-names></name>, <name name-style="western"><surname>Darwiche</surname><given-names>A</given-names></name>, <name name-style="western"><surname>Eskin</surname><given-names>E</given-names></name> (<year>2010</year>) <article-title>Optimal algorithms for haplotype assembly from whole-genome sequence data</article-title>. <source>Bioinformatics</source> <volume>26</volume>: <fpage>i183</fpage>–<lpage>i190</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Bansal2"><label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Bansal</surname><given-names>V</given-names></name>, <name name-style="western"><surname>Halpern</surname><given-names>AL</given-names></name>, <name name-style="western"><surname>Axelrod</surname><given-names>N</given-names></name>, <name name-style="western"><surname>Bafna</surname><given-names>V</given-names></name> (<year>2008</year>) <article-title>An mcmc algorithm for haplotype assembly from whole-genome sequence data</article-title>. <source>Genome research</source> <volume>18</volume>: <fpage>1336</fpage>–<lpage>1346</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Efros1"><label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Efros</surname><given-names>A</given-names></name>, <name name-style="western"><surname>Halperin</surname><given-names>E</given-names></name> (<year>2012</year>) <article-title>Haplotype reconstruction using perfect phylogeny and sequence data</article-title>. <source>BMC bioinformatics</source> <volume>13</volume>: <fpage>S3</fpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Lancia1"><label>14</label>
<mixed-citation publication-type="other" xlink:type="simple">Lancia G, Bafna V, Istrail S, Lippert R, Schwartz R (2001) Snps problems, complexity, and algorithms. In: AlgorithmsESA 2001, Springer. pp. 182–193.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Lippert1"><label>15</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Lippert</surname><given-names>R</given-names></name>, <name name-style="western"><surname>Schwartz</surname><given-names>R</given-names></name>, <name name-style="western"><surname>Lancia</surname><given-names>G</given-names></name>, <name name-style="western"><surname>Istrail</surname><given-names>S</given-names></name> (<year>2002</year>) <article-title>Algorithmic strategies for the single nucleotide polymorphism haplotype assembly problem</article-title>. <source>Briefings in bioinformatics</source> <volume>3</volume>: <fpage>23</fpage>–<lpage>31</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Panconesi1"><label>16</label>
<mixed-citation publication-type="other" xlink:type="simple">Panconesi A, Sozio M (2004) Fast hare: A fast heuristic for single individual snp haplotype reconstruction. In: Algorithms in Bioinformatics, Springer. pp. 266–277.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Abecasis1"><label>17</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Abecasis</surname><given-names>G</given-names></name>, <name name-style="western"><surname>Altshuler</surname><given-names>D</given-names></name>, <name name-style="western"><surname>Auton</surname><given-names>A</given-names></name>, <name name-style="western"><surname>Brooks</surname><given-names>L</given-names></name>, <name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name>, <etal>et al</etal>. (<year>2010</year>) <article-title>A map of human genome variation from population-scale sequencing</article-title>. <source>Nature</source> <volume>467</volume>: <fpage>1061</fpage>–<lpage>1073</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Geraci1"><label>18</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Geraci</surname><given-names>F</given-names></name> (<year>2010</year>) <article-title>A comparison of several algorithms for the single individual snp haplotyping reconstruction problem</article-title>. <source>Bioinformatics</source> <volume>26</volume>: <fpage>2217</fpage>–<lpage>2225</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1003502-Berger1"><label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple"><name name-style="western"><surname>Berger</surname><given-names>E</given-names></name>, <name name-style="western"><surname>Yorukoglu</surname><given-names>D</given-names></name>, <name name-style="western"><surname>Peng</surname><given-names>J</given-names></name>, <name name-style="western"><surname>Berger</surname><given-names>B</given-names></name> (<year>2014</year>) <article-title>HapTree: A Novel Bayesian Framework for Single Individual Polyplotyping Using NGS Data. In: Research in Computational Molecular Biology, Springer. pp 18–19</article-title>.</mixed-citation>
</ref>
</ref-list></back>
</article>