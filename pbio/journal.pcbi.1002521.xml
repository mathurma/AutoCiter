<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN">
  <front>
    <journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher>
        <publisher-name>Public Library of Science</publisher-name>
        <publisher-loc>San Francisco, USA</publisher-loc>
      </publisher></journal-meta>
    <article-meta><article-id pub-id-type="publisher-id">PCOMPBIOL-D-10-00211</article-id><article-id pub-id-type="doi">10.1371/journal.pcbi.1002521</article-id><article-categories>
        <subj-group subj-group-type="heading">
          <subject>Research Article</subject>
        </subj-group>
        <subj-group subj-group-type="Discipline-v2">
          <subject>Biology</subject>
          <subj-group>
            <subject>Computational biology</subject>
            <subj-group>
              <subject>Computational neuroscience</subject>
              <subj-group>
                <subject>Single neuron function</subject>
              </subj-group>
            </subj-group>
            <subj-group>
              <subject>Biophysic al simulations</subject>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group subj-group-type="Discipline-v2">
          <subject>Computer science</subject>
          <subj-group>
            <subject>Programming languages</subject>
            <subj-group>
              <subject>Simulation languages</subject>
            </subj-group>
          </subj-group>
        </subj-group>
        <subj-group subj-group-type="Discipline">
          <subject>Computational Biology</subject>
          <subject>Computer Science</subject>
        </subj-group>
      </article-categories><title-group><article-title>The Layer-Oriented Approach to Declarative Languages for Biological Modeling</article-title><alt-title alt-title-type="running-head">Layer-Oriented Biological Modeling Languages</alt-title></title-group><contrib-group>
        <contrib contrib-type="author" xlink:type="simple">
          <name name-style="western">
            <surname>Raikov</surname>
            <given-names>Ivan</given-names>
          </name>
          <xref ref-type="aff" rid="aff1">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="aff2">
            <sup>2</sup>
          </xref>
          <xref ref-type="corresp" rid="cor1">
            <sup>*</sup>
          </xref>
        </contrib>
        <contrib contrib-type="author" xlink:type="simple">
          <name name-style="western">
            <surname>De Schutter</surname>
            <given-names>Erik</given-names>
          </name>
          <xref ref-type="aff" rid="aff1">
            <sup>1</sup>
          </xref>
          <xref ref-type="aff" rid="aff2">
            <sup>2</sup>
          </xref>
        </contrib>
      </contrib-group><aff id="aff1"><label>1</label><addr-line>Okinawa Institute of Science and Technology, Onna-son, Okinawa, Japan</addr-line>       </aff><aff id="aff2"><label>2</label><addr-line>University of Antwerp, Antwerp, Belgium</addr-line>       </aff><contrib-group>
        <contrib contrib-type="editor" xlink:type="simple">
          <name name-style="western">
            <surname>Hill</surname>
            <given-names>Sean</given-names>
          </name>
          <role>Editor</role>
          <xref ref-type="aff" rid="edit1"/>
        </contrib>
      </contrib-group><aff id="edit1">Ecole Polytechnique Fédérale de Lausanne, Switzerland</aff><author-notes>
        <corresp id="cor1">* E-mail: <email xlink:type="simple">raikov@oist.jp</email></corresp>
        <fn fn-type="con">
          <p>Wrote the paper: IR EDS. Designed and implemented the prototype software: IR. </p>
        </fn>
      <fn fn-type="conflict">
        <p>The authors have declared that no competing interests exist.</p>
      </fn></author-notes><pub-date pub-type="collection">
        <month>5</month>
        <year>2012</year>
      </pub-date><pub-date pub-type="epub">
        <day>17</day>
        <month>5</month>
        <year>2012</year>
      </pub-date><volume>8</volume><issue>5</issue><elocation-id>e1002521</elocation-id><history>
        <date date-type="received">
          <day>9</day>
          <month>11</month>
          <year>2010</year>
        </date>
        <date date-type="accepted">
          <day>31</day>
          <month>3</month>
          <year>2012</year>
        </date>
      </history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2012</copyright-year><copyright-holder>Raikov, De Schutter</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract>
        <p>We present a new approach to modeling languages for computational biology, which we call the layer-oriented approach. The approach stems from the observation that many diverse biological phenomena are described using a small set of mathematical formalisms (e.g. differential equations), while at the same time different domains and subdomains of computational biology require that models are structured according to the accepted terminology and classification of that domain. Our approach uses distinct semantic layers to represent the domain-specific biological concepts and the underlying mathematical formalisms. Additional functionality can be transparently added to the language by adding more layers. This approach is specifically concerned with declarative languages, and throughout the paper we note some of the limitations inherent to declarative approaches. The layer-oriented approach is a way to specify explicitly how high-level biological modeling concepts are mapped to a computational representation, while abstracting away details of particular programming languages and simulation environments. To illustrate this process, we define an example language for describing models of ionic currents, and use a general mathematical notation for semantic transformations to show how to generate model simulation code for various simulation environments. We use the example language to describe a Purkinje neuron model and demonstrate how the layer-oriented approach can be used for solving several practical issues of computational neuroscience model development. We discuss the advantages and limitations of the approach in comparison with other modeling language efforts in the domain of computational biology and outline some principles for extensible, flexible modeling language design. We conclude by describing in detail the semantic transformations defined for our language.</p>
      </abstract><abstract abstract-type="summary">
        <title>Author Summary</title>
        <p>The pursuit for understanding of neural function by computational modeling has produced a variety of software tools, with each tool targeting specific audiences and often requiring input in its own distinct language. Consequently, comprehending and communicating neuroscience models is a difficult and time-consuming task. In this paper we suggest a new approach towards designing biological modeling languages, which we call the layer-oriented approach. The approach stems from the observation that diverse biological phenomena are described using a small set of mathematical formalisms (e.g. differential equations), which are structured according to some biological principles. Our proposal is illustrated by means of a computer language for describing computational models of ionic currents. The language consists of rules for expressing mathematical equations as well as rules to organize these equations according to the specific terminology used by neuroscientists. The layer-oriented approach offers two chief advantages. First, it allows the flexible use of mathematical equations to represent many different kinds of biological models. Second, it restricts the language within a framework of biological concepts so that existing modeling software can be reused. The goal of the layer-oriented approach is to help define appropriate notations for computational biology while enabling interoperability of software for biological modeling.</p>
      </abstract><funding-group><funding-statement>This work was funded by the Okinawa Institute of Science and Technology and ‘Fonds voor Wetenschappelijk Onderzoek Vlaanderen’ grant FWO-G.0836.08. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement></funding-group><counts>
        <page-count count="21"/>
      </counts></article-meta>
  </front>
  <body>
    <sec id="s1">
      <title>Introduction</title>
      <p>Scientists who construct computational models of biological processes often find it necessary to use several different software tools in order to carry out various forms of data analysis and model simulation. However, each tool may employ its own model description format, consisting of diverse syntactic structures, and often can make implicit assumptions that are not reflected in the corresponding technical documentation <xref ref-type="bibr" rid="pcbi.1002521-Cannon1">[1]</xref>, <xref ref-type="bibr" rid="pcbi.1002521-DeSchutter1">[2]</xref>. As a result, constructing an exact implementation of a published model is a complex and time-consuming task.</p>
      <p>As an example, in computational neuroscience, both the GENESIS <xref ref-type="bibr" rid="pcbi.1002521-Bower1">[3]</xref> and NEURON <xref ref-type="bibr" rid="pcbi.1002521-Carnevale1">[4]</xref> simulators provide a parameterized form of the Hodgkin-Huxley model <xref ref-type="bibr" rid="pcbi.1002521-Hodgkin1">[5]</xref> as a basic object for model construction, but with some important differences between their description languages. The Hodgkin-Huxley object that exists in the Genesis language allows the rate equations to be specified in functional form and thus it can express not only the standard formulation of the model, but a whole family of conductance-based models of ionic currents. The NEURON HOC language also provides a Hodgkin-Huxley object, but its rate equations are fixed and it only allows different values for the parameters and initial states. NEURON includes a separate language, NMODL, which is intended for detailed descriptions of ionic current mechanisms that are distinct from the Hodgkin-Huxley equations. Hence, the two simulators have very different assumptions about what is meant by a “Hodgkin-Huxley model”.</p>
      <p>In</p>
      <p>These efforts are now facing their own information exchange challenges <xref ref-type="bibr" rid="pcbi.1002521-Raikov1">[12]</xref>. For instance, the Simulation Experiment Description Markup Language (SED-ML) <xref ref-type="bibr" rid="pcbi.1002521-Koehn1">[13]</xref>, which is an emerging standard for encoding numerical simulation protocols on top of SBML and CellML, has faced problems such as different sets of mathematical expressions allowed in different modeling languages and representing a diverse range of simulation time courses in the simulator software <xref ref-type="bibr" rid="pcbi.1002521-Bergmann1">[14]</xref>. Other limitations of existing markup languages for biological modeling are pointed out in Section <xref ref-type="sec" rid="s3">Discussion</xref>.</p>
      <p>These issues suggest that a more comprehensive approach may be necessary to build an interoperable ‘stack’ of extensible declarative languages for model description, simulation protocols, data analysis and so on.</p>
      <p>The layer-oriented approach described in this paper is a methodology to specify the syntax and semantics of several interlinked declarative languages (or layers), each targeted at a particular problem domain, and formally describe how they relate to one another. We refer to syntax as the grammar according to which the sentences of a language are constructed; semantics is the system of rules that gives meaning to those sentences. The layers are not standalone languages, such as in the case of SED-ML, SBML and CellML, but share common properties in order to ensure their compatibility.</p>
      <p>The work presented here was developed prior to the authors' involvement in the NineML effort, which is a model description language developed as part of the Large-Scale Network Modeling initiative of the International Neuroinformatics Coordinating Facility (<ext-link ext-link-type="uri" xlink:href="http://www.incf.org/" xlink:type="simple">http://www.incf.org/</ext-link>) <xref ref-type="bibr" rid="pcbi.1002521-DeSchutter2">[15]</xref>. The design of NineML is also divided in semantic layers, however its focus is on describing large-scale networks of integrate-and-fire neurons, and its design significantly diverges from the language presented here, which is oriented towards conductance-based models of ionic currents.</p>
      <p>The rest of this paper is structured as follows. Section Results gives an informal introduction to an example language for describing ionic currents, presents a high-level overview of the layer-oriented design of the language and highlights several language features necessary to express a complex model of currents in the Purkinje neuron. Section <xref ref-type="sec" rid="s3">Discussion</xref> relates the layer-oriented approach to other model description language efforts and discusses its advantages and limitations. Section <xref ref-type="sec" rid="s4">Methods</xref> presents a detailed syntactic and semantic specification of all layers in the example language and includes a brief summary of pertinent computer science literature.</p>
    </sec>
    <sec id="s2">
      <title>Results</title>
      <p>We propose the layer-oriented approach as a methodology to develop common semantics for declarative biological modeling languages and supporting software tools. The premise of the approach is that computational models of biology are not merely a flat collection of equations, but follow a hierarchical structure that reflects the organization of the actual biological object or process <xref ref-type="bibr" rid="pcbi.1002521-Gennari1">[16]</xref>.</p>
      <p>This work was initially motivated by our attempts to express models of Purkinje neuron currents in a declarative format and to solve the problem of automatically merging together ionic current mechanism descriptions in the NMODL language to reduce simulation run time (see Section Ionic current mechanism mapping problem in NEURON).</p>
      <p>Implementing the necessary model description concepts in an equation-based framework while preserving the neuroscience-specific model structure led us to adopt a general layer-oriented approach, where neuroscience-specific concepts are explicitly mapped onto structured equations. As a result, this approach accommodates a number of additional modeling concepts, supports multiple code generation targets and further offers several advantages:</p>
      <list list-type="order">
        <list-item>
          <p>Semantic unambiguity: every element of a layer-oriented language has exactly one unique mathematical representation.</p>
        </list-item>
        <list-item>
          <p>Extensibility: new elements and corresponding semantics can be added to layer-oriented language in a consistent and unambiguous manner.</p>
        </list-item>
        <list-item>
          <p>Expressiveness: all possible relationships among the entities in a model of a biological system can be described.</p>
        </list-item>
      </list>
      <p>A key assumption of the layer-oriented approach is that the target domain of modeling is sufficiently well-defined so that its concepts can be encoded using the methodology we outline. Thus, the approach might not be necessarily suited for modeling techniques that rely on empirical algorithms, as opposed to a well-understood mathematical theory. This limitation and a possible methodology for community development of a layer-oriented language are discussed in Section When and how to use the layer-oriented approach.</p>
      <p>Furthermore, we emphasize that our approach is concerned specifically with declarative languages. Variations of the layer-oriented approach based on algorithmic languages do exist in computational neuroscience. In Section Declarative and Algorithmic Languages we discuss this distinction and its implications. The introduction of Section <xref ref-type="sec" rid="s4">Methods</xref> relates our approach to computer science literature on domain-specific language design.</p>
      <sec id="s2a">
        <title>The layer-oriented approach by example</title>
        <p>We first informally illustrate the layer-oriented approach with an example language for describing conductance-based ionic current models. Some technical details are omitted here, but complete formal grammar and semantic rules for the language are given in Section <xref ref-type="sec" rid="s4">Methods</xref>. In the following sections we show how to use this language to describe a complex model of ionic currents in the Purkinje neuron.</p>
        <p>The example language provides convenient idioms for common neuroscience modeling concepts. The layer-oriented approach ensures that each language idiom has a consistent mathematical representation that can be understood by each simulation or analysis software we desire to use. Furthermore, we will be able to extend the language by defining new concepts in terms of differential equations and other mathematical abstractions.</p>
        <p>We begin with a representation of a Hodgkin-Huxley-style model, which implicitly relies on several physiological modeling concepts such as Ohmic currents and gating variables.</p>
        <p>For the reader interested in technical details, the syntax presented below uses SXML, an alternative XML Infoset implementation based on Lisp s-expressions <xref ref-type="bibr" rid="pcbi.1002521-Kiselyov1">[17]</xref>. This syntax has an exact equivalent in conventional XML, but the use of s-expressions eliminates the necessity of closing tags and considerably reduces syntactic clutter.</p>
        <p>
          <monospace>(Membrane-potential</monospace>
        </p>
        <p> <monospace>(Membrane-capacitance 1.0 uF/cm*cm)</monospace></p>
        <p> <monospace>(Ohmic-current Na (E = 115 mV) (g_max = 120 mS/cm*cm)</monospace></p>
        <p>  <monospace>(gating m (power 3)</monospace></p>
        <p>   <monospace>(forward-rate (2.5 - 0.1*V)/((exp (2.5 - 0.1*V)) - 1))</monospace></p>
        <p>   <monospace>(reverse-rate (0.125 * exp(-V/80))))</monospace></p>
        <p>  <monospace>(gating h (power 1)</monospace></p>
        <p>   <monospace>(forward-rate …)</monospace></p>
        <p>   <monospace>(reverse-rate …))</monospace></p>
        <p>
          <monospace>) ;; end of Ohmic-current Na</monospace>
        </p>
        <p>
          <monospace>(Ohmic-current K (E = …) (g_max = …)</monospace>
        </p>
        <p>  <monospace>(gating n (power 4)</monospace></p>
        <p>   <monospace>(forward-rate …)</monospace></p>
        <p>   <monospace>(reverse-rate …))</monospace></p>
        <p>
          <monospace>) ;; end of Ohmic-current K</monospace>
        </p>
        <p> <monospace>(Ohmic-current Leak …)</monospace></p>
        <p>
          <monospace>) ;; end of Membrane-potential</monospace>
        </p>
        <p>Although the sentences above are a fairly idiomatic representation of the Hodgkin-Huxley model, we must ensure that the underlying mathematics are consistently represented when this model is loaded in different software environments.</p>
        <p>To meet this requirement we need a language mechanism to automatically transform the above model code into the corresponding equations:</p>
        <p>
          <monospace>Capacitance = 1.0 uF/cm*cm</monospace>
        </p>
        <p>
          <monospace>g_Na = g_max_Na * m_Na * m_Na * m_Na * h_Na</monospace>
        </p>
        <p>
          <monospace>I_Na = g_NA * (V - E_Na)</monospace>
        </p>
        <p>
          <monospace>dm_Na/dt = alpha_m_Na(V) * (1 - m_Na) - beta_m_Na * m_Na</monospace>
        </p>
        <p>
          <monospace>alpha_m (V) = (2.5 - 0.1*V)/((exp (2.5 - 0.1*V)) - 1)</monospace>
        </p>
        <p>
          <monospace>…</monospace>
        </p>
        <p>
          <monospace>V = - (I_Na+I_K+…)/Capacitance</monospace>
        </p>
        <p><xref ref-type="fig" rid="pcbi-1002521-g001">Figure 1</xref> is a conceptual overview of the steps performed by such a transformation mechanism in order to construct ionic current and membrane potential equations. In step A.1 the gating variable declarations are used to construct the gating dynamics equation, and in step A.2 the maximal conductance and reversal potential declarations are combined together to form the complete ionic current equation. In step B.1 all Ohmic current declarations are assembled together and used to construct the membrane potential equation in step B.2.</p>
        <fig id="pcbi-1002521-g001" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g001</object-id>
          <label>Figure 1</label>
          <caption>
            <title>Conceptual overview of the transformation steps involved in generating a membrane potential equation from a collection of Ohmic current definitions.</title>
            <p>Step A.1 obtains the constituent parts of the gating component and constructs the gating dynamics equations. Step A.2 constructs the ionic current equation using the gating variables, maximal conductance and reversal potential declarations. Step B.1 assembles together all Ohmic current declarations and Step B.2 is constructing the membrane potential equation.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g001" xlink:type="simple"/>
        </fig>
        <p>This kind of transformation mechanism is key to ensuring consistency of the mathematical representations of our model. Furthermore, extending the set of available model description concepts then becomes a matter of defining appropriate transformation rules. For example, to accommodate Goldman-Hodgkin-Katz (GHK) currents we use the transformation rules illustrated in <xref ref-type="fig" rid="pcbi-1002521-g002">Figure 2</xref>. This example already demonstrates the extensibility of the layer-oriented approach. <xref ref-type="fig" rid="pcbi-1002521-g002">Figure 2</xref> clearly shows that incorporating this important feature requires only minimal extensions to the structures presented in <xref ref-type="fig" rid="pcbi-1002521-g001">Figure 1</xref>. Note that the gating mechanisms are identical for <xref ref-type="fig" rid="pcbi-1002521-g001">Figures 1A</xref> and <xref ref-type="fig" rid="pcbi-1002521-g002">2A</xref> and that <xref ref-type="fig" rid="pcbi-1002521-g002">Figure 2B</xref> just adds GHK currents at the appropriate structure without disturbing the overall model structure.Analogously with the Ohmic current transformation, step A.1 constructs the gating dynamics and step A.2 constructs the GHK current equation.</p>
        <fig id="pcbi-1002521-g002" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g002</object-id>
          <label>Figure 2</label>
          <caption>
            <title>Conceptual overview of the transformation steps involved in generating a membrane potential equation from a collection of Ohmic and GHK current definitions.</title>
            <p>Step A.1 constructs the gating dynamics equations and extracting the maximal permeability and concentration definition. Step A.2 constructs the ionic current equation using the gating values, the maximal permeability and the GHK equation, which depends on the definitions of concentration. Step B.1 assembles together all Ohmic and GHK current declarations and Step B.2 constructs the membrane potential equation.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g002" xlink:type="simple"/>
        </fig>
        <p>Thus, the layer-oriented approach is primarily concerned with definitions of biological modeling concepts and their equivalent equational form. The transformation from one to the other is explained in detail in the following sections.</p>
      </sec>
      <sec id="s2b">
        <title>Concepts of the layer-oriented approach</title>
        <p>The layer-oriented approach is a structured methodology to define notations for declarative computational models. It involves:</p>
        <list list-type="bullet">
          <list-item>
            <p><italic>language layers</italic>, which are collections of grammatical rules that correspond to concepts from a particular domain, such as computational neuroscience or differential calculus;</p>
          </list-item>
          <list-item>
            <p><italic>semantic transformation functions</italic>, which assign semantics to the layers, in the form of rules that specify how concepts from one layer can be represented by a combination of concepts in another layer.</p>
          </list-item>
        </list>
        <p>The question of which biological modeling and mathematical concepts are chosen and grouped in layers is one that must be properly answered by the scientific community. The layer-oriented approach provides the technical means to formalize the relationships between the domains of biological modeling and mathematical concepts. The process of formalizing these relationships is a way to identify and eliminate potential flaws in the language and to communicate the language semantics in a concise manner. More on this topic can be found in Section When and how to use the layer-oriented approach.</p>
        <p>As a concrete example, <xref ref-type="fig" rid="pcbi-1002521-g003">Figure 3</xref> illustrates the structure and the relationships of several language layers that together can describe the structure of computational neuroscience models of ionic currents as well as voltage clamp protocols, explained below.</p>
        <fig id="pcbi-1002521-g003" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g003</object-id>
          <label>Figure 3</label>
          <caption>
            <title>Conceptual layers of modeling and their relationships.</title>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g003" xlink:type="simple"/>
        </fig>
        <p>The ionic current layer consists of elements that correspond to neuroscience modeling concepts, such as channel gates and ionic conductances. The mathematical layer consists of elements that correspond to general mathematical concepts, such as rate equations and functions.</p>
        <p><xref ref-type="fig" rid="pcbi-1002521-g003">Figure 3</xref> is not meant to be an exhaustive representation of the biological modeling ‘universe’. It can be easily conceived that e.g. adding stochastic differential equations to the mathematical layer will allow a range of stochastic models to be included in the higher layers. The point is that the layer-oriented approach enables such additions to be explicitly and clearly specified while preserving full compatibility with existing definitions, as illustrated with the GHK example in <xref ref-type="fig" rid="pcbi-1002521-g002">Figure 2</xref>.</p>
      </sec>
      <sec id="s2c">
        <title>A metalanguage for describing layers and transformations between them</title>
        <p>In our approach, a semantic transformation function is a collection of rules that specify how concepts from one layer are represented as a combination of concepts from another. An important practical aim is to represent the layers and the transformations between them by means of a mathematical notation that does not have the clutter of programming details inherent to a concrete implementation yet can be easily expressed in any reasonable programming language.</p>
        <p>Thus, the semantic transformation functions in this paper are written in a metalanguage that contains the essence of some typical patterns of programming languages. With this approach, the semantics of layer-oriented language can be described independently of the implementation language by a sequence of various layer transformation functions, e.g.:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e001" xlink:type="simple"/></disp-formula>The sequence of transformation functions comprising <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e002" xlink:type="simple"/></inline-formula> describes a set of common operations necessary to express a model of ionic currents as an environment of equations conforming to the syntax of the equation-oriented mathematical layer (detailed definitions are given in Section <xref ref-type="sec" rid="s4">Methods</xref>).</p>
        <p>The specification of a layer-oriented language then takes the form of semantic transformation functions for all layers, which can be straightforwardly mapped to an implementation. We note here that the metalanguage is not concerned with issues such as error handling for invalid input as these are details unique to each implementation.</p>
        <p>A further practical benefit of this manner of specification is that semantic transformation functions provide a convenient blueprint for code generation, or the process of transforming computational biology models to computer-executable form <xref ref-type="bibr" rid="pcbi.1002521-Goodman1">[18]</xref>, in this specific instance generation of Matlab or NMODL language. The two sequences of transformation functions below describe code generation for two very different software platforms (Matlab and the NEURON simulator) using largely identical sequences of steps (details are given in Section <xref ref-type="sec" rid="s4">Methods</xref>).<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e003" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e004" xlink:type="simple"/></disp-formula></p>
        <p>From a practical standpoint, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e005" xlink:type="simple"/></inline-formula> and its constituent parts need only be implemented once and reside in a standard software library, which can then be shared between multiple simulators and other software that aims to read this particular model description language. Additional information for code generation, such as provided by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e006" xlink:type="simple"/></inline-formula> (needed for NEURON) can also be specified with semantic transformation functions and implemented either as part of the standard library or for specific platforms.</p>
        <p>The transformations specific to neuroscience modeling software are briefly described in the following sections. All transformation functions mentioned in this section are defined in Section <xref ref-type="sec" rid="s4">Methods</xref></p>
      </sec>
      <sec id="s2d">
        <title>Components and structured layer-based models of ionic currents</title>
        <p>Our model examples thus far have included the use of two layers, one for ionic current descriptions and one for equations and functions. The equation layer omitted any of the structure associated with biological interpretation of the equations, such as the gating elements. But the language must have the capability not merely to represent a set of equations, but to group related definitions and equations across layers.</p>
        <p>We therefore introduce the notion of model components, which encapsulate related equations and functions that are part of a model. They are generic entities that are not concerned with how these equations are grouped together and permit arbitrary nesting of sub-components. We further characterize a component by its type and output quantities.</p>
        <p>From the point of view of biological modeling, only particular combinations of nesting are valid. Wimalaratne et al. observed that allowing arbitrary structuring of hierarchical biological models leads to difficulties in model exchange, and therefore we need to define rules that require models of ionic currents to be structured according to the accepted principles of computational biology <xref ref-type="bibr" rid="pcbi.1002521-Wimalaratne1">[19]</xref>.</p>
        <p>The syntax and semantics of the component layer and structuring rules are given in Section <xref ref-type="sec" rid="s4">Methods</xref>. These rules stipulate that the following structure must be followed:</p>
        <p>
          <monospace>(Membrane-potential Modelname</monospace>
        </p>
        <p> <monospace>(Membrane-capacitance (out C)</monospace></p>
        <p>  <monospace>… definition of capacitance …)</monospace></p>
        <p> <monospace>(Ohmic-current (name ion)</monospace></p>
        <p>  <monospace>(gating (out m)</monospace></p>
        <p>   <monospace>… equations for channel gate dynamics …)</monospace></p>
        <p>  <monospace>(pore (out gbar)</monospace></p>
        <p>   <monospace>… equations and parameters of maximal conductance …)</monospace></p>
        <p>  <monospace>(permeating-ion (name ion) (out e)</monospace></p>
        <p>   <monospace>… definition of reversal potential …)))</monospace></p>
        <p>Compared with the previous example, the model structure above explicitly labels the sub-components of the ohmic current component (gating, pore and permeating-ion). While slightly more verbose, this notation allows easier formulation of transformation rules, as we explain in Section <xref ref-type="sec" rid="s4">Methods</xref>.</p>
        <p>These are not intended to be authoritative rules, but an illustration of the capabilities of the layer-oriented approach. A different set of rules can be easily formulated and formalized as determined by discourse in the scientific community. Further details can be found in Section <xref ref-type="sec" rid="s3">Discussion</xref> and Section <xref ref-type="sec" rid="s4">Methods</xref>.</p>
      </sec>
      <sec id="s2e">
        <title>The Khaliq-Raman model of the cerebellar Purkinje neuron</title>
        <p>We have used the prototype language to implement a previously published model of the Purkinje neuron. The component abstraction gives us the ability to construct models as aggregations of components containing definitions of ionic gates, conductances and so on. <xref ref-type="fig" rid="pcbi-1002521-g004">Figure 4</xref> illustrates the component structure of our description of the Khaliq-Raman model of cerebellar Purkinje neurons (ModelDB accession number 48332) <xref ref-type="bibr" rid="pcbi.1002521-Khaliq1">[20]</xref>. The complete prototype listing is given in Supporting <xref ref-type="supplementary-material" rid="pcbi.1002521.s002">Text S1</xref>.</p>
        <fig id="pcbi-1002521-g004" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g004</object-id>
          <label>Figure 4</label>
          <caption>
            <title>Components of a layer-oriented implementation of the Khaliq-Raman model of the Purkinje neuron.</title>
            <p>The model representation in the ionic current layer consists of a set of components that refer to the various biological concepts in the model — membrane capacitance, calcium concentration dynamics and the ionic currents comprising this model. Each component contains mathematical definitions pertaining to those biological concepts.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g004" xlink:type="simple"/>
        </fig>
        <p>Our layer-oriented description of this model consists of the Ohmic and GHK current components already mentioned as well as a calcium concentration dynamics components that will be explained in the following subsections.</p>
        <sec id="s2e1">
          <title>Parametric gating dynamics</title>
          <p>The declarations contained in the <monospace>Ohmic-current</monospace> component shown in <xref ref-type="fig" rid="pcbi-1002521-g004">Figure 4</xref> define four relations that represent activation and inactivation rates and whose expression bodies are omitted from the figure for brevity. The construct <monospace>HH-gating-dynamics</monospace> is a template which is expanded into equations for the two state variables <monospace>m</monospace> and <monospace>h</monospace> using the given rate function expressions.</p>
          <p>Templates are special case of components where the contained equations are required to have certain names. A regular component can contain equations and functions with arbitrary names, but the <monospace>HH-gating-dynamics</monospace> template must contain equations that are exactly called <monospace>m_inf, tau_m,</monospace> etc. In all other aspects, templates are treated in the same manner as the other types of components.</p>
          <p>The transformation function for <monospace>HH-gating-dynamics</monospace> is given in Section <xref ref-type="sec" rid="s4">Methods</xref>.</p>
        </sec>
        <sec id="s2e2">
          <title>Resurgent sodium current</title>
          <p>Although the definitions shown above refer to standard Hodgkin-Huxley-type models, arbitrary reaction rules to represent gate dynamics can be included in the model as long as the correct component interface is used. Moreover, models of additional biophysical processes can be seamlessly incorporated in the functions that compute the channel opening and closing rates.</p>
          <p>The resurgent sodium current in the Khaliq-Raman model uses a 13-state kinetic scheme and therefore we must use the <monospace>Reaction</monospace> type of equation, rather than the <monospace>HH-gating-dynamics</monospace> template. The transformation procedures for the lower-level layers already handle kinetic schemes, as shown in Section <xref ref-type="sec" rid="s4">Methods</xref> and therefore we can represent this type of current without further extensions to the language. A fragment of the resurgent sodium kinetic scheme is shown in the <monospace>Narsg</monospace> component box in <xref ref-type="fig" rid="pcbi-1002521-g004">Figure 4</xref>.</p>
        </sec>
        <sec id="s2e3">
          <title>P-type calcium current</title>
          <p>The Khaliq-Raman model uses the standard Ohmic equation to describe most of its currents and the Goldman-Hodgkin-Katz (GHK) constant field equation <xref ref-type="bibr" rid="pcbi.1002521-Clay1">[21]</xref> to describe its P-type calcium current. As illustrated in the introductory example, this has necessitated the addition of a GHK current transformation function and extending the membrane potential transformation function with an additional clause, following the GHK formulation <xref ref-type="bibr" rid="pcbi.1002521-DeSchutter3">[22]</xref>.</p>
          <p>The definition of the GHK current transformation function is given in Section <xref ref-type="sec" rid="s4">Methods</xref>. It still refers to probability that channel gates are open, however the current equation now refers to a permeability quantity <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e007" xlink:type="simple"/></inline-formula> and no longer includes reversal potential. We have extended the set of component types with the type permeability and use it to encapsulate equations that compute current rather than conductance.</p>
          <p>The CaP current can then be formulated by means of the permeability component, as shown in the the <monospace>CaP</monospace> component box in <xref ref-type="fig" rid="pcbi-1002521-g004">Figure 4</xref>.</p>
          <p>In the code shown in the figure, the external calcium concentration is a constant but the internal concentration is given by variable cai, which does not appear to be defined in the component. As we will see in the next section, the internal concentration dynamics are defined in a separate component, which is not visible in the component defining the CaP current. In the present paper, we address this issue by a global declaration that specifies that the global identifier cai is related to the definitions in the calcium concentration component so that it is visible to declarations from other components:</p>
          <p>
            <monospace>input (cai from decaying-pool ca)</monospace>
          </p>
          <p>The above declaration specifies that the value <monospace>cai</monospace> must come from a component named <monospace>ca</monospace> of type <monospace>decaying-pool</monospace>. An example of such a component comes next.</p>
        </sec>
        <sec id="s2e4">
          <title>Calcium concentration dynamics</title>
          <p>Our description of the Khaliq-Raman model includes the component type <monospace>decaying-pool</monospace>, which is used to encapsulate the calcium concentration dynamics of the model. The representation of this component is the calcium decay equation due to Traub <xref ref-type="bibr" rid="pcbi.1002521-Traub1">[23]</xref>, shown in <xref ref-type="fig" rid="pcbi-1002521-g004">Figure 4</xref>.</p>
          <p>The <monospace>cac</monospace> variable is exported from this component and, because of the input declaration in the previous section the semantic transformations described in Section <xref ref-type="sec" rid="s4">Methods</xref> assign the value <monospace>cac</monospace> to the global <monospace>cai</monospace>.</p>
        </sec>
      </sec>
      <sec id="s2f">
        <title>Simulation experiments</title>
        <p>The layer-oriented approach can be easily applied to describing simulation experiments. The simulation results in <xref ref-type="fig" rid="pcbi-1002521-g005">Figures 5</xref> and <xref ref-type="fig" rid="pcbi-1002521-g006">6</xref> were produced from the same model description with code generated by our prototype implementation of a translator for layer-oriented neuroscience models, as applied to the Khaliq-Raman model. The simulation software used was NEURON 7.1 and GNU Octave 3.2, in both cases running under Debian Linux 5.0 on a Dell Precision T5400 workstation. The code generation algorithm is based on the transformation rules defined in Section <xref ref-type="sec" rid="s4">Methods</xref>. Additional simulation results addressing runtime efficiency in the NEURON simulation environment are described in Section Ionic current mechanism mapping problem in NEURON and presented in Supporting <xref ref-type="supplementary-material" rid="pcbi.1002521.s001">Figure S1</xref>.</p>
        <fig id="pcbi-1002521-g005" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g005</object-id>
          <label>Figure 5</label>
          <caption>
            <title>Comparison between simulation runs of the Khaliq-Raman model under different computing environments.</title>
            <p>NEURON is a software for simulations of neurons and networks of neurons. GNU Octave is an open-source equivalent to Matlab. The NEURON simulation was conducted with NEURON 7.1 using the cvode method, and the GNU Octave simulation was conducted with Octave 3.2 using the RADAU solver from the OdePkg toolbox version 0.6.10. In both cases, the software was run under Debian Linux 5.0 on a Dell Precision T5400 computer (CPU Intel Xeon E5430 2.66 GHz). The difference in how the respective simulation platforms compute the initial values for the resurgent sodium current causes the initial discrepancy between the two simulation runs.</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g005" xlink:type="simple"/>
        </fig>
        <fig id="pcbi-1002521-g006" position="float">
          <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g006</object-id>
          <label>Figure 6</label>
          <caption>
            <title>Comparison between voltage clamp simulation of the Khaliq-Raman model under different computing environments.</title>
            <p>The NEURON simulation was conducted with NEURON 7.1 using the cvode method, and the GNU Octave simulation was conducted with Octave 3.2 using the RADAU solver from the OdePkg toolbox version 0.6.10. In both cases, the software was run under Debian Linux 5.0 on a Dell Precision T5400 computer (CPU Intel Xeon E5430 2.66 GHz).</p>
          </caption>
          <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g006" xlink:type="simple"/>
        </fig>
        <p>The transformation functions for simulation experiments are given in Section <xref ref-type="sec" rid="s4">Methods</xref>. We define two new types of components, <monospace>simulation</monospace> and <monospace>voltage-clamp</monospace>, and use them to specify simulation and voltage clamp parameters for the different currents of the model, e.g.:</p>
        <p>
          <monospace>(simulation (out duration stepsize)</monospace>
        </p>
        <p> <monospace>(const duration = 2000)</monospace></p>
        <p> <monospace>(const stepsize = 1e-4)</monospace></p>
        <p>
          <monospace>)</monospace>
        </p>
        <p>
          <monospace>(voltage-clamp (name CaBK)</monospace>
        </p>
        <p> <monospace>(out hold base stepsize nsteps holding-duration base-duration)</monospace></p>
        <p> <monospace>(const hold = −90)</monospace></p>
        <p> <monospace>(const base = −40)</monospace></p>
        <p> <monospace>(const stepsize = 10)</monospace></p>
        <p> <monospace>(const nsteps = 5)</monospace></p>
        <p> <monospace>(const holding-duration = 5)</monospace></p>
        <p> <monospace>(const base-duration = 20))</monospace></p>
        <p>The semantics associated with each component of type <monospace>voltage-clamp</monospace> require that there must be a corresponding ionic current component of the same name. This then allows the generation of voltage clamp scripts that are consistent with the currents of the model.</p>
        <sec id="s2f1">
          <title>Ionic current mechanism mapping problem in NEURON</title>
          <p>To aid the construction of models and simulations the NEURON simulation environment provides a number of predefined constructs that correspond to familiar neuroscience idioms. User-defined mechanisms, such as voltage- and ligand-gated ion channels, diffusion, buffering, etc., can be added to the default set of mechanisms by writing model descriptions in NMODL, an equation-oriented declarative language.</p>
          <p>These mechanisms are often structured such that there is a one-to-one mapping between NMODL files (.mod extension) and ionic current mechanism descriptions (7 A).</p>
          <p>However, it is frequently advantageous to combine the descriptions of several mechanisms in the same NMODL file so that their equations can be solved together, in order to improve the numerical efficiency of the simulation. Unfortunately, the standard NEURON software does not provide means to merge mechanism descriptions automatically and users are forced to maintain large NMODL files that are difficult to read and understand. Ideally, the modeling language must permit an easy-to-read model description that can be automatically transformed into efficient code (<xref ref-type="fig" rid="pcbi-1002521-g007">Figure 7 B</xref>).</p>
          <fig id="pcbi-1002521-g007" position="float">
            <object-id pub-id-type="doi">10.1371/journal.pcbi.1002521.g007</object-id>
            <label>Figure 7</label>
            <caption>
              <title>Ion channel mechanism mapping problem in NEURON.</title>
              <p>A) standard approach; B) merging of several ion channel mechanisms in order to improve efficiency. Our layer-oriented code generation tool generates the .mod files, the .c files are generated by NEURON.</p>
            </caption>
            <graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.g007" xlink:type="simple"/>
          </fig>
          <p>The difficulty in combining the ionic current equations together comes from the fact that the same variable names may be used for equations that belong to different types of ionic currents. This is not a problem as long as these equations reside in separate NMODL files, however merging them together presents the risk of collisions between common variable names (e.g. <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e008" xlink:type="simple"/></inline-formula>) and therefore the users must resort to a very careful (and possibly verbose) coding style to ensure unique naming.</p>
          <p>This issue is naturally solved by the modularity and semantic unambiguity of our approach because the equations for each ionic current reside in separate components and a renaming step in the transformation function ensures that each variable has a unique name that is prefixed by the name of the component (specified in detail in Section <xref ref-type="sec" rid="s4">Methods</xref>). Furthermore, each ionic-current component contains information identifying the ionic species, which is used to combine the current equations for all channels of a given ionic species.</p>
          <p>As a result, the NMODL code generator implemented in our prototype software allows a very systematic methodology for exploration of NEURON's performance. We have conducted a number of performance benchmarks with the Khaliq-Raman model, as detailed in Supporting <xref ref-type="supplementary-material" rid="pcbi.1002521.s001">Figure S1</xref>. The average simulation time using merged mechanism descriptions was reduced by 18.5% when using NEURON's variable time step solver and by 22.3% when using NEURON's fixed time step solver.</p>
        </sec>
      </sec>
    </sec>
    <sec id="s3">
      <title>Discussion</title>
      <p>The shortcomings of existing standardization efforts suggest that future work should address the formal specification of mathematical concepts and the mapping of high-level modeling concepts to computational representation. This will make it possible to uniformly describe, share and use a new modeling technique within the same language. In particular, we believe that the layer-oriented approach has the following advantages over the existing approaches.</p>
      <sec id="s3a">
        <title>Semantic unambiguity</title>
        <p>The different domains and subdomains of computational biology each require that models are structured according to the accepted terminology and classification of that domain. Therefore, successful development of future biological modeling languages will depend on appropriately formalised representation of domain knowledge. One common approach to developing such formalizations are the multiple ontological efforts to represent various biological entities for multiple levels of granularity <xref ref-type="bibr" rid="pcbi.1002521-Burgun1">[24]</xref>.</p>
        <p>Our layer-oriented approach complements ontologies with the systematic development of domain-specific language rules so that the conventions and categories of the domain are distinctly and clearly represented to the user, while generality is preserved by the underlying layers that provide access to general mathematical and algorithmic concepts.</p>
      </sec>
      <sec id="s3b">
        <title>Extensibility</title>
        <p>By ‘extensibility’ we mean functionality to describe new modeling techniques in addition to those provided by standard model databases.</p>
        <p>For example, suppose that a scientist wishes to use conditional expressions in the mathematical layer of a layer-based language, which is necessary for e.g. threshold detection in the integrate-and-fire formalism <xref ref-type="bibr" rid="pcbi.1002521-Brunel1">[25]</xref>.</p>
        <p>In such a case, the mathematical layer can be extended with conditional primitives to express transitions between dynamical systems and the neuroscience modeling layer can be extended with a regime concept, which encapsulates the subthreshold equations and specifies the firing condition and reset equation. The mapping between the high-level regime concept and the condition primitives can be defined by a semantic transformation function.</p>
        <p>As another example, suppose that a scientist wishes to integrate morphological descriptions in a layer-based language. While the examples in this paper do not address geometric descriptions and partial differential equations the same transformation approaches can be applied to define complex surfaces and dynamics based on core abstractions for spatial PDEs.</p>
        <p>Once the precise hierarchy of concepts and mathematical mechanisms are defined by the community, a layer-oriented language can allow scientists using the language to formally describe new approaches and make them shareable without having to alter the core language specification, as must be done for NeuroML.</p>
      </sec>
      <sec id="s3c">
        <title>Expressiveness</title>
        <p>As already observed by Wimalaratne, et al., explicitly defined hierarchical structuring rules are a necessity for many kinds of biological modeling. As we discuss in Section Existing biological modeling languages, some of the key evolutionary improvements in existing and emerging modeling languages are related to modularity, hierarchical structuring and expressing relationships between different components of a biological model. These properties are well-addressed in our approach by means of compositionality.</p>
        <p>We refer as compositionality to the ability to compose a model from pre-existing parts. For example, given a set of standard ion channel objects from a model library and a set of parameters provided by the user, the equations for the model could be automatically constructed depending on the chosen channel objects.</p>
        <p>A sophisticated component model is required to support descriptions such as a dendritic maximal conductance that is dependent on distance from the soma <xref ref-type="bibr" rid="pcbi.1002521-Migliore1">[26]</xref>. In order to support such functionality, the language must have formal semantics for composition and extension.</p>
        <p>Layer-based components in a biological modeling language can express different functional and structural relationships and allow scientists to invent and share their own components, as well as build on the existing mechanisms.</p>
      </sec>
      <sec id="s3d">
        <title>When and how to use the layer-oriented approach</title>
        <p>One of the most important problems facing biological modeling languages is formulating the extent and requirements of the target domain. The layer-oriented approach provides the technical means to formalize the relationships between the domains of biological modeling and mathematical formalisms, but the researchers who wish to design and use such a language must already have some informal understanding of these relationships.</p>
        <p>Once the domain is well-defined in terms of mathematical formalisms, as is the case with deterministic models of ionic currents in computational neuroscience, our layer-oriented approach can be applied by constructing a formal grammar for the language and corresponding transformation rules that explicitly link the biological modeling concepts to mathematical formalisms. As we show in Section <xref ref-type="sec" rid="s4">Methods</xref>, the transformation rules can be written in a metalanguage that generalizes the typical patterns of programming languages without the operational details of a real implementation. The process of writing and understanding such rules assists researchers in clarifying and refining the semantics of the language, as Scott and Strachey showed in their influential work on programming language specification <xref ref-type="bibr" rid="pcbi.1002521-Scott1">[27]</xref>, <xref ref-type="bibr" rid="pcbi.1002521-Schmidt1">[28]</xref>.</p>
        <p>Constructing a set of transformation rules for a given biological modeling concept may be a whole scientific endeavor, such as, for example, approximating the voltage dynamics of 3D cell membranes with the 1D cable formalism commonly used in computational neuroscience <xref ref-type="bibr" rid="pcbi.1002521-Rall1">[29]</xref>.</p>
        <p>Furthermore, our approach relies on a mathematical language that is sufficiently rich to formulate all concepts and problems of the scientific field of interest. The development of computational science suggests that mathematical languages based on ODEs and PDEs are well-suited to express many theories and concepts of physics and chemistry. However, additional formalisms, such as stochastic equations, may be necessary to model problems in computational biology. The layer-oriented approach as a method for interoperability assumes that such additional formalisms would be consistently supported by several software platforms.</p>
        <p>It is possible that for some biological concepts there exist semantic ambiguities, i.e. several alternative mathematical formulations. The layer-oriented approach is modular and can accommodate different sets of transformation rules for the same concepts in the form of namespaces or modules <xref ref-type="bibr" rid="pcbi.1002521-Jagannathan1">[30]</xref>, but ultimately it is the responsibility of the language designers to use such technical tools to resolve the differences between the mathematical approaches.</p>
        <p>The layer-oriented approach would not be applicable in a case where a biological modeling concept has only an empirical algorithmic representation and no consistent underlying mathematical theory. This is a consequence of the declarative nature of the approach. For example, the exact stochastic simulation algorithm (SSA) is widely used in computational biology <xref ref-type="bibr" rid="pcbi.1002521-Gillespie1">[31]</xref>. However, the necessity to simulate every reaction event causes the algorithm to be too slow for some applications. An approximation strategy known as tau-leaping sacrifices exactness for reduced computational cost <xref ref-type="bibr" rid="pcbi.1002521-Gillespie2">[32]</xref>. At present there is no widely adopted declarative generalization of SSA and tau-leaping, although proposals have been made <xref ref-type="bibr" rid="pcbi.1002521-Spicher1">[33]</xref>. Applying the layer-oriented approach to modeling problems based on tau-leaping, or other approximations of SSA, would require that the various decision procedures involved are represented in a declarative form that reflects the underlying mathematical model. In this sense our approach is limited by the scientific understanding of the concepts in the particular modeling domain.</p>
        <p>Another important aspect of designing biological modeling language is the process of community validation. For instance, the community validation process of SBML Level 3 involves having at least two independent software implementations of a proposed feature before that feature can be considered for inclusion in the standard. From our personal observations on the development process of the emerging NineML language, the NineML committee has also converged on peer-reviewing implementation code as means to ensure that prototype implementations of the language not only have the same grammar, but also have consistent and community-approved semantics. However, the informal processes of SBML and NineML are limited by the fact that code in different programming languages cannot in general be directly compared. The layer-oriented approach is a way to lift this restriction. It enables the community first to agree on the semantic transformation rules, then to relate them to particular software implementation. It does not mandate a particular implementation, or a particular programming language, and thus can be used by a diverse community of developers. As a further step in language specification, the layer-oriented approach opens the possibility for using mathematical reasoning methodologies <xref ref-type="bibr" rid="pcbi.1002521-Paulson1">[34]</xref> to formally prove that a particular software implementation is faithful to a particular set of semantic transformation rules.</p>
      </sec>
      <sec id="s3e">
        <title>Declarative and algorithmic languages</title>
        <p>Variations of the layer-oriented approach are not new to computational neuroscience. The NEURON simulator has pioneered the use of an introspective interpreter (HOC or Python) and a declarative model description language (NMODL) for extending the available modeling mechanisms.</p>
        <p>However, the work presented here is specifically concerned with layers of purely declarative languages. In our approach, the interfaces between layers are explicitly specified in an implementation-neutral mathematical notation and additional layers can be introduced in a consistent and conceptually clear manner. In contrast, simulators such as NEURON typically employ an algorithmic language for experiment control and a declarative language for model equations, and the details of interfacing the two languages are unique to the particular software implementation.</p>
        <p>Declarative languages describe problems in a particular domain, and possibly some properties of the desired solutions, rather than explicit mechanisms for computing solutions <xref ref-type="bibr" rid="pcbi.1002521-Hanus1">[35]</xref>, <xref ref-type="bibr" rid="pcbi.1002521-Lloyd1">[36]</xref>. Algorithmic languages take the form of stepwise machine instructions for performing computation. Algorithmic languages have much greater expressive power than declarative ones, however they introduce operational details that might be entirely irrelevant to the higher-level concepts that they express.</p>
        <p>Because of the expressiveness of algorithmic languages, it could be argued that all tasks in neuroscience simulation and modeling could be accomplished with a combination of NMODL and HOC or Python, or similar combination of declarative and algorithmic languages. However, the many engineering details of interfacing such languages – variable scoping, data representation and propagation, control flow – would make any such combination of languages unique and difficult to comprehend and to replicate in different software implementations.</p>
        <p>Because in our approach each layer is declarative and constrained to a specific purpose, a complete set of rules can be given for how the different layers relate to one another and how executable code can be generated from a layer-based description. Such rules then provide a convenient blueprint for consistent and interoperable software implementations.</p>
      </sec>
      <sec id="s3f">
        <title>Existing biological modeling languages</title>
        <sec id="s3f1">
          <title>NeuroML</title>
          <p>The primary goals of the NeuroML family of modeling languages <xref ref-type="bibr" rid="pcbi.1002521-Gleeson1">[6]</xref>, <xref ref-type="bibr" rid="pcbi.1002521-Goddard1">[7]</xref> are ability to express commonly used concepts in computational neuroscience and support of a large number of published models. To achieve these goals, the NeuroML development team has been focused on defining language concepts that closely correspond to the modeling idioms used by existing and well-established simulators, such as NEURON and GENESIS.</p>
          <p>However, a number of sweeping changes to the language were found necessary by the NeuroML team when it was decided to support the PSICS software <xref ref-type="bibr" rid="pcbi.1002521-Cannon2">[37]</xref> as a simulation platform. This restructuring revealed some weaknesses of NeuroML 1.x, which are consistent with our experiences with describing the Khaliq-Raman model using ChannelML versions 1.6.x and 1.7.1. We can summarize these weaknesses in the following categories:</p>
          <list list-type="order">
            <list-item>
              <p>Lack of formally-defined semantics for the elements of the language: The ChannelML 1.x standard does not give the precise mathematical definition of its concepts, nor how each concept relates to the other structures in the language. It merely states that a ‘ChannelType’ entity could contain an ‘hh_gate’ or a ‘ks_gate’, but the proper mathematical and/or algorithmic background is not given anywhere in the specification.</p>
              <p>The problem with this approach is that it is very difficult to ensure consistent semantics when transforming ChannelML models to code for particular simulators and analysis software, such as NEURON and XPP <xref ref-type="bibr" rid="pcbi.1002521-Ermentrout1">[38]</xref>.</p>
            </list-item>
            <list-item>
              <p>A lack of means to specify conductance and current laws: The lack of a mathematical model for ChannelML means that no support is provided for non-Ohmic definitions of conductance and current, such as the Goldman-Hodgkin-Katz formalism.</p>
            </list-item>
          </list>
        </sec>
        <sec id="s3f2">
          <title>SBML and CellML</title>
          <p>SBML <xref ref-type="bibr" rid="pcbi.1002521-Hucka1">[8]</xref>, <xref ref-type="bibr" rid="pcbi.1002521-Hucka2">[9]</xref> and CellML <xref ref-type="bibr" rid="pcbi.1002521-Cuellar1">[10]</xref> are two well-known XML-based model exchange formats used in the life sciences. SBML in particular is well supported by a wide array of software packages. SBML is designed so as to capture several biophysical concepts at the core language level. For example, chemical reactions and species are an integral part of the language core. SBML was originally developed for exchange of monolithic models between simulation programs and its Level 1 and 2 specifications did not support reusable model components <xref ref-type="bibr" rid="pcbi.1002521-Hucka3">[39]</xref>. SBML Level 3 is developed as a modular language and its specification is organized in a central core and extension packages layered on top of this core <xref ref-type="bibr" rid="pcbi.1002521-Hucka1">[8]</xref>.</p>
          <p>CellML version 1.1 is more abstract and provides a component abstraction with flexibility sufficient to model different types of biological concepts. A CellML component can be an entirely conceptual entity created for modeling convenience, or it can have some real physical interpretation (for example, it could represent the cell membrane). CellML allows several kinds of relationships between components to be expressed, such as containment or connectivity.</p>
          <p>However, the component model of CellML 1.1 does not permit user-defined component relationships in a semantically meaningful way, nor does it support parametric components. Furthermore, the CellML specification offers few guidelines for how to produce well-structured, layered models. A mathematical model of a biological process can be represented in CellML in many different ways and the structure of a model mainly depends on the style of the individual author. Wimalaratne et al. have published guidelines for structuring CellML models, which encourage hierarchical structuring and reusable components with generic mathematical expressions <xref ref-type="bibr" rid="pcbi.1002521-Wimalaratne1">[19]</xref>. But as the CellML specification and tools do not currently support the codification of these informal guidelines, the biophysical concepts isolated in one CellML model cannot be conveyed in a machine-readable format to the software that interprets this model.</p>
        </sec>
        <sec id="s3f3">
          <title>InsilicoML</title>
          <p>InsilicoML (ISML) is a language that can explicitly describe hierarchical structures of physiological functions in a mathematical model <xref ref-type="bibr" rid="pcbi.1002521-Asai1">[40]</xref>. In ISML, each part of a model is called a module and relationships between modules are defined as edges. ISML is fully compatible with CellML 1.0 and adds features to annotate models with ontological information and links to model databases.</p>
          <p>ISML features extensive support for spatial PDEs and its modularity features are an evolutionary improvement over CellML. Two unique features of ISML are the morphology and time series data types, which allow direct integration of models with experimental data.</p>
          <p>Efforts such as ISML highlight the importance of layered semantic specification for biological modeling languages. In systems biology, models that integrate heterogeneous experimental data, which are stored in numerous life-science databases, can have considerable errors in data integration if different sources do not describe their information consistently <xref ref-type="bibr" rid="pcbi.1002521-Philippi1">[41]</xref>. Furthermore, a layer-oriented approach can be used to formally describe the features unique to ISML and incorporate them in other modeling languages and existing software.</p>
        </sec>
        <sec id="s3f4">
          <title>PyNN</title>
          <p>PyNN is a software package for simulator-independent specification of neuronal network models <xref ref-type="bibr" rid="pcbi.1002521-Davison1">[42]</xref>. PyNN allows the users to write network model code in the Python programming language, and then run it without modification on any of the four simulators supported by PyNN.</p>
          <p>The PyNN API is mainly aimed at describing populations of neurons and the connections between them. Neuronal dynamics are described not on the equation level, but are referenced via a library of standard neuron types. PyNN can express concepts commonly found in neuronal network modeling, however the exact computational semantics remain implicit in the targeted simulator platforms.</p>
          <p>Reproducibility of results in different simulators can be achieved with PyNN only for those models that are a part of the pre-defined neuron library. Extending the repertoire of models supported by PyNN is achieved by implementing the necessary extensions in Python using specific internal APIs.</p>
          <p>Our approach differs than that of PyNN in two ways. First, the layer-oriented language presented here is not a collection of models, but a collection of general concepts, such as Ohmic currents and differential equations, that can be then utilized to build particular models. This means that, as long as a model is expressible with these concepts, executable code can be automatically generated for this model by applying common semantic transformation rules and performing a final code generation step for the specific executable target.</p>
          <p>Second, the specification of a layer-based model description language is intended to be independent of the semantics of the implementation language and thus our semantic transformation rules are given in a notation that is easy to encode in general-purpose programming languages, but is not biased towards a specific one. If, for example, one wished to implement some or all of the functionality of PyNN in a language such as Java, then they must find a way to translate the idioms of Python and the data structures and algorithms of PyNN to a suitable and idiomatic Java representation. Our semantic transformation rules rely on simple pattern match (destructuring), function call, list/set construction and decomposition. These are all operations present in the popular programming languages of today and thus it is possible for PyNN to accommodate our semantic transformation functions.</p>
        </sec>
      </sec>
      <sec id="s3g">
        <title>Summary</title>
        <p>Designing modeling languages involves the translation of the concepts of the domain into semantic concepts appropriate for computer representation. Often the transformation from domain-specific concepts into computer code cannot be done in a single step but requires several intermediate steps. The layer-oriented approach is an attempt to discern these intermediate semantic steps.</p>
        <p>The layer-oriented approach relies heavily on model structuring. Structuring is a common modeling technique of dividing an object into a number of parts and indicating relationships between these parts. In this way quite naturally a layered model arises. Our prototype language defines a form of structuring based on components that allows models of arbitrary complexity to be constructed. In this way, the language provides extensibility and flexibility in describing new models that involve detailed biophysical modeling.</p>
      </sec>
    </sec>
    <sec id="s4" sec-type="methods">
      <title>Methods</title>
      <p>Our approach is inspired by the work of Scott and Strachey on the mathematical foundations of the semantics of programming languages <xref ref-type="bibr" rid="pcbi.1002521-Scott1">[27]</xref>. Scott and Strachey attempted to formalize and make explicit the meta-theories intuitively employed by language designers, and developed solid mathematical methods for language engineering <xref ref-type="bibr" rid="pcbi.1002521-Schmidt1">[28]</xref>. Their approach resulted in clear, concise and unambiguous specification of programming language semantics and compiler transformations.</p>
      <p>Among the innovations of Scott and Strachey was a calculus for semantic description in the form of a minimal metalanguage based on the lambda calculus <xref ref-type="bibr" rid="pcbi.1002521-Cardone1">[43]</xref>. Our metalanguage is based on a small subset of the Standard ML programming language <xref ref-type="bibr" rid="pcbi.1002521-Milner1">[44]</xref> and is summarized in the following section.</p>
      <p>While the present paper cannot include an exhaustive discussion of the software engineering methods for constructing a layer-oriented language, Paulson's “ML for the Working Programmer” <xref ref-type="bibr" rid="pcbi.1002521-Paulson1">[34]</xref> has a practical introduction on modeling domain concepts as mathematical objects, while Gunter's textbook on semantics <xref ref-type="bibr" rid="pcbi.1002521-Gunter1">[45]</xref> is an in-depth treatise on the mathematical foundations of programming languages.</p>
      <p>From the point of view of domain-specific languages, our approach is most closely related to the pipeline pattern identified by Spinellis <xref ref-type="bibr" rid="pcbi.1002521-Spinellis1">[46]</xref>. The pipeline pattern involves a chain of domain-specific language processors that are each dedicated to a specific sub-language. As Spinellis points out, “often a system can best be described using a family of DSLs,” and, “the use of the pipeline pattern encourages the division of responsibility among small specialised DSLs and discourages bloated feature-rich language designs.” Our approach refines the pipeline pattern in that all possible transformation paths are explicit, thus allowing a more rigorous process of validating and extending the language, but possibly at the loss of some flexibility.</p>
      <sec id="s4a">
        <title>Metalanguage definitions</title>
        <p>The following syntactic constructs are used in the metalanguage:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e009" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e010" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e011" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e012" xlink:type="simple"/></disp-formula>Expressions in the metalanguage are typically constructors for the various data structures that correspond to the domain-specific syntaxes discussed in this paper. For example, the definition<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e013" xlink:type="simple"/></disp-formula>means that metafunction <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e014" xlink:type="simple"/></inline-formula> matches the sequence consisting of the symbol <monospace>const</monospace>, followed by the pattern variable <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e015" xlink:type="simple"/></inline-formula> (which must be of a defined type), the symbol = and the pattern variable <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e016" xlink:type="simple"/></inline-formula>. The result of the function is an entry constructed using the pattern variables and the <monospace>Parameter</monospace> constructor defined previously.</p>
      </sec>
      <sec id="s4b">
        <title>An ionic current description language</title>
        <p>The language we have developed for describing models of ionic currents has a hierarchical structure that is meant to reflect the logical relationships between the different parts of ionic current descriptions. For example, an Ohmic current consists of ionic current name, gating dynamics description and maximal conductance definition.</p>
        <p>The syntax of this language in Backus-Naur form <xref ref-type="bibr" rid="pcbi.1002521-Backus1">[47]</xref> is given below. We note that the definition of the Equation domain is not part of this language but refers to the equation-oriented language in the next section.<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e017" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e018" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e019" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e020" xlink:type="simple"/></disp-formula></p>
      </sec>
      <sec id="s4c">
        <title>An equation-oriented language</title>
        <p>We base our layer-oriented approach on a domain-specific language that is capable of expressing differential and algebraic equations and later use it to construct complex models of ionic currents.</p>
        <p>The language has a simple syntax for expressing relations and first-order differential equations, and we define a transformation function on this syntax that transforms every declaration in the language to an intermediate form suitable for further processing, such as code generation, or some type of model transformation, such as parameter perturbation.</p>
        <p>The syntax of this language in Backus-Naur form is:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e021" xlink:type="simple"/></disp-formula><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e022" xlink:type="simple"/></inline-formula> [Constant during integration]</p>
        <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e023" xlink:type="simple"/></inline-formula> [Algebraic equation]</p>
        <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e024" xlink:type="simple"/></inline-formula> [Relation]</p>
        <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e025" xlink:type="simple"/></inline-formula> [ODE of the form dx/dt = e]</p>
        <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e026" xlink:type="simple"/></inline-formula> [Forward kinetic scheme]</p>
        <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e027" xlink:type="simple"/></inline-formula> [Forward and reverse kinetic scheme]</p>
      </sec>
      <sec id="s4d">
        <title>Identifiers, entities, environments</title>
        <p>The equation-oriented language is transformed to an intermediate semantic form suitable for further processing. We use an intermediate language of the following form:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e028" xlink:type="simple"/></disp-formula>where</p>
        <list list-type="bullet">
          <list-item>
            <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e029" xlink:type="simple"/></inline-formula> is the identifier we use to refer to this entity;</p>
          </list-item>
          <list-item>
            <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e030" xlink:type="simple"/></inline-formula> is one of <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e031" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e032" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e033" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e034" xlink:type="simple"/></inline-formula>, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e035" xlink:type="simple"/></inline-formula></p>
          </list-item>
          <list-item>
            <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e036" xlink:type="simple"/></inline-formula> represents the argument of a relation or the state variables in ODEs and reactions;</p>
          </list-item>
          <list-item>
            <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e037" xlink:type="simple"/></inline-formula> is the right-hand side arithmetic expression</p>
          </list-item>
        </list>
        <p>The transformation function <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e038" xlink:type="simple"/></inline-formula> describes the process of creating new entities:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e039" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e040" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e041" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e042" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e043" xlink:type="simple"/></disp-formula></p>
        <p>Entities are characterized by name, type and expression. However, we must use these entities together in order to solve the corresponding system of equations. We use an environment structure in which entities are indexed by name and type, and which can be queried to extract information for further model processing. We represent environments by a function<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e044" xlink:type="simple"/></disp-formula>which we call the current environment of entities. We use the metafunction notation <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e045" xlink:type="simple"/></inline-formula> to express the extension of the current environment with a new entity.</p>
      </sec>
      <sec id="s4e">
        <title>Component language</title>
        <p>The syntax of the component language in Backus-Naur form is:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e046" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e047" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e048" xlink:type="simple"/></disp-formula></p>
        <p>We use the set of types defined above to identify structures specific to ionic current models, although the schema of supported types can be naturally extended to support a broader range of modeling concepts. The transformation function <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e049" xlink:type="simple"/></inline-formula> transforms the component syntax into nested environments:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e050" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e051" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e052" xlink:type="simple"/></disp-formula></p>
        <p>The metafunction <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e053" xlink:type="simple"/></inline-formula> returns the set of names defined in the given environment. The transformation function <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e054" xlink:type="simple"/></inline-formula> is as defined before. We do not define the case when the list of output entities is not a subset of the entities defined in the given component, but a real implementation must signal an error in such case.</p>
        <p>Furthermore, although our definitions allow the nesting of environments, our target numerical platforms, such as Matlab, do not necessarily support namespace control. In order to generate code for such environments, we must conduct <italic>flattening</italic> of the nested environments, so that all identifiers can occupy the same namespace without collision.</p>
        <p>The transformation function <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e055" xlink:type="simple"/></inline-formula> flattens nested environments by replacing all identifiers with explicit paths based on their enclosing environments:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e056" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e057" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e058" xlink:type="simple"/></disp-formula></p>
        <p>The metafunction <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e059" xlink:type="simple"/></inline-formula> substitutes identifiers in an expression, given a substitution environment that maps identifiers to expressions. The metafunction <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e060" xlink:type="simple"/></inline-formula> builds nested substitution environments: during the substitution process, if an identifier is not found in the immediate environment, it is looked up in the enclosing environment, and so on.</p>
      </sec>
      <sec id="s4f">
        <title>Membrane potential transformation function</title>
        <p>Let <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e061" xlink:type="simple"/></inline-formula> denote the set of components of type <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e062" xlink:type="simple"/></inline-formula> contained in the environment <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e063" xlink:type="simple"/></inline-formula>. Let <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e064" xlink:type="simple"/></inline-formula> indicate the outputs declared for component <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e065" xlink:type="simple"/></inline-formula>. <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e066" xlink:type="simple"/></inline-formula> can then be defined as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e067" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e068" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e069" xlink:type="simple"/></disp-formula></p>
        <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e070" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e071" xlink:type="simple"/></inline-formula> take an additional argument, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e072" xlink:type="simple"/></inline-formula>, which indicates the current scope, or environment nesting path. The path specified by <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e073" xlink:type="simple"/></inline-formula> is used to disambiguate the variable names that are used in the current and voltage equations that are constructed by the transformation functions.</p>
        <p>The transformation functions defined above require that ionic current models consist of one component of type <monospace>membrane-capacitance</monospace>, and one or more components of type <monospace>Ohmic-current</monospace>. Components of type <monospace>Ohmic-current</monospace> must in turn contain one or more components of type <monospace>gating</monospace> (gate dynamics), one component of type <monospace>pore</monospace> (maximal conductance) and one component of type <monospace>permeating-ion</monospace> (reversal potential).</p>
        <p>The <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e074" xlink:type="simple"/></inline-formula> procedure takes input in the form of nested environments. We rely on the metafunctions <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e075" xlink:type="simple"/></inline-formula> and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e076" xlink:type="simple"/></inline-formula> to perform operations on a list of components. <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e077" xlink:type="simple"/></inline-formula> applies a given function to every member of a list of components and returns a list of the results. <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e078" xlink:type="simple"/></inline-formula> (also known as <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e079" xlink:type="simple"/></inline-formula> in Python or <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e080" xlink:type="simple"/></inline-formula> in C++) iterates a given function over a list of components and builds up a cumulative result.</p>
      </sec>
      <sec id="s4g">
        <title>Gating dynamics transformation function</title>
        <p>The transformation function for HH-gating-dynamics has the following definition:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e081" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e082" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e083" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e084" xlink:type="simple"/></disp-formula></p>
      </sec>
      <sec id="s4h">
        <title>Extended membrane potential transformation function</title>
        <p>To support the GHK formalism, we first extend the grammar of the ionic current description language from the beginning of this section with the requisite clauses:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e085" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e086" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e087" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e088" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e089" xlink:type="simple"/></disp-formula>Then <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e090" xlink:type="simple"/></inline-formula> must be extended with matching clauses:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e091" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e092" xlink:type="simple"/></disp-formula></p>
      </sec>
      <sec id="s4i">
        <title>Abstract code generation</title>
        <p>Having defined the structures for describing ionic currents and component-based systems of equations, we can now define a transformation function that takes in an environment of entities as input and produces code for a given solver API. We abstract away the details of implementation by using idealized mathematical structures that mimic the structure of the target API. Nevertheless, we indicate what procedures are necessary to turn our abstract notation into concrete programming language syntax.</p>
        <p>We first define a code generation function for a Matlab-like language, following the API required by the Matlab ODE solver: <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e093" xlink:type="simple"/></inline-formula> where <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e094" xlink:type="simple"/></inline-formula> receives the independent variable <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e095" xlink:type="simple"/></inline-formula> and a state vector <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e096" xlink:type="simple"/></inline-formula> and must return the vector of derivatives that corresponds to the given input.</p>
        <p>In order to proceed with code generation, we must have the following representation of the system of equations:</p>
        <list list-type="bullet">
          <list-item>
            <p>An ordered list of parameters and algebraic assignments: if any assignments or parameters depend on one another, we must order them appropriately and ensure no circular assignments are present.</p>
          </list-item>
          <list-item>
            <p>A list of relations: relations take the form of function declarations in Matlab and most other numerical computing environments.</p>
          </list-item>
          <list-item>
            <p>A list of differential equations</p>
          </list-item>
          <list-item>
            <p>A mapping that assigns integer indices to state variable names: we use this mapping to retrieve state values from the initial state vector and to construct the vector of derivatives.</p>
          </list-item>
        </list>
        <p>We first define transformation function, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e097" xlink:type="simple"/></inline-formula>, which computes the free variables of every expression and orders the entries in the environment according the dependencies in their associated expression:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e098" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e099" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e100" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e101" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e102" xlink:type="simple"/></disp-formula>where the metafunction <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e103" xlink:type="simple"/></inline-formula> computes the free variables in an expression, and <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e104" xlink:type="simple"/></inline-formula> inserts a new entry in an ordered collection according to a partial order predicate:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e105" xlink:type="simple"/></disp-formula></p>
        <p>Given an ordered environment <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e106" xlink:type="simple"/></inline-formula>, we can now define a transformation function to construct a structure suitable for input to code generation procedures. In this particular case, our target structure is a 5-tuple of the form:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e107" xlink:type="simple"/></disp-formula>The last element in the tuple is a mapping between state vector indices and state variable names.</p>
        <p>The transformation function can then be defined as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e108" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e109" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e110" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e111" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e112" xlink:type="simple"/></disp-formula>We use the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e113" xlink:type="simple"/></inline-formula> characters to indicate tuple construction, the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e114" xlink:type="simple"/></inline-formula> metafunction to indicate list concatenation and the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e115" xlink:type="simple"/></inline-formula> metafunction returns the largest integer plus one from the given map.</p>
        <p>The concrete code generation procedures can be defined as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e116" xlink:type="simple"/></disp-formula>Each of the <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e117" xlink:type="simple"/></inline-formula> metafunctions are relatively simple procedures that map the abstract representation to the concrete syntax of the target language. foreach applies the given procedure to each element of the given list.</p>
        <sec id="s4i1">
          <title>Code generation specific to neuroscience modeling software</title>
          <p>From a code generation point of view, the component mechanism facilitates the generation of code for neuroscience-specific software environments, such as NEURON. The code generation process for NMODL uses the same transformation functions as for Matlab, but it requires one additional transformation function, <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e118" xlink:type="simple"/></inline-formula>.</p>
          <p><inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e119" xlink:type="simple"/></inline-formula> extracts information about the ionic currents and gate complexes present in the model description and uses this information to generate declarations required for NMODL. The structure with information specific to ionic current models has the following definition:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e120" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e121" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e122" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e123" xlink:type="simple"/></disp-formula></p>
          <p>This structure contains the definitions of ionic currents, along with information about the names of permeating and accumulating ions. This is necessary in order to generate the appropriate USEION and RANGE statements for NMODL.</p>
          <p>The transformation function to build <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e124" xlink:type="simple"/></inline-formula> takes entities as input and can be defined as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e125" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e126" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e127" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e128" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e129" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e130" xlink:type="simple"/></disp-formula>In the definition above, + is the string concatenation operator and is used to construct names for the ionic currents and reversal potentials for the specified ionic species.</p>
          <p>The NMODL code generation function can be defined as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e131" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e132" xlink:type="simple"/></disp-formula></p>
        </sec>
        <sec id="s4i2">
          <title>Simulation experiment code generation</title>
          <p>The code generation procedures for simulation experiments are analogous with those in the previous sections. We assume that the simulation code generators for particular platforms take the form of templates instantiated by substitution, such as the ones employed by the Brian simulator <xref ref-type="bibr" rid="pcbi.1002521-Goodman1">[18]</xref>.</p>
          <p>In the case of voltage clamp simulation experiments, we assume the following template interface:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e133" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e134" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e135" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e136" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e137" xlink:type="simple"/></disp-formula>That is, we assume the target voltage clamp procedure receives a model name, names of the current variables and a list of voltage clamp parameters for each current.</p>
          <p>The transformation function for voltage clamp script generation is then:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e138" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e139" xlink:type="simple"/></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e140" xlink:type="simple"/></disp-formula>The procedure <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1002521.e141" xlink:type="simple"/></inline-formula> collects all voltage clamp parameter sets from the given model environment and, if the given current names correspond to the model current names, replaces the membrane potential equation with an equation that keeps the potential at the given initial value.</p>
        </sec>
      </sec>
      <sec id="s4j">
        <title>Implementation study</title>
        <p>We have conducted an implementation study of a prototype layer-oriented language for describing models of ionic currents. The implemented prototype is closely related to the semantics presented in this paper, but is not identical. The software is available for download at <ext-link ext-link-type="uri" xlink:href="http://wiki.call-cc.org/nemo" xlink:type="simple">http://wiki.call-cc.org/nemo</ext-link>. It is developed in the Scheme programming language using the Chicken Scheme compiler (<ext-link ext-link-type="uri" xlink:href="http://www.call-cc.org/" xlink:type="simple">http://www.call-cc.org/</ext-link>). The Scheme and Lisp family of languages have a long tradition of domain-specific language development <xref ref-type="bibr" rid="pcbi.1002521-Shivers1">[48]</xref> and are intrinsically suitable for XML processing <xref ref-type="bibr" rid="pcbi.1002521-Kiselyov1">[17]</xref>.</p>
      </sec>
    </sec>
    <sec id="s5">
      <title>Supporting Information</title>
      <supplementary-material id="pcbi.1002521.s001" mimetype="image/tiff" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.s001" xlink:type="simple">
        <label>Figure S1</label>
        <caption>
          <p><bold>NEURON simulation run times averaged over 100 trials.</bold> A) NMODL mechanisms merged into one file; B) NMODL mechanisms in separate files. In all cases, NEURON 7.1 was used for 2000 ms of simulation time. Method cnexp indicates that NEURON's modified Crank-Nicolson method is used for solving the equations of all currents. Method cnexp+sparse indicates that NEURON's special method for kinetic equations is used for solving the equations of the resurgent sodium current and the modified Crank-Nicolson method is used for solving the equations of all other currents. Method cvode indicates that the CVODE variable step method is used for solving the equations of all currents. The hardware used was Dell Precision T5400 (CPU Intel Xeon E5430 2.66 GHz) for the Linux platform, and Apple Computer MacPro1,1 (CPU Intel Xeon 5150 2.66 GHz×2) for the Mac OS X platform.</p>
          <p>(TIF)</p>
        </caption>
      </supplementary-material>
      <supplementary-material id="pcbi.1002521.s002" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1002521.s002" xlink:type="simple">
        <label>Text S1</label>
        <caption>
          <p><bold>A layer-oriented description of the 2003 Purkinje neuron model due to Khaliq et al.</bold> Shown are two representations of the model. The first utilizes a concise parenthesized syntax, which is more convenient for human users to write. The second is canonical XML representation suitable for automatic exchange between different software. The two formats are completely interchangeable and our prototype software NEMO supports reading and writing both.</p>
          <p>(PDF)</p>
        </caption>
      </supplementary-material>
    </sec>
  </body>
  <back>
    <ack>
      <p>The authors wish to thank Sungho Hong and Mario Negrello for comments on early drafts, Iain Hepburn for punctuation corrections, as well as the anonymous reviewers whose constructive comments contributed significantly to improving the paper. The authors also wish to extend special thanks to the Chicken Scheme community for developing and maintaining the Chicken compiler and software ecosystem, which have been used to develop the prototype software for this paper.</p>
    </ack>
    <ref-list>
      <title>References</title>
      <ref id="pcbi.1002521-Cannon1">
        <label>1</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Cannon</surname><given-names>R</given-names></name><name name-style="western"><surname>Gewaltig</surname><given-names>MO</given-names></name><name name-style="western"><surname>Gleeson</surname><given-names>P</given-names></name><name name-style="western"><surname>Bhalla</surname><given-names>U</given-names></name><name name-style="western"><surname>Cornelis</surname><given-names>H</given-names></name><etal/></person-group>             <year>2007</year>             <article-title>Interoperability of neuro-science modeling software: Current status and future directions.</article-title>             <source>Neuroinformatics</source>             <volume>5</volume>             <fpage>127</fpage>             <lpage>138</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-DeSchutter1">
        <label>2</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>De Schutter</surname><given-names>E</given-names></name></person-group>             <year>2008</year>             <article-title>Why are computational neuroscience and systems biology so separate?</article-title>             <source>PLoS Comput Biol</source>             <volume>4</volume>             <fpage>e1000078</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Bower1">
        <label>3</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Bower</surname><given-names>J</given-names></name><name name-style="western"><surname>Beeman</surname><given-names>D</given-names></name></person-group>             <year>1998</year>             <source>The Book of GENESIS: Exploring Realistic Neural Models with the GEneral NEural SImulation System</source>             <publisher-loc>New York</publisher-loc>             <publisher-name>Springer-Verlag</publisher-name>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Carnevale1">
        <label>4</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Carnevale</surname><given-names>N</given-names></name><name name-style="western"><surname>Hines</surname><given-names>M</given-names></name></person-group>             <year>2006</year>             <source>The NEURON Book</source>             <publisher-loc>UK</publisher-loc>             <publisher-name>Cambridge University Press</publisher-name>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Hodgkin1">
        <label>5</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hodgkin</surname><given-names>A</given-names></name><name name-style="western"><surname>Huxley</surname><given-names>A</given-names></name></person-group>             <year>1952</year>             <article-title>A quantitative description of membrane current and its application to conduction and excitation in nerve.</article-title>             <source>J Physiol</source>             <volume>117</volume>             <fpage>500</fpage>             <lpage>544</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Gleeson1">
        <label>6</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gleeson</surname><given-names>P</given-names></name><name name-style="western"><surname>Crook</surname><given-names>S</given-names></name><name name-style="western"><surname>Cannon</surname><given-names>R</given-names></name><name name-style="western"><surname>Hines</surname><given-names>M</given-names></name><name name-style="western"><surname>Billings</surname><given-names>G</given-names></name><etal/></person-group>             <year>2010</year>             <article-title>NeuroML: A language for describing data driven models of neurons and networks with a high degree of biological detail.</article-title>             <source>PLoS Comput Biol</source>             <volume>6</volume>             <fpage>e1000815</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Goddard1">
        <label>7</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Goddard</surname><given-names>N</given-names></name><name name-style="western"><surname>Hucka</surname><given-names>M</given-names></name><name name-style="western"><surname>Howell</surname><given-names>F</given-names></name><name name-style="western"><surname>Cornelis</surname><given-names>H</given-names></name><name name-style="western"><surname>Shankar</surname><given-names>K</given-names></name><etal/></person-group>             <year>2001</year>             <article-title>Towards NeuroML: Model description methods for collaborative modeling in neuroscience.</article-title>             <source>Philos Trans R Soc Lond B Biol Sci</source>             <volume>356</volume>             <fpage>1209</fpage>             <lpage>1228</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Hucka1">
        <label>8</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hucka</surname><given-names>M</given-names></name><name name-style="western"><surname>Bergmann</surname><given-names>F</given-names></name><name name-style="western"><surname>Hoops</surname><given-names>S</given-names></name><name name-style="western"><surname>Keating</surname><given-names>S</given-names></name><name name-style="western"><surname>Sahle</surname><given-names>S</given-names></name><etal/></person-group>             <year>2010</year>             <article-title>Sys- tems biology markup language (SBML) Level 3 Version 1 Core.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://sbml.org/Documents/Specifications/SBML_Level_3" xlink:type="simple">http://sbml.org/Documents/Specifications/SBML_Level_3</ext-link>. Accessed 7 April 2012</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Hucka2">
        <label>9</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hucka</surname><given-names>M</given-names></name><name name-style="western"><surname>Finney</surname><given-names>A</given-names></name><name name-style="western"><surname>Bornstein</surname><given-names>B</given-names></name><name name-style="western"><surname>Keating</surname><given-names>S</given-names></name><name name-style="western"><surname>Shapiro</surname><given-names>B</given-names></name><etal/></person-group>             <year>2004</year>             <article-title>Evolving a lingua franca and associated software infrastructure for computational systems biology: the systems biology markup language (SBML) project.</article-title>             <source>Syst Biol</source>             <volume>1</volume>             <fpage>41</fpage>             <lpage>53</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Cuellar1">
        <label>10</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Cuellar</surname><given-names>A</given-names></name><name name-style="western"><surname>Nielsen</surname><given-names>P</given-names></name><name name-style="western"><surname>Bullivant</surname><given-names>D</given-names></name><name name-style="western"><surname>Hunter</surname><given-names>P</given-names></name></person-group>             <year>2003</year>             <article-title>CellML 1.1 for the definition and exchange of biological models.</article-title>             <source>Proceedings of the 5th IFAC Symposium on Modelling and Control in Biomedical Systems</source>             <fpage>451</fpage>             <lpage>456</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Cuellar2">
        <label>11</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Cuellar</surname><given-names>A</given-names></name><name name-style="western"><surname>Nielsen</surname><given-names>P</given-names></name><name name-style="western"><surname>Hallstead</surname><given-names>M</given-names></name><name name-style="western"><surname>Bullivant</surname><given-names>D</given-names></name><name name-style="western"><surname>Nickerson</surname><given-names>D</given-names></name></person-group>             <year>2002</year>             <article-title>CellML specification version 1.1.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://www.cellml.org/specifications/cellml_1.1" xlink:type="simple">http://www.cellml.org/specifications/cellml_1.1</ext-link>. Accessed 7 April 2012</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Raikov1">
        <label>12</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Raikov</surname><given-names>I</given-names></name><name name-style="western"><surname>De Schutter</surname><given-names>E</given-names></name></person-group>             <year>2012</year>             <article-title>The promise and shortcomings of XML as an interchange format for computational models of biology.</article-title>             <source>Neuroinformatics</source>             <volume>10</volume>             <fpage>1</fpage>             <lpage>3</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Koehn1">
        <label>13</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Koehn</surname><given-names>D</given-names></name><name name-style="western"><surname>Novere</surname><given-names>N</given-names></name></person-group>             <year>2008</year>             <article-title>SED-ML – An XML Format for the Implementation of the MIASE Guidelines.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Heiner</surname><given-names>M</given-names></name><name name-style="western"><surname>Uhrmacher</surname><given-names>A</given-names></name></person-group>             <source>Computational Methods in Systems Biology</source>             <publisher-name>Springer</publisher-name>             <fpage>176</fpage>             <lpage>190</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Bergmann1">
        <label>14</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Bergmann</surname><given-names>F</given-names></name></person-group>             <year>2010</year>             <article-title>A simple nested simulation for SED-ML.</article-title>             <comment>Nature Precedings. Available: <ext-link ext-link-type="uri" xlink:href="http://precedings.nature.com/documents/4257/version/2" xlink:type="simple">http://precedings.nature.com/documents/4257/version/2</ext-link>. Accessed 7 April 2012</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-DeSchutter2">
        <label>15</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>De Schutter</surname><given-names>E</given-names></name></person-group>             <year>2009</year>             <article-title>The International Neuroinformatics Coordinating Facility: evaluating the first years.</article-title>             <source>Neuroinformatics</source>             <volume>7</volume>             <fpage>161</fpage>             <lpage>163</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Gennari1">
        <label>16</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gennari</surname><given-names>J</given-names></name><name name-style="western"><surname>Neal</surname><given-names>M</given-names></name><name name-style="western"><surname>Galdzicki</surname><given-names>M</given-names></name><name name-style="western"><surname>Cook</surname><given-names>D</given-names></name></person-group>             <year>2011</year>             <article-title>Multiple ontologies in action: Composite annotations for biosimulation models.</article-title>             <source>J Biomed Inform</source>             <volume>44</volume>             <fpage>146</fpage>             <lpage>154</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Kiselyov1">
        <label>17</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Kiselyov</surname><given-names>O</given-names></name></person-group>             <year>2004</year>             <article-title>XML in Scheme, version 3.0.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://okmij.org/ftp/Scheme/SXML.html" xlink:type="simple">http://okmij.org/ftp/Scheme/SXML.html</ext-link>. Accessed 7 April 2012</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Goodman1">
        <label>18</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Goodman</surname><given-names>D</given-names></name></person-group>             <year>2010</year>             <article-title>Code generation: a strategy for neural network simulators.</article-title>             <source>Neuroinformatics</source>             <volume>8</volume>             <fpage>183</fpage>             <lpage>196</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Wimalaratne1">
        <label>19</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Wimalaratne</surname><given-names>S</given-names></name><name name-style="western"><surname>Halstead</surname><given-names>M</given-names></name><name name-style="western"><surname>Lloyd</surname><given-names>C</given-names></name><name name-style="western"><surname>Cooling</surname><given-names>M</given-names></name><name name-style="western"><surname>Crampin</surname><given-names>E</given-names></name><etal/></person-group>             <year>2009</year>             <article-title>Facilitating modularity and reuse: guidelines for structuring CellML 1.1 models by isolating common biophysical concepts.</article-title>             <source>Exp Physiol</source>             <volume>94</volume>             <fpage>472</fpage>             <lpage>485</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Khaliq1">
        <label>20</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Khaliq</surname><given-names>Z</given-names></name><name name-style="western"><surname>Gouwens</surname><given-names>N</given-names></name><name name-style="western"><surname>Raman</surname><given-names>I</given-names></name></person-group>             <year>2003</year>             <article-title>The contribution of resurgent sodium current to high- frequency firing in Purkinje neurons: An experimental and modeling study.</article-title>             <source>J Neurosci</source>             <volume>23</volume>             <fpage>4899</fpage>             <lpage>4912</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Clay1">
        <label>21</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Clay</surname><given-names>J</given-names></name></person-group>             <year>2009</year>             <article-title>Determining K+ channel activation curves from K+ channel currents often requires the Goldman-Hodgkin-Katz equation.</article-title>             <source>Front Cell Neurosci</source>             <volume>3</volume>             <fpage>20</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-DeSchutter3">
        <label>22</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>De Schutter</surname><given-names>E</given-names></name><name name-style="western"><surname>Smolen</surname><given-names>P</given-names></name></person-group>             <year>1998</year>             <article-title>Calcium dynamics in large neuronal models.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Koch</surname><given-names>C</given-names></name><name name-style="western"><surname>Segev</surname><given-names>I</given-names></name></person-group>             <source>Methods in neuronal modeling: From ions to networks. 2nd edition</source>             <publisher-name>MIT Press</publisher-name>             <fpage>211</fpage>             <lpage>250</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Traub1">
        <label>23</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Traub</surname><given-names>R</given-names></name></person-group>             <year>1982</year>             <article-title>Simulation of intrinsic bursting in CA3 hippocampal neurons.</article-title>             <source>Neuroscience</source>             <volume>7</volume>             <fpage>1233</fpage>             <lpage>1242</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Burgun1">
        <label>24</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Burgun</surname><given-names>A</given-names></name><name name-style="western"><surname>Bodenreider</surname><given-names>O</given-names></name></person-group>             <year>2008</year>             <article-title>Accessing and integrating data and knowledge for biomedical research.</article-title>             <source>Yearb Med Inform</source>             <volume>2008</volume>             <fpage>91</fpage>             <lpage>101</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Brunel1">
        <label>25</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Brunel</surname><given-names>N</given-names></name></person-group>             <year>2010</year>             <article-title>Modeling point neurons: From Hodgkin-Huxley to integrate-and-fire.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>De Schutter</surname><given-names>E</given-names></name></person-group>             <source>Computational Modeling Methods for Neuroscientists</source>             <publisher-name>MIT Press</publisher-name>             <fpage>161</fpage>             <lpage>186</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Migliore1">
        <label>26</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Migliore</surname><given-names>M</given-names></name><name name-style="western"><surname>Hoffman</surname><given-names>D</given-names></name><name name-style="western"><surname>Magee</surname><given-names>J</given-names></name><name name-style="western"><surname>Johnston</surname><given-names>D</given-names></name></person-group>             <year>1999</year>             <article-title>Role of an A-type K+ conductance in the back- propagation of action potentials in the dendrites of hippocampal pyramidal neurons.</article-title>             <source>J Comput Neurosci</source>             <volume>7</volume>             <fpage>5</fpage>             <lpage>15</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Scott1">
        <label>27</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Scott</surname><given-names>D</given-names></name><name name-style="western"><surname>Strachey</surname><given-names>C</given-names></name></person-group>             <year>1971</year>             <article-title>Toward a mathematical semantics for computer languages.</article-title>             <source>Proceedings of the Symposium on Computers and Automata</source>             <fpage>19</fpage>             <lpage>46</lpage>             <comment>volume XXI</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Schmidt1">
        <label>28</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Schmidt</surname><given-names>D</given-names></name></person-group>             <year>2000</year>             <article-title>Induction, domains, calculi: Strachey's contributions to programming-language engineering.</article-title>             <source>Higher-Order and Symbolic Computation</source>             <volume>13</volume>             <fpage>89</fpage>             <lpage>101</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Rall1">
        <label>29</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Rall</surname><given-names>W</given-names></name><name name-style="western"><surname>Agmon-Snir</surname><given-names>H</given-names></name></person-group>             <year>1998</year>             <article-title>Cable theory for dendritic neurons.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Koch</surname><given-names>C</given-names></name><name name-style="western"><surname>Segev</surname><given-names>I</given-names></name></person-group>             <source>Methods in neuronal modeling: From ions to networks. 2nd edition</source>             <publisher-name>MIT Press</publisher-name>             <fpage>27</fpage>             <lpage>92</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Jagannathan1">
        <label>30</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Jagannathan</surname><given-names>S</given-names></name></person-group>             <year>1994</year>             <article-title>Metalevel building blocks for modular systems.</article-title>             <source>ACM Trans Program Lang Syst</source>             <volume>16</volume>             <fpage>456</fpage>             <lpage>492</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Gillespie1">
        <label>31</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gillespie</surname><given-names>D</given-names></name></person-group>             <year>2007</year>             <article-title>Stochastic simulation of chemical kinetics.</article-title>             <source>Annu Rev Phys Chem</source>             <volume>58</volume>             <fpage>35</fpage>             <lpage>55</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Gillespie2">
        <label>32</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gillespie</surname><given-names>D</given-names></name></person-group>             <year>2001</year>             <article-title>Approximate accelerated stochastic simulation of chemically reacting systems.</article-title>             <source>Annu Rev Phys Chem</source>             <volume>115</volume>             <fpage>1716</fpage>             <lpage>1733</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Spicher1">
        <label>33</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Spicher</surname><given-names>A</given-names></name><name name-style="western"><surname>Michel</surname><given-names>O</given-names></name><name name-style="western"><surname>Giavitto</surname><given-names>J</given-names></name><name name-style="western"><surname>Prusinkiewicz</surname><given-names>P</given-names></name></person-group>             <year>2008</year>             <article-title>Stochastic p systems and the simulation of biochemical processes with dynamic compartments.</article-title>             <source>Biosystems</source>             <volume>91</volume>             <fpage>458</fpage>             <lpage>473</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Paulson1">
        <label>34</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Paulson</surname><given-names>L</given-names></name></person-group>             <year>1996</year>             <article-title>Reasoning about functional programs.</article-title>             <source>ML for the working programmer. 2nd edition</source>             <publisher-name>Cambridge University Press</publisher-name>             <fpage>213</fpage>             <lpage>256</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Hanus1">
        <label>35</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hanus</surname><given-names>M</given-names></name></person-group>             <year>2007</year>             <article-title>Multi-paradigm declarative languages.</article-title>             <source>Proceedings of the 23rd International Conference on Logic Programming (ICLP)</source>             <publisher-name>Springer-Verlag</publisher-name>             <fpage>45</fpage>             <lpage>75</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Lloyd1">
        <label>36</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Lloyd</surname><given-names>J</given-names></name></person-group>             <year>1994</year>             <article-title>Practical advantages of declarative programming.</article-title>             <source>Proceedings of the 1994 Joint Conference on Declarative Programming, GULP-PRODE'94</source>             <fpage>18</fpage>             <lpage>30</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Cannon2">
        <label>37</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Cannon</surname><given-names>R</given-names></name><name name-style="western"><surname>O'Donnell</surname><given-names>C</given-names></name><name name-style="western"><surname>Nolan</surname><given-names>M</given-names></name></person-group>             <year>2010</year>             <article-title>Stochastic ion channel gating in dendritic neurons: Morphology dependence and probabilistic synaptic activation of dendritic spikes.</article-title>             <source>PLoS Comput Biol</source>             <volume>6</volume>             <fpage>e1000886</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Ermentrout1">
        <label>38</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Ermentrout</surname><given-names>B</given-names></name></person-group>             <year>2002</year>             <article-title>Simulating, Analyzing, and Animating Dynamical Systems: A Guide to XPPAUT for Researchers and Students.</article-title>             <comment>SIAM</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Hucka3">
        <label>39</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hucka</surname><given-names>M</given-names></name><name name-style="western"><surname>Finney</surname><given-names>A</given-names></name><name name-style="western"><surname>Hoops</surname><given-names>S</given-names></name><name name-style="western"><surname>Keating</surname><given-names>S</given-names></name><name name-style="western"><surname>Novere</surname><given-names>N</given-names></name></person-group>             <year>2008</year>             <article-title>Systems biology markup language (SBML) Level 2 Version 4: Structures and facilities for model definitions.</article-title>             <comment>Available: <ext-link ext-link-type="uri" xlink:href="http://sbml.org/Documents/Specifications/SBML_Level_2/Version_4" xlink:type="simple">http://sbml.org/Documents/Specifications/SBML_Level_2/Version_4</ext-link>. Accessed 7 April 2012</comment>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Asai1">
        <label>40</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Asai</surname><given-names>Y</given-names></name><name name-style="western"><surname>Suzuki</surname><given-names>Y</given-names></name><name name-style="western"><surname>Kido</surname><given-names>Y</given-names></name><name name-style="western"><surname>Oka</surname><given-names>H</given-names></name><name name-style="western"><surname>Heien</surname><given-names>E</given-names></name></person-group>             <year>2008</year>             <article-title>Specifications of insilicoML 1.0: A multilevel biophysical model description language.</article-title>             <source>J Physiol Sci</source>             <volume>58</volume>             <fpage>447</fpage>             <lpage>458</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Philippi1">
        <label>41</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Philippi</surname><given-names>S</given-names></name><name name-style="western"><surname>Koehler</surname><given-names>J</given-names></name></person-group>             <year>2006</year>             <article-title>Addressing the problems with life-science databases for traditional uses and systems biology.</article-title>             <source>Nat Rev Genet</source>             <volume>7</volume>             <fpage>482</fpage>             <lpage>488</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Davison1">
        <label>42</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Davison</surname><given-names>A</given-names></name><name name-style="western"><surname>Bruederle</surname><given-names>D</given-names></name><name name-style="western"><surname>Eppler</surname><given-names>J</given-names></name><name name-style="western"><surname>Kremkow</surname><given-names>J</given-names></name><name name-style="western"><surname>Muller</surname><given-names>E</given-names></name><etal/></person-group>             <year>2008</year>             <article-title>PyNN: a common interface for neuronal network simulators.</article-title>             <source>Front Neuroinform</source>             <volume>2</volume>             <fpage>11</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Cardone1">
        <label>43</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Cardone</surname><given-names>F</given-names></name><name name-style="western"><surname>Hindley</surname><given-names>J</given-names></name></person-group>             <year>2009</year>             <article-title>Lambda-calculus and combinators in the 20th century.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Woods</surname><given-names>J</given-names></name><name name-style="western"><surname>Gabbay</surname><given-names>D</given-names></name></person-group>             <source>Handbook of the History of Logic: Volume 5 – Logic From Russell to Church</source>             <publisher-loc>North Holland</publisher-loc>             <publisher-name>Elsevier</publisher-name>             <fpage>723</fpage>             <lpage>817</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Milner1">
        <label>44</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Milner</surname><given-names>R</given-names></name><name name-style="western"><surname>Tofte</surname><given-names>M</given-names></name><name name-style="western"><surname>Harper</surname><given-names>R</given-names></name><name name-style="western"><surname>MacQueen</surname><given-names>D</given-names></name></person-group>             <year>1997</year>             <source>The Definition of Standard ML, Revised Edition</source>             <publisher-name>MIT Press</publisher-name> <!--===== Restructure page-count as size[@units="page"] =====--><size units="page">130</size>           </element-citation>
      </ref>
      <ref id="pcbi.1002521-Gunter1">
        <label>45</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gunter</surname><given-names>C</given-names></name></person-group>             <year>1992</year>             <source>Semantics of programming languages: structures and techniques</source>             <publisher-name>MIT Press</publisher-name>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Spinellis1">
        <label>46</label>
        <element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Spinellis</surname><given-names>D</given-names></name></person-group>             <year>2001</year>             <article-title>Notable design patterns for domain specific languages.</article-title>             <source>J Syst Softw</source>             <volume>56</volume>             <fpage>9199</fpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Backus1">
        <label>47</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Backus</surname><given-names>J</given-names></name><name name-style="western"><surname>Bauer</surname><given-names>F</given-names></name><name name-style="western"><surname>Green</surname><given-names>J</given-names></name><name name-style="western"><surname>Katz</surname><given-names>C</given-names></name><name name-style="western"><surname>McCarthy</surname><given-names>J</given-names></name><etal/></person-group>             <year>1997</year>             <article-title>Revised report on the algorithmic language ALGOL 60.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>O'Hearn</surname><given-names>P</given-names></name></person-group>             <source>ALGOL-like Languages, Volume 1</source>             <publisher-loc>Boston</publisher-loc>             <publisher-name>Birkhauser</publisher-name>             <fpage>19</fpage>             <lpage>49</lpage>          </element-citation>
      </ref>
      <ref id="pcbi.1002521-Shivers1">
        <label>48</label>
        <element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Shivers</surname><given-names>O</given-names></name></person-group>             <year>1996</year>             <article-title>A universal scripting framework or Lambda: the ultimate “little language”.</article-title>             <source>Concurrency and Parallelism: Programming, Networking and Security</source>             <publisher-name>Springer-Verlag</publisher-name>             <fpage>254</fpage>             <lpage>265</lpage>          </element-citation>
      </ref>
    </ref-list>
    
  </back>
</article>