<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="3.0" xml:lang="en" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-15-00802</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1004579</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
</article-categories>
<title-group>
<article-title>Temporal Gillespie Algorithm: Fast Simulation of Contagion Processes on Time-Varying Networks</article-title>
<alt-title alt-title-type="running-head">Temporal Gillespie Algorithm</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<name name-style="western">
<surname>Vestergaard</surname> <given-names>Christian L.</given-names></name>
<xref ref-type="aff" rid="aff001"/>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Génois</surname> <given-names>Mathieu</given-names></name>
<xref ref-type="aff" rid="aff001"/>
</contrib>
</contrib-group>
<aff id="aff001">
<addr-line>Aix Marseille Université, Université de Toulon, CNRS, CPT, UMR 7332, Marseille, France</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Salathé</surname> <given-names>Marcel</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1"><addr-line>Ecole Polytechnique Federale de Lausanne, SWITZERLAND</addr-line></aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<fn fn-type="con" id="contrib001">
<p>Conceived and designed the experiments: CLV MG. Performed the experiments: CLV. Analyzed the data: CLV. Contributed reagents/materials/analysis tools: CLV. Wrote the paper: CLV MG.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">cvestergaard@gmail.com</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<month>10</month>
<year>2015</year>
</pub-date>
<pub-date pub-type="epub">
<day>30</day>
<month>10</month>
<year>2015</year>
</pub-date>
<volume>11</volume>
<issue>10</issue>
<elocation-id>e1004579</elocation-id>
<history>
<date date-type="received">
<day>19</day>
<month>5</month>
<year>2015</year>
</date>
<date date-type="accepted">
<day>2</day>
<month>10</month>
<year>2015</year>
</date>
</history>
<permissions>
<copyright-year>2015</copyright-year>
<copyright-holder>Vestergaard, Génois</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1004579" xlink:type="simple"/>
<abstract>
<p>Stochastic simulations are one of the cornerstones of the analysis of dynamical processes on complex networks, and are often the only accessible way to explore their behavior. The development of fast algorithms is paramount to allow large-scale simulations. The Gillespie algorithm can be used for fast simulation of stochastic processes, and variants of it have been applied to simulate dynamical processes on static networks. However, its adaptation to temporal networks remains non-trivial. We here present a temporal Gillespie algorithm that solves this problem. Our method is applicable to general Poisson (constant-rate) processes on temporal networks, stochastically exact, and up to multiple orders of magnitude faster than traditional simulation schemes based on rejection sampling. We also show how it can be extended to simulate non-Markovian processes. The algorithm is easily applicable in practice, and as an illustration we detail how to simulate both Poissonian and non-Markovian models of epidemic spreading. Namely, we provide pseudocode and its implementation in C++ for simulating the paradigmatic Susceptible-Infected-Susceptible and Susceptible-Infected-Recovered models and a Susceptible-Infected-Recovered model with non-constant recovery rates. For empirical networks, the temporal Gillespie algorithm is here typically from 10 to 100 times faster than rejection sampling.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author Summary</title>
<p>When studying how e.g. diseases spread in a population, intermittent contacts taking place between individuals—through which the infection spreads—are best described by a time-varying network. This object captures both their complex structure and dynamics, which crucially affect spreading in the population. The dynamical process in question is then usually studied by simulating it on the time-varying network representing the population. Such simulations are usually time-consuming, especially when they require exploration of different parameter values. We here show how to adapt an algorithm originally proposed in 1976 to simulate chemical reactions—the Gillespie algorithm—to speed up such simulations. Instead of checking at each time-step if each possible reaction takes place, as traditional rejection sampling algorithms do, the Gillespie algorithm determines what reaction takes place next and at what time. This offers a substantial speed gain by doing away with the many rejected trials of the traditional methods, with the added benefit of giving stochastically exact results. In practice this new temporal Gillespie algorithm is tens to hundreds of times faster than the current state-of-the-art, opening up for thorough characterization of spreading phenomena and fast large-scale applications such as the simulation of city- or world-wide epidemics.</p>
</abstract>
<funding-group>
<funding-statement>This work was supported by the EU FET project MULTIPLEX 317532 to CLV and the French ANR HARMS-flu, ANR-12-MONU-0018 to MG. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="8"/>
<table-count count="3"/>
<page-count count="28"/>
</counts>
<custom-meta-group>
<custom-meta id="data-availability" xlink:type="simple">
<meta-name>Data Availability</meta-name>
<meta-value>All relevant data are within the paper and its Supporting Information files.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<disp-quote>
<p>This is a <italic>PLoS Computational Biology</italic> Methods paper.</p>
</disp-quote>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Networks have emerged as a natural description of complex systems and their dynamics [<xref ref-type="bibr" rid="pcbi.1004579.ref001">1</xref>], notably in the case of spreading phenomena, such as social contagion, rumor and information spreading, or epidemics [<xref ref-type="bibr" rid="pcbi.1004579.ref001">1</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref003">3</xref>]. The dynamics of contagion processes occurring on a network are usually complex, and analytical results are attainable only in special cases [<xref ref-type="bibr" rid="pcbi.1004579.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref004">4</xref>]. Furthermore, such results almost systematically involve approximations [<xref ref-type="bibr" rid="pcbi.1004579.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref004">4</xref>]. Numerical studies based on stochastic simulations are therefore necessary, both to verify analytical approximations, and to study the majority of cases for which no analytical results exist. The development of fast algorithms is thus important for the characterization of contagion phenomena, and for large-scale applications such as simulations of world-wide epidemics [<xref ref-type="bibr" rid="pcbi.1004579.ref002">2</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref005">5</xref>].</p>
<p>The Doob-Gillespie algorithm [<xref ref-type="bibr" rid="pcbi.1004579.ref006">6</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref011">11</xref>] (also known as Gillespie’s <italic>Stochastic Simulation Algorithm—SSA</italic> or <italic>Gillespie’s direct method</italic>), originally proposed by David Kendall in 1950 for simulating birth-death processes and made popular by Daniel Gillespie in 1976 for the simulation of coupled chemical reactions, offers an elegant way to speed up such simulations by doing away with the many rejected trials of traditional Monte Carlo methods. Instead of checking at each time-step if each possible reaction takes place, as rejection sampling algorithms do, the Gillespie algorithm draws directly the time elapsed until the next reaction takes place and what reaction takes place at that time. It is readily adapted to the simulation of Poisson processes on static networks [<xref ref-type="bibr" rid="pcbi.1004579.ref012">12</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref016">16</xref>] and can be generalized to non-Markovian processes [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>].</p>
<p>Systems in which spreading processes take place, e.g., social, technological, infrastructural, or ecological systems, are not static though. Individuals create and break contacts at time-scales comparable to the time-scales of such processes [<xref ref-type="bibr" rid="pcbi.1004579.ref018">18</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref020">20</xref>], and the dynamics of the networks themselves thus profoundly affect dynamical processes taking place on top of them [<xref ref-type="bibr" rid="pcbi.1004579.ref021">21</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref027">27</xref>]. This means that one needs to take the network’s dynamics into account, e.g., by representing it as a time-varying network (also known as a time-varying graph, temporal network, or dynamical network) [<xref ref-type="bibr" rid="pcbi.1004579.ref028">28</xref>]. The dynamical nature of time-varying networks makes the adaptation of the Gillespie algorithm to such systems non-trivial.</p>
<p>The main difficulty in adapting the Gillespie algorithm to time-varying networks is taking into account the variation of the set of possible transitions and of their rates at each time step. We show that by normalizing time by the instantaneous cumulative transition rate, we can construct a temporal Gillespie algorithm that is applicable to Poisson (constant rate) processes on time-varying networks. We give pseudocode and C++ implementations for its application to simulate the paradigmatic Susceptible-Infected-Susceptible (SIS) and Susceptible-Infected-Recovered (SIR) models of epidemic spreading, for both homogeneous and heterogeneous [<xref ref-type="bibr" rid="pcbi.1004579.ref029">29</xref>] populations. We verify the accuracy of the temporal Gillespie algorithm numerically by comparison with a classical rejection sampling algorithm, and we show that it is up to ∼ 500 times faster for the processes and the parameter ranges investigated here.</p>
<p>While Poissonian models are of widespread use, real contagion phenomena show memory effects, i.e., they are non-Markovian. Notably, for realistic infectious diseases, the rate at which an infected individual recovers is not constant over time [<xref ref-type="bibr" rid="pcbi.1004579.ref030">30</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref031">31</xref>]. Social contagion may also show memory effects, e.g., one may be more (or less) prone to adopt an idea the more times one has been exposed to it. To treat this larger class of models, we show how the temporal Gillespie algorithm can be extended to non-Markovian processes. We give in particular an algorithm for simulating SIR epidemic models with non-constant recovery rates.</p>
</sec>
<sec id="sec002" sec-type="results">
<title>Results</title>
<p>The following subsections present the main results of the article. Section 1: “Stochastic processes on time-varying networks” defines the stochastic processes which can be simulated using the temporal Gillespie algorithm, and describes the class of compartmental models for contagion phenomena on networks—the class we will use in examples throughout this paper. Section 2: “Rejection sampling for Monte Carlo simulations” gives a quick overview of the traditional rejection sampling algorithms. Section 3: “Gillespie algorithm on static networks” outlines a derivation of the static Gillespie algorithm. Section 4: “Temporal Gillespie algorithm” derives the temporal Gillespie algorithm for Poisson (constant-rate) processes. In Section 5: “Comparison of Gillespie and rejection sampling algorithms” we validate the temporal Gillespie algorithm through numerical comparison with a rejection sampling algorithm; we also compare their speeds for simulating SIR and SIS processes on both synthetic and empirical time-varying networks. Section 6: “Non-Markovian processes” shows how the temporal Gillespie algorithm can be extended to simulate non-Markovian processes; the approach is verified numerically and the speed of the non-Markovian temporal Gillespie algorithm is compared to rejection sampling.</p>
<p>Tables listing the notation used in the manuscript, details on how Monte Carlo simulations were performed, and pseudocode for application of the temporal Gillespie algorithm are given in the Methods section.</p>
<sec id="sec003">
<title>1 Stochastic processes on time-varying networks</title>
<p>We define in this section the type of stochastic processes for which the temporal Gillespie algorithm can be applied. At the time of writing, the main domain of application of the algorithm is the class of compartmental models for contagion processes on time-varying networks, which we introduce below. For definiteness, algorithms detailing the application of the temporal Gillespie algorithm will concern this class of stochastic processes.</p>
<p>In general, we consider a system whose dynamics can be described by a set of stochastic transition events. We assume that the system can be modeled at any point in time by a set, Ω(<italic>t</italic>), of <italic>M</italic>(<italic>t</italic>) independent stochastic processes <italic>m</italic>, which we term <italic>transition processes</italic>; the rate at which the transition <italic>m</italic> takes place is denoted λ<sub><italic>m</italic></sub>. The set Ω(<italic>t</italic>) thus defines the possible transition events at time <italic>t</italic> and in general changes over time, depending on both external factors and the evolution of the system itself; the number of possible transitions, <italic>M</italic>(<italic>t</italic>), thus also generally changes over time, while λ<sub><italic>m</italic></sub> may or may not vary over time. For the classic “static” Gillespie algorithm to be applicable, Ω(<italic>t</italic>) is allowed to change only when a transition (or chemical reaction in the context of Gillespie’s original article) takes place. For processes taking place on time-varying networks, the medium of the process—the network—also changes with time. As these changes may allow or forbid transitions, Ω(<italic>t</italic>) is not only modified by every reaction, but also by every change in the network. This is the domain of the temporal Gillespie algorithm, which only requires that the number of points in which Ω(<italic>t</italic>) changes be finite over a finite time-interval [<xref ref-type="bibr" rid="pcbi.1004579.ref032">32</xref>].</p>
<p>The assumption that the transition processes are independent is essential to the validity of the Gillespie algorithm, as it allows the calculation of the distribution of waiting times between consecutive transitions. This assumption is not overly restrictive, as it only requires a transition process to be independent of the evolution of the other simultaneous transition processes. A transition process may depend on all earlier transitions, and the current and past states of all nodes. As such, Gillespie algorithms can notably be applied to models of cooperative infections and other non-linear processes such as threshold models [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>], and has even been applied to model the dynamics of ant battles [<xref ref-type="bibr" rid="pcbi.1004579.ref033">33</xref>].</p>
<sec id="sec004">
<title>Compartmental models of contagion</title>
<p>In a network-based description of the population in which a contagion process takes place, an individual is modeled as a node <italic>i</italic> (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref>). A contact between two individuals taking place at time <italic>t</italic> is represented by an edge (<italic>i</italic>, <italic>j</italic>)<sub><italic>t</italic></sub> in the graph describing the population at the instant <italic>t</italic> (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref>). In a compartmental model, each node is in a certain state, which belongs to a fixed, finite set of <italic>q</italic> different states (compartments) [<xref ref-type="bibr" rid="pcbi.1004579.ref003">3</xref>]. A random variable <inline-formula id="pcbi.1004579.e001"><alternatives><graphic id="pcbi.1004579.e001g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e001"/><mml:math id="M1" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>x</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>∈</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:msub><mml:mi mathvariant="script">X</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="script">X</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="script">X</mml:mi> <mml:mi>q</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> specifies the state of the node <italic>i</italic> at time <italic>t</italic> (i.e. to which compartment it belongs). Nodes may stochastically transition between states, governed by the set Ω(<italic>t</italic>) of transition processes. One is usually interested in the evolution of the number of nodes in each state, which we denote <italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>, …, <italic>X</italic><sub><italic>q</italic></sub>.</p>
<fig id="pcbi.1004579.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Schematic representation of a compartmental contagion process on a network.</title>
<p>(A) Illustration of a contagion process evolving on a time-varying network. Nodes’ colors correspond to their current state; edges denote current contacts between nodes; edge colors correspond to: black: no contagion may take place over the edge, red: contagion takes place during the present time-step, and red-to-blue gradient: contagion is possible but does not take place. (B) Example: reaction types in the SIR model. (C) Spontaneous reaction: a node <italic>i</italic> may spontaneously transition from its current state <italic>x</italic><sub><italic>i</italic></sub> to <inline-formula id="pcbi.1004579.e002"><alternatives><graphic id="pcbi.1004579.e002g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e002"/><mml:math id="M2" display="inline" overflow="scroll"><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> with rate λ<sub><italic>m</italic></sub>. (D) Contact-dependent reaction: a node <italic>i</italic> may transition from its current state <italic>x</italic><sub><italic>i</italic></sub> to <inline-formula id="pcbi.1004579.e003"><alternatives><graphic id="pcbi.1004579.e003g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e003"/><mml:math id="M3" display="inline" overflow="scroll"><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> with rate λ<sub><italic>m</italic></sub> upon contact with the node <italic>j</italic> in state <italic>x</italic><sub><italic>j</italic></sub>. (E) Mixed transition: a node <italic>i</italic> may spontaneously transition from its current state <italic>x</italic><sub><italic>i</italic></sub> to another state, <inline-formula id="pcbi.1004579.e004"><alternatives><graphic id="pcbi.1004579.e004g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e004"/><mml:math id="M4" display="inline" overflow="scroll"><mml:msubsup><mml:mi>x</mml:mi> <mml:mi>i</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> with rate λ<sub><italic>m</italic></sub>; contact with another node <italic>j</italic>, in state <italic>x</italic><sub><italic>j</italic></sub>, may alter the transition rate of <italic>m</italic>, <inline-formula id="pcbi.1004579.e005"><alternatives><graphic id="pcbi.1004579.e005g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e005"/><mml:math id="M5" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mo>→</mml:mo> <mml:msubsup><mml:mo>λ</mml:mo> <mml:mrow><mml:mi>m</mml:mi></mml:mrow> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>. After the contact (<italic>i</italic>, <italic>j</italic>)<sub><italic>t</italic></sub> ends, the transition rate may revert to λ<sub><italic>m</italic></sub>, remain unchanged, or change to a third value.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g001"/>
</fig>
<p>As an example, we consider the classic SIR model of epidemic spreading with constant transition rates in a homogeneous population (rates are the same for all individuals) (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1B</xref>). Here nodes can be in one of three states: susceptible, infected, and recovered, <inline-formula id="pcbi.1004579.e006"><alternatives><graphic id="pcbi.1004579.e006g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e006"/><mml:math id="M6" display="inline" overflow="scroll"><mml:mrow><mml:mo>{</mml:mo> <mml:mi mathvariant="script">S</mml:mi> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">I</mml:mi> <mml:mo>,</mml:mo> <mml:mi mathvariant="script">R</mml:mi> <mml:mo>}</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Two different transition types let nodes change state: (i) a node <italic>i</italic> in the <inline-formula id="pcbi.1004579.e007"><alternatives><graphic id="pcbi.1004579.e007g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e007"/><mml:math id="M7" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula> state switches to the <inline-formula id="pcbi.1004579.e008"><alternatives><graphic id="pcbi.1004579.e008g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e008"/><mml:math id="M8" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula> state with rate state with rate <inline-formula id="pcbi.1004579.e009"><alternatives><graphic id="pcbi.1004579.e009g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e009"/><mml:math id="M9" display="inline" overflow="scroll"><mml:msub><mml:mi>k</mml:mi> <mml:mi mathvariant="script">I</mml:mi></mml:msub> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo> <mml:mi>β</mml:mi></mml:math></alternatives></inline-formula> (an <inline-formula id="pcbi.1004579.e010"><alternatives><graphic id="pcbi.1004579.e010g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e010"/><mml:math id="M10" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> reaction), where <inline-formula id="pcbi.1004579.e011"><alternatives><graphic id="pcbi.1004579.e011g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e011"/><mml:math id="M11" display="inline" overflow="scroll"><mml:msub><mml:mi>k</mml:mi> <mml:mi mathvariant="script">I</mml:mi></mml:msub> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:math></alternatives></inline-formula> is the number of contacts <italic>i</italic> has with nodes in the <inline-formula id="pcbi.1004579.e012"><alternatives><graphic id="pcbi.1004579.e012g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e012"/><mml:math id="M12" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula> state at time <italic>t</italic> (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref>); (ii) a node <italic>i</italic> in the <inline-formula id="pcbi.1004579.e013"><alternatives><graphic id="pcbi.1004579.e013g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e013"/><mml:math id="M13" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula> state switches to the <inline-formula id="pcbi.1004579.e014"><alternatives><graphic id="pcbi.1004579.e014g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e014"/><mml:math id="M14" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula> state at rate <italic>μ</italic> (an <inline-formula id="pcbi.1004579.e015"><alternatives><graphic id="pcbi.1004579.e015g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e015"/><mml:math id="M15" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> reaction).</p>
<p>In general, the transition processes can be divided into three types:</p>
<list list-type="order">
<list-item>
<p>spontaneous transitions, which only depend on the current state of the node, <italic>x</italic><sub><italic>i</italic></sub>(<italic>t</italic>) (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1C</xref>)—e.g. an infected node recovers spontaneously in the SIR model (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1B</xref>);</p>
</list-item>
<list-item>
<p>contact-dependent transitions, which may take place only when the node <italic>i</italic> is in contact with other nodes in a given state; it thus depends on the states <italic>x</italic><sub><italic>j</italic></sub> of the nodes <italic>j</italic> currently in contact with <italic>i</italic> (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1D</xref>)—e.g. a susceptible node may be infected upon contact with an infectious node in the SIR model (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1B</xref>).</p>
</list-item>
<list-item>
<p>mixed transitions, which take place spontaneously, but may depend on the node’s past and current contacts (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1E</xref>)—e.g. in rumor spreading, an individual may learn on his own that a rumor is false (spontaneous) or may be convinced by another individual who knows the rumor is false (contact-dependent).</p>
</list-item>
</list>
<p>This division is important for practical application of the temporal Gillespie algorithm as transition processes of type <italic>a</italic> need only be updated after a transition has taken place, and processes of type <italic>c</italic> need only be updated whenever a relevant contact takes place, but not at each time-step. Using this distinction is crucial to obtaining the large speed-increase that the temporal Gillespie algorithm offers over rejection sampling, as discussed below (Secs. 4: “Temporal Gillespie algorithm” and 5: “Comparison of Gillespie and rejection sampling algorithms”).</p>
</sec>
</sec>
<sec id="sec005">
<title>2 Rejection sampling for Monte Carlo simulations</title>
<p>A straightforward way to simulate a stochastic process is to use a rejection sampling algorithm, akin to the classical Metropolis algorithm. Here one divides the time-axis in small time-steps Δ<italic>t</italic>, where Δ<italic>t</italic> should be chosen sufficiently small such that this discretization does not influence the outcome of the process significantly; on time-varying networks, the choice of Δ<italic>t</italic> often comes naturally as the time-resolution at which the network is measured or simulated (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref>).</p>
<p>At each time-step <italic>t</italic> = 0, Δ<italic>t</italic>, 2Δ<italic>t</italic>, …, we test whether each possible transition <italic>m</italic> ∈ Ω(<italic>t</italic>) takes place or not. In practice this is done by drawing a random number <italic>r</italic><sub><italic>m</italic></sub> that is uniformly distributed on [0, 1) for each <italic>m</italic> and comparing it to λ<sub><italic>m</italic></sub>Δ<italic>t</italic>: if <italic>r</italic><sub><italic>m</italic></sub> &lt; λ<sub><italic>m</italic></sub>Δ<italic>t</italic> the reaction takes place, if <italic>r</italic><sub><italic>m</italic></sub> ≥ λ<sub><italic>m</italic></sub>Δ<italic>t</italic> nothing happens [<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2</xref> (Transitions)]. (Note that one should technically compare <italic>r</italic><sub><italic>m</italic></sub> to 1 − exp(λ<sub><italic>m</italic></sub>Δ<italic>t</italic>) to ensure that λ<sub><italic>m</italic></sub> defines a proper transition rate for finite Δ<italic>t</italic>. However, the two procedures are equivalent in the limit Δ<italic>t</italic> → 0.)</p>
<fig id="pcbi.1004579.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Example of how the temporal Gillespie algorithm works for an SIR process on a time-varying network.</title>
<p>We consider the time-varying network of <xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref> (Network)—time evolves along the vertical axis; a rejection sampling algorithm considers each transition process at each time-step individually (Transitions); the temporal Gillespie algorithm considers the integrated cumulative transition rate of all transition processes, <inline-formula id="pcbi.1004579.e016"><alternatives><graphic id="pcbi.1004579.e016g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e016"/><mml:math id="M16" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, and compares it with the random normalized waiting times <inline-formula id="pcbi.1004579.e017"><alternatives><graphic id="pcbi.1004579.e017g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e017"/><mml:math id="M17" display="inline" overflow="scroll"><mml:msubsup><mml:mi>τ</mml:mi> <mml:mi>l</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> (Normalized time). A transition takes place whenever <inline-formula id="pcbi.1004579.e018"><alternatives><graphic id="pcbi.1004579.e018g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e018"/><mml:math id="M18" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>l</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mi>q</mml:mi></mml:msubsup> <mml:msubsup><mml:mi>τ</mml:mi> <mml:mi>l</mml:mi> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for any <inline-formula id="pcbi.1004579.e019"><alternatives><graphic id="pcbi.1004579.e019g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e019"/><mml:math id="M19" display="inline" overflow="scroll"><mml:mrow><mml:mi>q</mml:mi> <mml:mo>∈</mml:mo> <mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. The temporal Gillespie algorithm works as follows. (A) The first normalized waiting time <inline-formula id="pcbi.1004579.e020"><alternatives><graphic id="pcbi.1004579.e020g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e020"/><mml:math id="M20" display="inline" overflow="scroll"><mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> is drawn from an exponential distribution with unit rate [<inline-formula id="pcbi.1004579.e021"><alternatives><graphic id="pcbi.1004579.e021g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e021"/><mml:math id="M21" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>∼</mml:mo> <mml:mtext>Exp</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>] (Normalized time). From the state of the network at the first time-step, the set of possible transitions Ω(0) is found (Transitions), and from this the cumulative transition rate Λ(0) is calculated. The integrated cumulative transition rate, <inline-formula id="pcbi.1004579.e022"><alternatives><graphic id="pcbi.1004579.e022g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e022"/><mml:math id="M22" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is compared to <inline-formula id="pcbi.1004579.e023"><alternatives><graphic id="pcbi.1004579.e023g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e023"/><mml:math id="M23" display="inline" overflow="scroll"><mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula>. If, as in the present example, <inline-formula id="pcbi.1004579.e024"><alternatives><graphic id="pcbi.1004579.e024g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e024"/><mml:math id="M24" display="inline" overflow="scroll"><mml:mrow><mml:mo>Λ</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>&lt;</mml:mo> <mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> the algorithm is advanced to the next time-step. (B) and (C) The set of possible transitions Ω(<italic>t</italic><sub><italic>n</italic></sub>) and the cumulative transition rate Λ(<italic>t</italic><sub><italic>n</italic></sub>) is updated at each following time-step <italic>n</italic>; if <inline-formula id="pcbi.1004579.e025"><alternatives><graphic id="pcbi.1004579.e025g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e025"/><mml:math id="M25" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>n</mml:mi></mml:msub> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>l</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>l</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is still smaller than <inline-formula id="pcbi.1004579.e026"><alternatives><graphic id="pcbi.1004579.e026g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e026"/><mml:math id="M26" display="inline" overflow="scroll"><mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula>, the algorithm is advanced to the next time-step. (D) During the first time-step <italic>n</italic>** where <inline-formula id="pcbi.1004579.e027"><alternatives><graphic id="pcbi.1004579.e027g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e027"/><mml:math id="M27" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≥</mml:mo> <mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, a transition takes place. The exact time of this transition, <italic>t</italic>**, is given by <xref ref-type="disp-formula" rid="pcbi.1004579.e048">Eq (12)</xref> and the transition <italic>m</italic> that takes place is chosen among the possible transitions in the given time-step with probability proportional to its transition rate λ<sub><italic>m</italic></sub> [Transitions and <xref ref-type="disp-formula" rid="pcbi.1004579.e042">Eq (10)</xref>]. (E) The transition changes the system (Network) and consequently the set of possible transitions, Ω(<italic>t</italic>**), (Transitions); thus Ω(<italic>t</italic>**) and Λ(<italic>t</italic>**) must be updated, which in turn changes the remainder of <inline-formula id="pcbi.1004579.e028"><alternatives><graphic id="pcbi.1004579.e028g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e028"/><mml:math id="M28" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> (Normalized time). A new normalized waiting time is then drawn, <inline-formula id="pcbi.1004579.e029"><alternatives><graphic id="pcbi.1004579.e029g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e029"/><mml:math id="M29" display="inline" overflow="scroll"><mml:mrow><mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>2</mml:mn> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>∼</mml:mo> <mml:mtext>Exp</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>; if <inline-formula id="pcbi.1004579.e030"><alternatives><graphic id="pcbi.1004579.e030g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e030"/><mml:math id="M30" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>&lt;</mml:mo> <mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>1</mml:mn> <mml:mo>′</mml:mo></mml:msubsup> <mml:mo>+</mml:mo> <mml:msubsup><mml:mi>τ</mml:mi> <mml:mn>2</mml:mn> <mml:mo>′</mml:mo></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>, no further transitions takes place during the time-step and the algorithm is advanced to the next time-step (note that multiple transitions may occur during the same time-step). (F) The above procedure is reiterated.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g002"/>
</fig>
<p>From the design of the rejection sampling algorithm we see that the proportion of trials that are rejected is equal to a weighted average over {1 − λ<sub><italic>m</italic></sub>Δ<italic>t</italic>}<sub><italic>m</italic></sub>. Thus, since we require λ<sub><italic>m</italic></sub>Δ<italic>t</italic> ≪ 1 in order to avoid discretization errors, the vast majority of trials are rejected and the rejection sampling algorithm is computationally inefficient.</p>
</sec>
<sec id="sec006">
<title>3 Gillespie algorithm on static networks</title>
<p>The Gillespie algorithm lets us perform stochastically exact Monte Carlo simulations without having to reject trials. For Poisson processes on static networks, it works by recognizing that the waiting time between two consecutive transitions is exponentially distributed, and that each transition happens with a probability that is proportional to its rate.</p>
<p>Specifically, the (survival) probability that the transition <italic>m</italic> has not taken place after a time <italic>τ</italic> since the last transition event is
<disp-formula id="pcbi.1004579.e031"><alternatives><graphic id="pcbi.1004579.e031g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e031"/><mml:math id="M31" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msup><mml:mi>e</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mi>τ</mml:mi></mml:mrow></mml:msup> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(1)</label></disp-formula>
Since each transition takes place independently, the probability that no event takes place during the interval <italic>τ</italic> since the last event is
<disp-formula id="pcbi.1004579.e032"><alternatives><graphic id="pcbi.1004579.e032g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e032"/><mml:math id="M32" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mo>∏</mml:mo> <mml:mi>m</mml:mi></mml:munder> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msup><mml:mi>e</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mo>Λ</mml:mo> <mml:mi>τ</mml:mi></mml:mrow></mml:msup> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(2)</label></disp-formula>
where <inline-formula id="pcbi.1004579.e033"><alternatives><graphic id="pcbi.1004579.e033g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e033"/><mml:math id="M33" display="inline" overflow="scroll"><mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>m</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>M</mml:mi></mml:msubsup> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula> is the cumulative transition rate. The above result is obtained by using the fact that while Ω and <italic>M</italic> do depend on <italic>t</italic>, they only change when an event takes place and not in-between. They can thus be treated as constant for the purpose of calculating the waiting time between events. The distribution of the waiting times <italic>τ</italic> is then given by the probability density <italic>p</italic>(<italic>τ</italic>) = Λ<italic>e</italic><sup> − Λ<italic>τ</italic></sup>, while the probability density for the reaction <italic>m</italic> being the next reaction that takes place and that it takes place after exactly time <italic>τ</italic> is equal to <italic>p</italic><sub><italic>m</italic></sub>(<italic>τ</italic>) = λ<sub><italic>m</italic></sub> <italic>e</italic><sup> − Λ<italic>τ</italic></sup></p>
<p>The static Gillespie algorithm thus consists in drawing the waiting time <italic>τ</italic>∼ Exp (Λ) until the next transition and then drawing which transition <italic>m</italic> takes place with probability <italic>π</italic><sub><italic>m</italic></sub> = λ<sub><italic>m</italic></sub>/Λ. [Here <italic>τ</italic>∼ Exp (Λ) is short for: <italic>τ</italic> is exponentially distributed with rate Λ.]</p>
</sec>
<sec id="sec007">
<title>4 Temporal Gillespie algorithm</title>
<p>For processes taking place on time-varying networks however, the set of transition process, Ω(<italic>t</italic>), changes with time independently of the transition events, e.g., for the case of an SIR process nodes may become infected only when in contact with an infected individual (<xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref>). This means that the survival probability does not reduce to a simple exponential as in <xref ref-type="disp-formula" rid="pcbi.1004579.e031">Eq (1)</xref>; it is instead given by
<disp-formula id="pcbi.1004579.e034"><alternatives><graphic id="pcbi.1004579.e034g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e034"/><mml:math id="M34" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mtext>exp</mml:mtext> <mml:mo>(</mml:mo> <mml:mo>-</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(3)</label></disp-formula>
where <italic>t</italic>* is the time at which the last transition took place, <italic>t</italic>** = <italic>t</italic>* + <italic>τ</italic> is the time when the next transition takes place, and I<sub><italic>m</italic></sub>(<italic>t</italic>) is an indicator function that is equal to one when the process <italic>m</italic> may take place, e.g., when two given nodes are in contact, and zero when <italic>m</italic> may not take place. The meaning of I<sub><italic>m</italic></sub> is exemplified in <xref ref-type="fig" rid="pcbi.1004579.g001">Fig 1A</xref>: the node <italic>i</italic> may be infected by the infectious node <italic>j</italic> only when the two nodes are in contact; if we let <italic>m</italic> denote this transition process, I<sub><italic>m</italic></sub>(<italic>t</italic>) is then one for <italic>t</italic> = Δ<italic>t</italic>, 3Δ<italic>t</italic>, 4Δ<italic>t</italic> and zero for <italic>t</italic> = 0, 2Δ<italic>t</italic>.</p>
<p>Note that for processes taking place on adaptive time-varying networks, whose changes only depend on the process itself, I<sub><italic>m</italic></sub>(<italic>t</italic>) only changes when a transition takes place and <xref ref-type="disp-formula" rid="pcbi.1004579.e034">Eq (3)</xref> reduces to <xref ref-type="disp-formula" rid="pcbi.1004579.e031">Eq (1)</xref>. This means that from the point of view of the algorithm, such networks are effectively static and the classic “static” Gillespie algorithm may simply be used there [<xref ref-type="bibr" rid="pcbi.1004579.ref014">14</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref016">16</xref>].</p>
<p>We now consider the general case where Ω(<italic>t</italic>) may change independently of the processes evolving on the network (described in Sec. 1: “Stochastic processes on time-varying networks”). Using, as in the previous section, that transition processes are independent, we can write the probability that no event takes place during an interval <italic>τ</italic> (the waiting time survival function):
<disp-formula id="pcbi.1004579.e035"><alternatives><graphic id="pcbi.1004579.e035g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e035"/><mml:math id="M35" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:munder><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>m</mml:mi> <mml:mo>∈</mml:mo> <mml:mo>Ω</mml:mo></mml:mrow></mml:munder> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mtext>exp</mml:mtext> <mml:mo>(</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>m</mml:mi> <mml:mo>∈</mml:mo> <mml:mo>Ω</mml:mo></mml:mrow></mml:munder> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(4)</label></disp-formula>
where Ω denotes the set of all possible transitions (transition processes) on the interval between two transition events, (<italic>t</italic>*, <italic>t</italic>**], i.e., Ω is the union over Ω(<italic>t</italic>) for <italic>t</italic> ∈ (<italic>t</italic>*, <italic>t</italic>**], and <italic>M</italic> is the total number of transition processes on the same interval (the size of Ω). We switch the sum and the integral in <xref ref-type="disp-formula" rid="pcbi.1004579.e035">Eq (4)</xref> to obtain
<disp-formula id="pcbi.1004579.e036"><alternatives><graphic id="pcbi.1004579.e036g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e036"/><mml:math id="M36" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mtext>exp</mml:mtext> <mml:mo>(</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>m</mml:mi> <mml:mo>∈</mml:mo> <mml:mo>Ω</mml:mo></mml:mrow></mml:munder> <mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(5)</label></disp-formula>
Finally, using that I<sub><italic>m</italic></sub>(<italic>t</italic>) = 0 for all <italic>m</italic> ∉ Ω(<italic>t</italic>), we may write
<disp-formula id="pcbi.1004579.e037"><alternatives><graphic id="pcbi.1004579.e037g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e037"/><mml:math id="M37" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo form="prefix">exp</mml:mo> <mml:mo>(</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="0.166667em"/><mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(6)</label></disp-formula>
where
<disp-formula id="pcbi.1004579.e038"><alternatives><graphic id="pcbi.1004579.e038g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e038"/><mml:math id="M38" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>m</mml:mi> <mml:mo>∈</mml:mo> <mml:mo>Ω</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:munder> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(7)</label></disp-formula>
is the cumulative transition rate at time <italic>t</italic>.</p>
<p>The dynamics of empirical time-varying networks is highly intermittent and we cannot describe Ω(<italic>t</italic>) analytically. This means that we cannot perform the integral of <xref ref-type="disp-formula" rid="pcbi.1004579.e079">Eq (6)</xref> to find the waiting time distribution directly. We may instead normalize time by the instantaneous cumulative transition rate, Λ(<italic>t</italic>): We define a unitless <italic>normalized waiting time</italic> between two consecutive transitions, <italic>τ</italic>′, as
<disp-formula id="pcbi.1004579.e039"><alternatives><graphic id="pcbi.1004579.e039g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e039"/><mml:math id="M39" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo stretchy="false">(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo stretchy="false">)</mml:mo> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(8)</label></disp-formula>
i.e., equal to the cumulative transition rate integrated over (<italic>t</italic>*, <italic>t</italic>**]. The survival function of <italic>τ</italic>′ has the following simple form:
<disp-formula id="pcbi.1004579.e040"><alternatives><graphic id="pcbi.1004579.e040g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e040"/><mml:math id="M40" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo form="prefix">exp</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(9)</label></disp-formula>
The time <italic>t</italic>** when a new transition takes place is given implicitly by <inline-formula id="pcbi.1004579.e041"><alternatives><graphic id="pcbi.1004579.e041g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e041"/><mml:math id="M41" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>, while the probability that <italic>m</italic> is the transition that takes place at time <italic>t</italic> = <italic>t</italic>** is given by:
<disp-formula id="pcbi.1004579.e042"><alternatives><graphic id="pcbi.1004579.e042g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e042"/><mml:math id="M42" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>π</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mrow><mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub></mml:mrow> <mml:mo>/</mml:mo> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(10)</label></disp-formula></p>
<p>This lets us define a Gillespie-type algorithm for time-varying networks by first drawing a normalized waiting time <italic>τ</italic>′ until the next event from a standard exponential distribution [i.e. with unit rate, <italic>τ</italic>′ ∼ Exp (1)], and second, solving <inline-formula id="pcbi.1004579.e043"><alternatives><graphic id="pcbi.1004579.e043g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e043"/><mml:math id="M43" display="inline" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> numerically to find <italic>t</italic>**. In practice, since Λ(<italic>t</italic>) only changes when a transition takes place or at <italic>t</italic><sub><italic>n</italic></sub> = <italic>n</italic>Δ<italic>t</italic> with <inline-formula id="pcbi.1004579.e044"><alternatives><graphic id="pcbi.1004579.e044g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e044"/><mml:math id="M44" display="inline" overflow="scroll"><mml:mrow><mml:mi>n</mml:mi> <mml:mo>∈</mml:mo> <mml:mi mathvariant="double-struck">N</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, we need only compare <italic>τ</italic>′ to
<disp-formula id="pcbi.1004579.e045"><alternatives><graphic id="pcbi.1004579.e045g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e045"/><mml:math id="M45" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:msup><mml:mi>n</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:msup><mml:mi>n</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(11)</label></disp-formula>
for each time-step <italic>n</italic> (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2A–2C</xref>). Here <italic>n</italic>* is the time-step during which the last transition took place, and Λ(<italic>t</italic>*) is the cumulative transition rate at <italic>t</italic>*, immediately after the last transition has taken place. The first term of <xref ref-type="disp-formula" rid="pcbi.1004579.e045">Eq (11)</xref> is the cumulative transition rate integrated over the remainder of the <italic>n</italic>*th time-step left after the last transition; the second term is equal to <inline-formula id="pcbi.1004579.e046"><alternatives><graphic id="pcbi.1004579.e046g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e046"/><mml:math id="M46" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>;</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:msup><mml:mi>n</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. A new transition takes place during the time-step <italic>n</italic>** where <inline-formula id="pcbi.1004579.e047"><alternatives><graphic id="pcbi.1004579.e047g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e047"/><mml:math id="M47" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≥</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2D</xref>); the precise time of this new transition is
<disp-formula id="pcbi.1004579.e048"><alternatives><graphic id="pcbi.1004579.e048g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e048"/><mml:math id="M48" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>-</mml:mo> <mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mfrac> <mml:mspace width="5.0pt"/><mml:mo>;</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(12)</label></disp-formula>
the reaction <italic>m</italic> that takes place is drawn with probability given by <xref ref-type="disp-formula" rid="pcbi.1004579.e042">Eq (10)</xref> (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2D</xref>). We then update Ω and Λ to Ω(<italic>t</italic>**) and Λ(<italic>t</italic>**) (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2E</xref>), draw a new waiting time, <italic>τ</italic>′ ∼ Exp (1), and reiterate the above procedure (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2F</xref>).</p>
<p>The algorithm can be implemented for contagion processes on time-varying networks as follows (see <xref ref-type="sec" rid="sec004">Methods</xref> for pseudocode for specific contagion models and <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref> for implementation in C++):</p>
<list list-type="order">
<list-item>
<p>Draw a normalized waiting time until the first event from a standard exponential distribution, <italic>τ</italic>′ ∼ Exp (1) (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2A</xref>).</p>
</list-item>
<list-item>
<p>At each time-step <italic>t</italic><sub><italic>n</italic></sub> = <italic>n</italic>Δ<italic>t</italic>, with <italic>n</italic> = 0, 1, 2, …, let Ω ≡ Ω(<italic>t</italic><sub><italic>n</italic></sub>) and Λ ≡ Λ(<italic>t</italic><sub><italic>n</italic></sub>); here, only contact-dependent processes (type <italic>b</italic>, Sec. 1: “Stochastic processes on time-varying networks”) and mixed (type <italic>c</italic>) processes that depend on contacts taking place at <italic>t</italic><sub><italic>n</italic></sub> or <italic>t</italic><sub><italic>n</italic> − 1</sub> need to be updated—an important point, as it lets the temporal Gillespie algorithm be much faster than rejection sampling (see <xref ref-type="sec" rid="sec003">Discussion</xref> in the following section). Then, compare <italic>τ</italic>′ to ΛΔ<italic>t</italic>:</p>
<list list-type="simple">
<list-item>
<p><bold>if</bold> ΛΔ<italic>t</italic> ≤ <italic>τ</italic>′ Subtract ΛΔ<italic>t</italic> from <italic>τ</italic>′, continue to next time-step and repeat 2 (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2A–2C</xref>) [<xref ref-type="bibr" rid="pcbi.1004579.ref034">34</xref>].</p>
</list-item>
<list-item>
<p><bold>if</bold> ΛΔ<italic>t</italic> &gt; <italic>τ</italic>′ Let the reaction <italic>m</italic> take place, chosen from Ω with probability <italic>π</italic><sub><italic>m</italic></sub> = λ<sub><italic>m</italic></sub>/Λ. The fraction that is left of the time-step when the transition takes place is <italic>ξ</italic> = 1 − <italic>τ</italic>′/(ΛΔ<italic>t</italic>) and the precise time of the transition is <italic>t</italic>** = <italic>t</italic><sub><italic>n</italic></sub> + <italic>τ</italic>′/Λ (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2D and 2F</xref>). Next, update Ω and Λ (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2E</xref>); this time all transition processes should be updated, as spontaneous processes (type <italic>a</italic>) may change, emerge, or disappear when a transition takes place. Then:</p>
<list list-type="simple">
<list-item>
<label>(a)</label> <p>draw a new normalized waiting time, <italic>τ</italic>′ ∼ Exp (1) (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2F</xref>);</p>
</list-item>
<list-item>
<label>(b)</label> <p>compare <italic>τ</italic>′ to <italic>ξ</italic>ΛΔ<italic>t</italic>:</p>
<list list-type="simple">
<list-item>
<p><bold>if</bold> <italic>τ</italic>′ ≥ <italic>ξ</italic>ΛΔ<italic>t</italic> subtract <italic>ξ</italic>ΛΔ<italic>t</italic> from <italic>τ</italic>′, continue to the next time-step and repeat 2 (<xref ref-type="fig" rid="pcbi.1004579.g002">Fig 2F</xref>).</p>
</list-item>
<list-item>
<p><bold>if</bold> <italic>τ</italic>′ &lt; <italic>ξ</italic>ΛΔ<italic>t</italic> Another transition takes place during the present time-step (at time <italic>t</italic>*** = <italic>t</italic>** + <italic>τ</italic>′/Λ, where <italic>t</italic>** is the time of the last transition during the same time-step): choose <italic>m</italic> from Ω with probability <italic>π</italic><sub><italic>m</italic></sub> = λ<sub><italic>m</italic></sub>/Λ; let <italic>ξ</italic> → <italic>ξ</italic> − <italic>τ</italic>′/ΛΔ<italic>t</italic>, and update Ω and Λ. Repeat a) and b).</p>
</list-item>
</list>
</list-item>
</list>
</list-item>
</list>
</list-item>
</list>
<p>By construction, the above procedure produces realizations of a stochastic process for which the waiting times for each transition follow exactly their correct distributions. The temporal Gillespie algorithm is thus what we term <italic>stochastically exact</italic>: all distributions and moments of a stochastic process evolving on a time-varying network obtained through Monte Carlo simulations converge to their exact values. Rejection based sampling algorithms are stochastically exact only in the limit λ<sub><italic>m</italic></sub>Δ<italic>t</italic> → 0.</p>
<p>A large literature exists on the related problem of simulating coupled chemical reactions under externally changing conditions (e.g., time-varying temperature or volume) [<xref ref-type="bibr" rid="pcbi.1004579.ref035">35</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref040">40</xref>]. Most of these methods consider only external perturbations that can be described by an analytical expression. In this case the problem reduces to that of defining a static, yet non-Markovian, algorithm. Some methods, and notably the <italic>modified next reaction method</italic> developed by Anderson [<xref ref-type="bibr" rid="pcbi.1004579.ref037">37</xref>], can be adapted to a completely general form of the external driving and thus, in principle, to simulate dynamical processes taking place on time-varying networks. These methods are based on a scheme that is conceptually similar to Gillespie’s direct algorithm, the <italic>next reaction method</italic>, proposed by Gibson and Bruck [<xref ref-type="bibr" rid="pcbi.1004579.ref035">35</xref>]. The next reaction method draws a waiting time for each reaction individually and chooses the next reaction that happens as the one with the shortest corresponding waiting time. It then updates the remaining waiting times, draws new waiting times (if applicable), and reiterates. To generalize the next reaction method to processes with non-exponential waiting times, Anderson introduced the concept of the <italic>internal time</italic> for each transition process [<xref ref-type="bibr" rid="pcbi.1004579.ref037">37</xref>]. In the notation used in the present article it is defined as <inline-formula id="pcbi.1004579.e049"><alternatives><graphic id="pcbi.1004579.e049g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e049"/><mml:math id="M49" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mn>0</mml:mn> <mml:mi>t</mml:mi></mml:msubsup> <mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and is thus equivalent to the normalized time, <inline-formula id="pcbi.1004579.e050"><alternatives><graphic id="pcbi.1004579.e050g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e050"/><mml:math id="M50" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>,</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, only for an individual transition process.</p>
<p>By construction, the next reaction method needs to draw only one random number per transition event, where the Gillespie algorithm draws two. However, this reduction in the number of required random variables comes at a price: one must draw a random number for each individual transition process and keep track of, compare, and update each of the individual waiting times. For chemical reactions, where the number of different chemical reactions is small (it scales with the number of chemical species), this tradeoff favors the next reaction method. However, for contagion processes on networks, each individual is unique (if not intrinsically, at least due to its position in the network). The number transition processes thus scales with the number of nodes and contacts, which favors the Gillespie algorithm as it does not need to keep track of each of them individually [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>].</p>
<p>On time-varying networks (or for time-varying external driving) one must furthermore update relevant internal times each time the network structure (external conditions) changes in the next reaction method. Chemically reacting systems are usually close to being adiabatic, i.e., the external driving changes slowly compared to the time-scales of chemical reactions. Thus, the additional overhead related to updating individual internal times is practically negligible. However, the dynamics of temporal networks is highly intermittent and the time-scale of network change is typically smaller than the time-scales of relevant dynamical processes. Here one must thus update the internal times many times between each transition event, inducing a substantial overhead. Since the temporal Gillespie algorithm operates with a single global normalized waiting time, it handles these updates more efficiently.</p>
<p>Finally, the modified next reaction method may in principle be extended to non-Markovian processes taking place on time-varying networks (as treated in Sec. 6: “Non-Markovian processes” using the temporal Gillespie algorithm). However, such an approach would, for each single transition, require solving numerically Eq. (13) of [<xref ref-type="bibr" rid="pcbi.1004579.ref037">37</xref>] for the internal waiting time of each individual transition process, taking into account the time-varying network structure, finding the shortest corresponding waiting time in real time, and then updating the internal waiting times of all the other reactions, rendering the next reaction method even more inefficient in this general case.</p>
</sec>
<sec id="sec008">
<title>5 Comparison of Gillespie and rejection sampling algorithms</title>
<sec id="sec009">
<title>Numerical validation</title>
<p>We compare the outcome of SIR and SIS processes on activity-driven time-varying networks [<xref ref-type="bibr" rid="pcbi.1004579.ref041">41</xref>] simulated using the temporal Gillespie algorithm to the outcome of simulations using traditional rejection sampling. For sufficiently small λ<sub><italic>m</italic></sub>Δ<italic>t</italic>, the outcomes are indistinguishable (<xref ref-type="fig" rid="pcbi.1004579.g003">Fig 3</xref>, see also <xref ref-type="supplementary-material" rid="pcbi.1004579.s001">S1 Fig</xref> for an empirical network of face-to-face contacts in a high school), confirming the validity of the temporal Gillespie algorithm. Note that rejection sampling is only expected to be accurate for λ<sub><italic>m</italic></sub>Δ<italic>t</italic> ≪ 1, while the temporal Gillespie algorithm is stochastically exact for all λ<sub><italic>m</italic></sub>Δ<italic>t</italic>; the results of the two algorithms thus differ when the assumption λ<sub><italic>m</italic></sub>Δ<italic>t</italic> ≪ 1 does not hold (<xref ref-type="supplementary-material" rid="pcbi.1004579.s002">S2 Fig</xref>).</p>
<fig id="pcbi.1004579.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Comparison of numerical results from temporal Gillespie and rejection sampling algorithms.</title>
<p>(A) Mean number of nodes in each state of the SIR model as function of time. (B) Distribution of final epidemic sizes (number of recovered nodes when <italic>I</italic> = 0) in the SIR model. (C) Mean number of nodes in each state of the SIS model as function of time. (D) Distribution of the number of infected nodes in the stationary state (<italic>t</italic> → ∞) of the SIS model. All simulations were performed 1 000 000 times with the root node chosen at random on an activity driven network [<xref ref-type="bibr" rid="pcbi.1004579.ref041">41</xref>] consisting of <italic>N</italic> = 100 nodes, with activities <italic>a</italic><sub><italic>i</italic></sub> = <italic>ηz</italic><sub><italic>i</italic></sub>, where <italic>η</italic> = 0.1 and <inline-formula id="pcbi.1004579.e051"><alternatives><graphic id="pcbi.1004579.e051g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e051"/><mml:math id="M51" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>z</italic><sub><italic>i</italic></sub> ∈ [0.03, 1), and a node formed two contacts when active. Parameters of the epidemic processes were <italic>β</italic>Δ<italic>t</italic> = 10<sup>−2</sup> and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−4</sup>.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g003"/>
</fig>
</sec>
<sec id="sec010">
<title>Comparison of simulation speed</title>
<p>Next, we compare the speeds of the temporal Gillespie and the rejection sampling algorithms for SIR and SIS processes (see <xref ref-type="sec" rid="sec004">Methods</xref> for details on how simulations were performed). <xref ref-type="fig" rid="pcbi.1004579.g004">Fig 4</xref> shows that the temporal Gillespie algorithm is up to multiple orders of magnitude faster than traditional rejection sampling. These results are confirmed by simulations on empirical time-varying networks of face-to-face contacts (<xref ref-type="fig" rid="pcbi.1004579.g005">Fig 5</xref>, <xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref>). The speed gain is higher for larger systems (compare <italic>N</italic> = 1 000 to <italic>N</italic> = 100 in <xref ref-type="fig" rid="pcbi.1004579.g004">Fig 4</xref>) We also see that the speed gain is larger the sparser the network is. This is because the calculation of the contacts between susceptible and infected nodes at each time-step, necessary to determine the possible <inline-formula id="pcbi.1004579.e052"><alternatives><graphic id="pcbi.1004579.e052g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e052"/><mml:math id="M52" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transitions, is the performance limiting step of the temporal Gillespie algorithm (see below). In the extreme case of a contagion model where all transitions are contact-dependent (type b, Sec. 1: “Stochastic processes on time-varying networks”), such as the classic Maki-Thompson model of rumor spreading [<xref ref-type="bibr" rid="pcbi.1004579.ref042">42</xref>], the temporal Gillespie algorithm is approximately a factor two faster than the rejection sampling algorithm.</p>
<fig id="pcbi.1004579.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Comparison of the speed of the temporal Gillespie and the rejection sampling algorithms.</title>
<p>Ratio between computational times Θ<sub>RS</sub> and Θ<sub>TGA</sub> per single realization of a spreading process using rejection sampling and the temporal Gillespie algorithm, respectively: (A) for a SIR process and (B) for a SIS process on networks with different mean degree, <inline-formula id="pcbi.1004579.e053"><alternatives><graphic id="pcbi.1004579.e053g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e053"/><mml:math id="M53" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> ([for empirical contact networks, <inline-formula id="pcbi.1004579.e054"><alternatives><graphic id="pcbi.1004579.e054g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e054"/><mml:math id="M54" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>≈</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>004</mml:mn> <mml:mo>−</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>07</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> (<xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref>)]. Networks consisted of <italic>N</italic> = 100 or <italic>N</italic> = 1000 nodes, with activities <italic>a</italic><sub><italic>i</italic></sub> = <italic>ηz</italic><sub><italic>i</italic></sub> and <inline-formula id="pcbi.1004579.e055"><alternatives><graphic id="pcbi.1004579.e055g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e055"/><mml:math id="M55" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>z</italic><sub><italic>i</italic></sub> ∈ [0.03, 1); a node formed two contacts each time it was active. For Δ<italic>t</italic> = 20 s (as for the empirical data), <italic>μ</italic>Δ<italic>t</italic> ≈ 3⋅10<sup>−5</sup> corresponds to a recovery time of roughly one week, typical of flu-like diseases. The infection rate was <italic>β</italic> = 10<sup>3</sup> <italic>μ</italic> for networks with <inline-formula id="pcbi.1004579.e056"><alternatives><graphic id="pcbi.1004579.e056g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e056"/><mml:math id="M56" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>002</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, <italic>β</italic> = 10<sup>2</sup> <italic>μ</italic> for networks with <inline-formula id="pcbi.1004579.e057"><alternatives><graphic id="pcbi.1004579.e057g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e057"/><mml:math id="M57" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>02</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, and <italic>β</italic> = 10<italic>μ</italic> for networks with <inline-formula id="pcbi.1004579.e058"><alternatives><graphic id="pcbi.1004579.e058g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e058"/><mml:math id="M58" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>. (Details on how simulations were performed are found in Methods.)</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g004"/>
</fig>
<fig id="pcbi.1004579.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g005</object-id>
<label>Fig 5</label>
<caption>
<title>Comparison of the speed of the temporal Gillespie and rejection sampling algorithms on empirical time-varying networks.</title>
<p>Ratio Θ<sub>RS</sub>/Θ<sub>TGA</sub> between the time per realization of a single simulation using rejection sampling and the temporal Gillespie algorithm on empirical face-to-face contact networks in different social settings (<xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref>): (A) for a SIR process, without (TGA) and with (TGA + CR) contact removal; (B) for a SIS process. Simulations were performed with <italic>β</italic> = 1 000<italic>μ</italic> for the workplace and <italic>β</italic> = 100<italic>μ</italic> for the other networks. (Details on how simulations were performed are found in Methods.)</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g005"/>
</fig>
<table-wrap id="pcbi.1004579.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.t001</object-id>
<label>Table 1</label>
<caption>
<title>Summary statistics for empirical face-to-face contact networks from the <italic>SocioPatterns</italic> collaboration [<xref ref-type="bibr" rid="pcbi.1004579.ref045">45</xref>]: social setting; number of nodes in the network, <italic>N</italic>; total duration of measurements, <italic>T</italic>; average instantaneous degree, <inline-formula id="pcbi.1004579.e059"><alternatives><graphic id="pcbi.1004579.e059g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e059"/><mml:math id="M59" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>.</title>
</caption>
<alternatives>
<graphic id="pcbi.1004579.t001g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.t001"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Setting</bold></th>
<th align="center" rowspan="1" colspan="1"><italic>N</italic></th>
<th align="center" rowspan="1" colspan="1"><italic>T</italic></th>
<th align="center" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e060">
<alternatives>
<graphic id="pcbi.1004579.e060g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e060"/>
<mml:math id="M60" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:mi>k</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</th>
<th align="center" rowspan="1" colspan="1">Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1">Workplace</td>
<td align="center" rowspan="1" colspan="1">92</td>
<td align="center" rowspan="1" colspan="1">11 days</td>
<td align="char" char="." rowspan="1" colspan="1">0.004</td>
<td align="center" rowspan="1" colspan="1">[<xref ref-type="bibr" rid="pcbi.1004579.ref046">46</xref>]</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Hospital</td>
<td align="center" rowspan="1" colspan="1">80</td>
<td align="center" rowspan="1" colspan="1">4 days</td>
<td align="char" char="." rowspan="1" colspan="1">0.064</td>
<td align="center" rowspan="1" colspan="1">[<xref ref-type="bibr" rid="pcbi.1004579.ref047">47</xref>]</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">High school</td>
<td align="center" rowspan="1" colspan="1">327</td>
<td align="center" rowspan="1" colspan="1">4 days</td>
<td align="char" char="." rowspan="1" colspan="1">0.063</td>
<td align="center" rowspan="1" colspan="1">[<xref ref-type="bibr" rid="pcbi.1004579.ref048">48</xref>]</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Conference</td>
<td align="center" rowspan="1" colspan="1">399</td>
<td align="center" rowspan="1" colspan="1">32 hours</td>
<td align="char" char="." rowspan="1" colspan="1">0.070</td>
<td align="center" rowspan="1" colspan="1">[<xref ref-type="bibr" rid="pcbi.1004579.ref049">49</xref>]</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec011">
<title>Expected time complexity of the algorithms</title>
<p>We may gain insight into the performance of the algorithms by considering their <italic>time-complexity</italic>, i.e., how their running time scales with the input parameters of the simulated system. Since the algorithms are used for Monte Carlo simulations, it is most interesting to consider the <italic>expected complexity</italic> given a set of parameters, i.e., the mean running time of an algorithm averaged over an ensemble of simulations, not the <italic>worst-case complexity</italic> which is usually considered for deterministic algorithms.</p>
<p>The expected running time of the rejection sampling algorithm scales as
<disp-formula id="pcbi.1004579.e061"><alternatives><graphic id="pcbi.1004579.e061g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e061"/><mml:math id="M61" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mo>Θ</mml:mo> <mml:mtext>RS</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mover><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>n</mml:mi> <mml:mtext>simu</mml:mtext></mml:msub> <mml:mo>)</mml:mo> <mml:mo>+</mml:mo> <mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mover><mml:mrow><mml:mi>M</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>n</mml:mi> <mml:mtext>simu</mml:mtext></mml:msub> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(13)</label></disp-formula>
where <inline-formula id="pcbi.1004579.e062"><alternatives><graphic id="pcbi.1004579.e062g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e062"/><mml:math id="M62" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mi>x</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> denotes a term that is of order <italic>x</italic>, <inline-formula id="pcbi.1004579.e063"><alternatives><graphic id="pcbi.1004579.e063g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e063"/><mml:math id="M63" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mi>N</mml:mi> <mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>/</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> is the mean number of contacts per time-step, <inline-formula id="pcbi.1004579.e064"><alternatives><graphic id="pcbi.1004579.e064g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e064"/><mml:math id="M64" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:mi>M</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is the mean number of possible transitions at any instant, and <italic>n</italic><sub>simu</sub> is the number of time-steps simulated. For comparison, the expected running time of the temporal Gillespie algorithm is given by
<disp-formula id="pcbi.1004579.e065"><alternatives><graphic id="pcbi.1004579.e065g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e065"/><mml:math id="M65" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mo>Θ</mml:mo> <mml:mtext>TGA</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mover><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>n</mml:mi> <mml:mtext>simu</mml:mtext></mml:msub> <mml:mo>)</mml:mo> <mml:mo>+</mml:mo> <mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mover><mml:mrow><mml:mi>Q</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>n</mml:mi> <mml:mtext>simu</mml:mtext></mml:msub> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(14)</label></disp-formula>
where <inline-formula id="pcbi.1004579.e066"><alternatives><graphic id="pcbi.1004579.e066g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e066"/><mml:math id="M66" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:mi>Q</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is the mean number of transitions that take place per time-step.</p>
<p>The first term of the r.h.s. of Eqs (<xref ref-type="disp-formula" rid="pcbi.1004579.e061">13</xref>) and (<xref ref-type="disp-formula" rid="pcbi.1004579.e065">14</xref>) correspond to the time needed for looking through the set of contacts at each time-step to determine the set of possible infections and are thus similar for the rejection sampling and temporal Gillespie algorithms (with the temporal Gillespie algorithm incurring a small additional overhead related to calculating the cumulative transition rate and keeping track of of the normalized waiting time left till the next transition). For rejection sampling [<xref ref-type="disp-formula" rid="pcbi.1004579.e061">Eq (13)</xref>], the second term corresponds to the determination of whether each of the possible transitions takes place at each time-step; for the temporal Gillespie algorithm [<xref ref-type="disp-formula" rid="pcbi.1004579.e065">Eq (14)</xref>], the second term corresponds to drawing inter-event waiting times and which transitions that take place. For the SIR and SIS processes considered above, <inline-formula id="pcbi.1004579.e067"><alternatives><graphic id="pcbi.1004579.e067g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e067"/><mml:math id="M67" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>M</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mover><mml:mrow><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mi mathvariant="normal">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="normal">I</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>+</mml:mo> <mml:mover><mml:mrow><mml:mi>I</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pcbi.1004579.e068"><alternatives><graphic id="pcbi.1004579.e068g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e068"/><mml:math id="M68" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mi mathvariant="normal">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="normal">I</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is mean the number of possible <italic>S</italic> → <italic>I</italic> transitions per time-step, and <inline-formula id="pcbi.1004579.e069"><alternatives><graphic id="pcbi.1004579.e069g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e069"/><mml:math id="M69" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:mi>I</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is the mean number of infected nodes.</p>
<p>Empirically relevant networks are sparse and transition rates are small, so typically <inline-formula id="pcbi.1004579.e070"><alternatives><graphic id="pcbi.1004579.e070g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e070"/><mml:math id="M70" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>Q</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>⪡</mml:mo> <mml:mover><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>⪡</mml:mo> <mml:mover><mml:mrow><mml:mi>M</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>. (The first inequality is a consequence of transition rates being small compared to 1/Δ<italic>t</italic>; the second inequality follows by noting that <inline-formula id="pcbi.1004579.e071"><alternatives><graphic id="pcbi.1004579.e071g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e071"/><mml:math id="M71" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>I</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>∼</mml:mo> <mml:mi>N</mml:mi> <mml:mo>≫</mml:mo> <mml:mover><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula>.) This means that the performance of the rejection sampling algorithm is limited by the rejection sampling step [second term of <xref ref-type="disp-formula" rid="pcbi.1004579.e061">Eq (13)</xref>], while the performance of the temporal Gillespie algorithm is limited by the iteration over the set of contacts in order to update Ω(<italic>t</italic>) [first term in <xref ref-type="disp-formula" rid="pcbi.1004579.e065">Eq (14)</xref>]; this explains why the difference in performance decreases with the mean instantaneous degree of the network. This also hints at how we may improve the speed of the temporal Gillespie algorithm: by rendering the identification of relevant contacts during each time-step faster. One such approach which may be applied to processes with an absorbing state (e.g. an <inline-formula id="pcbi.1004579.e072"><alternatives><graphic id="pcbi.1004579.e072g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e072"/><mml:math id="M72" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula> state) is explored below.</p>
</sec>
<sec id="sec012">
<title>Improving performance by removing obsolete contacts</title>
<p>Empirical networks describing human contact differ from simulated networks in a number of ways. For example, their structure and dynamics are more complex [<xref ref-type="bibr" rid="pcbi.1004579.ref025">25</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref046">46</xref>–<xref ref-type="bibr" rid="pcbi.1004579.ref049">49</xref>] but perhaps most importantly in the perspective of optimizing simulations, they are of finite length. One is often interested in long-time behavior or slowly evolving processes compared to the length of available data. To overcome this limitation, one usually loops over the data set. This means that if a node enters an inactive absorbing state such as the recovered (<inline-formula id="pcbi.1004579.e073"><alternatives><graphic id="pcbi.1004579.e073g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e073"/><mml:math id="M73" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula>) state in the SIR model, one may remove all following contacts to this node from the data, thus reducing the number of contacts that one must go through during the following loop. Furthermore, since the <inline-formula id="pcbi.1004579.e074"><alternatives><graphic id="pcbi.1004579.e074g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e074"/><mml:math id="M74" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition is independent of the network, one may also remove all contacts between two infected nodes.</p>
<p>Pseudocode for an algorithm that removes obsolete contacts is given in Methods and C++ code is given in <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref>. <xref ref-type="fig" rid="pcbi.1004579.g005">Fig 5A</xref> compares the speed gain of the temporal Gillespie algorithm relative to rejection sampling with and without contact removal for simulations of a constant-rate SIR process on empirical networks of face-to-face contacts (<xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref>). Depending on the parameters of the simulated process, removing obsolete contacts may induce both a significant gain or loss in speed; for processes that are fast compared to the length of the data set, the data is not repeated or only repeated few times during a simulation and the additional overhead involved in identifying and removing the obsolete contacts renders the algorithm slower; for slow processes the data is looped many times and removing the obsolete contacts makes the algorithm faster. <xref ref-type="fig" rid="pcbi.1004579.g005">Fig 5A</xref> suggests an empirically determined rule-of-thumb: if the slowest time-scale of the simulated process (here ∼ 1/<italic>μ</italic>) is longer than the length of the data, <italic>T</italic>, removing obsolete contacts pays off, if it is shorter, one should not remove obsolete contacts.</p>
</sec>
<sec id="sec013">
<title>Slow network dynamics</title>
<p>For time-varying networks of face-to-face contacts, which are relevant for simulating epidemic spreading in a population, network dynamics are typically much faster than the time-scales of the dynamical process that is simulated (compare the 20 s time-resolution of the empirical data of <xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref> to typical 1/<italic>β</italic> ∼ 1 hour and 1/<italic>μ</italic> ∼ 1 week for flu-like diseases). In the opposite case, i.e., if the network evolves much slower than the dynamical process, the temporal Gillespie algorithm simply works like a static Gillespie algorithm in-between changes in the network structure while taking the changes changes into account exactly when they occur. The performance of the temporal Gillespie algorithm then approaches that of a static Gillespie algorithm in this case. Note that since <inline-formula id="pcbi.1004579.e075"><alternatives><graphic id="pcbi.1004579.e075g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e075"/><mml:math id="M75" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>Q</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>≫</mml:mo> <mml:mover><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula> in this limit, the second term dominates in <xref ref-type="disp-formula" rid="pcbi.1004579.e065">Eq (14)</xref>, which means that the speed of the algorithm is limited by the selection of waiting times and transitions that take place, and care should be taken to optimize these steps, e.g., by organizing the transition processes in a heap or a priority queue [<xref ref-type="bibr" rid="pcbi.1004579.ref037">37</xref>]. Note finally that to obtain reliable results using a rejection sampling algorithm one must use a time-step for simulations Δ<italic>t</italic><sub>RS</sub> which is much smaller than the time-step Δ<italic>t</italic> of network change. Thus the expected time complexity of rejection sampling scales with Δ<italic>t</italic>/Δ<italic>t</italic><sub>RS</sub> <italic>n</italic><sub>simu</sub> ≫ <italic>n</italic><sub>simu</sub> in this case.</p>
</sec>
</sec>
<sec id="sec014">
<title>6 Non-Markovian processes</title>
<p>For real-world contagion processes, transition rates are typically not constant but in general depend on the history of the process [<xref ref-type="bibr" rid="pcbi.1004579.ref030">30</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref031">31</xref>]. Such processes are termed <italic>non-Markovian</italic>. The survival probability for a single non-Markovian transition process taking place on a time-varying network is given by:
<disp-formula id="pcbi.1004579.e076"><alternatives><graphic id="pcbi.1004579.e076g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e076"/><mml:math id="M76" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mo form="prefix">exp</mml:mo> <mml:mo>(</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(15)</label></disp-formula>
Here <inline-formula id="pcbi.1004579.e077"><alternatives><graphic id="pcbi.1004579.e077g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e077"/><mml:math id="M77" display="inline" overflow="scroll"><mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> is a filtration for the process <italic>m</italic>, i.e., all information relevant to the transition process available up to and including time <italic>t</italic>; typically, <inline-formula id="pcbi.1004579.e078"><alternatives><graphic id="pcbi.1004579.e078g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e078"/><mml:math id="M78" display="inline" overflow="scroll"><mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> will be its starting time and relevant contacts that have taken place since. As above, <italic>t</italic>* is the time of the last transition and <italic>t</italic>** = <italic>t</italic>* + <italic>τ</italic> is the time of the next. [Note that since λ<sub><italic>m</italic></sub> now depends explicitly on <italic>t</italic>, we may absorb I<sub><italic>m</italic></sub> in λ<sub><italic>m</italic></sub>; however, to underscore the analogy with the Poissonian case, we keep the factor I<sub><italic>m</italic></sub> explicitly in <xref ref-type="disp-formula" rid="pcbi.1004579.e076">Eq (15)</xref>.]</p>
<p>We use again that the transition processes are independent, to write the waiting time survival probability:
<disp-formula id="pcbi.1004579.e079"><alternatives><graphic id="pcbi.1004579.e079g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e079"/><mml:math id="M79" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo form="prefix">exp</mml:mo> <mml:mo>(</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:mo>Λ</mml:mo> <mml:mo stretchy="false">(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(16)</label></disp-formula>
with
<disp-formula id="pcbi.1004579.e080"><alternatives><graphic id="pcbi.1004579.e080g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e080"/><mml:math id="M80" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>m</mml:mi> <mml:mo>∈</mml:mo> <mml:mo>Ω</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:munder> <mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(17)</label></disp-formula>
and where <inline-formula id="pcbi.1004579.e081"><alternatives><graphic id="pcbi.1004579.e081g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e081"/><mml:math id="M81" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:math></alternatives></inline-formula> is the union over <inline-formula id="pcbi.1004579.e082"><alternatives><graphic id="pcbi.1004579.e082g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e082"/><mml:math id="M82" display="inline" overflow="scroll"><mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> for <italic>m</italic> ∈ Ω.</p>
<p>For a static network, <xref ref-type="disp-formula" rid="pcbi.1004579.e079">Eq (6)</xref> reduces to the result found in [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>]. This can be seen by noting that <italic>M</italic>(<italic>t</italic>) = <italic>M</italic> and Ω(<italic>t</italic>) = Ω are then constant, and thus that <inline-formula id="pcbi.1004579.e083"><alternatives><graphic id="pcbi.1004579.e083g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e083"/><mml:math id="M83" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo>-</mml:mo> <mml:mrow><mml:mo>[</mml:mo> <mml:mi>d</mml:mi> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>/</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>]</mml:mo></mml:mrow> <mml:mo>/</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi>d</mml:mi> <mml:mrow><mml:mo>{</mml:mo> <mml:mo form="prefix">ln</mml:mo> <mml:mrow><mml:mo>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>]</mml:mo></mml:mrow> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>/</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1004579.e084"><alternatives><graphic id="pcbi.1004579.e084g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e084"/><mml:math id="M84" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>/</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, yielding directly Eq. (7) of [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>].</p>
<p>As in the Poissonian case (Sec. 4: “Temporal Gillespie algorithm”) we define the normalized waiting time, <italic>τ</italic>′, as
<disp-formula id="pcbi.1004579.e085"><alternatives><graphic id="pcbi.1004579.e085g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e085"/><mml:math id="M85" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msubsup><mml:mo>∫</mml:mo> <mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup></mml:mrow> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msubsup> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(18)</label></disp-formula>
This gives us the same simple form as above for the survival function of the normalized waiting time, <italic>τ</italic>′,
<disp-formula id="pcbi.1004579.e086"><alternatives><graphic id="pcbi.1004579.e086g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e086"/><mml:math id="M86" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>S</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo form="prefix">exp</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>-</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(19)</label></disp-formula>
and the probability that <italic>m</italic> is the transition that takes place at <italic>t</italic> = <italic>t</italic>**,
<disp-formula id="pcbi.1004579.e087"><alternatives><graphic id="pcbi.1004579.e087g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e087"/><mml:math id="M87" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>π</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msub><mml:mi mathvariant="normal">I</mml:mi> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mfrac><mml:mrow><mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mfrac> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(20)</label></disp-formula></p>
<p>Until now our approach and results are entirely equivalent to the Poissonian case considered above. However, since λ<sub><italic>m</italic></sub>(<italic>t</italic>) in general depend continuously on time, the transition time <italic>t</italic>** is not simply found by linear interpolation as in <xref ref-type="disp-formula" rid="pcbi.1004579.e048">Eq (12)</xref>. Instead, one would need to solve the implicit equation <inline-formula id="pcbi.1004579.e088"><alternatives><graphic id="pcbi.1004579.e088g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e088"/><mml:math id="M88" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> numerically to find <italic>t</italic>** exactly. To keep things simple and speed up calculations, we may approximate Λ(<italic>t</italic>) as constant over a time-step. This assumes that ΔΛ(<italic>t</italic>)Δ<italic>t</italic> ≪ 1, where ΔΛ(<italic>t</italic>) is the change of Λ(<italic>t</italic>) during a single time-step. It is a more lenient assumption than the assumption that Λ(<italic>t</italic>)Δ<italic>t</italic> ≪ 1 which rejection sampling relies on, as can be seen by noting that in general ΔΛ(<italic>t</italic>)/Λ(<italic>t</italic>) ≪ 1. The same assumption also lets us calculate <inline-formula id="pcbi.1004579.e089"><alternatives><graphic id="pcbi.1004579.e089g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e089"/><mml:math id="M89" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> as in the Poissonian case:
<disp-formula id="pcbi.1004579.e090"><alternatives><graphic id="pcbi.1004579.e090g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e090"/><mml:math id="M90" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>n</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:msup><mml:mi>n</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>Λ</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>t</mml:mi></mml:mrow> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>=</mml:mo> <mml:msup><mml:mi>n</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>n</mml:mi></mml:munderover> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(21)</label></disp-formula>
and the time, <italic>t</italic>**, at which the next transition takes place:
<disp-formula id="pcbi.1004579.e091"><alternatives><graphic id="pcbi.1004579.e091g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e091"/><mml:math id="M91" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mi>τ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>-</mml:mo> <mml:mi mathvariant="double-struck">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:msup><mml:mi>n</mml:mi> <mml:mrow><mml:mo>*</mml:mo> <mml:mo>*</mml:mo></mml:mrow></mml:msup></mml:msub> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mfrac> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(22)</label></disp-formula>
Using the above equations, we can now construct a temporal Gillespie algorithm for non-Markovian processes.</p>
<p>This algorithm updates all λ<sub><italic>m</italic></sub>(<italic>t</italic>) that depend on time at each time-step, where for the Poissonian case we only had to initialize new processes, i.e., contact-dependent processes (type <italic>b</italic> and <italic>c</italic>, Sec. 1: “Stochastic processes on time-varying networks”). This means the algorithm is only roughly a factor two faster than rejection sampling [compare dotted lines (<italic>ϵ</italic> = 0) in <xref ref-type="fig" rid="pcbi.1004579.g006">Fig 6</xref>]. To speed up the algorithm, we may employ a first-order cumulant expansion of <inline-formula id="pcbi.1004579.e092"><alternatives><graphic id="pcbi.1004579.e092g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e092"/><mml:math id="M92" display="inline" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi> <mml:mo>(</mml:mo> <mml:mi>τ</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> around <italic>τ</italic> = 0, as proposed in [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>, <xref ref-type="bibr" rid="pcbi.1004579.ref038">38</xref>] for static non-Markovian Gillespie algorithms. It consists in approximating <inline-formula id="pcbi.1004579.e093"><alternatives><graphic id="pcbi.1004579.e093g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e093"/><mml:math id="M93" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> by the constant <inline-formula id="pcbi.1004579.e094"><alternatives><graphic id="pcbi.1004579.e094g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e094"/><mml:math id="M94" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mo>λ</mml:mo> <mml:mi>m</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msup> <mml:mo>;</mml:mo> <mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> for <italic>t</italic>* &lt; <italic>t</italic> &lt; <italic>t</italic>** and gives a considerable speed increase of the algorithm [full (<italic>ϵ</italic> → ∞) in <xref ref-type="fig" rid="pcbi.1004579.g006">Fig 6</xref>]. However, the approximation is only valid when <italic>M</italic>(<italic>t</italic>) ≫ 1 [<xref ref-type="bibr" rid="pcbi.1004579.ref043">43</xref>], which is not always the case for contagion processes. Notably, at the beginning and end of an SIR process, and near the epidemic threshold for an SIS process, <italic>M</italic> is small and the approximation breaks down; the approximate algorithm for example overestimates the peak number of infected nodes in a SIR process with recovery rates that increase over time [compare full black line (<italic>ϵ</italic> → ∞) to the quasi-exact full red line (<italic>ϵ</italic> = 0) in <xref ref-type="fig" rid="pcbi.1004579.g007">Fig 7A</xref>]. An intermediate approach, which works when the number of transition processes is small, but is not too slow to be of practical relevance, is needed. We propose one such approach below [<xref ref-type="bibr" rid="pcbi.1004579.ref044">44</xref>].</p>
<fig id="pcbi.1004579.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Comparison of the speed of the temporal Gillespie and the rejection sampling algorithms: non-Markovian SIR process.</title>
<p>Ratio Θ<sub>RS</sub>/Θ<sub>TGA</sub> between the time per realization of a single simulation of an SIR process with Weibull distributed recovery times using rejection sampling and the temporal Gillespie algorithm on activity driven networks of different average degree <inline-formula id="pcbi.1004579.e095"><alternatives><graphic id="pcbi.1004579.e095g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e095"/><mml:math id="M95" display="inline" overflow="scroll"><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> [for empirical contact networks, <inline-formula id="pcbi.1004579.e096"><alternatives><graphic id="pcbi.1004579.e096g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e096"/><mml:math id="M96" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>≈</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>004</mml:mn> <mml:mo>−</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>07</mml:mn></mml:mrow></mml:math></alternatives></inline-formula> (<xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref>)]: (A) for networks consisting of <italic>N</italic> = 100 nodes and (B) of <italic>N</italic> = 1 000 nodes. The parameter <italic>ϵ</italic> controls the accuracy of the temporal Gillespie algorithm: for <italic>ϵ</italic> = 0, where λ<sub><italic>m</italic></sub>(<italic>t</italic>) is approximated as constant over a single time-step, it is most accurate; for <italic>ϵ</italic> → ∞, where λ<sub><italic>m</italic></sub> is approximated as constant between two consecutive transition events, it is the least accurate. Node activities were given by <italic>a</italic><sub><italic>i</italic></sub> = <italic>ηz</italic><sub><italic>i</italic></sub> with <inline-formula id="pcbi.1004579.e097"><alternatives><graphic id="pcbi.1004579.e097g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e097"/><mml:math id="M97" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>z</italic><sub><italic>i</italic></sub> ∈ [0.03, 1); a node formed two contacts each time it was active. The recovery rate of an infected node was given by <xref ref-type="disp-formula" rid="pcbi.1004579.e103">Eq (23)</xref> with <italic>γ</italic> = 1.5. The infection rate was <italic>β</italic> = 10<sup>3</sup> <italic>μ</italic><sub>0</sub> for networks with <inline-formula id="pcbi.1004579.e098"><alternatives><graphic id="pcbi.1004579.e098g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e098"/><mml:math id="M98" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>002</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, <italic>β</italic> = 10<sup>2</sup> <italic>μ</italic><sub>0</sub> for networks with <inline-formula id="pcbi.1004579.e099"><alternatives><graphic id="pcbi.1004579.e099g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e099"/><mml:math id="M99" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>02</mml:mn></mml:mrow></mml:math></alternatives></inline-formula>, and <italic>β</italic> = 10<italic>μ</italic><sub>0</sub> for networks with <inline-formula id="pcbi.1004579.e100"><alternatives><graphic id="pcbi.1004579.e100g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e100"/><mml:math id="M100" display="inline" overflow="scroll"><mml:mrow><mml:mover><mml:mrow><mml:mi>k</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn> <mml:msub><mml:mi>μ</mml:mi> <mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. (See <xref ref-type="sec" rid="sec004">Methods</xref> for details on how simulations were performed.)</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g006"/>
</fig>
<fig id="pcbi.1004579.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g007</object-id>
<label>Fig 7</label>
<caption>
<title>Comparison of the outcome of non-Markovian SIR processes for different values of the parameter <italic>ϵ</italic>.</title>
<p>(A) Average number of infected nodes, 〈<italic>I</italic>〉, as function of time for a SIR process with Weibull distributed recovery times. (B) Distribution of the numbers of recovered nodes after the infection has died out (i.e. when <italic>I</italic> = 0). For <italic>ϵ</italic> = 0 the temporal Gillespie algorithm is quasi-exact (see <xref ref-type="supplementary-material" rid="pcbi.1004579.s003">S3 Fig</xref> for comparison with rejection sampling); for <italic>ϵ</italic> → ∞, corresponding to a first-order cumulant expansion of <inline-formula id="pcbi.1004579.e101"><alternatives><graphic id="pcbi.1004579.e101g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e101"/><mml:math id="M101" display="inline" overflow="scroll"><mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> around <italic>t</italic> = <italic>t</italic>* (see main text), it is least accurate. As <italic>ϵ</italic> is decreased, both 〈<italic>I</italic>〉(<italic>t</italic>) and <italic>p</italic>(<italic>R</italic>) rapidly approach the quasi-exact result obtained for <italic>ϵ</italic> = 0. Simulations were performed on an activity-driven network consisting of <italic>N</italic> = 100 nodes with activities <italic>a</italic><sub><italic>i</italic></sub> = <italic>z</italic><sub><italic>i</italic></sub>/10, where <inline-formula id="pcbi.1004579.e102"><alternatives><graphic id="pcbi.1004579.e102g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e102"/><mml:math id="M102" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula>; nodes’ recovery times followed <xref ref-type="disp-formula" rid="pcbi.1004579.e103">Eq (23)</xref> with <italic>γ</italic> = 1.5 and <italic>μ</italic><sub>0</sub> = 10<sup>−4</sup> Hz; the length of a time-step was Δ<italic>t</italic> = 1 s and the infection rate β = 100μ<sub>0</sub> = 10<sup>−2</sup> Hz.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g007"/>
</fig>
<sec id="sec015">
<title>Efficient non-Markovian temporal Gillespie algorithm</title>
<p>As discussed above, we neither want to update all transition rates at each time-step as this makes the temporal Gillespie algorithm slow, nor do we want to only update them when a transition event takes place as this makes the algorithm inaccurate.</p>
<p>An intermediate approach is found by looking at the relevant physical time-scales of the transition processes: the average waiting time before they take place, 〈<italic>τ</italic><sup>(<italic>m</italic>)</sup>〉. If the time elapsed since we last updated λ<sub><italic>m</italic></sub>(<italic>t</italic>) is small compared to 〈<italic>τ</italic><sup>(<italic>m</italic>)</sup>〉, we do not make a large error by treating it as constant over the interval; however, if the elapsed time is comparable to or larger than 〈<italic>τ</italic><sup>(<italic>m</italic>)</sup>〉, the error may be considerable. Thus, instead of updating λ<sub><italic>m</italic></sub> at each time-step, we may update it only after a time <italic>t</italic> &gt; <italic>ϵ</italic>〈<italic>τ</italic><sup>(<italic>m</italic>)</sup>〉 has elapsed since it was last updated. Here <italic>ϵ</italic> controls the precision of the algorithm.</p>
<p>Below, we use this approach to simulate a non-Markovian SIR process, where the recovery times of infected nodes follow a Weibull distribution (see <xref ref-type="sec" rid="sec004">Methods</xref> for an algorithm written in pseudocode and <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref> for implementation in C++). The recovery rate of an infected node is here given by
<disp-formula id="pcbi.1004579.e103"><alternatives><graphic id="pcbi.1004579.e103g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e103"/><mml:math id="M103" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi>γ</mml:mi> <mml:msubsup><mml:mi>μ</mml:mi> <mml:mn>0</mml:mn> <mml:mi>γ</mml:mi></mml:msubsup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:msup><mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>γ</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:mspace width="5.0pt"/><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(23)</label></disp-formula>
where <italic>μ</italic><sub>0</sub> sets the scale, <italic>t</italic><sup><italic>(m)</italic></sup> is time when the node was infected, and <italic>γ</italic> is a shape parameter of the distribution. For <italic>γ</italic> = 1, we recover the constant-rate Poissonian case with <italic>μ</italic>(<italic>t</italic>;<italic>t</italic><sup><italic>(m)</italic></sup>) = <italic>μ</italic><sub>0</sub>. For realistic modeling of infections, <italic>γ</italic> &gt; 1; here <italic>μ</italic>(<italic>t</italic>;<italic>t</italic><sup><italic>(m)</italic></sup>) is zero at <italic>t</italic> = <italic>t</italic><sup><italic>(m)</italic></sup> and grows with time. In this case, we thus update the recovery rates <italic>μ</italic>(<italic>t</italic>;<italic>t</italic><sup><italic>(m)</italic></sup>) whenever the time elapsed since a transition last took place exceeds 〈<italic>τ</italic><sup>(<italic>m</italic>)</sup>〉 = Γ(1 + 1/<italic>γ</italic>)/<italic>μ</italic><sub>0</sub>.</p>
<p>The parameter <italic>ϵ</italic> lets us control the precision of the non-Markovian temporal Gillespie algorithm: the smaller <italic>ϵ</italic> is, the more precise the algorithm is, on the other hand, the larger <italic>ϵ</italic> is, the faster the algorithm is (<xref ref-type="fig" rid="pcbi.1004579.g008">Fig 8</xref>). At <italic>ϵ</italic> = 0, the temporal Gillespie algorithm is maximally accurate, but also slowest, corresponding to the quasi-exact approximation that <inline-formula id="pcbi.1004579.e104"><alternatives><graphic id="pcbi.1004579.e104g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e104"/><mml:math id="M104" display="inline" overflow="scroll"><mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> stays constant over a single time-step. Letting <italic>ϵ</italic> → ∞ corresponds to the first order cumulant expansion of [<xref ref-type="bibr" rid="pcbi.1004579.ref017">17</xref>], and is the fastest, but least accurate. Intermediate <italic>ϵ</italic> gives intermediate accuracy and speed, and permits one to obtain the desired accuracy without sacrificing performance. In the case of the SIR process with Weibull-distributed recovery times, <italic>ϵ</italic> = 0.1 gives an error of no more than a few percent (Figs <xref ref-type="fig" rid="pcbi.1004579.g008">8A–8D</xref> and <xref ref-type="fig" rid="pcbi.1004579.g007">7</xref>)—which is usually acceptable as the discrepancy between model and reality can be expected to be larger—with an almost optimal computation time (Figs <xref ref-type="fig" rid="pcbi.1004579.g008">8E</xref> and <xref ref-type="fig" rid="pcbi.1004579.g006">6</xref>).</p>
<fig id="pcbi.1004579.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.g008</object-id>
<label>Fig 8</label>
<caption>
<title>Accuracy and speed of the non-Markovian temporal Gillespie algorithm as function of <italic>ϵ</italic>.</title>
<p>(A)–(D) Different measures of the difference in outcome of simulations between algorithms with <italic>ϵ</italic> &gt; 0 and <italic>ϵ</italic> = 0 (quasi-exact). (A) Difference, <inline-formula id="pcbi.1004579.e105"><alternatives><graphic id="pcbi.1004579.e105g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e105"/><mml:math id="M105" display="inline" overflow="scroll"><mml:mrow><mml:mo>Δ</mml:mo> <mml:msub><mml:mover><mml:mi>i</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mtext>max</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mover><mml:mi>i</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mtext>max</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>ϵ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:msub><mml:mover><mml:mi>i</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mtext>max</mml:mtext></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, in the peak average fraction of infected nodes, <inline-formula id="pcbi.1004579.e106"><alternatives><graphic id="pcbi.1004579.e106g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e106"/><mml:math id="M106" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mover><mml:mi>i</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mtext>max</mml:mtext></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mover><mml:mi>I</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mtext>max</mml:mtext></mml:msub> <mml:mo>/</mml:mo> <mml:mi>N</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. (B) Difference Δ<italic>t</italic><sub>max</sub> between the times at which this peak takes place, normalized by <italic>μ</italic><sub>0</sub>. (C) Difference, <inline-formula id="pcbi.1004579.e107"><alternatives><graphic id="pcbi.1004579.e107g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e107"/><mml:math id="M107" display="inline" overflow="scroll"><mml:mrow><mml:mo>Δ</mml:mo> <mml:msub><mml:mover><mml:mi>r</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>∞</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, in the average fraction of nodes affected by the infection—the average <italic>attack rate</italic>. (D) Kullback-Leibler divergence, KL[<italic>p</italic>(<italic>r</italic><sub>∞</sub>)], between the distributions of attack rates (E) Time per simulation of the process. Simulations were performed on an activity-driven network with <italic>N</italic> = 100 nodes and activities <italic>a</italic><sub><italic>i</italic></sub> = <italic>z</italic><sub><italic>i</italic></sub>/10 with <inline-formula id="pcbi.1004579.e108"><alternatives><graphic id="pcbi.1004579.e108g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e108"/><mml:math id="M108" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>z</italic><sub><italic>i</italic></sub> ∈ [0.03, 1); nodes’ recovery times followed <xref ref-type="disp-formula" rid="pcbi.1004579.e103">Eq (23)</xref> with <italic>γ</italic> = 1.5, μ<sub>0</sub> = 10<sup>−4</sup> Hz, and Δ<italic>t</italic> = 1 s.</p>
</caption>
<graphic mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.g008"/>
</fig>
</sec>
</sec>
</sec>
<sec id="sec016" sec-type="conclusions">
<title>Discussion</title>
<p>We have presented a fast temporal Gillespie algorithm for simulating stochastic processes on time-varying networks. The temporal Gillespie algorithm is up to multiple orders of magnitude faster than current algorithms for simulating stochastic processes on time-varying networks. For Poisson (constant-rate) processes, where it is stochastically exact, its application is particularly simple. The algorithm is also applicable to non-Markovian processes, where a control parameter lets one choose the desired accuracy and performance in terms of simulation speed. We have shown how to apply it to compartmental models of contagion in human contact networks. The scope of the temporal Gillespie algorithm is more general than this, however, and it may be applied e.g. to diffusion-like processes or systems for which a network description is not appropriate.</p>
</sec>
<sec id="sec017" sec-type="materials|methods">
<title>Methods</title>
<p>The following four subsections contain supporting information to the manuscript: the first subsection lists notation used in the article (Notation); the second details how Monte Carlo simulations were performed (Details on how Monte Carlo simulations were performed) the third gives pseudocode for application of the temporal Gillespie algorithm to specific contagion processes on time-varying networks (Algorithms for simulating specific contagion models). Finally, in the fourth subsection we give pseudocode for further optimization of the algorithm for empirical networks by removal of obsolete contacts (Removing obsolete contacts for an SIR process on empirical networks).</p>
<sec id="sec018">
<title>Notation</title>
<p>Tables <xref ref-type="table" rid="pcbi.1004579.t002">2</xref> and <xref ref-type="table" rid="pcbi.1004579.t003">3</xref> list the notation used in the manuscript. <xref ref-type="table" rid="pcbi.1004579.t002">Table 2</xref> gives notation pertaining to the temporal Gillespie algorithm, and <xref ref-type="table" rid="pcbi.1004579.t003">Table 3</xref> lists notation pertaining to time-varying networks and compartmental contagion processes.</p>
<table-wrap id="pcbi.1004579.t002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.t002</object-id>
<label>Table 2</label>
<caption>
<title>Notation pertaining to the temporal Gillespie algorithm.</title>
<p>The row “First appearance(s)” points to where where the notation is introduced in the Results section.</p>
</caption>
<alternatives>
<graphic id="pcbi.1004579.t002g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.t002"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Symbol</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Description</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>First appearance(s)</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>t</italic></td>
<td align="left" rowspan="1" colspan="1">Real time.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Δ<italic>t</italic></td>
<td align="left" rowspan="1" colspan="1">Duration of a time-step.</td>
<td align="left" rowspan="1" colspan="1">Sec. 2</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>n</italic></td>
<td align="left" rowspan="1" colspan="1">Time-step number.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>t</italic><sub><italic>n</italic></sub></td>
<td align="left" rowspan="1" colspan="1">Time at beginning of time-step <italic>n</italic>: <italic>t</italic><sub><italic>n</italic></sub> = <italic>n</italic>Δ<italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>m</italic></td>
<td align="left" rowspan="1" colspan="1">Possible transition / transition process.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">λ<sub><italic>m</italic></sub></td>
<td align="left" rowspan="1" colspan="1">Transition rate for <italic>m</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">I<sub><italic>m</italic></sub>(<italic>t</italic>)</td>
<td align="left" rowspan="1" colspan="1">Function indicating if the transition <italic>m</italic> may take place at time <italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Ω(<italic>t</italic>)</td>
<td align="left" rowspan="1" colspan="1">Set of transition processes at time <italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">Secs. 1, 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>M</italic>(<italic>t</italic>)</td>
<td align="left" rowspan="1" colspan="1">Number of transition processes at time <italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">Secs. 1, 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Ω</td>
<td align="left" rowspan="1" colspan="1">Set of total possible transitions between two consecutive transition events.</td>
<td align="left" rowspan="1" colspan="1">Secs. 1, 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>M</italic></td>
<td align="left" rowspan="1" colspan="1">Number of total possible transitions between two consecutive transition events.</td>
<td align="left" rowspan="1" colspan="1">Secs. 1, 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Λ, Λ(<italic>t</italic>)</td>
<td align="left" rowspan="1" colspan="1">Cumulative transition rate (at time <italic>t</italic>): Λ(<italic>t</italic>) = ∑<sub><italic>m</italic> ∈ Ω(<italic>t</italic>)</sub> λ<sub><italic>m</italic></sub>.</td>
<td align="left" rowspan="1" colspan="1">Secs. 3, 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e109">
<alternatives>
<graphic id="pcbi.1004579.e109g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e109"/>
<mml:math id="M109" display="inline" overflow="scroll">
<mml:mrow>
<mml:mi mathvariant="double-struck">L</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>;</mml:mo>
<mml:msup>
<mml:mi>t</mml:mi>
<mml:mo>*</mml:mo>
</mml:msup>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Integrated cumulative transition rate (from <italic>t</italic>* to <italic>t</italic>).</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>τ</italic></td>
<td align="left" rowspan="1" colspan="1">Waiting time between two consecutive transitions.</td>
<td align="left" rowspan="1" colspan="1">Sec. 3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>S</italic>(<italic>τ</italic>)</td>
<td align="left" rowspan="1" colspan="1">Waiting time survival function.</td>
<td align="left" rowspan="1" colspan="1">Sec. 3</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>t</italic>*, <italic>t</italic>**</td>
<td align="left" rowspan="1" colspan="1">Times when the last/next transition took/takes place, respectively.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>n</italic>*, <italic>n</italic>**</td>
<td align="left" rowspan="1" colspan="1">Time-steps during which the last/next transition took/takes place, respectively.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>τ</italic>′</td>
<td align="left" rowspan="1" colspan="1">Normalized waiting time between two consecutive transition events.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>S</italic>(<italic>τ</italic>′)</td>
<td align="left" rowspan="1" colspan="1">Normalized waiting time survival function.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>τ</italic>′ ∼ Exp (1)</td>
<td align="left" rowspan="1" colspan="1"><italic>τ</italic>′ is exponentially distributed with unit rate.</td>
<td align="left" rowspan="1" colspan="1">Sec. 4 (Sec. 3)</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Θ<sub>RS</sub></td>
<td align="left" rowspan="1" colspan="1">Time per simulation for the rejection sampling algorithm.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Θ<sub>TGA</sub></td>
<td align="left" rowspan="1" colspan="1">Time per simulation for the temporal Gillespie algorithm.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e110">
<alternatives>
<graphic id="pcbi.1004579.e110g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e110"/>
<mml:math id="M110" display="inline" overflow="scroll">
<mml:mrow>
<mml:mi mathvariant="script">O</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>x</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Term of order <italic>x</italic>, i.e., <inline-formula id="pcbi.1004579.e111"><alternatives><graphic id="pcbi.1004579.e111g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e111"/><mml:math id="M111" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mi>x</mml:mi> <mml:mo>)</mml:mo> <mml:mo>=</mml:mo> <mml:mi>a</mml:mi> <mml:mspace width="0.166667em"/><mml:mi>x</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> for a given constant <italic>a</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e112">
<alternatives>
<graphic id="pcbi.1004579.e112g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e112"/>
<mml:math id="M112" display="inline" overflow="scroll">
<mml:msubsup>
<mml:mi mathvariant="script">F</mml:mi>
<mml:mi>t</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>m</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Filtration for the transition process <italic>m</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 6</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e113">
<alternatives>
<graphic id="pcbi.1004579.e113g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e113"/>
<mml:math id="M113" display="inline" overflow="scroll">
<mml:msub>
<mml:mi mathvariant="script">F</mml:mi>
<mml:mi>t</mml:mi>
</mml:msub>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Union of all <inline-formula id="pcbi.1004579.e114"><alternatives><graphic id="pcbi.1004579.e114g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e114"/><mml:math id="M114" display="inline" overflow="scroll"><mml:msubsup><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 6</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<table-wrap id="pcbi.1004579.t003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004579.t003</object-id>
<label>Table 3</label>
<caption>
<title>Notation pertaining to compartmental contagion models and time-varying networks.</title>
<p>The row “First appearance(s)” points to where where the notation is introduced in the Results section.</p>
</caption>
<alternatives>
<graphic id="pcbi.1004579.t003g" mimetype="image" xlink:type="simple" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.t003"/>
<table frame="box" rules="all" border="0">
<colgroup span="1">
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
<col align="left" valign="top" span="1"/>
</colgroup>
<thead>
<tr>
<th align="left" rowspan="1" colspan="1"><bold>Symbol</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>Description</bold></th>
<th align="left" rowspan="1" colspan="1"><bold>First appearance</bold></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>i</italic>, <italic>j</italic></td>
<td align="left" rowspan="1" colspan="1">Node.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>N</italic></td>
<td align="left" rowspan="1" colspan="1">Number of nodes in network.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">(<italic>i</italic>, <italic>j</italic>)<sub><italic>t</italic></sub></td>
<td align="left" rowspan="1" colspan="1">Contact taking place at time <italic>t</italic> between nodes <italic>i</italic> and <italic>j</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><inline-formula id="pcbi.1004579.e115">
<alternatives>
<graphic id="pcbi.1004579.e115g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e115"/>
<mml:math id="M115" display="inline" overflow="scroll">
<mml:msub>
<mml:mi>k</mml:mi>
<mml:mi mathvariant="script">I</mml:mi>
</mml:msub>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:math>
</alternatives>
</inline-formula></td>
<td align="left" rowspan="1" colspan="1">Number of infected nodes in contact with <italic>i</italic> at time <italic>t</italic></td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e116">
<alternatives>
<graphic id="pcbi.1004579.e116g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e116"/>
<mml:math id="M116" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:mi>k</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Average degree (number of contacts per node) of network at time <italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">
<xref ref-type="fig" rid="pcbi.1004579.g004">Fig 4</xref>
</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>x</italic><sub><italic>i</italic></sub>(<italic>t</italic>)</td>
<td align="left" rowspan="1" colspan="1">Random variable specifying the state (compartment) of node <italic>i</italic> at time <italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e117">
<alternatives>
<graphic id="pcbi.1004579.e117g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e117"/>
<mml:math id="M117" display="inline" overflow="scroll">
<mml:mrow>
<mml:msub>
<mml:mi mathvariant="script">X</mml:mi>
<mml:mrow/>
</mml:msub>
<mml:mo>∈</mml:mo>
<mml:mrow>
<mml:mo>{</mml:mo>
<mml:msub>
<mml:mi mathvariant="script">X</mml:mi>
<mml:mn>1</mml:mn>
</mml:msub>
<mml:mo>,</mml:mo>
<mml:msub>
<mml:mi mathvariant="script">X</mml:mi>
<mml:mn>2</mml:mn>
</mml:msub>
<mml:mo>…</mml:mo>
<mml:msub>
<mml:mi mathvariant="script">X</mml:mi>
<mml:mi>q</mml:mi>
</mml:msub>
<mml:mo>}</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Possible node states (compartments).</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>X</italic><sub><italic>p</italic></sub></td>
<td align="left" rowspan="1" colspan="1">Number of nodes in state <inline-formula id="pcbi.1004579.e118"><alternatives><graphic id="pcbi.1004579.e118g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e118"/><mml:math id="M118" display="inline" overflow="scroll"><mml:msub><mml:mi mathvariant="script">X</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e119">
<alternatives>
<graphic id="pcbi.1004579.e119g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e119"/>
<mml:math id="M119" display="inline" overflow="scroll">
<mml:mi mathvariant="script">S</mml:mi>
</mml:math>
</alternatives>
</inline-formula>, <inline-formula id="pcbi.1004579.e120"><alternatives><graphic id="pcbi.1004579.e120g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e120"/><mml:math id="M120" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1004579.e121"><alternatives><graphic id="pcbi.1004579.e121g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e121"/><mml:math id="M121" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula></td>
<td align="left" rowspan="1" colspan="1">Possible node states in SIS and SIR models of epidemic spreading.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>S</italic>, <italic>I</italic>, <italic>R</italic></td>
<td align="left" rowspan="1" colspan="1">Number of nodes in each of the states <inline-formula id="pcbi.1004579.e122"><alternatives><graphic id="pcbi.1004579.e122g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e122"/><mml:math id="M122" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1004579.e123"><alternatives><graphic id="pcbi.1004579.e123g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e123"/><mml:math id="M123" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula>, and <inline-formula id="pcbi.1004579.e124"><alternatives><graphic id="pcbi.1004579.e124g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e124"/><mml:math id="M124" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula>, respectively.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>β</italic></td>
<td align="left" rowspan="1" colspan="1">Rate of <inline-formula id="pcbi.1004579.e125"><alternatives><graphic id="pcbi.1004579.e125g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e125"/><mml:math id="M125" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition of a susceptible node in contact with an infectious node.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>μ</italic></td>
<td align="left" rowspan="1" colspan="1">Rate of spontaneous <inline-formula id="pcbi.1004579.e126"><alternatives><graphic id="pcbi.1004579.e126g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e126"/><mml:math id="M126" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> or <inline-formula id="pcbi.1004579.e127"><alternatives><graphic id="pcbi.1004579.e127g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e127"/><mml:math id="M127" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition of an infectious node.</td>
<td align="left" rowspan="1" colspan="1">Sec. 1</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e128">
<alternatives>
<graphic id="pcbi.1004579.e128g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e128"/>
<mml:math id="M128" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:mi>E</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Mean number of contacts during a single time-step.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e129">
<alternatives>
<graphic id="pcbi.1004579.e129g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e129"/>
<mml:math id="M129" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:mi>M</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Mean number of transition processes per single time-step.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e130">
<alternatives>
<graphic id="pcbi.1004579.e130g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e130"/>
<mml:math id="M130" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:mi>Q</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Mean number of transitions that take place per time-step.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e131">
<alternatives>
<graphic id="pcbi.1004579.e131g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e131"/>
<mml:math id="M131" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:msub>
<mml:mi>M</mml:mi>
<mml:mrow>
<mml:mi mathvariant="normal">S</mml:mi>
<mml:mo>→</mml:mo>
<mml:mi mathvariant="normal">I</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Mean number of <inline-formula id="pcbi.1004579.e132"><alternatives><graphic id="pcbi.1004579.e132g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e132"/><mml:math id="M132" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula>–<inline-formula id="pcbi.1004579.e133"><alternatives><graphic id="pcbi.1004579.e133g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e133"/><mml:math id="M133" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula> contacts during a single time-step.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">
<inline-formula id="pcbi.1004579.e134">
<alternatives>
<graphic id="pcbi.1004579.e134g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e134"/>
<mml:math id="M134" display="inline" overflow="scroll">
<mml:mover>
<mml:mrow>
<mml:mi>I</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>t</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
<mml:mo>¯</mml:mo>
</mml:mover>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left" rowspan="1" colspan="1">Mean number of infectious nodes.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>T</italic></td>
<td align="left" rowspan="1" colspan="1">Length of a data set describing a time-varying network (in time).</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>n</italic><sub>simu</sub></td>
<td align="left" rowspan="1" colspan="1">Number of time-steps that are simulated during a single realization.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1">Δ<italic>t</italic><sub>RS</sub></td>
<td align="left" rowspan="1" colspan="1">Time-step used for rejection sampling when λ<sub><italic>m</italic></sub>Δ<italic>t</italic> are large, Δ<italic>t</italic><sub>RS</sub> ≤Δ<italic>t</italic>.</td>
<td align="left" rowspan="1" colspan="1">Sec. 5</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>μ</italic><sub>0</sub></td>
<td align="left" rowspan="1" colspan="1">Scale parameter of the Weibull distribution.</td>
<td align="left" rowspan="1" colspan="1">Sec. 7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>γ</italic></td>
<td align="left" rowspan="1" colspan="1">Shape parameter of the Weibull distribution.</td>
<td align="left" rowspan="1" colspan="1">Sec. 7</td>
</tr>
<tr>
<td align="left" rowspan="1" colspan="1"><italic>t</italic><sup>(<italic>m</italic>)</sup></td>
<td align="left" rowspan="1" colspan="1">Starting time for transition process <italic>m</italic> (e.g. the time when a node was infected).</td>
<td align="left" rowspan="1" colspan="1">Sec. 7</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec019">
<title>Details on how Monte Carlo simulations were performed</title>
<p>All simulations for comparing the speed of algorithms were performed sequentially on a HP EliteBook Folio 9470m with a dual-core (4 threads) Intel Core i7-3687U CPU @ 2.10 GHz. The system had 8 GB 1 600 MHz DDR3 SDRAM and a 256 GB mSATA Solid State Drive. Code was compiled with TDM GCC 64 bit using <monospace>g++</monospace> with the optimization option <monospace>-O2</monospace>. Speedtests were also performed using <monospace>-O3</monospace> and <monospace>-Ofast</monospace>, but <monospace>-O2</monospace> gave the fastest results, both for rejection sampling and temporal Gillespie algorithms.</p>
<p>For SIR processes simulations were run until <italic>I</italic> = 0; for SIS processes simulations were run for 20/(<italic>μ</italic>Δ<italic>t</italic>) time-steps (as in <xref ref-type="fig" rid="pcbi.1004579.g003">Fig 3</xref>) or until <italic>I</italic> = 0, whichever happened first. Between 100 and 10 000 independent realizations were performed for each data point depending on <italic>μ</italic>Δ<italic>t</italic> (100 for low <italic>μ</italic>Δ<italic>t</italic> and 10 000 for high <italic>μ</italic>Δ<italic>t</italic>). For simulations on empirical contact data, data sets were looped if necessary.</p>
</sec>
<sec id="sec020">
<title>Algorithms for simulating specific contagion models</title>
<p>We here give pseudocode for the application of the temporal Gillespie algorithm to three specific models: the first subsection treats the Poissonian SIR process, the second treats the Poissonian SIS process, and the third treats a non-Markovian SIR process with recovery times following a general distribution.</p>
<p>We assume in the following that the time-varying network is represented by a list of lists of individual contacts taking place during each time-step. An individual contact, termed <monospace>contact</monospace>, is represented by a tuple of nodes, <monospace>i</monospace> and <monospace>j</monospace>. The list <monospace>contactLists[t]</monospace> gives the contacts taking place during a single time-step, <monospace>t</monospace>, for <monospace>t = 0, 1, …, T_simulation-1</monospace>, where <monospace>T_simulation</monospace> is the desired number of time-steps to simulate. The state of each node is given by the vector <monospace>x</monospace>, where the entry <monospace>x[i] ∈ {S,I,R}</monospace> gives the state of node <italic>i</italic>.</p>
<p>As one may always normalize time by the duration of a time-step, Δ<italic>t</italic>, we have in the following set Δ<italic>t</italic> = 1. Note that <monospace>beta</monospace> and <monospace>mu</monospace> in the code then corresponds to <italic>β</italic>Δ<italic>t</italic> and <italic>μ</italic>Δ<italic>t</italic>, respectively.</p>
<sec id="sec021">
<title>SIR process</title>
<p>The classical SIR model with constant infection and recovery rates is the simplest epidemic model where individuals can gain immunity. As discussed in the main text, nodes may be in one of three states: susceptible (<inline-formula id="pcbi.1004579.e135"><alternatives><graphic id="pcbi.1004579.e135g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e135"/><mml:math id="M135" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula>), infectious (<inline-formula id="pcbi.1004579.e136"><alternatives><graphic id="pcbi.1004579.e136g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e136"/><mml:math id="M136" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula>), or recovered (<inline-formula id="pcbi.1004579.e137"><alternatives><graphic id="pcbi.1004579.e137g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e137"/><mml:math id="M137" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula>). Two different transition types let the nodes switch state: a spontaneous <inline-formula id="pcbi.1004579.e138"><alternatives><graphic id="pcbi.1004579.e138g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e138"/><mml:math id="M138" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition which takes place with rate <italic>μ</italic>, and a contact-dependent <inline-formula id="pcbi.1004579.e139"><alternatives><graphic id="pcbi.1004579.e139g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e139"/><mml:math id="M139" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition which takes place with rate <italic>β</italic> upon contact with an infectious node. Pseudocode 1 shows how the temporal Gillespie algorithm may be implemented for an SIR process on a time-varying contact network.</p>
<p specific-use="line"><monospace><bold>Pseudocode 1: Pseudocode for an SIR process with constant and homogeneous transition rates.</bold> C++ code for homogeneous and heterogeneous populations is given in <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref>.</monospace></p>
<p specific-use="line"><monospace> //Initialize:</monospace></p>
<p specific-use="line"><monospace>01 FOR i = 1,…,N</monospace></p>
<p specific-use="line"><monospace>02  x[i] = S //set node states to S</monospace></p>
<p specific-use="line"><monospace>03 ENDFOR</monospace></p>
<p specific-use="line"><monospace>04 x[root] = I //set state of root node to I</monospace></p>
<p specific-use="line"><monospace>05 m_I = [root] //list of infected nodes</monospace></p>
<p specific-use="line"><monospace>06 N_I = 1 //number of infected nodes</monospace></p>
<p specific-use="line"><monospace>07 N_R = 0 //number of recovered nodes</monospace></p>
<p specific-use="line"><monospace>08 Mu = mu //cumulative recovery rate</monospace></p>
<p specific-use="line"><monospace>09 tau = randexp(1) //draw tau Exp(1)</monospace></p>
<p specific-use="line"><monospace> //Run through the time-steps:</monospace></p>
<p specific-use="line"><monospace>10 FOR t = 0,1,…,T_simulation-1</monospace></p>
<p specific-use="line"><monospace>  //Update list of possible S-&gt;I transitions:</monospace></p>
<p specific-use="line"><monospace>11  CLEAR m_SI //S nodes in contact with I nodes</monospace></p>
<p specific-use="line"><monospace>12  FOR contact in contactLists[t]</monospace></p>
<p specific-use="line"><monospace>13   (i,j) = contact</monospace></p>
<p specific-use="line"><monospace>14   IF (x[i],x[j])==(S,I)</monospace></p>
<p specific-use="line"><monospace>15    APPEND i to m_SI</monospace></p>
<p specific-use="line"><monospace>16   ELSE IF (x[i],x[j])==(I,S)</monospace></p>
<p specific-use="line"><monospace>17    APPEND j to m_SI</monospace></p>
<p specific-use="line"><monospace>18   ENDIF</monospace></p>
<p specific-use="line"><monospace>19  ENDFOR</monospace></p>
<p specific-use="line"><monospace>20  M_SI = length of m_si</monospace></p>
<p specific-use="line"><monospace>21  Beta = beta*M_SI //cumulative infection rate</monospace></p>
<p specific-use="line"><monospace>22  Lambda = Mu + Beta //cumulative transition rate</monospace></p>
<p specific-use="line"><monospace>  //Check if a transition takes place:</monospace></p>
<p specific-use="line"><monospace>23  IF Lambda&lt;tau //no transition</monospace></p>
<p specific-use="line"><monospace>24   tau -= Lambda</monospace></p>
<p specific-use="line"><monospace>25  ELSE //at least one transition</monospace></p>
<p specific-use="line"><monospace>26   xi = 1. //remaining fraction of time-step</monospace></p>
<p specific-use="line"><monospace>27   WHILE xi*Lambda&gt;=tau</monospace></p>
<p specific-use="line"><monospace>28    DRAW z uniformly from [0,Lambda)</monospace></p>
<p specific-use="line"><monospace>29    IF z&lt;Beta //S-&gt;I transition</monospace></p>
<p specific-use="line"><monospace>30     DRAW m at random from m_SI</monospace></p>
<p specific-use="line"><monospace>31     x[m] = I</monospace></p>
<p specific-use="line"><monospace>32     APPEND m to m_I</monospace></p>
<p specific-use="line"><monospace>33     N_I += 1</monospace></p>
<p specific-use="line"><monospace>34     Mu += mu</monospace></p>
<p specific-use="line"><monospace>35    ELSE //I-&gt;R transition</monospace></p>
<p specific-use="line"><monospace>36     DRAW m at random from m_I</monospace></p>
<p specific-use="line"><monospace>37     x[m] = R</monospace></p>
<p specific-use="line"><monospace>38     REMOVE m from m_I</monospace></p>
<p specific-use="line"><monospace>39     N_I -= 1</monospace></p>
<p specific-use="line"><monospace>40     N_R += 1</monospace></p>
<p specific-use="line"><monospace>41     Mu -= mu</monospace></p>
<p specific-use="line"><monospace>42    ENDIF</monospace></p>
<p specific-use="line"><monospace>43    xi -= tau/Lambda //update remaining fraction</monospace></p>
<p specific-use="line"><monospace>    //Update list of S-&gt;I transitions and rates:</monospace></p>
<p specific-use="line"><monospace>44    REDO lines 11–22</monospace></p>
<p specific-use="line"><monospace>45    tau = randexp(1) //draw new tau</monospace></p>
<p specific-use="line"><monospace>46   ENDWHILE</monospace></p>
<p specific-use="line"><monospace>47  ENDIF</monospace></p>
<p specific-use="line"><monospace>  //Read out the desired quantities:</monospace></p>
<p specific-use="line"><monospace>48  WRITE N_I, N_R, …</monospace></p>
<p specific-use="line"><monospace>49 ENDFOR</monospace></p>
</sec>
<sec id="sec022">
<title>SIS process</title>
<p>In the SIS model, nodes can be in one of two states: susceptible (<inline-formula id="pcbi.1004579.e140"><alternatives><graphic id="pcbi.1004579.e140g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e140"/><mml:math id="M140" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula>) or infectious (<inline-formula id="pcbi.1004579.e141"><alternatives><graphic id="pcbi.1004579.e141g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e141"/><mml:math id="M141" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula>). As for the SIR model, two different transition types let the nodes switch state: a spontaneous <inline-formula id="pcbi.1004579.e142"><alternatives><graphic id="pcbi.1004579.e142g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e142"/><mml:math id="M142" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition which takes place with rate <italic>μ</italic>, and a contact-dependent <inline-formula id="pcbi.1004579.e143"><alternatives><graphic id="pcbi.1004579.e143g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e143"/><mml:math id="M143" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition which takes place with rate <italic>β</italic> upon contact with an infectious node.</p>
<p>The SIS model is implemented in a manner very similar to the SIR model; an implementation can be found by using the code of Pseudocode 1 with lines <monospace>07</monospace> and <monospace>40</monospace> removed and line <monospace>37</monospace> replaced by <monospace>x[m] = S</monospace>. C++ code is given in <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref> for both homogeneous and heterogeneous populations.</p>
</sec>
<sec id="sec023">
<title>Non-Markovian SIR process</title>
<p>We consider in the main text (Sec. 6: “Non-Markovian processes”) an SIR model with non-constant recovery rates; instead of being exponentially distributed (as in the constant-rate SIR model), the individual recovery times, <italic>τ</italic><sup>(<italic>m</italic>)</sup>, are here Weibull distributed,
<disp-formula id="pcbi.1004579.e144"><alternatives><graphic id="pcbi.1004579.e144g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e144"/><mml:math id="M144" display="block" overflow="scroll"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msup><mml:mi>τ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>∼</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>μ</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:msup><mml:mi>τ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>γ</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msup> <mml:msup><mml:mi>e</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:msup><mml:mi>τ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>m</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:mrow></mml:msup> <mml:mspace width="5.0pt"/><mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(24)</label></disp-formula>
As for the classical SIR model, nodes may be in one of three states: susceptible (<inline-formula id="pcbi.1004579.e145"><alternatives><graphic id="pcbi.1004579.e145g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e145"/><mml:math id="M145" display="inline" overflow="scroll"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula>), infectious (<inline-formula id="pcbi.1004579.e146"><alternatives><graphic id="pcbi.1004579.e146g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e146"/><mml:math id="M146" display="inline" overflow="scroll"><mml:mi mathvariant="script">I</mml:mi></mml:math></alternatives></inline-formula>), or recovered (<inline-formula id="pcbi.1004579.e147"><alternatives><graphic id="pcbi.1004579.e147g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e147"/><mml:math id="M147" display="inline" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi></mml:math></alternatives></inline-formula>). Two different transition types let the nodes switch state: a contact-dependent <inline-formula id="pcbi.1004579.e148"><alternatives><graphic id="pcbi.1004579.e148g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e148"/><mml:math id="M148" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition with constant rate <italic>β</italic> upon contact with an infectious node, and a spontaneous <inline-formula id="pcbi.1004579.e149"><alternatives><graphic id="pcbi.1004579.e149g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e149"/><mml:math id="M149" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">I</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transition which takes place with rate <italic>μ</italic>(<italic>t</italic>;<italic>t</italic><sup>(<italic>m</italic>)</sup>), given by <xref ref-type="disp-formula" rid="pcbi.1004579.e103">Eq (23)</xref>.</p>
<p>The implementation of the SIR model with non-exponentially distributed waiting times requires some extension of the code for the constant-rate SIR model to account for the heterogeneous and time-dependent recovery rates. To this end, we introduce the following variables: <monospace>t_inf</monospace> lists the times at which each node was infected (if applicable); <monospace>t*</monospace> is the exact time at which the last transition took place; <monospace>mu</monospace> is a function of time that is called as <monospace>mu(t-t_inf[m])</monospace> to return the instantaneous recovery rate of <monospace>m</monospace> at time <monospace>t</monospace>; <monospace>mu_avg</monospace> is the expected recovery time of an infected node and is used together with the precision control parameter <monospace>epsilon</monospace> in the approximate simulation scheme discussed in Section 6: “Non-Markovian processes”. Pseudocode 2 shows pseudocode for an implementation of such a SIR model with non-constant recovery rates.</p>
<p specific-use="line"><monospace><bold>Pseudocode 2: Pseudocode for a non-Markovian SIR process with non-constant recovery rates.</bold> The function returns the instantaneous recovery rate as function of (<italic>t</italic> − <italic>t</italic>*); for Weibull distributed recovery times, is given by <xref ref-type="disp-formula" rid="pcbi.1004579.e103">Eq (23)</xref>. C++ code is given in <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref>.</monospace></p>
<p specific-use="line"><monospace> //Initialize:</monospace></p>
<p specific-use="line"><monospace>01 FOR i = 1,…,N</monospace></p>
<p specific-use="line"><monospace>02  x[i] = S //set nodes states to S</monospace></p>
<p specific-use="line"><monospace>03 ENDFOR</monospace></p>
<p specific-use="line"><monospace>04 x[root] = I //set state of root node to I</monospace></p>
<p specific-use="line"><monospace>05 t_inf[root] = 0 //time of infection = 0</monospace></p>
<p specific-use="line"><monospace>06 m_I = [root] //list of infected nodes</monospace></p>
<p specific-use="line"><monospace>07 mus = [mu(0)] //list of recovery rates</monospace></p>
<p specific-use="line"><monospace>08 Mu = mu(0) //cumulative recovery rate</monospace></p>
<p specific-use="line"><monospace>09 N_I = 1 //number of infected nodes</monospace></p>
<p specific-use="line"><monospace>10 N_R = 0 //number of recovered nodes</monospace></p>
<p specific-use="line"><monospace>11 tau = randexp(1) //draw tau Exp(1)</monospace></p>
<p specific-use="line"><monospace> //Run through the time-steps:</monospace></p>
<p specific-use="line"><monospace>12 FOR t = 0,1,…,T_simulation-1</monospace></p>
<p specific-use="line"><monospace>  //Update mus if t-t*&gt;=epsilon*mu_avg:</monospace></p>
<p specific-use="line"><monospace>13  IF t-t*&gt;=epsilon*mu_avg</monospace></p>
<p specific-use="line"><monospace>14   CLEAR mus</monospace></p>
<p specific-use="line"><monospace>15   FOR m in m_I</monospace></p>
<p specific-use="line"><monospace>16    APPEND mu(t-t_inf[m]) to mus</monospace></p>
<p specific-use="line"><monospace>17   ENDFOR</monospace></p>
<p specific-use="line"><monospace>18   Mu = sum of mus</monospace></p>
<p specific-use="line"><monospace>19  ENDIF</monospace></p>
<p specific-use="line"><monospace>  //Update list of possible S-&gt;I transitions:</monospace></p>
<p specific-use="line"><monospace>20  CLEAR m_SI //S nodes in contact with I nodes</monospace></p>
<p specific-use="line"><monospace>21  FOR contact in contactLists[t]</monospace></p>
<p specific-use="line"><monospace>22   (i,j) = contact</monospace></p>
<p specific-use="line"><monospace>23   IF (x[i],x[j])==(S,I)</monospace></p>
<p specific-use="line"><monospace>24    APPEND i to m_SI</monospace></p>
<p specific-use="line"><monospace>25   ELSE IF (x[i],x[j])==(I,S)</monospace></p>
<p specific-use="line"><monospace>26    APPEND j to m_SI</monospace></p>
<p specific-use="line"><monospace>27   ENDIF</monospace></p>
<p specific-use="line"><monospace>28  ENDFOR</monospace></p>
<p specific-use="line"><monospace>29  M_SI = length of m_si</monospace></p>
<p specific-use="line"><monospace>30  Beta = beta*M_SI //cumulative infection rate</monospace></p>
<p specific-use="line"><monospace>31  Lambda = Mu + Beta //cumulative transition rate</monospace></p>
<p specific-use="line"><monospace>  //Check if transition takes place:</monospace></p>
<p specific-use="line"><monospace>32  IF Lambda&lt;tau //no transition</monospace></p>
<p specific-use="line"><monospace>33   tau -= Lambda</monospace></p>
<p specific-use="line"><monospace>34  ELSE //at least one transition</monospace></p>
<p specific-use="line"><monospace>35   xi = 1. //remaining fraction of time-step</monospace></p>
<p specific-use="line"><monospace>36   t* = t //for calculating transition times</monospace></p>
<p specific-use="line"><monospace>37   WHILE xi*Lambda&gt;=tau</monospace></p>
<p specific-use="line"><monospace>38    t* += tau/Lambda //transition time</monospace></p>
<p specific-use="line"><monospace>39    DRAW z uniformly from [0,Lambda)</monospace></p>
<p specific-use="line"><monospace>40    IF z&lt;Beta //S-&gt;I transition</monospace></p>
<p specific-use="line"><monospace>41     DRAW m at random from m_SI</monospace></p>
<p specific-use="line"><monospace>42     x[m] = I</monospace></p>
<p specific-use="line"><monospace>43     t_inf[m] = t*</monospace></p>
<p specific-use="line"><monospace>44     APPEND m to m_I</monospace></p>
<p specific-use="line"><monospace>45     N_I += 1</monospace></p>
<p specific-use="line"><monospace>46    ELSE //I-&gt;R transition</monospace></p>
<p specific-use="line"><monospace>47     DRAW m from m_I with weight mus[m]</monospace></p>
<p specific-use="line"><monospace>48     x[m] = R</monospace></p>
<p specific-use="line"><monospace>49     REMOVE m from m_I</monospace></p>
<p specific-use="line"><monospace>50     N_I -= 1</monospace></p>
<p specific-use="line"><monospace>51     N_R += 1</monospace></p>
<p specific-use="line"><monospace>52    ENDIF</monospace></p>
<p specific-use="line"><monospace>53    xi -= tau/Lambda //update remaining fraction</monospace></p>
<p specific-use="line"><monospace>    //Update mus:</monospace></p>
<p specific-use="line"><monospace>54    CLEAR mus</monospace></p>
<p specific-use="line"><monospace>55    FOR m in m_I</monospace></p>
<p specific-use="line"><monospace>56     APPEND mu(t*-t_inf[m]) to mus</monospace></p>
<p specific-use="line"><monospace>57    ENDFOR</monospace></p>
<p specific-use="line"><monospace>58    Mu = sum of mus</monospace></p>
<p specific-use="line"><monospace>    //Update list of S-&gt;I transitions and rates:</monospace></p>
<p specific-use="line"><monospace>59    REDO lines 20–31</monospace></p>
<p specific-use="line"><monospace>60    tau = randexp(1) //draw new tau</monospace></p>
<p specific-use="line"><monospace>61   ENDWHILE</monospace></p>
<p specific-use="line"><monospace>62  ENDIF</monospace></p>
<p specific-use="line"><monospace>  //Read out the desired quantities:</monospace></p>
<p specific-use="line"><monospace>63  WRITE N_I, N_R, …</monospace></p>
<p specific-use="line"><monospace>64 ENDFOR</monospace></p>
</sec>
</sec>
<sec id="sec024">
<title>Removing obsolete contacts for an SIR process on empirical networks</title>
<p>When simulations are carried out on data which are looped due to their finite length, the speed of the temporal Gillespie algorithm may be further increased for processes with an absorbing state, such as the SIR process, by removing obsolete contacts to nodes that have entered such a state. Pseudocode 3 shows pseudocode for removing obsolete contacts; its replaces lines 11 to 19 of Pseudocode 1.</p>
<p specific-use="line"><monospace><bold>Pseudocode 3: Pseudocode for counting possible <inline-formula id="pcbi.1004579.e150"><alternatives><graphic id="pcbi.1004579.e150g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e150"/><mml:math id="M150" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">S</mml:mi> <mml:mo>→</mml:mo> <mml:mi mathvariant="script">I</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> transitions with removal of outdated contacts.</bold></monospace> C++ code is given in <xref ref-type="supplementary-material" rid="pcbi.1004579.s004">S1 Files</xref>.</p>
<p specific-use="line"><monospace>01  CLEAR m_SI //S nodes in contact with I nodes</monospace></p>
<p specific-use="line"><monospace>02  FOR contact in contactLists[t]</monospace></p>
<p specific-use="line"><monospace>03   (i,j) = contact</monospace></p>
<p specific-use="line"><monospace>04   IF x[i]==S</monospace></p>
<p specific-use="line"><monospace>05    IF x[j]==I</monospace></p>
<p specific-use="line"><monospace>06     APPEND i to m_SI</monospace></p>
<p specific-use="line"><monospace>07    ELSE IF x[j]==R //remove if x[j]==R</monospace></p>
<p specific-use="line"><monospace>08     REMOVE contact from contactLists[t]</monospace></p>
<p specific-use="line"><monospace>09    ENDIF</monospace></p>
<p specific-use="line"><monospace>10   ELSE IF x[i]==I</monospace></p>
<p specific-use="line"><monospace>11    IF x[j]==S</monospace></p>
<p specific-use="line"><monospace>12     APPEND j to m_SI</monospace></p>
<p specific-use="line"><monospace>13    ELSE //remove if (x[i],x[j])==I or x[i]==R</monospace></p>
<p specific-use="line"><monospace>14     REMOVE contact from contactLists[t]</monospace></p>
<p specific-use="line"><monospace>15    ENDIF</monospace></p>
<p specific-use="line"><monospace>16   ELSE //remove if x[i]==R</monospace></p>
<p specific-use="line"><monospace>17    REMOVE contact from contactLists[t]</monospace></p>
<p specific-use="line"><monospace>18   ENDIF</monospace></p>
<p specific-use="line"><monospace>19  ENDFOR</monospace></p>
</sec>
</sec>
<sec id="sec025">
<title>Supporting Information</title>
<supplementary-material id="pcbi.1004579.s001" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.s001" mimetype="application/pdf" xlink:type="simple">
<label>S1 Fig</label>
<caption>
<title>Numerical results from temporal Gillespie and rejection sampling algorithms for contagion processes taking place on empirical networks.</title>
<p>(A)–(D) for a SIR process and (E)–(H) a SIS process. (A),(B),(E), and (F) for <italic>β</italic>Δ<italic>t</italic> = 10<sup>−2</sup> and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−4</sup>; (C),(D),(G), and (H) for <italic>β</italic>Δ<italic>t</italic> = 10<sup>−1</sup> and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−3</sup>. (A),(C) Mean number of nodes in each state of the SIR model as function of time. (B),(D) Distribution of final epidemic size (number of recovered nodes when <italic>I</italic> = 0) in the SIR model. (E),(G) Mean number of nodes in each state of the SIS model as function of time. (F),(H) Distribution of the number of infected nodes in the stationary state (<italic>t</italic> → ∞) of the SIS model. All simulations were performed 1 000 000 times with the root node chosen at random on a face-to-face contact network recorded in a high school (<xref ref-type="table" rid="pcbi.1004579.t001">Table 1</xref>).</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1004579.s002" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.s002" mimetype="application/pdf" xlink:type="simple">
<label>S2 Fig</label>
<caption>
<title>Comparison of numerical results from temporal Gillespie and rejection sampling algorithms for high transition probability per time-step.</title>
<p>(A)–(D) for a SIR process and (E)–(H) a SIS process. (A),(B),(E), and (F) for <italic>β</italic>Δ<italic>t</italic> = 10<sup>−1</sup> and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−3</sup>; (C),(D),(G), and (H) for <italic>β</italic>Δ<italic>t</italic> = 1 and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−2</sup>. (A),(C) Mean number of nodes in each state of the SIR model as function of time. (B),(D) Distribution of final epidemic size (number of recovered nodes when <italic>I</italic> = 0) in the SIR model. (E),(G) Mean number of nodes in each state of the SIS model as function of time. (F),(H) Distribution of the number of infected nodes in the stationary state (<italic>t</italic> → ∞) of the SIS model. All simulations were performed 1 000 000 times with the root node chosen at random on an activity driven network consisting of <italic>N</italic> = 100 nodes, with activities <italic>a</italic><sub><italic>i</italic></sub> = <italic>ηz</italic><sub><italic>i</italic></sub>, where <italic>η</italic> = 0.1 and <inline-formula id="pcbi.1004579.e151"><alternatives><graphic id="pcbi.1004579.e151g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e151"/><mml:math id="M151" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>z</italic><sub><italic>i</italic></sub> ∈ [0.03,1), and a node formed two contacts when active.</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1004579.s003" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.s003" mimetype="application/pdf" xlink:type="simple">
<label>S3 Fig</label>
<caption>
<title>Comparison of numerical results from temporal Gillespie and rejection sampling algorithms for a non-Markovian SIR process.</title>
<p>(a),(c) Mean number of nodes in each state as function of time in the SIR model with Weibull distributed recovery times (Sec. 6: “Non-Markovian processes”); the parameter controlling the precision of the temporal Gillespie algorithm was set to <italic>ϵ</italic> = 0 (quasi-exact). (b),(d) Distribution of final epidemic size (number of recovered nodes when <italic>I</italic> = 0). (a),(b) <italic>β</italic>Δ<italic>t</italic> = 10<sup>−2</sup> and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−4</sup>; (c),(d) <italic>β</italic>Δ<italic>t</italic> = 10<sup>−1</sup> and <italic>μ</italic>Δ<italic>t</italic> = 10<sup>−3</sup>. The outcome of the rejection sampling algorithm approaches that of the temporal Gillespie algorithm as <italic>β</italic>Δ<italic>t</italic> and <italic>μ</italic>Δ<italic>t</italic> become smaller. All simulations were performed 100 000 times with the root node chosen at random on an activity driven network consisting of <italic>N</italic> = 100 nodes, with activities <italic>a</italic><sub><italic>i</italic></sub> = <italic>ηz</italic><sub><italic>i</italic></sub>, where <italic>η</italic> = 0.1 and <inline-formula id="pcbi.1004579.e152"><alternatives><graphic id="pcbi.1004579.e152g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e152"/><mml:math id="M152" display="inline" overflow="scroll"><mml:mrow><mml:msub><mml:mi>z</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:msubsup><mml:mi>z</mml:mi> <mml:mi>i</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>3</mml:mn> <mml:mo>.</mml:mo> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:math></alternatives></inline-formula> for <italic>z</italic><sub><italic>i</italic></sub> ∈ [0.03,1), and a node formed two contacts when active. Nodes’ recovery times followed <xref ref-type="disp-formula" rid="pcbi.1004579.e087">Eq (20)</xref> with <italic>γ</italic> = 1.5 and the length of a time-step was Δ<italic>t</italic> = 1 s.</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1004579.s004" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004579.s004" mimetype="application/zip" xlink:type="simple">
<label>S1 Files</label>
<caption>
<title>C++ code for implementations of the temporal Gillespie algorithm to examples of epidemic processes on time-varying networks.</title>
<p>Specifically, we provide the following programs: (SIR-Poisson-homogeneous.cpp) constant-rate SIR process in a homogeneous population, i.e., same infection/recovery rates for all nodes; (SIR-Poisson-homogeneous-contactRemoval.cpp) constant-rate SIR process in a homogeneous population where obsolete contacts are removed from the contact data as they occur; (SIR-Poisson-heterogeneous.cpp) constant-rate SIR process in a heterogeneous population, i.e., infection/recovery rates may differ between nodes; (SIR-nonMarkovian.cpp) non-Markovian SIR process with Weibull distributed recovery times of individual nodes; (SIS-Poisson-homogeneous.cpp) constant-rate SIS process in a homogeneous population, i.e., same infection/recovery rates for all nodes; (SIS-Poisson-heterogeneous.cpp) constant-rate SIS process in a heterogeneous population, i.e., infection/recovery rates may differ between nodes.</p>
<p>(ZIP)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ack>
<p>The authors thank Alain Barrat, Rossana Mastrandrea and Julie Fournet for helpful discussions and critical reading of the manuscript and Thomas L. Vestergaard for help with debugging and code review. The authors also thank the SocioPatterns collaboration for privileged access to data sets.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1004579.ref001">
<label>1</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Barthélemy</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Vespignani</surname> <given-names>A</given-names></name>. <source>Dynamical Processes on Complex Networks</source>. <publisher-name>Cambridge University Press</publisher-name>; <year>2008</year>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref002">
<label>2</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Balcan</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Colizza</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Gonçalves</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Hu</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Ramasco</surname> <given-names>JJ</given-names></name>, <name name-style="western"><surname>Vespignani</surname> <given-names>A</given-names></name>. <article-title>Multiscale mobility networks and the spatial spreading of infectious diseases</article-title>. <source>Proc Natl Acad Sci USA</source>. <year>2009</year> <month>Dec</month>;<volume>106</volume>(<issue>51</issue>):<fpage>21484</fpage>–<lpage>21489</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1073/pnas.0906910106" xlink:type="simple">10.1073/pnas.0906910106</ext-link></comment> <object-id pub-id-type="pmid">20018697</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref003">
<label>3</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Pastor-Satorras</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Castellano</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Van Mieghem</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Vespignani</surname> <given-names>A</given-names></name>. <article-title>Epidemic processes in complex networks</article-title>. <source>Rev Mod Phys</source>. <year>2015</year> <month>Aug</month>;<volume>87</volume>(<issue>3</issue>):<fpage>925</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/RevModPhys.87.925" xlink:type="simple">10.1103/RevModPhys.87.925</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref004">
<label>4</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Ferreira</surname> <given-names>SC</given-names></name>, <name name-style="western"><surname>Castellano</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Pastor-Satorras</surname> <given-names>R</given-names></name>. <article-title>Epidemic thresholds of the susceptible-infected-susceptible model on networks: a comparison of numerical and theoretical results</article-title>. <source>Phys Rev E</source>. <year>2012</year> <month>Oct</month>;<volume>86</volume>(<issue>4</issue>):<fpage>041125</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevE.86.041125" xlink:type="simple">10.1103/PhysRevE.86.041125</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref005">
<label>5</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Tizzoni</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Bajardi</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Poletto</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Ramasco</surname> <given-names>JJ</given-names></name>, <name name-style="western"><surname>Balcan</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Gonçalves</surname> <given-names>B</given-names></name>, <etal>et al</etal>. <article-title>Real-time numerical forecast of global epidemic spreading: case study of 2009 A/H1N1pdm</article-title>. <source>BMC Med</source>. <year>2012</year>;<volume>10</volume>:<fpage>165</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/1741-7015-10-165" xlink:type="simple">10.1186/1741-7015-10-165</ext-link></comment> <object-id pub-id-type="pmid">23237460</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref006">
<label>6</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Doob</surname> <given-names>JL</given-names></name>. <article-title>Topics in the theory of Markoff chains</article-title>. <source>T Am Math Soc</source>. <year>1942</year>;<volume>52</volume>(<issue>1</issue>):<fpage>37</fpage>–<lpage>64</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1090/S0002-9947-1942-0006633-7" xlink:type="simple">10.1090/S0002-9947-1942-0006633-7</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref007">
<label>7</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Doob</surname> <given-names>JL</given-names></name>. <article-title>Markoff chains—denumerable case</article-title>. <source>T Am Math Soc</source>. <year>1945</year>;<volume>58</volume>(<issue>3</issue>):<fpage>455</fpage>–<lpage>473</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.2307/1990339" xlink:type="simple">10.2307/1990339</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref008">
<label>8</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Kendall</surname> <given-names>DG</given-names></name>. <article-title>An Artificial Realization of a Simple “Birth-and-Death” Process</article-title>. <source>J R Stat Soc Ser B Stat Methodol</source>. <year>1950</year>;<volume>12</volume>(<issue>1</issue>):<fpage>116</fpage>–<lpage>119</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref009">
<label>9</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Bartlett</surname> <given-names>MS</given-names></name>. <article-title>Stochastic Processes or the Statistics of Change</article-title>. <source>J R Stat Soc Ser C Appl Stat</source>. <year>1953</year> <month>March</month>;<volume>2</volume>(<issue>1</issue>):<fpage>44</fpage>–<lpage>64</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref010">
<label>10</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Gillespie</surname> <given-names>DT</given-names></name>. <article-title>A general method for numerically simulating the stochastic time evolution of coupled chemical reactions</article-title>. <source>J Comput Phys</source>. <year>1976</year>;<volume>22</volume>(<issue>4</issue>):<fpage>403</fpage>–<lpage>434</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/0021-9991(76)90041-3" xlink:type="simple">10.1016/0021-9991(76)90041-3</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref011">
<label>11</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Gillespie</surname> <given-names>DT</given-names></name>. <article-title>Exact stochastic simulation of coupled chemical reactions</article-title>. <source>J Phys Chem</source>. <year>1977</year>;<volume>81</volume>(<issue>25</issue>):<fpage>2340</fpage>–<lpage>2361</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1021/j100540a008" xlink:type="simple">10.1021/j100540a008</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref012">
<label>12</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Huerta</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Tsimring</surname> <given-names>LS</given-names></name>. <article-title>Contact tracing and epidemics control in social networks</article-title>. <source>Phys Rev E</source>. <year>2002</year> <month>Nov</month>;<volume>66</volume>(<issue>5</issue>):<fpage>056115</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevE.66.056115" xlink:type="simple">10.1103/PhysRevE.66.056115</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref013">
<label>13</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Dangerfield</surname> <given-names>CE</given-names></name>, <name name-style="western"><surname>Ross</surname> <given-names>JV</given-names></name>, <name name-style="western"><surname>Keeling</surname> <given-names>MJ</given-names></name>. <article-title>Integrating stochasticity and network structure into an epidemic model</article-title>. <source>J R Soc Interface</source>. <year>2009</year> <month>Sep</month>;<volume>6</volume>(<issue>38</issue>):<fpage>761</fpage>–<lpage>774</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1098/rsif.2008.0410" xlink:type="simple">10.1098/rsif.2008.0410</ext-link></comment> <object-id pub-id-type="pmid">18974032</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref014">
<label>14</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Hladish</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Melamud</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Barrera</surname> <given-names>LA</given-names></name>, <name name-style="western"><surname>Galvani</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Meyers</surname> <given-names>LA</given-names></name>. <article-title>EpiFire: An open source C++ library and application for contact network epidemiology</article-title>. <source>BMC Bioinform</source>. <year>2012</year>;<volume>13</volume>:<fpage>76</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/1471-2105-13-76" xlink:type="simple">10.1186/1471-2105-13-76</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref015">
<label>15</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Holme</surname> <given-names>P</given-names></name>. <source>Model versions and fast algorithms for network epidemiology</source>. arXiv:14031011v1.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref016">
<label>16</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Zschaler</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Gross</surname> <given-names>T</given-names></name>. <source>Largenet2: an object-oriented programming library for simulating large adaptive networks</source>. arXiv:1207.3914v1.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref017">
<label>17</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Boguña</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Lafuerza</surname> <given-names>LF</given-names></name>, <name name-style="western"><surname>Toral</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Serrano</surname> <given-names>MA</given-names></name>. <article-title>Simulating non-Markovian stochastic processes</article-title>. <source>Phys Rev E</source>. <year>2014</year>;<volume>90</volume>(<issue>4</issue>):<fpage>042108</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevE.90.042108" xlink:type="simple">10.1103/PhysRevE.90.042108</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref018">
<label>18</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Onnela</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Saramäki</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Hyvönen</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Szabó</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Lazer</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Kaski</surname> <given-names>K</given-names></name>, <etal>et al</etal>. <article-title>Structure and tie strengths in mobile communication networks</article-title>. <source>Proc Natl Acad Sci USA</source>. <year>2007</year> <month>May</month>;<volume>104</volume>(<issue>18</issue>):<fpage>7332</fpage>–<lpage>7336</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1073/pnas.0610245104" xlink:type="simple">10.1073/pnas.0610245104</ext-link></comment> <object-id pub-id-type="pmid">17456605</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref019">
<label>19</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Rybski</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Buldyrev</surname> <given-names>SV</given-names></name>, <name name-style="western"><surname>Havlin</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Liljeros</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Makse</surname> <given-names>HA</given-names></name>. <article-title>Scaling laws of human interaction activity</article-title>. <source>Proc Natl Acad Sci USA</source>. <year>2009</year> <month>Aug</month>;<volume>106</volume>(<issue>31</issue>):<fpage>12640</fpage>–<lpage>12645</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1073/pnas.0902667106" xlink:type="simple">10.1073/pnas.0902667106</ext-link></comment> <object-id pub-id-type="pmid">19617555</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref020">
<label>20</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Cattuto</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Van den Broeck</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Colizza</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Pinton</surname> <given-names>JF</given-names></name>, <name name-style="western"><surname>Vespignani</surname> <given-names>A</given-names></name>. <article-title>Dynamics of person-to-person interactions from distributed RFID sensor networks</article-title>. <source>PLoS One</source>. <year>2010</year>;<volume>5</volume>(<issue>7</issue>):<fpage>e11596</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0011596" xlink:type="simple">10.1371/journal.pone.0011596</ext-link></comment> <object-id pub-id-type="pmid">20657651</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref021">
<label>21</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Vázquez</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Rácz</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Lukács</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Barabási</surname> <given-names>AL</given-names></name>. <article-title>Impact of non-Poissonian activity patterns on spreading processes</article-title>. <source>Phys Rev Lett</source>. <year>2007</year> <month>Apr</month>;<volume>98</volume>(<issue>15</issue>):<fpage>158702</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevLett.98.158702" xlink:type="simple">10.1103/PhysRevLett.98.158702</ext-link></comment> <object-id pub-id-type="pmid">17501392</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref022">
<label>22</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Miritello</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Moro</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Lara</surname> <given-names>R</given-names></name>. <article-title>Dynamical strength of social ties in information spreading</article-title>. <source>Phys Rev E</source>. <year>2011</year> <month>Apr</month>;<volume>83</volume>(<issue>4</issue>):<fpage>045102</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevE.83.045102" xlink:type="simple">10.1103/PhysRevE.83.045102</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref023">
<label>23</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Karsai</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Kivelä</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Pan</surname> <given-names>RK</given-names></name>, <name name-style="western"><surname>Kaski</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Kertész</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Barabási</surname> <given-names>AL</given-names></name>, <etal>et al</etal>. <article-title>Small but slow world: how network topology and burstiness slow down spreading</article-title>. <source>Phys Rev E</source>. <year>2011</year> <month>Feb</month>;<volume>83</volume>(<issue>2</issue>):<fpage>025102</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevE.83.025102" xlink:type="simple">10.1103/PhysRevE.83.025102</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref024">
<label>24</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Panisson</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Cattuto</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Van den Broeck</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Ruffo</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Schifanella</surname> <given-names>R</given-names></name>. <article-title>On the dynamics of human proximity for data diffusion in ad-hoc networks</article-title>. <source>Ad Hoc Networks</source>. <year>2012</year> <month>Nov</month>;<volume>10</volume>(<issue>8</issue>):<fpage>1532</fpage>–<lpage>1543</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.adhoc.2011.06.003" xlink:type="simple">10.1016/j.adhoc.2011.06.003</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref025">
<label>25</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Gauvin</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Panisson</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Cattuto</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>. <article-title>Activity clocks: spreading dynamics on temporal networks of human contact</article-title>. <source>Sci Rep</source>. <year>2013</year> <month>Oct</month>;<volume>3</volume>:<fpage>3099</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/srep03099" xlink:type="simple">10.1038/srep03099</ext-link></comment> <object-id pub-id-type="pmid">24172876</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref026">
<label>26</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Holme</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Liljeros</surname> <given-names>F</given-names></name>. <article-title>Birth and death of links control disease spreading in empirical contact networks</article-title>. <source>Sci Rep</source>. <year>2014</year>;<volume>4</volume>:<fpage>4999</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/srep04999" xlink:type="simple">10.1038/srep04999</ext-link></comment> <object-id pub-id-type="pmid">24851942</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref027">
<label>27</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Karsai</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Perra</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Vespignani</surname> <given-names>A</given-names></name>. <article-title>Time varying networks and the weakness of strong ties</article-title>. <source>Sci Rep</source>. <year>2014</year>;<volume>4</volume>:<fpage>4001</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/srep04001" xlink:type="simple">10.1038/srep04001</ext-link></comment> <object-id pub-id-type="pmid">24510159</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref028">
<label>28</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Holme</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Saramäki</surname> <given-names>J</given-names></name>. <article-title>Temporal networks</article-title>. <source>Phys Rep</source>. <year>2012</year>;p. <fpage>1</fpage>–<lpage>28</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref029">
<label>29</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Cai</surname> <given-names>CR</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>ZX</given-names></name>, <name name-style="western"><surname>Guan</surname> <given-names>JY</given-names></name>. <article-title>Behavior of susceptible-vaccinated-infected-recovered epidemics with diversity in the infection rate of individuals</article-title>. <source>Phys Rev E</source>. <year>2013</year> <month>Dec</month>;<volume>88</volume>(<issue>6</issue>):<fpage>062805</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1103/PhysRevE.88.062805" xlink:type="simple">10.1103/PhysRevE.88.062805</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref030">
<label>30</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Ferguson</surname> <given-names>NM</given-names></name>, <name name-style="western"><surname>Cummings</surname> <given-names>DAT</given-names></name>, <name name-style="western"><surname>Fraser</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Cajka</surname> <given-names>JC</given-names></name>, <name name-style="western"><surname>Cooley</surname> <given-names>PC</given-names></name>, <name name-style="western"><surname>Burke</surname> <given-names>DS</given-names></name>. <article-title>Strategies for mitigating an influenza pandemic</article-title>. <source>Nature</source>. <year>2006</year> <month>Jul</month>;<volume>442</volume>(<issue>7101</issue>):<fpage>448</fpage>–<lpage>452</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature04795" xlink:type="simple">10.1038/nature04795</ext-link></comment> <object-id pub-id-type="pmid">16642006</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref031">
<label>31</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Lloyd</surname> <given-names>AL</given-names></name>. <article-title>Realistic distributions of infectious periods in epidemic models: changing patterns of persistence and dynamics</article-title>. <source>Theor Popul Biol</source>. <year>2001</year> <month>Aug</month>;<volume>60</volume>(<issue>1</issue>):<fpage>59</fpage>–<lpage>71</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1006/tpbi.2001.1525" xlink:type="simple">10.1006/tpbi.2001.1525</ext-link></comment> <object-id pub-id-type="pmid">11589638</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref032">
<label>32</label>
<mixed-citation xlink:type="simple" publication-type="other">Note that, while the principal field of application of the algorithm is time-varying networks, the algorithm may also be applied to systems where a network-based description is not appropriate, e.g., where transition rates may be modulated by external time-series.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref033">
<label>33</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Martelloni</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Santarlasci</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Bagnoli</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Santini</surname> <given-names>G</given-names></name>. <source>Modeling ant battles by means of a diffusion-limited Gillespie algorithm</source>. arXiv:150306094v1.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref034">
<label>34</label>
<mixed-citation xlink:type="simple" publication-type="other">Instead of keeping track of <inline-formula id="pcbi.1004579.e153"><alternatives><graphic id="pcbi.1004579.e153g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e153"/><mml:math id="M153" display="inline" overflow="scroll"><mml:mrow><mml:mi mathvariant="double-struck">L</mml:mi> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and comparing it to <italic>τ</italic>′ at each time-step, we may in an enterily equivalent manner subtract Λ(Δ<italic>t</italic>) from <italic>τ</italic>′ after each time-step and simply compare Λ(Δ<italic>t</italic>) to the remainder of <italic>τ</italic>′.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref035">
<label>35</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Gibson</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>Bruck</surname> <given-names>J</given-names></name>. <article-title>Efficient exact stochastic simulation of chemical systems with many species and many channels</article-title>. <source>J Phys Chem A</source>. <year>2000</year>;<volume>104</volume>(<issue>9</issue>):<fpage>1876</fpage>–<lpage>1889</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1021/jp993732q" xlink:type="simple">10.1021/jp993732q</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref036">
<label>36</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Lu</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Volfson</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Tsimring</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Hasty</surname> <given-names>J</given-names></name>. <article-title>Cellular growth and division in the Gillespie algorithm</article-title>. <source>Syst Biol (Stevenage)</source>. <year>2004</year> <month>Jun</month>;<volume>1</volume>(<issue>1</issue>):<fpage>121</fpage>–<lpage>128</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1049/sb:20045016" xlink:type="simple">10.1049/sb:20045016</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref037">
<label>37</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Anderson</surname> <given-names>DF</given-names></name>. <article-title>A modified next reaction method for simulating chemical systems with time dependent propensities and delays</article-title>. <source>J Chem Phys</source>. <year>2007</year> <month>Dec</month>;<volume>127</volume>(<issue>21</issue>):<fpage>214107</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1063/1.2799998" xlink:type="simple">10.1063/1.2799998</ext-link></comment> <object-id pub-id-type="pmid">18067349</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref038">
<label>38</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Carletti</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Filisetti</surname> <given-names>A</given-names></name>. <article-title>The Stochastic Evolution of a Protocell: The Gillespie Algorithm in a Dynamically Varying Volume</article-title>. <source>Comput Math Methods Med</source>. <year>2012</year>;<volume>2012</volume>:<fpage>423627</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1155/2012/423627" xlink:type="simple">10.1155/2012/423627</ext-link></comment> <object-id pub-id-type="pmid">22536297</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref039">
<label>39</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Caravagna</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Mauri</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>d’Onofrio</surname> <given-names>A</given-names></name>. <article-title>The interplay of intrinsic and extrinsic bounded noises in biomolecular networks</article-title>. <source>PLoS One</source>. <year>2013</year>;<volume>8</volume>(<issue>2</issue>):<fpage>e51174</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0051174" xlink:type="simple">10.1371/journal.pone.0051174</ext-link></comment> <object-id pub-id-type="pmid">23437034</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref040">
<label>40</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Zechner</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Koeppl</surname> <given-names>H</given-names></name>. <article-title>Uncoupled analysis of stochastic reaction networks in fluctuating environments</article-title>. <source>PLoS Comput Biol</source>. <year>2014</year> <month>Dec</month>;<volume>10</volume>(<issue>12</issue>):<fpage>e1003942</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pcbi.1003942" xlink:type="simple">10.1371/journal.pcbi.1003942</ext-link></comment> <object-id pub-id-type="pmid">25473849</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref041">
<label>41</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Perra</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Gonçalves</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Pastor-Satorras</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Vespignani</surname> <given-names>A</given-names></name>. <article-title>Activity driven modeling of time varying networks</article-title>. <source>Sci Rep</source>. <year>2012</year> <month>Jan</month>;<volume>2</volume>:<fpage>469</fpage>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref042">
<label>42</label>
<mixed-citation xlink:type="simple" publication-type="book">
<name name-style="western"><surname>Maki</surname> <given-names>D.P.</given-names></name>, <name name-style="western"><surname>Thompson</surname> <given-names>M</given-names></name>. <source>Mathematical Models and Applications Prentice-Hall</source>, <publisher-loc>Englewood Cliffs (NJ)</publisher-loc>; <year>1973</year>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref043">
<label>43</label>
<mixed-citation xlink:type="simple" publication-type="other">Technically, for the approximation to be valid, <inline-formula id="pcbi.1004579.e154"><alternatives><graphic id="pcbi.1004579.e154g" mimetype="image" xlink:type="simple" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004579.e154"/><mml:math id="M154" display="inline" overflow="scroll"><mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mrow><mml:mo>Λ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>;</mml:mo> <mml:msub><mml:mi mathvariant="script">F</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> must be much smaller than the time-scale at which the λ<sub><italic>m</italic></sub> change.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref044">
<label>44</label>
<mixed-citation xlink:type="simple" publication-type="other">A second-order cumulant expansion is proposed in [38]. However, while this is generally a better approximation than the first-order expansion, it still assumes that <italic>M</italic>(<italic>t</italic>) ≫ 1. Furthermore, if the functions describing λ<sub><italic>m</italic></sub> are not differentiable, this approach is not applicable. This is notably the case for Weibull (or Gamma) distributed waiting times with shape parameter <italic>k</italic> &lt; 2 as in the example considered here.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref045">
<label>45</label>
<mixed-citation xlink:type="simple" publication-type="other">
<ext-link ext-link-type="uri" xlink:type="simple" xlink:href="http://www.sociopatterns.org">www.sociopatterns.org</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1004579.ref046">
<label>46</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Génois</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Vestergaard</surname> <given-names>CL</given-names></name>, <name name-style="western"><surname>Fournet</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Panisson</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Bonmarin</surname> <given-names>I</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>. <article-title>Data on face-to-face contacts in an office building suggests a low-cost vaccination strategy based on community linkers</article-title>. <source>Network Science</source>. <year>2015</year>;<volume>3</volume>(<issue>3</issue>):<fpage>326</fpage>–<lpage>347</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1017/nws.2015.10" xlink:type="simple">10.1017/nws.2015.10</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref047">
<label>47</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Vanhems</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Cattuto</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Pinton</surname> <given-names>JF</given-names></name>, <name name-style="western"><surname>Khanafer</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Régis</surname> <given-names>C</given-names></name>, <etal>et al</etal>. <article-title>Estimating potential infection transmission routes in hospital wards using wearable proximity sensors</article-title>. <source>PLoS One</source>. <year>2013</year>;<volume>8</volume>(<issue>9</issue>):<fpage>e73970</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0073970" xlink:type="simple">10.1371/journal.pone.0073970</ext-link></comment> <object-id pub-id-type="pmid">24040129</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref048">
<label>48</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Fournet</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>. <article-title>Contact patterns among high school students</article-title>. <source>PLoS One</source>. <year>2014</year>;<volume>9</volume>(<issue>9</issue>):<fpage>e107878</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0107878" xlink:type="simple">10.1371/journal.pone.0107878</ext-link></comment> <object-id pub-id-type="pmid">25226026</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004579.ref049">
<label>49</label>
<mixed-citation xlink:type="simple" publication-type="journal">
<name name-style="western"><surname>Stehlé</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Voirin</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Barrat</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Cattuto</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Colizza</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Isella</surname> <given-names>L</given-names></name>, <etal>et al</etal>. <article-title>Simulation of an SEIR infectious disease model on the dynamic contact network of conference attendees</article-title>. <source>BMC Med</source>. <year>2011</year> <month>Jan</month>;<volume>9</volume>(<issue>1</issue>):<fpage>87</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1186/1741-7015-9-87" xlink:type="simple">10.1186/1741-7015-9-87</ext-link></comment> <object-id pub-id-type="pmid">21771290</object-id></mixed-citation>
</ref>
</ref-list>
</back>
</article>