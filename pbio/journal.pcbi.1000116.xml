<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article
  PUBLIC "-//NLM//DTD Journal Publishing DTD v3.0 20080202//EN" "http://dtd.nlm.nih.gov/publishing/3.0/journalpublishing3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="3.0" xml:lang="EN"><front><journal-meta><journal-id journal-id-type="publisher-id">plos</journal-id><journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id><journal-id journal-id-type="pmc">ploscomp</journal-id><!--===== Grouping journal title elements =====--><journal-title-group><journal-title>PLoS Computational Biology</journal-title></journal-title-group><issn pub-type="ppub">1553-734X</issn><issn pub-type="epub">1553-7358</issn><publisher><publisher-name>Public Library of Science</publisher-name><publisher-loc>San Francisco, USA</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="publisher-id">07-PLCB-RA-0508R3</article-id><article-id pub-id-type="doi">10.1371/journal.pcbi.1000116</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group><subj-group subj-group-type="Discipline"><subject>Computational Biology/Genomics</subject><subject>Computer Science/Applications</subject></subj-group></article-categories><title-group><article-title>Similarity Queries for Temporal Toxicogenomic Expression Profiles</article-title><alt-title alt-title-type="running-head">Similarity Queries for Expression Profiles</alt-title></title-group><contrib-group><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Smith</surname><given-names>Adam A.</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref><xref ref-type="corresp" rid="cor1"><sup>*</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Vollrath</surname><given-names>Aaron</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Bradfield</surname><given-names>Christopher A.</given-names></name><xref ref-type="aff" rid="aff3"><sup>3</sup></xref></contrib><contrib contrib-type="author" xlink:type="simple"><name name-style="western"><surname>Craven</surname><given-names>Mark</given-names></name><xref ref-type="aff" rid="aff1"><sup>1</sup></xref><xref ref-type="aff" rid="aff2"><sup>2</sup></xref></contrib></contrib-group><aff id="aff1"><label>1</label><addr-line>Department of Computer Science, University of Wisconsin, Madison, Wisconsin, United States of America</addr-line>       </aff><aff id="aff2"><label>2</label><addr-line>Department of Biostatistics and Medical Informatics, University of Wisconsin, Madison, Wisconsin, United States of America</addr-line>       </aff><aff id="aff3"><label>3</label><addr-line>Department of Oncology, University of Wisconsin, Madison, Wisconsin, United States of America</addr-line>       </aff><contrib-group><contrib contrib-type="editor" xlink:type="simple"><name name-style="western"><surname>Lengauer</surname><given-names>Thomas</given-names></name><role>Editor</role><xref ref-type="aff" rid="edit1"/></contrib></contrib-group><aff id="edit1">Max-Planck-Institut für Informatik, Germany</aff><author-notes><corresp id="cor1">* E-mail: <email xlink:type="simple">aasmith@cs.wisc.edu</email></corresp><fn fn-type="con"><p>Conceived and designed the experiments: AAS MC. Performed the experiments: AAS. Analyzed the data: AAS AV. Contributed reagents/materials/analysis tools: AV CAB. Wrote the paper: AAS MC.</p></fn><fn fn-type="conflict"><p>The authors have declared that no competing interests exist.</p></fn></author-notes><pub-date pub-type="collection"><month>7</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>18</day><month>7</month><year>2008</year></pub-date><volume>4</volume><issue>7</issue><elocation-id>e1000116</elocation-id><history><date date-type="received"><day>22</day><month>8</month><year>2007</year></date><date date-type="accepted"><day>5</day><month>6</month><year>2008</year></date></history><!--===== Grouping copyright info into permissions =====--><permissions><copyright-year>2008</copyright-year><copyright-holder>Smith et al</copyright-holder><license><license-p>This is an open-access article distributed under the terms of the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p></license></permissions><abstract><p>We present an approach for answering similarity queries about gene expression time series that is motivated by the task of characterizing the potential toxicity of various chemicals. Our approach involves two key aspects. First, our method employs a novel alignment algorithm based on time warping. Our time warping algorithm has several advantages over previous approaches. It allows the user to impose fairly strong biases on the form that the alignments can take, and it permits a type of local alignment in which the entirety of only one series has to be aligned. Second, our method employs a relaxed spline interpolation to predict expression responses for unmeasured time points, such that the spline does not necessarily exactly fit every observed point. We evaluate our approach using expression time series from the E<sc>dge</sc> toxicology database. Our experiments show the value of using spline representations for sparse time series. More significantly, they show that our time warping method provides more accurate alignments and classifications than previous standard alignment methods for time series.</p></abstract><abstract abstract-type="summary"><title>Author Summary</title><p>We are developing an approach to characterize chemicals and environmental conditions by comparing their effects on gene expression with those of well characterized treatments. We evaluate our approach in the context of the E<sc>dge</sc> (Environment, Drugs, and Gene Expression) database, which contains microarray observations collected from mouse liver tissue over the days following exposure to a variety of treatments. Our approach takes as input an unknown query series, consisting of several gene-expression measurements over time. It then picks out treatments from a database of known treatments that exhibit the most similar expression responses. This task is difficult because the data tends to be noisy, sparse in time, and measured at irregular intervals. We start by reconstructing the unobserved parts of the series using splines. We then align the given query to each database series so that the similarities in their expression responses are maximized. Our approach uses dynamic programming to find the best alignment of each pair of series. Unlike other methods, our approach allows alignments in which the end of one of the two series remains unaligned, if it appears that one series shows more of the expression response than the other. We finally return the best match(es) and alignment(s), in the hope that they will help with the query's eventual characterization and addition to the database.</p></abstract><funding-group><funding-statement>This work was supported by NIH/NIEHS grant R01-ES012752, NIH/NLM grant R01-LM07050, and NIH/NCI grants P30-CA014520 and T32-CA009135.</funding-statement></funding-group><counts><page-count count="13"/></counts></article-meta></front><body><sec id="s1"><title>Introduction</title><p>Characterizing and comparing temporal gene expression responses is an important computational task for answering a variety of questions in biological studies. We present an approach for answering similarity queries about gene expression time series that is motivated by the task of characterizing the potential toxicity of various chemicals. Our approach is designed to handle the plethora of problems that arise in comparing gene expression time series, including sparsity, high-dimensionality, noise in the measurements, and the local distortions that can occur in similar time series.</p><p>The task that we consider is motivated by the need for faster, more cost-efficient protocols for characterizing the potential toxicity of industrial chemicals. More than 80,000 chemicals are used commercially, and approximately 2,000 new ones are added each year. This number makes it impossible to properly assess the toxicity of each compound in a timely manner using conventional methods. However, the effects of toxic chemicals may often be predicted by how they influence global gene expression over time. By using microarrays, it is possible to measure the expression of thousands of genes simultaneously. It is likely that transcriptional profiles will soon become a standard component of toxicology assessment and government regulation of drugs and other chemicals.</p><p>One resource for toxicology-related gene expression information is the E<sc>dge</sc> (Environment, Drugs, and Gene Expression) database <xref ref-type="bibr" rid="pcbi.1000116-Hayes1">[1]</xref>. E<sc>dge</sc> contains expression profiles from mouse liver tissue following exposure to a variety of chemicals and physiological changes, which we refer to as <italic>treatments</italic>. Some of the treatments in E<sc>dge</sc> have been assayed as time series. <xref ref-type="fig" rid="pcbi-1000116-g001">Figure 1A</xref> provides a simplified illustration of the type of data with which we are concerned. The small database in this figure contains time series data for four different treatments, each of which includes measurements for three genes. The true, underlying expression response is not known, but instead the database contains sampled observations which may be noisy. We use the term <italic>observation</italic> to refer to the expression measurements made at a single time point in a treatment.</p><fig id="pcbi-1000116-g001" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g001</object-id><label>Figure 1</label><caption><title>An example of the similarity-query task for four different treatments with three genes.</title><p>(A) The curves show the actual hidden expression profile for each treatment, even though we must rely on the noisy sampled observations (the dots). (B) We have reconstructed the profiles at unobserved times, and used them to perform a similarity query. The highlighted areas represent possible good matches.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g001" xlink:type="simple"/></fig><p>The computational task that we consider is illustrated in <xref ref-type="fig" rid="pcbi-1000116-g001">Figure 1B</xref>. Given an expression profile as a query, we want to identify the treatment in the database that has the expression profile most similar to the query. In the general case, the query and/or some of the database treatments are time series. In this case, we want to also determine the temporal correspondence between queries and putatively similar treatments in the database. In the toxicology domain, we are interested in answering this type of query in order to characterize poorly understood chemicals.</p><p>There are several properties of the expression time series at hand that are important considerations for our work.</p><list list-type="bullet"><list-item><p><italic>Sparsity:</italic> As is the case with most time series characterizing gene expression <xref ref-type="bibr" rid="pcbi.1000116-Ernst1">[2]</xref>, the time series available from toxicological studies typically contain measurements from only a handful of time points. The longest time series in the E<sc>dge</sc> database has observations at only 9 times, and several of the series include only two points.</p></list-item><list-item><p><italic>High-dimensionality:</italic> Because the expression data we consider is measured via microarrays, each time “point” in our series lies in a high-dimensional space. For the experiments reported here, each time point represents expression levels for 1,600 genes. (Technically, the expression measurements correspond to clones selected from liver-derived EST and full-length cDNAs. These clones represent products for 1,600 unique genes.)</p></list-item><list-item><p><italic>Non-uniform and irregular sampling:</italic> Given the sparsity of the time series, it is typically the case that they have been sampled at non-uniform time intervals. Moreover, the sampling times may vary for different time series.</p></list-item><list-item><p><italic>Noise:</italic> As is the case with all microarray data, the measurements involve a fair amount of noise due to technical issues in the process.</p></list-item><list-item><p><italic>Biological variability:</italic> Because a mouse model is used for the toxicology experiments we consider, there is also a component of biological variation that affects the data measured. Each microarray assays a sample from a different animal.</p></list-item></list><p>These properties of the data result in several additional challenges for the task we consider.</p><list list-type="bullet"><list-item><p>The time points present in a given query may not correspond to measured points in some or any of the time series in the database.</p></list-item><list-item><p>Queries may be of variable size. Some queries may consist of only a single observation, whereas others may contain multiple time points. Additionally, queries may vary in their extent: some may span only a few hours whereas others include measurements taken over days.</p></list-item><list-item><p>A given query and its best match in the database may differ in the amplitude, temporal offset, or temporal extent of their responses. For example, the expression profile represented by a query treatment may be similar to a database treatment except that the gene expression responses are attenuated, or occur later, or take place more slowly.</p></list-item><list-item><p>A given query and its best match in the database may differ in that one of them shows more of the temporal evolution of the treatment responses. In other words, the query may be similar to a truncated version of the database series, or vice versa.</p></list-item></list><p>To address these challenges, we have developed a generative model that approaches the problem from a probabilistic perspective. In order to temporally align gene-expression time series using our model, we employ a novel method for <italic>dynamic time warping</italic>. Dynamic time warping <xref ref-type="bibr" rid="pcbi.1000116-Sakoe1">[3]</xref>,<xref ref-type="bibr" rid="pcbi.1000116-Sankoff1">[4]</xref> is an approach for aligning pairs of time series that was originally developed for speech recognition problems. It employs dynamic programming to find an optimal alignment with respect to a given scoring function. We also use spline interpolation as a preprocessing step to predict expression responses for unmeasured time points, in order to reconstruct a more complete time series.</p><p>Our time warping approach differs in several substantial ways from the standard dynamic programming method. Unlike the standard approach, our method does not force the two series to be globally aligned. Instead, it permits a type of <italic>local</italic> alignment in which the end of one series is unaligned. We refer to this case as <italic>shorting</italic> the alignment. This aspect of the approach is motivated by the consideration that one of the series may show more of the temporal response than the other. For example, one series may not have been measured for as long as the other. Another significant way in which our approach differs from standard time warping is that it is based on an explicit, generative model. This model allows the user to explicitly encode costs/probabilities that characterize the likelihood of various types of differences in closely related time series. The most significant way in which our approach differs from standard time warping is that it enables the user to impose fairly strong biases on the form that the alignments can take. In particular, it allows alignments that partition the given time series into a small number of segments in which the changes from one time series to the other (e.g., in terms of amplitude) are fairly uniform. This is important given the sparsity, high-dimensionality, and noisiness of the time series being aligned.</p><p>We also investigate variations on spline interpolation in order to find an approach that results in accurate reconstructions of sparsely sampled time series. We find that we achieve more accurate interpolations when using higher order splines. Further, our experiments indicate that it is helpful to relax the splines' fit to the observed data, rather than potentially overfitting by exactly intercepting each observed data point.</p><p>In earlier work, our group <xref ref-type="bibr" rid="pcbi.1000116-Thomas1">[5]</xref> and others <xref ref-type="bibr" rid="pcbi.1000116-Natsoulis1">[6]</xref> have developed systems for classifying chemicals according to the expression profiles they induce. The approach that we present here differs in that it takes into account the temporal aspects of expression profiles, and it is able to answer similarity queries. The latter property is important because some classes may be very sparsely populated in the database, and class labels may not be available or readily defined for some treatments.</p><p>Lamb et al. <xref ref-type="bibr" rid="pcbi.1000116-Lamb1">[7]</xref> consider the task of finding expression profiles that are similar to a given query profile, such as one induced by a particular drug. Their approach does not represent time series, however. Moreover, it assumes that the query includes a specified set of genes which are known to be correlated with some state of interest, such as the expression activity induced by the drug. Our approach does not require that such a gene set be provided.</p><p>Aach and Church <xref ref-type="bibr" rid="pcbi.1000116-Aach1">[8]</xref> were the first to apply the method of dynamic time warping <xref ref-type="bibr" rid="pcbi.1000116-Sakoe1">[3]</xref> to gene expression profiles, and other groups have followed <xref ref-type="bibr" rid="pcbi.1000116-Criel1">[9]</xref>,<xref ref-type="bibr" rid="pcbi.1000116-Liu1">[10]</xref>. The method we present differs in several key respects. First, our method is able to not only align a pair of time series, but it is also able to pick out the known time series most similar to an unknown one for purposes of classification. Second, we use nonlinear spline models in conjunction with time warping in order to interpolate to unseen time points. Third, we consider local alignments of time series in which one of the series is shorted.</p><p>Bar-Joseph et al. <xref ref-type="bibr" rid="pcbi.1000116-BarJoseph1">[11]</xref> have investigated splines and warping in the context of clustering and aligning time series. Our work differs primarily in the task being considered and the use of a more expressive warping model. They restrict their attention to linear warping, whereas we use a “multisegment” model that warps different regions of the series by different amounts.</p><p>Listgarten et al. <xref ref-type="bibr" rid="pcbi.1000116-Listgarten1">[12]</xref> have developed a method for multiple alignment of time series data that has some similarities to our approach. The task they consider—multiple alignment—is different than ours, and their method does not employ splines.</p><p>A related approach to aligning time series is proposed by Gaffney and Smyth <xref ref-type="bibr" rid="pcbi.1000116-Gaffney1">[13]</xref>. They use an expectation-maximization method in concert with a mixture model in order to simultaneously align and cluster time series. Our work, however, is not concerned with clustering known time series. Rather our aim is to use a database of previously seen time series to answer similarity queries about a new one. Further the biases they allow are not appropriate to our task. They allow only linear scaling in time and measurement space whereas we need more complicated warpings, and they allow translation in both these dimensions as well which is unnecessary for us.</p><p>Another similar approach is <italic>correlation optimized warping</italic> (COW), devised by Nielsen et al. <xref ref-type="bibr" rid="pcbi.1000116-Nielsen1">[14]</xref>. They compare time series by dividing them into several roughly equal segments and summing the Pearson's correlations of corresponding segments. The segments may vary in length by up to a slack factor provided by the user, and dynamic programming is used to find the segments with the maximum sum of correlations. Unlike our approach, their method assumes that the series will be globally aligned, without any shorting. Further, the use of correlation can be limiting as COW is unable to distinguish between two series that are proportional to one another.</p><p>Our approach is also related to various probabilistic sequence models, such as <italic>generalized</italic> hidden Markov models, that directly evaluate the likelihood of <italic>segments</italic> of a sequence, instead of incrementally computing these likelihoods one sequence element at a time. Models of this type have been used for tasks such as gene finding <xref ref-type="bibr" rid="pcbi.1000116-Burge1">[15]</xref> and secondary structure prediction <xref ref-type="bibr" rid="pcbi.1000116-Schmidler1">[16]</xref>.</p></sec><sec id="s2"><title>Methods</title><p>In this section we detail our generative model for classifying and aligning time series, and present a dynamic programming algorithm that is able to find optimal alignments under this model. We also present a review of B-spline interpolation and discuss some useful variations of the method. We use spline interpolation to reconstruct unobserved microarray observations.</p><p>Our approach to answering similarity queries involves three basic steps: (i) we use interpolation methods as a preprocessing step to reconstruct unobserved expression values from our sparse time series; (ii) we use our alignment method to find the highest scoring alignment of the query series to each treatment series in the database; (iii) we return the treatment from the database that is most similar to the query, and the calculated alignment between the two series.</p><p>We have implemented all our algorithms in Java. The source code is available for download at <ext-link ext-link-type="uri" xlink:href="http://www.biostat.wisc.edu/aasmith/catcode/" xlink:type="simple">http://www.biostat.wisc.edu/aasmith/catcode/</ext-link>.</p><sec id="s2a"><title>Interpolating Expression Profiles with B-Splines</title><p>One challenge that arises when aligning a pair of expression time series is that the series may have been sampled at different time points. Moreover, the sampling may be sparse and occur at irregular intervals. To address these issues, we first use an interpolation method to reconstruct the unobserved parts of the time series before trying to align them. This interpolation step allows us to represent each time series by regularly spaced observations. We refer to the “observations” which come from the interpolation, as opposed to measurement, as <italic>pseudo-observations</italic>.</p><p>Although linear interpolation is a natural first approximation, other work has explored the use of B-splines to better reconstruct missing expression data <xref ref-type="bibr" rid="pcbi.1000116-BarJoseph1">[11]</xref>. A B-spline is a piecewise polynomial function that is a generalization of a Bézier curve. We present a brief review here, although for depth we refer the reader elsewhere <xref ref-type="bibr" rid="pcbi.1000116-Rogers1">[17]</xref>.</p><p>As shown in <xref ref-type="fig" rid="pcbi-1000116-g002">Figure 2</xref>, a B-spline is the weighted sum of a set of basis splines. The basis splines are determined by the desired order <italic>k</italic> of the splines, and the points of discontinuity <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e001" xlink:type="simple"/></inline-formula> which are called <italic>knots</italic>. There are <italic>n</italic> bases, where:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e002" xlink:type="simple"/><label>(1)</label></disp-formula>and they are defined via the Cox-de Boor regression formulas:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e003" xlink:type="simple"/><label>(2)</label></disp-formula><disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e004" xlink:type="simple"/><label>(3)</label></disp-formula>where <italic>b<sub>i</sub></italic><sub>,<italic>k</italic></sub> is the <italic>i</italic>th base of order <italic>k</italic>.</p><fig id="pcbi-1000116-g002" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g002</object-id><label>Figure 2</label><caption><title>A quadratic B-spline (<italic>k</italic> = 3).</title><p>The main spline which fits the observed points is a weighted sum of the basis splines shown at the bottom of the figure. These are defined by the Cox-de Boor regression formulas (Equations 2 and 3) in conjunction with pre-defined points of discontinuity (the vertical lines). The weights, called control points, are easily obtained by solving a set of linear equations.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g002" xlink:type="simple"/></fig><p>It follows that the segments of the <italic>k</italic>th-order basis splines have degree of <italic>k</italic>−1, so a second-order B-spline consists of line segments, a third-order spline consists of quadratic segments, etc. The splines are also continuous down to the (k−2)th derivative. The actual interpolating B-spline <italic>s</italic> inherits these properties. It is formally defined as:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e005" xlink:type="simple"/><label>(4)</label></disp-formula></p><p>The weights <italic>C<sub>i</sub></italic> are known as control points, and solving for them is a simple matter of solving linear equations. With <italic>n</italic> points (<italic>t<sub>i</sub></italic>,<italic>x<sub>i</sub></italic>) to interpolate:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e006" xlink:type="simple"/><label>(5)</label></disp-formula></p><p>With fewer than <italic>n</italic> points, the problem is underconstrained and cannot be solved with such a large <italic>k</italic>. With more than <italic>n</italic> points, the problem is overconstrained and can only be solved in a least-squares sense. This is easy to do with standard linear algebra techniques. However, one must make sure that every base overlaps with at least one observation, or the matrix will be rank-deficient and the equations unsolvable.</p><p>Unfortunately, B-splines have a tendency to overfit curves in data-impoverished conditions. Such reconstructions can show large oscillations in an attempt to exactly intercept every observed data point. This can be especially problematic with microarray data, which are already inherently noisy. The solution we use is to solve for the control points of a low-order spline, and then use those control points for a higher-order one. Such a spline will tend to fall within the convex hull created by the lower-order spline <xref ref-type="bibr" rid="pcbi.1000116-Rogers1">[17]</xref>. We refer to such splines as <italic>smoothing</italic> splines, and refer to B-splines solved with conventional methods as <italic>intercepting</italic> splines.</p></sec><sec id="s2b"><title>A Generative Model for Time Series Alignment</title><p>Each possible alignment we consider for two given time series (the query and the database series) partitions the series into <italic>m segments</italic>, where the <italic>i</italic>th segments of the series correspond to one another. Our dynamic programming method tries to find a partitioning of the series that reveals the maximal similarity between them. As discussed earlier, we want to take into account that the nature of the relationship between the two series may vary in different segments. For example, it may be the case that the first part of the expression response occurs more slowly in one treatment than in a similar treatment. Recall also that the segments do not have to cover the entirety of both series—one of the series may be “shorted.”</p><p><xref ref-type="fig" rid="pcbi-1000116-g003">Figure 3</xref> illustrates the type of alignment we want to consider. This figure shows the optimal alignment between a query treatment and a given treatment in the database. (For simplicity, the figure shows each treatment as consisting of only a single gene.) This alignment involves three different segments, and in each segment the amplitude and stretching relationships between the two series are somewhat different. We use the term <italic>stretching</italic> to refer to distortions in the rate of some response, and the term <italic>amplitude</italic> to refer to distortions in the magnitude of the response. In addition, the alignment has shorted so that the full query is aligned with only a partial database series.</p><fig id="pcbi-1000116-g003" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g003</object-id><label>Figure 3</label><caption><title>An example of an alignment with local effects.</title><p>The best alignment between the query treatment and the database treatment being considered involves three segments. The first two segments of the database treatment have increased amplitude, the first segment is contracted (or stretched in), and the third segment is stretched out in order to approximate the observed query treatment. Also the alignment shorts before the database treatment has ended, as there is no evidence that the query treatment expression has begun to increase again at the end.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g003" xlink:type="simple"/></fig><p>To determine the similarity between a query time series <italic>q</italic> and a particular database series <italic>d</italic>, we can calculate how likely it is that <italic>q</italic> is a somewhat distorted exemplar of the same process that resulted in <italic>d</italic>. In particular, we can think of a generative process that uses <italic>d</italic> to generate similar expression profiles. We can then ask how probable <italic>q</italic> looks under this generative process.</p><p>Given this generative process idea, we calculate the probability of a particular alignment of query <italic>q</italic> given a database series <italic>d</italic> as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e007" xlink:type="simple"/><label>(6)</label></disp-formula>where <italic>m</italic> is the number of segments in the alignment, <italic>q<sub>i</sub></italic> and <italic>d<sub>i</sub></italic> refer to the expression measurements for the <italic>i</italic>th query and database segments respectively, and <italic>s<sub>i</sub></italic> is the stretching value and <italic>a<sub>i</sub></italic> is the amplitude value for the <italic>i</italic>th segment. The location of each segment pair is assumed to be given here.</p><p><italic>P<sub>m</sub></italic> represents a probability distribution over the number of segments in an alignment, up to some maximum number <italic>M</italic> of allowed segments. <italic>P<sub>s</sub></italic> represents a probability distribution over possible stretching values for a pair of segments, <italic>P<sub>a</sub></italic> represents a probability distribution over possible amplitude values, and <italic>P<sub>e</sub></italic> represents a probability distribution over expression observations in the query series, given the database series and the stretching and amplitude parameters.</p><p>To represent <italic>P<sub>s</sub></italic>, we use a discretized version of the following distribution:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e008" xlink:type="simple"/><label>(7)</label></disp-formula></p><p>We choose this distributional form because it is a variation of the log normal distribution that is symmetric around one, such that <italic>P</italic>(<italic>x</italic>) = <italic>P</italic>(1/<italic>x</italic>). Thus for example, stretching some expression response by a factor of two is equiprobable to compressing it by a factor of two. This symmetry property means that it does not matter which series we consider to be the query and which we consider to be from the database. As we discuss in the next section, our dynamic programming algorithm only allows segments to begin and end at a limited number of points. Thus, our distribution is actually discretized so that probability mass is allocated only to possible stretching values, and then renormalized.</p><p>We use a similar distribution to represent <italic>P<sub>a</sub></italic>, the distribution of amplitude values, since we also want to have <italic>P</italic>(<italic>x</italic>) = <italic>P</italic>(1/<italic>x</italic>) symmetry with these values. Thus a twofold increase in an expression response is treated as equiprobable to a twofold decrease.</p><p>To calculate <italic>P<sub>e</sub></italic>(<italic>q<sub>i</sub></italic>|<italic>d<sub>i</sub></italic>,<italic>s<sub>i</sub></italic>,<italic>a<sub>i</sub></italic>), we transform our representation of <italic>d<sub>i</sub></italic> using the given stretching and amplitude values, and then ask how probable <italic>q<sub>i</sub></italic> appears when we use this transformed <italic>d<sub>i</sub></italic> series as a model. Let us first consider a simple case in which our time series have only one gene, and we are mapping only one point from the query segment <italic>q<sub>i</sub></italic> to the database segment <italic>d<sub>i</sub></italic>. Let <italic>t</italic> represent a time coordinate in the segment <italic>q<sub>i</sub></italic>, and let <italic>q<sub>i</sub>l</italic> and <italic>q<sub>i</sub>r</italic> denote the leftmost and rightmost time coordinates in the <italic>i</italic>th query segment. Let <italic>d<sub>i</sub>l</italic> and <italic>d<sub>i</sub>r</italic> denote the corresponding bounding time coordinates for the <italic>i</italic>th database segment. Then we can map a time coordinate from segment <italic>q<sub>i</sub></italic> into the corresponding coordinate in <italic>d<sub>i</sub></italic> as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e009" xlink:type="simple"/><label>(8)</label></disp-formula>where the stretching value <italic>s<sub>i</sub></italic> is defined by:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e010" xlink:type="simple"/><label>(9)</label></disp-formula></p><p>Our model for “generating” points in the query series from a point in the database series is a Gaussian centered at the database point. Let <italic>p</italic>(<italic>x</italic>,<italic>μ</italic>,<italic>σ<sub>e</sub></italic>) represent the probability density function of this Gaussian, where <italic>μ</italic> is the mean and <italic>σ<sub>e</sub></italic> is the standard deviation of the Gaussian. We can then compute the probability of generating a query point <italic>q<sub>i</sub></italic>(<italic>t</italic>) located at time <italic>t</italic> as:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e011" xlink:type="simple"/><label>(10)</label></disp-formula></p><p>In other words, we center a Gaussian on the expression level at the mapped time coordinate in the database series, and ask how probable the scaled expression value from the query looks at that time coordinate.</p><p>To generalize this calculation to multiple observations in the query series, we make the simplifying assumption that the observations are independent, and we have:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e012" xlink:type="simple"/><label>(11)</label></disp-formula>where <italic>n<sub>i</sub></italic> is the number of query observations in segment <italic>i</italic>.</p><p>Each of our observations represents measurements for hundreds of genes. We therefore generalize the description above by having <italic>p</italic>(<italic>x</italic>,<italic>μ</italic>,<italic>σ<sub>e</sub></italic>) be a multidimensional Gaussian, with one dimension for each gene measured. In our current work, we treat the genes as independent of one another given the time point. Thus the covariance matrix for this Gaussian is zero on all of the off-diagonal terms.</p><p>We assume that <italic>σ<sub>e</sub></italic> represents variation in expression measurements that are due to technical and biological variability. Thus, we estimate the standard deviation for each gene by considering the variance in a sample that consists of all the replicated experiments in the database.</p><p>In addition to considering the likelihood of the query series under the assumption that it exhibits a similar response to the given database series, we also consider its likelihood under a null model. The notion of a null model here is one that generates alignments by randomly picking observations from the database to align with the query sequence. The rationale for using such a null model is analogous to the use of a model of <italic>unrelated</italic> sequences in the derivation of substitution matrices for protein sequence alignment <xref ref-type="bibr" rid="pcbi.1000116-Altschul1">[18]</xref>,<xref ref-type="bibr" rid="pcbi.1000116-Durbin1">[19]</xref>. In the case of protein sequence alignment, we want to know the relative likelihood of two cases: one case in which the correspondence between the sequences is explained by their relatedness through evolution, and the alternative in which the sequences are unrelated. In our task, we similarly want to compare the probability of an alignment given a model of relatedness (described above), and an alternative that asks how probable the query would look if we aligned it to an unrelated series.</p><p>The value of a null model for our application is that it enables alignments of differing lengths, including shorted alignments, to be compared on an equal footing. Under our scoring function which incorporates the null model, segments have a positive score only if the database series in that segment explains the corresponding segment from the query series better than the null model does.</p><p>Let <italic>p</italic>(<italic>x</italic>,<italic>μ<sub>DB</sub></italic>,<italic>σ<sub>e</sub></italic>) represent the probability density function of a multidimensional Gaussian whose mean <italic>μ<sub>DB</sub></italic> is the average expression level of the observations in the database, and whose standard deviation is <italic>σ<sub>e</sub></italic> as before.</p><p>We then estimate the probability of the <italic>i</italic>th segment of the query series under the null model as:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e013" xlink:type="simple"/><label>(12)</label></disp-formula></p><p>Since our null model assumes that there is only a single segment with no amplitude change or stretching, we can compute the probability of the entire query series <italic>q</italic> as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e014" xlink:type="simple"/><label>(13)</label></disp-formula></p><p>Putting together the terms above, we can score a given alignment based on the log of the likelihood ratio of the query series under the “database series” model versus the query series under the null model as:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e015" xlink:type="simple"/><label>(14)</label></disp-formula></p><p>Up to now we have described this process in terms of using a database series to generate the query series. However, we want our alignment method to be symmetric so that it does not matter which series we consider to be the query and which we consider to be from the database. Due to the last two terms, this will not necessarily be the case using the scoring function defined above. Therefore, we modify the scoring function so that it also considers using the query series to generate the database series:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e016" xlink:type="simple"/><label>(15)</label></disp-formula></p><p>Here <italic>P<sub>e</sub></italic>(<italic>d<sub>i</sub></italic>|<italic>q<sub>i</sub></italic>,1/<italic>s<sub>i</sub></italic>,1/<italic>a<sub>i</sub></italic>) is calculated in an analogous manner to <italic>P<sub>e</sub></italic>(<italic>q<sub>i</sub></italic>|<italic>d<sub>i</sub></italic>,<italic>s<sub>i</sub></italic>,<italic>a<sub>i</sub></italic>) but the inverses of <italic>s<sub>i</sub></italic> and <italic>a<sub>i</sub></italic> are used to generate observations in the database series.</p></sec><sec id="s2c"><title>A Dynamic Program for Alignment</title><p>Given a pair of time series, we do not know a priori which alignment (i.e., placement of corresponding segments) is optimal. However we can find the optimal alignment using dynamic programming. The following algorithm takes as input two time series, termed <italic>q</italic> and <italic>d</italic>, both of which are represented by regularly spaced observations (or interpolated pseudo-observations) of the gene expression values.</p><p>In particular, given a segment pair (<italic>q<sub>i</sub></italic>,<italic>d<sub>i</sub></italic>), we can calculate its score as follows:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e017" xlink:type="simple"/><label>(16)</label></disp-formula></p><p>The arguments to this scoring function define the leftmost and rightmost time coordinates of the segments being aligned from the query series and the database series. These points are selected from the set of regularly spaced observations mentioned above. The stretching parameter, <italic>s<sub>i</sub></italic> is defined by the relative lengths of the two segments. We find the amplitude coefficient <italic>a<sub>i</sub></italic> via a least-squares method. Although this least-squares method is not guaranteed to find the optimal value of <italic>a<sub>i</sub></italic>, we have found that, in practice, it provides solutions comparable to a dense grid search of the parameter, and it is much faster than the latter.</p><p>The core of the dynamic program involves filling in a three-dimensional matrix Г in which each element <italic>γ</italic>(<italic>i</italic>,<italic>x</italic>,<italic>y</italic>) represents the best score found with <italic>i</italic> segments that align the query subseries from time 0 to <italic>x</italic> with the database subseries from time 0 to <italic>y</italic>. As above, <italic>x</italic> and <italic>y</italic> must be selected from the given observations in the two series. The basic idea is that in order to determine <italic>γ</italic>(<italic>i</italic>,<italic>x</italic>,<italic>y</italic>), we look through all <italic>γ</italic>(<italic>i</italic>−1,<italic>a</italic>,<italic>b</italic>) where <italic>a</italic>&lt;<italic>x</italic> and <italic>b</italic>&lt;<italic>y</italic>. We then add the score of the segment from (<italic>a</italic>,<italic>b</italic>) to (<italic>x</italic>,<italic>y</italic>) to the value <italic>γ</italic>(<italic>i</italic>−1,<italic>a</italic>,<italic>b</italic>), assigning the best such sum to <italic>γ</italic>(<italic>i</italic>,<italic>x</italic>,<italic>y</italic>).</p><p>We define <italic>γ</italic>(<italic>i</italic>,<italic>x</italic>,<italic>y</italic>) with the following recurrence relation:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e018" xlink:type="simple"/><label>(17)</label></disp-formula>where the base case is:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e019" xlink:type="simple"/><label>(18)</label></disp-formula></p><p>Here, <italic>q</italic>.<italic>r</italic> and <italic>d</italic>.<italic>r</italic> refer to the rightmost (last) time coordinates in the query series and the database series, respectively. The first condition in each recurrence relation ensures that the distribution over the number of segments <italic>P<sub>m</sub></italic> is taken into account when we consider the last pair of segments in a candidate alignment.</p><p>Recall that we are interested in possibly shorting the alignment, thus finding a local alignment rather than a global one. Allowed alignments are those that explain the entire extent of at least one of the two given time series. In order to recover the optimal alignment, we use a traceback procedure that involves scanning the elements of Г that represent alignments that include the entirety of the query series, the entirety of the database series, or both. The procedure returns the alignment corresponding to the highest-scoring entry among these. More formally, we find the score of the best alignment as follows, and start the traceback from the identified element:<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e020" xlink:type="simple"/><label>(19)</label></disp-formula></p><p>This dynamic program can be thought of as having three key “penalty terms” that determine the relative scores of alignments. These penalty terms correspond to the probability distributions that govern (i) the number of segments, (ii) the stretching values, and (iii) the amplitude values used in an alignment.</p><p>Preferences for the number of segments to be used in alignments are expressed by providing a distribution for <italic>P<sub>m</sub></italic>. In our work to date, we have assumed a uniform distribution up to the allowed number of segment pairs. It might be valuable to use a distribution that favors fewer segment pairs, however. Preferences for stretching and amplitude values are controlled via the standard deviation <italic>σ</italic> parameter in the distributions over these values. For example, as <italic>σ<sub>a</sub></italic> for the amplitude distribution is made smaller, a difference in amplitude between the series is penalized more in the scoring scheme.</p></sec></sec><sec id="s3"><title>Results</title><p>In this section we present experiments that evaluate the utility of our novel time warping method and spline models for the task of answering similarity queries with expression profiles.</p><sec id="s3a"><title>Data</title><p>The data we use in our experiments comes from the Edge toxicology database <xref ref-type="bibr" rid="pcbi.1000116-Hayes1">[1]</xref>, and can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://edge.oncology.wisc.edu/" xlink:type="simple">http://edge.oncology.wisc.edu/</ext-link>. Our data set consists of 216 unique observations of microarray data, each of which represents the expression values for 1,600 different genes. Each of these expression values is calculated by taking the average expression level from four treated animals, divided by the average level measured in four control animals. The data are then converted to a logarithmic scale, so that an expression of 0.0 corresponds to the average basal level observed in the control animals.</p><p>Each observation is associated with a treatment and a time point. The treatment refers to the chemical to which the animals were exposed and its dosage. The time point indicates the number of hours elapsed since exposure occurred. Times range from 6 hours up to 96 hours. The data used in our computational experiments span 11 different treatments, and for each treatment there are observations taken from at least three different time points.</p><p>We can assume that for all treatments there exists an implicit observation at time zero. This is the time at which the treatment was applied, so all expression values are assumed to be at base level. Therefore every query automatically includes at least two observations: the actual query time(s) and the zero point. Thus earlier points in time can be interpolated, even when there seems to be only a single query observation.</p><p><xref ref-type="fig" rid="pcbi-1000116-g004">Figure 4</xref> illustrates the evolution of four genes over time for 2,3,7,8-tetrachlorodibenzo-<italic>p</italic>-dioxin (TCDD), for four different dosages.</p><fig id="pcbi-1000116-g004" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g004</object-id><label>Figure 4</label><caption><title>Expression levels of four of the genes most active for TCDD.</title><p>Linear interpolation is used between these observations of 2,3,7,8-tetrachlorodibenzo-<italic>p</italic>-dioxin, which are represented as points.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g004" xlink:type="simple"/></fig></sec><sec id="s3b"><title>Interpolating Missing Times</title><p>Before we evaluate our generative alignment method, we wish to determine which type of spline (including simple linear interpolation) is the best to use in our preprocessing step. We do this by running a leave-one-out experiment in which we classify each observation in our data set in turn, using the remaining observations as the database. However, we exclude from the database any observation with the same treatment (i.e., chemical and dosage) and time as the query observation. We exclude from the queries observations from the last observed time of each treatment because we cannot interpolate pseudo-observations at these times when they are removed from the database series. We reconstruct hourly pseudo-observations for every treatment, using the different methods of interpolation. We search the reconstructed database for the pseudo-observation that is most like the query. We predict the query's treatment and time to be the same as this nearest neighbor. Notice that by excluding replicates of the query from the database, we are forcing our classifier to use interpolation in order to find the correct answer. We wish to know how accurately we are able to (i) identify the treatment from which each point was extracted, and (ii) align each query point to its actual time in the time series for the treatment. We refer to the former as <italic>treatment accuracy</italic> and the latter as <italic>alignment accuracy</italic>.</p><p>We note that this task is only a surrogate for the actual task with which we are concerned—classifying uncharacterized chemicals and aligning them with the most similar treatment in the database. It is a useful surrogate, however, because it is a task in which we know the most similar treatment and the correct alignment of the query to this treatment.</p><p>The metric we use to measure distance between the query observation and the database pseudo-observation being considered is a scale-independent Euclidean distance. The expression values of each database observation are all multiplied by a scalar, which is chosen via a least-squares method in order to minimize its distance to the query observation.</p><p>We consider seven different interpolation methods in all. We look at both <italic>intercepting</italic> and <italic>smoothing</italic> splines as explained in the <xref ref-type="sec" rid="s2">Methods</xref> section, with orders three, four, and five. The control points for the smoothing splines are based on those for second-order interpolation. We also perform linear interpolation as a control. We use the observed times themselves as our knots (points of discontinuity). If there are too few observation times for a particular order, we use the highest possible order. (For example, if there is only a single observation, we interpolate linearly between it and the implicit zero point, regardless of the overall order used.) To allow for smoothing splines, we must keep the number of bases <italic>n</italic> constant. By Equation 1, the number of knots <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e021" xlink:type="simple"/></inline-formula> must decrease when the order <italic>k</italic> increases. We do this by resampling them down to the proper number.</p><p>There are several advantages to using the observed times as the knots for our interpolating splines. First, it allows easy comparison to the basic linear interpolation control. Second, we assume that the data was taken at those times because interesting behavior was anticipated. Using them as knots allows our splines more flexibility there. Third, it keeps the linear equations from being rank-deficient as explained earlier. With uniformly spaced knots (as used by Bar-Joseph et al. <xref ref-type="bibr" rid="pcbi.1000116-BarJoseph1">[11]</xref>) it is possible to be unable to solve for some control points.</p><p>The results of this experiment are shown in <xref ref-type="fig" rid="pcbi-1000116-g005">Figure 5</xref>. The top line shows classification accuracy, while the lower lines show alignment accuracy—where a case is considered “correct” if in addition to the proper treatment, the predicted time is correct to within 24 or 12 hours respectively. We test the significance of the differences in accuracy (from the linear interpolation control) using McNemar's <italic>χ</italic><sup>2</sup> test. Highlighted points are those deemed significant, with <italic>p</italic>&lt;0.05. For all three accuracy measures we see improvement when using smoothing splines, while intercepting splines perform similarly or worse than the linear interpolation control. The fifth-order smoothing spline has a significantly higher classification accuracy (<italic>p</italic>≈0.025), and also appears to have better alignment accuracy (<italic>p</italic>≈0.132 for Δ<italic>t</italic>≤24 and <italic>p</italic>≈0.180 for Δ<italic>t</italic>≤12). By contrast the more traditional intercepting spline is likely overfitting its interpolation to the limited number of observed times. Although the fifth-order intercepting spline is not significantly different from the linear one for classification accuracy (<italic>p</italic>≈0.739) and alignment accuracy to within 24 hours (<italic>p</italic>≈0.705), there is a noticeable hit in the stricter alignment accuracy (<italic>p</italic>≈0.021). The <italic>p</italic>-values for the lower-ordered splines are qualitatively similar.</p><fig id="pcbi-1000116-g005" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g005</object-id><label>Figure 5</label><caption><title>Classification and alignment accuracies resulting from using different B-splines for interpolation.</title><p>All replicates of the observation tested are purged from the database. The top line shows classification accuracy, in which the correct treatment is chosen. The bottom lines show alignment accuracy, where the predicted time is within 24 and 12 hours respectively of the actual time. Highlighted points are significantly different from the linear case (<italic>p</italic>≤0.05 via McNemar's <italic>χ</italic><sup>2</sup> test).</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g005" xlink:type="simple"/></fig><p>Based on these results, we restrict our attention to smoothing splines in subsequent experiments.</p></sec><sec id="s3c"><title>Aligning Time Series</title><p>We now turn our attention to evaluating our multisegment time series alignment algorithm. For all of the experiments reported in this section, we set the parameters of this method as follows. We set the probability that the model has one, two, or three segments at <inline-formula><inline-graphic mimetype="image" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e022" xlink:type="simple"/></inline-formula> each, and 0 beyond that. We estimate <italic>σ<sub>e</sub></italic> (the deviation of the expression Gaussian) to be the standard deviation of the known observations as described previously. We set both <italic>σ<sub>s</sub></italic> (the stretching deviation) and <italic>σ<sub>a</sub></italic> (the amplitude deviation) to be 10×(# genes)<sup>−1</sup>. Thus the three main components of the model have roughly similar influence.</p><p>We assemble queries by randomly subsampling time series in our data set. We assemble ten such queries from each treatment. We build each query by first selecting the number of observations in it, then choosing which time points will be represented, and finally picking an observation for each of these time points. The query sizes are chosen from a uniform distribution that ranges from one up to the number of observed times in the given treatment. The maximum size of a query is eight, although most consist of four or fewer observations. The time points are chosen uniformly as are the observations for each chosen time.</p><p>We then classify and align the query using all the other observations as the database. We preprocess both the query and the eleven database treatments using smoothing splines to reconstruct pseudo-observations at every four hours (starting at time zero, when all expression values are at the basal level). As before, we use the highest interpolation order possible in cases where there are too few observations for the prescribed one. We then align the query against all eleven treatments using our method. We return the database treatment with the highest scoring alignment, as defined by Equation 14. Because the alignment also maps each query time to a database treatment time, we can find the temporal error for any query time point. We thus calculate the average temporal error for the times in the original query in order to assess alignment error.</p><p>We consider several other alignment methods as baselines. We term the first baseline <italic>one-segment generative</italic>. This method is essentially the same as our multisegment generative alignment method, except that its alignments consist of only a single segment. It allows amplitude scaling and stretching, but only within its one segment pair.</p><p>The second control is traditional Euclidean dynamic time warping <xref ref-type="bibr" rid="pcbi.1000116-Sakoe1">[3]</xref>,<xref ref-type="bibr" rid="pcbi.1000116-Sankoff1">[4]</xref>. Briefly, this method computes alignments by creating a matrix Г with elements defined recursively as<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e023" xlink:type="simple"/><label>(20)</label></disp-formula>where <italic>D</italic>(<italic>d<sub>i</sub></italic>,<italic>q<sub>j</sub></italic>) is the Euclidean distance between points <italic>d<sub>i</sub></italic> and <italic>q<sub>j</sub></italic> in the two series and <italic>predecesssors</italic>(<italic>γ</italic>,(<italic>i</italic>,<italic>j</italic>)) refers to the matrix elements adjacent to <italic>γ</italic>(<italic>i</italic>,<italic>j</italic>) with both indices less than or equal to <italic>i</italic> and <italic>j</italic> respectively. The first element <italic>γ</italic>(0,0) is just the Euclidean distance at time 0, and each other element <italic>γ</italic>(<italic>i</italic>,<italic>j</italic>) is the score of warping <italic>d</italic> from times 0 to <italic>i</italic> and <italic>q</italic> from 0 to <italic>j</italic>. We then create a normalized score matrix <italic>Γ̅</italic> where<disp-formula><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.e024" xlink:type="simple"/><label>(21)</label></disp-formula></p><p>This makes it easy to compare warpings to different treatments, where one or the other dimension has been shorted.</p><p>Another control we consider is linear parametric warping. This is similar to the method explored by Bar-Joseph et al. <xref ref-type="bibr" rid="pcbi.1000116-BarJoseph1">[11]</xref>, except that we make the assumption that the series are aligned at time zero. To find an alignment, we search possible slopes of the alignment line, and return the slope that results in the least average Euclidean distance between the query and the given database treatment.</p><p>Finally, we consider <italic>correlation optimized warping</italic> (COW) <xref ref-type="bibr" rid="pcbi.1000116-Nielsen1">[14]</xref> as another baseline. This method takes as input two parameters: the number of warping segments <italic>m</italic> and a slack factor <italic>s</italic>. Both the query series and the database series are split into <italic>m</italic> segments. However while the segments of the query series are of equal length, the segment lengths of the database series may be up to <italic>s</italic> longer or shorter than an equal division would warrant. It is assumed that the starting and ending points of both series are aligned. The Pearson's correlation of each segment pair is calculated, and these are summed to score a given alignment. Dynamic programming is used to find the exact lengths of the database segments that maximize this value. We tried all values for <italic>m</italic> from one to ten together with all the values for <italic>s</italic> from zero to five. We report results for those (<italic>m</italic> = 10 and <italic>s</italic> = 5) that resulted in the highest accuracies.</p><p>The results of these experiments are shown in <xref ref-type="fig" rid="pcbi-1000116-g006">Figure 6A</xref>. For each method the top line represents classification accuracy with different orders of splines, the middle line represents alignment accuracy by adding the criterion that the average time error in the mapping is less than or equal to 24 hours, and the bottom line shows alignment accuracy where this tolerance is decreased to 12 hours. Points highlighted with a small square are significantly different from the corresponding point using our one-segment generative model (<italic>p</italic>≤0.05) according to McNemar's <italic>χ</italic><sup>2</sup> test. Likewise, the large square indicates a significant difference from the three-segment generative model.</p><fig id="pcbi-1000116-g006" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g006</object-id><label>Figure 6</label><caption><title>Classification and alignment accuracies for our generative method and others.</title><p>The figure shows both when there is no temporal distortion (A), and when there is (B). The top lines represent treatment classification accuracy, while the bottom two lines add the criterion that the predicted times are within 24 and 12 hours respectively of the actual time, on average. Small highlights represent cases in which there is a significant difference in accuracy from the corresponding one-segment generative case (<italic>p</italic>≤0.05 with McNemar's <italic>χ</italic><sup>2</sup> test), while the larger highlights show a significant difference from the three-segment model.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g006" xlink:type="simple"/></fig><p>The one-segment and three-segment models are only significantly different from each other in a handful of cases. Because we have added no distortion to the queries, the one-segment model should be sufficient to explain them. We might expect to see some degradation when using the three-segment model, as it is allowed much more freedom in where it places its segments. However, it seems that this is not the case; the three-segment model results in slightly higher accuracies. One explanation for this result is that the spline preprocessing does not create perfect reconstructions of the missing data, and the more expressive three-segment model is better at compensating for this error. Of the control methods, only COW is competitive with our generative method. There is no significant difference between its accuracy and that of our method. Euclidean dynamic time warping classifies fewer queries correctly than our method, although those it does tend to be aligned correctly. This is probably because it has a strong bias toward performing little warping.</p><p>To better test the utility of the multisegment model, we next consider distorting the query time series temporally. We use three different distortions. The first one doubles all times in the first 48 hours (i.e., it stretches the first part of the series), and then halves all times (plus an offset for the doubling) for the next 24 hours. The second distortion halves for the first 36 hours and then doubles for 60 hours. The third one triples for the first 60 hours and then thirds for another 20. It should be noted that not all the treatment observations extend this long in time. The short ones (e.g., those for which we only have measurements up to 24 or 48 hours) will thus not be distorted as much as the long ones.</p><p>Aside from the distortion, we perform the same experiment as before. We show the results in <xref ref-type="fig" rid="pcbi-1000116-g006">Figure 6B</xref>. In this experiment, the three-segment model results in more accurate classifications and alignments than the simpler one-segment model. Both DTW and the linear method appear brittle when confronted with distortions. Although our three-segment method significantly beats COW only when the strictest correctness criteria are used, the results shown are the best COW returned for a wide variety of parameters. We did not perform a similar parameter search for our own method.</p><p>One concern is that by adding distortion we could be changing the best classification of a given treatment. For example, maybe we would distort 10 µg/kg of TCDD in exactly the right way to make it look like 64 µg/kg. To address this concern, we have performed similar distortion experiments in which we align a distorted query series only to the database series that was used to generate it. The results of this experiment are qualitatively the same as those reported in <xref ref-type="fig" rid="pcbi-1000116-g006">Figure 6</xref>.</p></sec><sec id="s3d"><title>Effect of Stretching and Amplitude Components</title><p>We conduct further experiments to evaluate the importance of the stretching and amplitude components of our model. First, we conduct an experiment in which we effectively remove the amplitude component of our model by fixing the value of <italic>a<sub>i</sub></italic> to 1.0 for all segments. With all of the probability mass on this single value, the log <italic>P<sub>a</sub></italic>(<italic>a<sub>i</sub></italic>) term in Equation 14 becomes zero. In a separate experiment, we set <italic>σ<sub>a</sub></italic> = ∞, which makes all amplitude changes equally likely. Similarly, we perform experiments in which we force <italic>s<sub>i</sub></italic> to 1.0 and set <italic>σ<sub>s</sub></italic> = ∞. The results of these experiments are shown in <xref ref-type="fig" rid="pcbi-1000116-g007">Figure 7</xref>.</p><fig id="pcbi-1000116-g007" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g007</object-id><label>Figure 7</label><caption><title>Classification and alignment accuracies when we have removed components of the model.</title><p>The panels show distortion not present (A) and present (B). The first model is the three-segment generative model as before. The second disallows any amplitude changes at all, while the third allows any amplitude coefficient with no penalty to the score. Likewise, the fourth disallows stretching and the fifth allows any stretching without penalty. Highlights indicate a significant difference from the unaltered three-segment model (<italic>p</italic>≤0.05 with McNemar's <italic>χ</italic><sup>2</sup> test).</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g007" xlink:type="simple"/></fig><p>Totally disallowing either stretching or amplitude changes has an overall deleterious effect on the accuracy of the alignments. However there seems to be little negative effect in allowing stretching and amplitude changes but not penalizing for greater values. These results imply that the stretching and amplitude components of the model are valuable, but that the accuracy of the alignments is relatively insensitive to the actual penalties selected.</p></sec><sec id="s3e"><title>Effect of Query Size and Number of Segments</title><p>We next consider a set of experiments in which we assess the accuracy of computed alignments as a function of the amount of data in the query. We restrict our experiments to a single treatment (41 observations of 1 µg/kg TCDD at eight time points), although other treatments yielded qualitatively similar results. We randomly pick out <italic>n</italic> observations from different times in the treatment to form each query. We use all the remaining observations in the treatment as the database. We interpolate both query and database series as before (every four hours), compute the best alignment using the one-segment and three-segment methods, and then assess alignment error. We do this 100 times for each value of <italic>n</italic>, which we vary from one to eight. We also vary the spline order from two to five, and repeat the experiment with the query times distorted (as in the last section) and not distorted. We perform paired, two-tailed <italic>t</italic>-tests on the alignment errors from the two methods in order to determine significant differences.</p><p>We expect the alignment error to generally decrease as we increase the query size. We also expect the one-segment method to perform slightly better when there is no distortion, and the three-segment method to be preferable when there is. However this latter behavior could be confounded for small query sizes, where the three-segment model may not have enough data to determine the segment parameters.</p><p>The results when we interpolate with third-order splines are shown in <xref ref-type="fig" rid="pcbi-1000116-g008">Figure 8</xref>. (The other orders of spline yield substantially similar results.) For queries of size two or less, the one-segment model performs slightly better. Its average error is less than that of the three-segment model, by less than one hour. However as the query size grows larger, the expected results become more apparent. When there is no distortion, the one-segment model is adequate. When there is distortion, a multisegment model is clearly preferable.</p><fig id="pcbi-1000116-g008" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g008</object-id><label>Figure 8</label><caption><title>Average alignment error versus query size.</title><p>The results shown in (A) have no temporal distortion, while those shown in (B) do. The dotted line represents the one-segment model, and the solid line represents the three-segment model, using third-order smoothing splines. Cases in which the two have significantly different results (<italic>p</italic>≤0.05 with a two-tailed Student's <italic>t</italic>-test) are highlighted.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g008" xlink:type="simple"/></fig><p>We next consider the sensitivity of the accuracy of the multisegment method to the number of segments it is allowed to use in its alignments. We would like to know to what extent the alignment accuracy degrades as the method is allowed to use more segments than the optimal alignment requires. We conduct an experiment in which we vary the number of segments from one to five, with query sizes of only one, four, and eight. The results of this experiment are shown in <xref ref-type="fig" rid="pcbi-1000116-g009">Figure 9</xref> for the third-order spline case. Here each line represents one of the query sizes, from one at the top to eight at the bottom. A highlighted part of a line shows a significant change in alignment accuracy when going from an <italic>m</italic>-segment model to an (<italic>m</italic>+1)-segment model.</p><fig id="pcbi-1000116-g009" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g009</object-id><label>Figure 9</label><caption><title>Average alignment error versus number of segments in the model.</title><p>As before, the results in (A) have no temporal distortion while those in (B) do. From top to bottom, the lines of each panel show queries of size one, four, and eight, using third-order smoothing splines. Lines are highlighted in cases where adding a segment to the model makes a significant difference (<italic>p</italic>≤0.05 with a two-tailed Student's <italic>t</italic>-test).</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g009" xlink:type="simple"/></fig><p>Again, we see that in the data-rich situation, the best models are those that closely approximate the number of segments needed to simulate the temporal distortion (or lack thereof) applied to the query. In data-poor situations, the alignments of the one-segment method are as accurate as multisegment alignments. Significantly, the accuracy of the multisegment method is quite robust when it is allowed to use more segments than necessary. This is important, as in practice we will not generally know the correct number of segments in order to find the best alignment of a query and its best matching series in the database.</p></sec><sec id="s3f"><title>An Alignment Example</title><p>Finally, we consider calculating the alignments for four treatments that we know are closely related. <xref ref-type="fig" rid="pcbi-1000116-g010">Figure 10</xref> illustrates the alignments computed by our method for a 10 µg/kg dose of TCDD to itself and three other dosages of the same chemical.</p><fig id="pcbi-1000116-g010" position="float"><object-id pub-id-type="doi">10.1371/journal.pcbi.1000116.g010</object-id><label>Figure 10</label><caption><title>Alignments found by our multisegment method between four different dosages of TCDD.</title><p>The boxed numbers on each segment represent the amplitude coefficient by which the expression levels of the 10 µg/kg segment are best multiplied in order to obtain the corresponding expression levels for the other treatment.</p></caption><graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1000116.g010" xlink:type="simple"/></fig><p>These alignments illustrate several interesting phenomena. First, they indicate that the overall amplitude of the response increases along with the dose. This effect is illustrated by the boxed numbers on the segments in <xref ref-type="fig" rid="pcbi-1000116-g010">Figure 10</xref>. Second, the 10 µg/kg and 64 µg/kg dosages induce similar responses, both in their amplitude and temporal evolution. Third, the alignment to the 100 µg/kg dosage suggests that the response induced by this treatment initially progresses more slowly than the responses caused by the lower doses. This somewhat surprising result and the abovementioned effects are consistent with the expression profiles for the highly expressed genes shown in <xref ref-type="fig" rid="pcbi-1000116-g004">Figure 4</xref>.</p></sec></sec><sec id="s4"><title>Discussion</title><p>We have presented an approach for answering similarity queries among gene expression time series, and aligning those queries in time. Our approach employs spline models to interpolate sparse time series, and a novel method for time warping. We have investigated our approach in the context of a toxicogenomics application in which we would like to know which treatments in a database of well characterized chemicals are most similar to a given query treatment.</p><p>The work we have presented features several novel aspects and contributions.</p><list list-type="bullet"><list-item><p>We have introduced a novel, <italic>multisegment</italic> alignment method for time series. This method offers more flexibility than linear alignment methods, yet is more constrained than the standard dynamic time warping approach. Our multisegment method is able to find accurate alignments in cases in which part, but not all, of the expression response occurs more slowly (rapidly) or has a smaller (greater) amplitude in one treatment than in a similar treatment.</p></list-item><list-item><p>To account for the fact that we have sparse time series, we have investigated the use of a variant of B-splines we refer to as <italic>smoothing</italic> splines. Smoothing splines determine their control points from interpolations calculated with lower-order splines.</p></list-item><list-item><p>We have empirically shown that our smoothing splines result in more accurate alignments than both conventional <italic>intercepting</italic> B-splines and a linear interpolation baseline.</p></list-item><list-item><p>We have empirically demonstrated that our generative alignment method generally produces more accurate alignments and treatment classifications than other commonly used alignment methods, including conventional dynamic time warping, linear parametric, and correlation optimized warping.</p></list-item></list><p>There are several avenues of future work we plan to pursue. One is to address the time complexity of our multisegment algorithm, which is <italic>O</italic>(<italic>n</italic><sup>5</sup>), where <italic>n</italic> is the length of the series. Alignment to all eleven database series and subsequent classification currently take about a half hour to execute. By contrast, the time complexity of ordinary dynamic time warping is only <italic>O</italic>(<italic>n</italic><sup>2</sup>). When the calculations are restricted to the so-called <italic>Sakoe-Chiba band</italic>, a narrow band centered on the diagonal of the warping matrix, the time complexity approaches <italic>O</italic>(<italic>n</italic>) <xref ref-type="bibr" rid="pcbi.1000116-Ratanamahatana1">[20]</xref>. We would like to devise heuristics to speed up our multisegment method. For example, although shorting complicates the use of a Sakoe-Chiba band, it might be possible to restrict calculations in the warping space to some other shape, such as a cone. Alternatively, we could perform a first pass with the faster one-segment model, and then restrict the multisegment model to an area near it in warping space.</p><p>In addition, we have made two independence assumptions that we plan to revisit in future research. First, we have assumed that each gene is independent of all the others given the model. We expect that representing some gene dependencies would lead to more accurate classifications and alignments. Second, we assume that the measurements at each time point are independent of each other time point. We plan to investigate a Markov-model like approach that represents dependencies between neighboring time points.</p></sec></body><back><ref-list><title>References</title><ref id="pcbi.1000116-Hayes1"><label>1</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Hayes</surname><given-names>K</given-names></name><name name-style="western"><surname>Vollrath</surname><given-names>A</given-names></name><name name-style="western"><surname>Zastrow</surname><given-names>G</given-names></name><name name-style="western"><surname>McMillan</surname><given-names>B</given-names></name><name name-style="western"><surname>Craven</surname><given-names>M</given-names></name><etal/></person-group>             <year>2005</year>             <article-title>EDGE: a centralized resource for the comparison, analysis and distribution of toxicogenomic information.</article-title>             <source>Mol Pharmacol</source>             <volume>67</volume>             <fpage>1360</fpage>             <lpage>1368</lpage>          </element-citation></ref><ref id="pcbi.1000116-Ernst1"><label>2</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Ernst</surname><given-names>J</given-names></name><name name-style="western"><surname>Nau</surname><given-names>G</given-names></name><name name-style="western"><surname>Bar-Joseph</surname><given-names>Z</given-names></name></person-group>             <year>2005</year>             <article-title>Clustering short time series gene expression data.</article-title>             <source>Bioinformatics</source>             <volume>21</volume>             <fpage>i159</fpage>             <lpage>i168</lpage>          </element-citation></ref><ref id="pcbi.1000116-Sakoe1"><label>3</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Sakoe</surname><given-names>H</given-names></name><name name-style="western"><surname>Chiba</surname><given-names>S</given-names></name></person-group>             <year>1978</year>             <article-title>Dynamic programming algorithm optimization for spoken word recognition.</article-title>             <source>IEEE Trans Acoust</source>             <volume>26</volume>             <fpage>43</fpage>             <lpage>49</lpage>          </element-citation></ref><ref id="pcbi.1000116-Sankoff1"><label>4</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Sankoff</surname><given-names>D</given-names></name><name name-style="western"><surname>Kruskal</surname><given-names>J</given-names></name></person-group>             <year>1983</year>             <source>Time Warps, String Edits, and Macromolecules: The Theory and Practice of Sequence Comparison</source>             <publisher-loc>Reading (Massachusetts)</publisher-loc>             <publisher-name>Addison-Wesley</publisher-name>          </element-citation></ref><ref id="pcbi.1000116-Thomas1"><label>5</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Thomas</surname><given-names>R</given-names></name><name name-style="western"><surname>Rank</surname><given-names>D</given-names></name><name name-style="western"><surname>Penn</surname><given-names>S</given-names></name><name name-style="western"><surname>Zastrow</surname><given-names>G</given-names></name><name name-style="western"><surname>Hay</surname><given-names>K</given-names></name><etal/></person-group>             <year>2001</year>             <article-title>Identification of toxicologically predictive gene sets using cDNA microarrays.</article-title>             <source>Mol Pharmacol</source>             <volume>60</volume>             <fpage>1189</fpage>             <lpage>1194</lpage>          </element-citation></ref><ref id="pcbi.1000116-Natsoulis1"><label>6</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Natsoulis</surname><given-names>G</given-names></name><name name-style="western"><surname>Ghaoui</surname><given-names>LE</given-names></name><name name-style="western"><surname>Lanckriet</surname><given-names>G</given-names></name><name name-style="western"><surname>Tolley</surname><given-names>A</given-names></name><name name-style="western"><surname>Leroy</surname><given-names>F</given-names></name><etal/></person-group>             <year>2005</year>             <article-title>Classification of a large microarray data set: algorithm comparison and analysis of drug signatures.</article-title>             <source>Genome Res</source>             <volume>15</volume>             <fpage>724</fpage>             <lpage>736</lpage>          </element-citation></ref><ref id="pcbi.1000116-Lamb1"><label>7</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Lamb</surname><given-names>J</given-names></name><name name-style="western"><surname>Crawford</surname><given-names>E</given-names></name><name name-style="western"><surname>Peck</surname><given-names>D</given-names></name><name name-style="western"><surname>Modell</surname><given-names>J</given-names></name><name name-style="western"><surname>Blat</surname><given-names>I</given-names></name><etal/></person-group>             <year>2006</year>             <article-title>The connectivity map: using gene-expression signatures to connect small molecules, genes and disease.</article-title>             <source>Science</source>             <volume>313</volume>             <fpage>1929</fpage>             <lpage>1935</lpage>          </element-citation></ref><ref id="pcbi.1000116-Aach1"><label>8</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Aach</surname><given-names>J</given-names></name><name name-style="western"><surname>Church</surname><given-names>G</given-names></name></person-group>             <year>2001</year>             <article-title>Aligning gene expression time series with time warping algorithms.</article-title>             <source>Bioinformatics</source>             <volume>17</volume>             <fpage>495</fpage>             <lpage>508</lpage>          </element-citation></ref><ref id="pcbi.1000116-Criel1"><label>9</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Criel</surname><given-names>J</given-names></name><name name-style="western"><surname>Tsiporkova</surname><given-names>E</given-names></name></person-group>             <year>2006</year>             <article-title>Gene time expression warper: a tool for alignment, template matching and visualization of gene expression time series.</article-title>             <source>Bioinformatics</source>             <volume>22</volume>             <fpage>251</fpage>             <lpage>252</lpage>          </element-citation></ref><ref id="pcbi.1000116-Liu1"><label>10</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Liu</surname><given-names>X</given-names></name><name name-style="western"><surname>Müller</surname><given-names>HG</given-names></name></person-group>             <year>2003</year>             <article-title>Modes and clustering for time-warped gene expression profile data.</article-title>             <source>Bioinformatics</source>             <volume>19</volume>             <fpage>1937</fpage>             <lpage>1944</lpage>          </element-citation></ref><ref id="pcbi.1000116-BarJoseph1"><label>11</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Bar-Joseph</surname><given-names>Z</given-names></name><name name-style="western"><surname>Gerber</surname><given-names>G</given-names></name><name name-style="western"><surname>Gifford</surname><given-names>D</given-names></name><name name-style="western"><surname>Jaakkola</surname><given-names>T</given-names></name><name name-style="western"><surname>Simon</surname><given-names>I</given-names></name></person-group>             <year>2003</year>             <article-title>Continuous representations of time-series expression data.</article-title>             <source>J Comput Biol</source>             <volume>10</volume>             <fpage>341</fpage>             <lpage>356</lpage>          </element-citation></ref><ref id="pcbi.1000116-Listgarten1"><label>12</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Listgarten</surname><given-names>J</given-names></name><name name-style="western"><surname>Neal</surname><given-names>R</given-names></name><name name-style="western"><surname>Roweis</surname><given-names>S</given-names></name><name name-style="western"><surname>Emili</surname><given-names>A</given-names></name></person-group>             <year>2005</year>             <article-title>Multiple alignment of continuous time series.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Saul</surname><given-names>L</given-names></name><name name-style="western"><surname>Weiss</surname><given-names>Y</given-names></name><name name-style="western"><surname>Bottou</surname><given-names>L</given-names></name></person-group>             <source>Advances in Neural Information Processing Systems 17</source>             <publisher-loc>Cambridge (Massachusetts)</publisher-loc>             <publisher-name>MIT Press</publisher-name>             <fpage>817</fpage>             <lpage>824</lpage>          </element-citation></ref><ref id="pcbi.1000116-Gaffney1"><label>13</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Gaffney</surname><given-names>SJ</given-names></name><name name-style="western"><surname>Smyth</surname><given-names>P</given-names></name></person-group>             <year>2005</year>             <article-title>Joint probabilistic curve clustering and alignment.</article-title>             <person-group person-group-type="editor"><name name-style="western"><surname>Saul</surname><given-names>LK</given-names></name><name name-style="western"><surname>Weiss</surname><given-names>Y</given-names></name><name name-style="western"><surname>Bottou</surname><given-names>L</given-names></name></person-group>             <source>Advances in Neural Information Processing Systems 17</source>             <publisher-loc>Cambridge, MA</publisher-loc>             <publisher-name>MIT Press</publisher-name>             <fpage>473</fpage>             <lpage>480</lpage>          </element-citation></ref><ref id="pcbi.1000116-Nielsen1"><label>14</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Nielsen</surname><given-names>NV</given-names></name><name name-style="western"><surname>Carstensen</surname><given-names>JM</given-names></name><name name-style="western"><surname>Smedsgaard</surname><given-names>J</given-names></name></person-group>             <year>1998</year>             <article-title>Aligning of single and multiple wavelength chromatographic profiles for chemometric data analysis using correlation optimised warping.</article-title>             <source>J Chromatogr A</source>             <volume>805</volume>             <fpage>17</fpage>             <lpage>35</lpage>          </element-citation></ref><ref id="pcbi.1000116-Burge1"><label>15</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Burge</surname><given-names>C</given-names></name><name name-style="western"><surname>Karlin</surname><given-names>S</given-names></name></person-group>             <year>1997</year>             <article-title>Prediction of complete gene human genomic DNA.</article-title>             <source>J Mol Biol</source>             <volume>268</volume>             <fpage>78</fpage>             <lpage>94</lpage>          </element-citation></ref><ref id="pcbi.1000116-Schmidler1"><label>16</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Schmidler</surname><given-names>S</given-names></name><name name-style="western"><surname>Liu</surname><given-names>J</given-names></name><name name-style="western"><surname>Brutlag</surname><given-names>D</given-names></name></person-group>             <year>2000</year>             <article-title>Bayesian protein secondary structure.</article-title>             <source>J Comput Biol</source>             <volume>7</volume>             <fpage>233</fpage>             <lpage>248</lpage>          </element-citation></ref><ref id="pcbi.1000116-Rogers1"><label>17</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Rogers</surname><given-names>D</given-names></name><name name-style="western"><surname>Adams</surname><given-names>J</given-names></name></person-group>             <year>1989</year>             <source>Mathematical Elements Graphics</source>             <publisher-loc>New York</publisher-loc>             <publisher-name>McGraw-Hill</publisher-name>          </element-citation></ref><ref id="pcbi.1000116-Altschul1"><label>18</label><element-citation publication-type="journal" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Altschul</surname><given-names>S</given-names></name></person-group>             <year>1991</year>             <article-title>Amino acid substitution matrices information theoretic perspective.</article-title>             <source>J Mol Biol</source>             <volume>219</volume>             <fpage>555</fpage>             <lpage>565</lpage>          </element-citation></ref><ref id="pcbi.1000116-Durbin1"><label>19</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Durbin</surname><given-names>R</given-names></name><name name-style="western"><surname>Eddy</surname><given-names>S</given-names></name><name name-style="western"><surname>Krogh</surname><given-names>A</given-names></name><name name-style="western"><surname>Mitchison</surname><given-names>G</given-names></name></person-group>             <year>1998</year>             <source>Sequence Analysis: Probabilistic Models of Proteins Acids</source>             <publisher-loc>Cambridge, UK</publisher-loc>             <publisher-name>Cambridge University Press</publisher-name>          </element-citation></ref><ref id="pcbi.1000116-Ratanamahatana1"><label>20</label><element-citation publication-type="other" xlink:type="simple">             <person-group person-group-type="author"><name name-style="western"><surname>Ratanamahatana</surname><given-names>C</given-names></name><name name-style="western"><surname>Keogh</surname><given-names>EJ</given-names></name></person-group>             <year>2005</year>             <article-title>Three myths time warping data mining.</article-title>             <source>Proceedings of SIAM Conference on Data Mining</source>             <publisher-loc>Philadelphia</publisher-loc>             <publisher-name>SIAM</publisher-name>             <fpage>506</fpage>             <lpage>510</lpage>          </element-citation></ref></ref-list></back></article>