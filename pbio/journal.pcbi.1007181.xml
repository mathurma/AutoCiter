<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.1d3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-19-00222</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1007181</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Numerical analysis</subject><subj-group><subject>Interpolation</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Artificial intelligence</subject><subj-group><subject>Machine learning</subject><subj-group><subject>Support vector machines</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Probability theory</subject><subj-group><subject>Random variables</subject><subj-group><subject>Covariance</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Mathematical and statistical techniques</subject><subj-group><subject>Statistical methods</subject><subj-group><subject>Regression analysis</subject><subj-group><subject>Linear regression analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Statistics</subject><subj-group><subject>Statistical methods</subject><subj-group><subject>Regression analysis</subject><subj-group><subject>Linear regression analysis</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Probability theory</subject><subj-group><subject>Statistical distributions</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Artificial intelligence</subject><subj-group><subject>Machine learning</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Geometry</subject><subj-group><subject>Ellipses</subject></subj-group></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Prepaid parameter estimation without likelihoods</article-title>
<alt-title alt-title-type="running-head">Prepaid parameter estimation without likelihoods</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" equal-contrib="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0001-5077-861X</contrib-id>
<name name-style="western">
<surname>Mestdagh</surname> <given-names>Merijn</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Data curation</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"/>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" equal-contrib="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-2199-1072</contrib-id>
<name name-style="western">
<surname>Verdonck</surname> <given-names>Stijn</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Investigation</role>
<role content-type="http://credit.casrai.org/">Methodology</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"/>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-9610-7712</contrib-id>
<name name-style="western">
<surname>Meers</surname> <given-names>Kristof</given-names></name>
<role content-type="http://credit.casrai.org/">Software</role>
<xref ref-type="aff" rid="aff001"/>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-7587-1922</contrib-id>
<name name-style="western">
<surname>Loossens</surname> <given-names>Tim</given-names></name>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<xref ref-type="aff" rid="aff001"/>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-1775-7654</contrib-id>
<name name-style="western">
<surname>Tuerlinckx</surname> <given-names>Francis</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"/>
</contrib>
</contrib-group>
<aff id="aff001">
<addr-line>KU Leuven, University of Leuven, Leuven, Belgium</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Simen</surname> <given-names>Patrick</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>Oberlin College, UNITED STATES</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">merijn.mestdagh@kuleuven.be</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<month>9</month>
<year>2019</year>
</pub-date>
<pub-date pub-type="epub">
<day>9</day>
<month>9</month>
<year>2019</year>
</pub-date>
<volume>15</volume>
<issue>9</issue>
<elocation-id>e1007181</elocation-id>
<history>
<date date-type="received">
<day>7</day>
<month>2</month>
<year>2019</year>
</date>
<date date-type="accepted">
<day>14</day>
<month>6</month>
<year>2019</year>
</date>
</history>
<permissions>
<copyright-year>2019</copyright-year>
<copyright-holder>Mestdagh et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1007181"/>
<abstract>
<p>In various fields, statistical models of interest are analytically intractable and inference is usually performed using a simulation-based method. However elegant these methods are, they are often painstakingly slow and convergence is difficult to assess. As a result, statistical inference is greatly hampered by computational constraints. However, for a given statistical model, different users, even with different data, are likely to perform similar computations. Computations done by one user are potentially useful for other users with different data sets. We propose a pooling of resources across researchers to capitalize on this. More specifically, we preemptively chart out the entire space of possible model outcomes in a prepaid database. Using advanced interpolation techniques, any individual estimation problem can now be solved on the spot. The prepaid method can easily accommodate different priors as well as constraints on the parameters. We created prepaid databases for three challenging models and demonstrate how they can be distributed through an online parameter estimation service. Our method outperforms state-of-the-art estimation techniques in both speed (with a 23,000 to 100,000-fold speed up) and accuracy, and is able to handle previously quasi inestimable models.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author summary</title>
<p>Interesting nonlinear models are often analytically intractable. As a result, statistical inference has to rely on massive, time-intensive, simulations. The main idea of our method is to avoid the redundancy of similar computations that typically occur when different researchers independently fit the same model to their particular dataset. Instead, we propose to pool computational resources across the researchers interested in any given model. The prepaid method starts with an extensive simulation of datasets across the parameter space. The simulated data are compressed into summary statistics, and the relation to the parameters is learned using machine learning techniques. This results in a parameter estimation machine that produces accurate estimates very quickly (a 23,000 to 100,000-fold speed up compared to traditional methods).</p>
</abstract>
<funding-group>
<funding-statement>This research was supported by the Research Fund of KU Leuven (GOA/15/003; OT/11/031) and the Interuniversity Attraction Poles program (IAP/P7/06). Merijn Mestdagh and Stijn Verdonck are supported by the Fund of Scientific Research Flanders. The computational resources and services used in this work were provided by the VSC (Flemish Supercomputer Center), funded by the Research Foundation - Flanders (FWO) and the Flemish Government - department EWI. The funders had no role in study design, data collection and analysis, decision to publish or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="17"/>
<table-count count="9"/>
<page-count count="42"/>
</counts>
<custom-meta-group>
<custom-meta>
<meta-name>PLOS Publication Stage</meta-name>
<meta-value>vor-update-to-uncorrected-proof</meta-value>
</custom-meta>
<custom-meta>
<meta-name>Publication Update</meta-name>
<meta-value>2019-09-19</meta-value>
</custom-meta>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>The data we use is mainly simulated data which can be reproduced by following the methods described in the paper. The real date set we use in the paper can be found at <ext-link ext-link-type="uri" xlink:href="http://www.prepaidestimation.org/" xlink:type="simple">http://www.prepaidestimation.org/</ext-link>. To see the data click on Example data and choose ‘Chillo partellus’.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<disp-quote><p>This is a <italic>PLOS Computational Biology</italic> Methods paper.</p></disp-quote>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Models without an analytical likelihood are increasingly used in various disciplines, such as genetics [<xref ref-type="bibr" rid="pcbi.1007181.ref001">1</xref>], ecology [<xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref003">3</xref>], economics [<xref ref-type="bibr" rid="pcbi.1007181.ref004">4</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref005">5</xref>] and neuroscience [<xref ref-type="bibr" rid="pcbi.1007181.ref006">6</xref>]. For such models, parameter estimation is a major challenge for which a variety of solutions have been proposed [<xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref001">1</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref007">7</xref>]. All these methods have in common that they rely on extensive Monte Carlo simulations and that their convergence can be painstakingly slow. As a result, the current methods can be very time consuming.</p>
<p>To date, the practice is to analyse each data set separately. However, considering all the calculations that have ever been performed during parameter estimation of a particular type of model, for each different data set, one cannot help but notice an incredible waste of resources. Indeed, simulations performed while estimating one data set may also be relevant for the estimation of another. Currently, each researcher estimating the same model with different data will start from scratch, and can not benefit from all the possibly relevant calculations that have already been performed in earlier analyses by other researchers, in other locations, on different hardware, and for other data sets, but concerning the same model.</p>
<p>Hence, we propose an estimation scheme that dramatically increases overall efficiency by avoiding this immense redundancy. Most current algorithms are inherently iterative and (slowly) adjust their window of interest to the area of convergence. Instead, we propose to generate an all-inclusive and one-shot prepaid database that is capable of estimating the parameters of a particular model for all potential data sets and with almost no additional computation time per data set. Our approach starts with the extensive simulation of data sets across the entire parameter space. These data are then compressed into summary statistics, after which the relation between the summary statistics and the parameters can be learned using interpolation techniques. Finally, global optimization methods can be used on the previously created (hence, prepaid) database for accurate and fast parameter estimation on any device. This results in a mass lookup and interpolation scheme that can produce estimates to any given dataset very quickly.</p>
<p>In <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref> we present a graphical illustration of the prepaid parameter estimation method. First (panel A), for a sufficient number of parameter vectors <bold><italic>θ</italic></bold>, large data sets are simulated, compressed into summary statistics (i.e., <bold><italic>s</italic></bold><sup>sim</sup>) and saved—creating the prepaid grid. This prepaid grid is computed beforehand and the results are stored at a central location. Second (panel B1), the observed (data) summary statistics (<bold><italic>s</italic></bold><sup>obs</sup>) are compared to the simulated (data) summary statistics (i.e., <bold><italic>s</italic></bold><sup>sim</sup>) using an appropriate objective loss function <italic>d</italic>(<bold><italic>s</italic></bold><sup>sim</sup>, <bold><italic>s</italic></bold><sup>obs</sup>) and a number of nearest neighbor simulated summary statistics are selected. The loss function is related to the loss function used in the generalized method of moments [<xref ref-type="bibr" rid="pcbi.1007181.ref008">8</xref>] and method of simulated moments [<xref ref-type="bibr" rid="pcbi.1007181.ref009">9</xref>].</p>
<fig id="pcbi.1007181.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Graphical illustration of the prepaid parameter estimation method.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g001" xlink:type="simple"/>
</fig>
<p>Third (panel B2), interpolation methods are used to find the relation <bold><italic>s</italic></bold> = <italic>f</italic>(<bold><italic>θ</italic></bold>) between the parameter values and the summary statistics for the selected points of the previous step [<xref ref-type="bibr" rid="pcbi.1007181.ref010">10</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref011">11</xref>]. In this paper, we use tuned least squares support vector machines, LS-SVM [<xref ref-type="bibr" rid="pcbi.1007181.ref012">12</xref>]. Finally (panel B3), the objective loss function <italic>d</italic>(<bold><italic>s</italic></bold><sup>pred</sup>, <bold><italic>s</italic></bold><sup>obs</sup>), now using predicted summary statistics <bold><italic>s</italic></bold><sup>pred</sup>, is minimized as a function of the unknown parameter values using an optimizer.</p>
<p>A number of important aspects of the prepaid method deserve special mention. First, the parameter space is required to be bounded. If this is unnatural for a given parametrization, then the parameters have to be appropriately transformed to a bounded space. Second, we typically start from a uniform distribution of parameter vectors in the final parameter space. This choice reflects on the uniformity of the grid’s resolution, but has no further implications provided the grid is sufficiently dense. Bayesian priors can be implemented without recreating the prepaid grid, since the prior can be taken into account in the loss function. Third, often a user is not interested in a single instance of a model, but rather has data from several experimental conditions that share some common parameters but assume other ones to be different. Also in these cases the prepaid grid does not need to be recreated, as the parameter constraints can be included through priors with tuning parameters (i.e., penalties). Fourth, the creation of the prepaid database is a fixed cost and usually takes from a couple of hours to one or more days, depending on the complexity of the model of interest (see below for a number of examples). Once its prepaid database is created, the parameters of the model can be estimated for any data set, with any amount of data (number of observations).</p>
<p>The prepaid method can be studied theoretically in simple situations. For example, in Methods, we apply the prepaid idea for estimating the mean of a normal distribution and study some of its properties for two different summary statistics. In what follows, the prepaid method will be applied to three more complicated, realistic scenarios.</p>
</sec>
<sec id="sec002" sec-type="results">
<title>Results</title>
<sec id="sec003">
<title>Example 1: The Ricker model</title>
<p>In a first example, we apply our prepaid method to the Ricker model [<xref ref-type="bibr" rid="pcbi.1007181.ref013">13</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>] which describes the dynamics of the number of individuals <italic>y</italic><sub><italic>t</italic></sub> in a species over time (with <italic>t</italic> = 1 to <italic>T</italic><sub>obs</sub>):
<disp-formula id="pcbi.1007181.e001"><alternatives><graphic id="pcbi.1007181.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e001" xlink:type="simple"/><mml:math display="block" id="M1"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mtext>Pois</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>ϕ</mml:mi> <mml:msub><mml:mi>N</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>N</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>r</mml:mi> <mml:msub><mml:mi>N</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:msup><mml:mo form="prefix">e</mml:mo> <mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>N</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>e</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(1)</label></disp-formula>
where <inline-formula id="pcbi.1007181.e002"><alternatives><graphic id="pcbi.1007181.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e002" xlink:type="simple"/><mml:math display="inline" id="M2"><mml:mrow><mml:msub><mml:mi>e</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. The variables <italic>N</italic><sub><italic>t</italic></sub> (i.e., the expected number of individuals at time <italic>t</italic>) and <italic>e</italic><sub><italic>t</italic></sub> are hidden states. Given an observed time series <inline-formula id="pcbi.1007181.e003"><alternatives><graphic id="pcbi.1007181.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e003" xlink:type="simple"/><mml:math display="inline" id="M3"><mml:msubsup><mml:mrow><mml:mo>{</mml:mo> <mml:msub><mml:mi>y</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>}</mml:mo></mml:mrow> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:msubsup></mml:math></alternatives></inline-formula>, we want to estimate the parameters <bold><italic>θ</italic></bold> = {<italic>r</italic>, <italic>σ</italic>, <italic>ϕ</italic>}, where <italic>r</italic> is the growth rate, <italic>σ</italic> the process noise and <italic>ϕ</italic> a scaling parameter. The Ricker model can demonstrate near-chaotic or chaotic behavior and no explicit likelihood formula is available.</p>
<p>Wood [<xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>] used the synthetic likelihood to estimate the model’s parameters. In the original synthetic likelihood approach (denoted as SL<sup>Orig</sup>), the assumed multivariate normal distribution of the summary statistics is used to create a synthetic likelihood. The mean and covariance matrix of this normal distribution are functions of the unknown parameters and are calculated using a large number of model simulations. The synthetic likelihood is proportional to the posterior distribution from which is sampled using MCMC and a posterior mean is computed.</p>
<p>Wood’s synthetic likelihood SL<sup>Orig</sup> approach is compared to the prepaid method, where we create a prepaid grid of the mean and the covariance matrix of a similar set of summary statistics. Prepaid estimation comes in multiple variants, depending on the use of an interpolation method. The first, which uses only the prepaid grid points and chooses the nearest neighbor (maximum synthetic likelihood) as final estimate, will be called <inline-formula id="pcbi.1007181.e004"><alternatives><graphic id="pcbi.1007181.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>. The second, <inline-formula id="pcbi.1007181.e005"><alternatives><graphic id="pcbi.1007181.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e005" xlink:type="simple"/><mml:math display="inline" id="M5"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, uses LS-SVM to interpolate between the parameters in the prepaid grid to increase accuracy. The differential evolution algorithm (a global optimizer; [<xref ref-type="bibr" rid="pcbi.1007181.ref014">14</xref>]) is used to maximize this interpolated synthetic (log)likelihood. Additional details on the implementation of the synthetic likelihood can also be found in Methods.</p>
<p>
<xref ref-type="fig" rid="pcbi.1007181.g002">Fig 2</xref> shows both the accuracy of parameter recovery (as measured with the RMSE) and computation time for the three methods under comparison: (1) SL<sup>Orig</sup> as in [<xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>], the prepaid method (2) with interpolation (<inline-formula id="pcbi.1007181.e006"><alternatives><graphic id="pcbi.1007181.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e006" xlink:type="simple"/><mml:math display="inline" id="M6"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>), and (3) without (<inline-formula id="pcbi.1007181.e007"><alternatives><graphic id="pcbi.1007181.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e007" xlink:type="simple"/><mml:math display="inline" id="M7"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>) interpolation. As can be seen in <xref ref-type="fig" rid="pcbi.1007181.g002">Fig 2</xref>, the prepaid estimation techniques lead to better results than the synthetic likelihood for <italic>T</italic><sub>obs</sub> = 1, 000, both in accuracy and speed. The SL<sup>Orig</sup> method leads to some clear outliers (see <xref ref-type="sec" rid="sec007">Methods</xref>) which testifies to possible convergence problems (probably due to local minima). The prepaid method suffers much less from this problem. Most striking is the speed up of the prepaid method: The <inline-formula id="pcbi.1007181.e008"><alternatives><graphic id="pcbi.1007181.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e008" xlink:type="simple"/><mml:math display="inline" id="M8"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> version of the prepaid estimation is finished before a single iteration of the 30,000 iterations in the synthetic likelihood method has been completed—100,000 times faster. In addition, it is demonstrated that the coverages of the prepaid method confidence intervals are very close or exactly equal to the nominal value (we look at 95% bootstrap-based confidence intervals). SVM interpolation is mainly helpful for large <italic>T</italic><sub>obs</sub>, where one expects a higher accuracy of the estimates and the grid is too coarse. The analyses with large <italic>T</italic><sub>obs</sub> could only be completed in a reasonable time using the prepaid method (See <xref ref-type="sec" rid="sec007">Methods</xref> for more detailed information).</p>
<fig id="pcbi.1007181.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g002</object-id>
<label>Fig 2</label>
<caption>
<title>The RMSE versus the time needed for the estimation of the three parameters of the Ricker model (see <xref ref-type="disp-formula" rid="pcbi.1007181.e001">Eq 1</xref>).</title>
<p>The RMSE and time are based on 100 test data sets with <italic>T</italic><sub>obs</sub> = 1000. The three colors represent the three parameters (blue for <italic>r</italic>, red for <italic>σ</italic> and yellow for <italic>ϕ</italic>). Solid lines represent the SL<sup>Orig</sup> approach, dashed lines the <inline-formula id="pcbi.1007181.e009"><alternatives><graphic id="pcbi.1007181.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e009" xlink:type="simple"/><mml:math display="inline" id="M9"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach (using only nearest neighbors), and dotted lines the <inline-formula id="pcbi.1007181.e010"><alternatives><graphic id="pcbi.1007181.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach (using interpolation). The stars and the dots represent the time needed for the <inline-formula id="pcbi.1007181.e011"><alternatives><graphic id="pcbi.1007181.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and the <inline-formula id="pcbi.1007181.e012"><alternatives><graphic id="pcbi.1007181.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e012" xlink:type="simple"/><mml:math display="inline" id="M12"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> estimation, respectively. The estimates for SL<sup>Orig</sup> are posterior means, based on the second half of the finished MCMC iterations. The time of the prepaid method shown in this picture does not include the creation of the prepaid grid, but only the time needed for any researcher to estimate the parameters once a prepaid grid is available.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g002" xlink:type="simple"/>
</fig>
<p>In the application above, the tacitly assumed prior on the parameter space is uniform. In addition, there is only one data set for which a single triplet of parameters (<italic>r</italic>, <italic>σ</italic>, <italic>ϕ</italic>) needs to be estimated. In Methods, we show how both limitations can be relaxed. First, it is explained how different priors for the Ricker model can be implemented. Second, it is discussed what can be done if there are two data sets (i.e., conditions) for which it holds that <italic>r</italic><sub>1</sub> = <italic>r</italic><sub>2</sub> and <italic>σ</italic><sub>1</sub> = <italic>σ</italic><sub>2</sub> but <italic>ϕ</italic><sub>1</sub> and <italic>ϕ</italic><sub>2</sub> are not related.</p>
<p>Finally, we also tested our estimation process on the population dynamics of the Chilo partellus, extracted from Fig 1 in Taneja and Leuschner [<xref ref-type="bibr" rid="pcbi.1007181.ref015">15</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref016">16</xref>]. Here we found that <italic>r</italic> = 1.10 (95% confidence interval 1.06–1.34), <italic>σ</italic> = 0.43 (95% confidence interval 0.30–0.54) and <italic>ϕ</italic> = 140.60 (95% confidence interval = 43.94–208.19). We found similar results using the synthetic likelihood method (see <xref ref-type="sec" rid="sec007">Methods</xref>), but our estimation was 4000 times faster.</p>
</sec>
<sec id="sec004">
<title>Example 2: A stochastic model of community dynamics</title>
<p>A second example we use to illustrate the prepaid inference method is a trait model of community dynamics [<xref ref-type="bibr" rid="pcbi.1007181.ref017">17</xref>] used to model the dispersion of species. For this model (see also <xref ref-type="sec" rid="sec007">Methods</xref> section), there are four parameters to be estimated: <italic>I</italic>, <italic>A</italic>, <italic>h</italic>, and <italic>σ</italic>. As with the first application, there is no analytical expression for the likelihood [<xref ref-type="bibr" rid="pcbi.1007181.ref017">17</xref>].</p>
<p>As an established benchmark procedure for this trait model, we apply the widely used Approximate Bayesian Computation (ABC) method [<xref ref-type="bibr" rid="pcbi.1007181.ref018">18</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref019">19</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref020">20</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref021">21</xref>] as implemented in the Easy ABC package and denoted here as <inline-formula id="pcbi.1007181.e013"><alternatives><graphic id="pcbi.1007181.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e013" xlink:type="simple"/><mml:math display="inline" id="M13"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Orig</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> (PM stands for posterior means, which will be used as point estimates) [<xref ref-type="bibr" rid="pcbi.1007181.ref022">22</xref>]. As priors, we use uniform distributions on bounded intervals for log(<italic>I</italic>), log(<italic>A</italic>), <italic>h</italic> and log(<italic>σ</italic>) (see <xref ref-type="sec" rid="sec007">Methods</xref> for the exact specifications), but this can be easily changed as explained for the first example.</p>
<p>To allow for a direct comparison with the ABC method (<inline-formula id="pcbi.1007181.e014"><alternatives><graphic id="pcbi.1007181.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e014" xlink:type="simple"/><mml:math display="inline" id="M14"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Orig</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>), and to illustrate the versatility of the prepaid method, we have also implemented three Bayesian versions of the prepaid method. The first, <inline-formula id="pcbi.1007181.e015"><alternatives><graphic id="pcbi.1007181.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e015" xlink:type="simple"/><mml:math display="inline" id="M15"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, creates a posterior proportional to the prepaid synthetic likelihood. The second method, <inline-formula id="pcbi.1007181.e016"><alternatives><graphic id="pcbi.1007181.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e016" xlink:type="simple"/><mml:math display="inline" id="M16"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, saves not only the mean and covariance matrix of the summary statistics for every parameter in the prepaid grid, but also a large set of uncompressed summary statistics. Using these statistics we are able to approximate an ABC approach. The third, <inline-formula id="pcbi.1007181.e017"><alternatives><graphic id="pcbi.1007181.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e017" xlink:type="simple"/><mml:math display="inline" id="M17"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, again interpolates between the grid points to achieve a higher accuracy.</p>
<p>All methods result in accuracies of the same order of magnitude as can be seen in <xref ref-type="table" rid="pcbi.1007181.t001">Table 1</xref>. The main difference is again the speed of the methods: <inline-formula id="pcbi.1007181.e026"><alternatives><graphic id="pcbi.1007181.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e026" xlink:type="simple"/><mml:math display="inline" id="M26"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> is about 23,000 times faster than traditional ABC. For small sample sizes, all ABC based methods achieve good coverage. However, for large sample sizes, <inline-formula id="pcbi.1007181.e027"><alternatives><graphic id="pcbi.1007181.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e027" xlink:type="simple"/><mml:math display="inline" id="M27"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Orig</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> cannot be used anymore (because of the unduly long computation time). For the prepaid versions and large samples, it is necessary to use SVM interpolation between the grid points to get accurate results.</p>
<table-wrap id="pcbi.1007181.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t001</object-id>
<label>Table 1</label>
<caption>
<title>The RMSE of the estimates of the test set of the trait model.</title>
<p><italic>T</italic><sub>obs</sub> refers to the number of observations (i.e., vector with species frequencies) and Ω is the number of prepaid points.</p>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t001g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t001" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="center"><italic>T</italic><sub>obs</sub></th>
<th align="left">version</th>
<th align="left">Ω</th>
<th align="right">log(<italic>I</italic>)</th>
<th align="right">log(<italic>A</italic>)</th>
<th align="right"><italic>h</italic></th>
<th align="right">log(<italic>σ</italic>)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e018">
<alternatives>
<graphic id="pcbi.1007181.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e018" xlink:type="simple"/>
<mml:math display="inline" id="M18">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Orig</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">/</td>
<td align="char" char=".">0.17</td>
<td align="char" char=".">0.67</td>
<td align="char" char=".">7.45</td>
<td align="char" char=".">0.74</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e019">
<alternatives>
<graphic id="pcbi.1007181.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e019" xlink:type="simple"/>
<mml:math display="inline" id="M19">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.17</td>
<td align="char" char=".">0.66</td>
<td align="char" char=".">7.49</td>
<td align="char" char=".">0.7</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e020">
<alternatives>
<graphic id="pcbi.1007181.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e020" xlink:type="simple"/>
<mml:math display="inline" id="M20">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.16</td>
<td align="char" char=".">0.63</td>
<td align="char" char=".">7.9</td>
<td align="char" char=".">0.7</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e021">
<alternatives>
<graphic id="pcbi.1007181.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e021" xlink:type="simple"/>
<mml:math display="inline" id="M21">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.16</td>
<td align="char" char=".">0.62</td>
<td align="char" char=".">8.17</td>
<td align="char" char=".">0.7</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e022">
<alternatives>
<graphic id="pcbi.1007181.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e022" xlink:type="simple"/>
<mml:math display="inline" id="M22">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.07</td>
<td align="char" char=".">0.35</td>
<td align="char" char=".">6.41</td>
<td align="char" char=".">0.61</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e023">
<alternatives>
<graphic id="pcbi.1007181.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e023" xlink:type="simple"/>
<mml:math display="inline" id="M23">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.05</td>
<td align="char" char=".">0.27</td>
<td align="char" char=".">4.83</td>
<td align="char" char=".">0.48</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e024">
<alternatives>
<graphic id="pcbi.1007181.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e024" xlink:type="simple"/>
<mml:math display="inline" id="M24">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.03</td>
<td align="char" char=".">0.23</td>
<td align="char" char=".">5.24</td>
<td align="char" char=".">0.42</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e025">
<alternatives>
<graphic id="pcbi.1007181.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e025" xlink:type="simple"/>
<mml:math display="inline" id="M25">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.03</td>
<td align="char" char=".">0.21</td>
<td align="char" char=".">4.39</td>
<td align="char" char=".">0.4</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec005">
<title>Example 3: The Leaky Competing Accumulator for choice response times</title>
<p>In a third example, we apply our method to stochastic accumulation models for elementary decision making. In this paradigm, a person has to choose, as quickly and accurately as possible, the correct response given a stimulus (e.g., is a collection of points moving to the left or to the right). Task difficulty is manipulated by applying different levels of stimulus ambiguity.</p>
<p>A popular neurally inspired model of decision making is the Leaky Competing Accumulator (LCA [<xref ref-type="bibr" rid="pcbi.1007181.ref023">23</xref>]). For two response options, two noisy evidence accumulators (stochastic differential equations, see <xref ref-type="sec" rid="sec007">Methods</xref> section) race each other until one of them reaches the required amount of evidence for the corresponding option to be chosen. The time that is required to reach that option’s threshold is interpreted as the associated choice response time. For different levels of stimulus difficulty, the model produces different levels of accuracy and choice response time distributions. The evidence accumulation process leading up to these choices and response times is assumed to be indicative of the activation levels of neural populations involved in the decision making.</p>
<p>As in the first two examples, there is no analytical likelihood available that can be used to estimate the parameters of the LCA. Moreover, the LCA is an extremely difficult model to estimate. To the best of our knowledge, only [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>] systematically investigated the recovery of the LCA parameters, but for a slightly different model (with three choice options) and with a method that is impractically slow for very large sample sizes, making it difficult to show near-asymptotic recovery properties with.</p>
<p>For an experiment with four stimulus difficulty levels, the LCA model has nine parameters. However, after a reparametrization of the model (but without a reduction in complexity), it is possible to reduce the prepaid space to four dimensions (see <xref ref-type="sec" rid="sec007">Methods</xref>) and conditionally estimate the remaining subset of the parameters with a less computationally intensive method. Three variants of the prepaid method have been implemented: taking the nearest neighboring parameter set (based on a symmetrized <italic>χ</italic><sup>2</sup> distance between distributions) on the prepaid grid (<inline-formula id="pcbi.1007181.e031"><alternatives><graphic id="pcbi.1007181.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e031" xlink:type="simple"/><mml:math display="inline" id="M31"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>NN</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>), averaging over the grids nearest neighboring parameter sets of 100 non-parametric bootstrap samples (<inline-formula id="pcbi.1007181.e032"><alternatives><graphic id="pcbi.1007181.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e032" xlink:type="simple"/><mml:math display="inline" id="M32"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>), using SVM interpolation for every bootstrap estimate (<inline-formula id="pcbi.1007181.e033"><alternatives><graphic id="pcbi.1007181.e033g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e033" xlink:type="simple"/><mml:math display="inline" id="M33"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>). A nearest neighbor or bootstrap averaged estimate completes in about a second on a Dell Precision T3600 (4 cores at 3.60GHz), an SVM interpolated estimate requires a couple of minutes extra.</p>
<p>
<xref ref-type="fig" rid="pcbi.1007181.g003">Fig 3</xref> displays the mean absolute error (MAE) of the estimates for four of the nine parameters as a function of sample size, separately for three estimation methods. The results for the other parameters are similar and can be consulted in the Methods section. It can be seen that with increasing sample size, MAE decreases. The SVM method pays off especially for larger samples. <xref ref-type="fig" rid="pcbi.1007181.g004">Fig 4</xref> shows detailed recovery scatter plots for a subset of the parameters for 1,200 observed trials, which is the typical size of decision experiments. To get better recovery, larger sample sizes have to be considered (see <xref ref-type="sec" rid="sec007">Methods</xref> section). In general, recovery is much better than what has been reported in [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>]. The coverage of the method, based on non-parametric bootstrapping, is satisfactory for all sample sizes, provided SVM interpolated estimates are used for <italic>T</italic><sub>obs</sub> &gt; 100000. In addition, we do not find evidence for a fundamental identification issue with the two option LCA, as has been stated in [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>].</p>
<fig id="pcbi.1007181.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g003</object-id>
<label>Fig 3</label>
<caption>
<title/>
<p>The mean absolute error of the estimates of four central parameters of the LCA (common input <italic>v</italic>, leakage <italic>γ</italic>, mutual inhibition <italic>κ</italic>, evidence threshold <italic>a</italic>) as a function of sample size (abscissa) and for three different methods: (1) choosing the nearest neighbor grid point in the space of summary statistics (<inline-formula id="pcbi.1007181.e028"><alternatives><graphic id="pcbi.1007181.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e028" xlink:type="simple"/><mml:math display="inline" id="M28"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>NN</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, triangles); (2) using the average of a set of nearest neighbor grid points based on bootstrap samples (<inline-formula id="pcbi.1007181.e029"><alternatives><graphic id="pcbi.1007181.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e029" xlink:type="simple"/><mml:math display="inline" id="M29"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, open circles) and (3) using SVM interpolation between the 100 nearest neighbors (<inline-formula id="pcbi.1007181.e030"><alternatives><graphic id="pcbi.1007181.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e030" xlink:type="simple"/><mml:math display="inline" id="M30"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, crosses).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g003" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007181.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Parameter recovery for the LCA model with 1200 observations (300 in each of the four difficulty conditions); the true value on the abscissa and estimated value on the ordinate.</title>
<p>The same parameters as in <xref ref-type="fig" rid="pcbi.1007181.g003">Fig 3</xref> are shown. The method used to produce these estimates is the averaged bootstrap approach (<inline-formula id="pcbi.1007181.e034"><alternatives><graphic id="pcbi.1007181.e034g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e034" xlink:type="simple"/><mml:math display="inline" id="M34"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, see <xref ref-type="sec" rid="sec007">Methods</xref> for details).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g004" xlink:type="simple"/>
</fig>
</sec>
</sec>
<sec id="sec006" sec-type="conclusions">
<title>Discussion</title>
<p>In three examples, we have demonstrated the efficacy and versatility of the prepaid method. The prepaid method is at least as accurate as current methods, but many times faster (23,000 to 100,000-fold speed up). Besides the improvements at the level of speed and accuracy, the prepaid method has a number of other distinct advantages. First, the prepaid method can be used for a very large number of observations, contrary to the synthetic likelihood or ABC methods. The use of very large simulated data sets allows a practical investigation of large-sample properties of the estimator, which is a problem for the synthetic likelihood and ABC. Second, because of the enormous speed improvement and having data sets available across the whole parameter space, the prepaid method allows for fast yet extensive testing of recovery of simulated data across this space—the recovery of every single parameter set can be evaluated. Such a practice leads to detailed internal quality control of the used estimation algorithm.</p>
<p>Although the idea behind the prepaid method is fairly simple, we want to anticipate a few misconceptions that might arise. First, as has been demonstrated in the context of the Ricker model (the first example), the prepaid method can easily deal with different priors and with equality constraints on parameters, without the need to recreate the underlying prepaid grid. Second, the observed data based on which the model parameters have to be estimated can be of any size, again without the need to recreate the prepaid grid for each and every sample size.</p>
<p>In the first two examples the synthetic likelihood [<xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>] is used, but its exact effect on likelihood based model selection techniques, such as information criteria, is not known. For users interested in model selection, we propose cross-validation as its implementation is straight forward. The main draw-back of this resampling method, its computational burden, is mitigated by the use of the prepaid method.</p>
<p>Ideally, the prepaid databases and the corresponding estimation algorithms will be constructed and made available by a team of experts for the model at hand. Subsequently, a cloud based service can be set up to offer high quality model estimations to a broad public of researchers. As an example, we created such a service for the Ricker model in <xref ref-type="disp-formula" rid="pcbi.1007181.e001">Eq 1</xref>: <ext-link ext-link-type="uri" xlink:href="http://www.prepaidestimation.org/" xlink:type="simple">http://www.prepaidestimation.org/</ext-link>, where we allow the user to estimate the parameters of the Ricker model for personal data as well as 4 example data sets including one real life data set [<xref ref-type="bibr" rid="pcbi.1007181.ref015">15</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref016">16</xref>]. By using such a cloud based service, researchers that need their data analyzed with computationally challenging models, can avoid many of the pitfalls they would otherwise encounter venturing out on their own. This practice will also lead to increased reproducibility of computational results.</p>
<p>As the need for reproducibility and transparency is (fortunately) increasingly recognized by the broader scientific community, critical model users will want to see proof of robust estimation across the entire parameter space, and be able to test this themselves. The current standard of simply sharing the code of a procedure, still grants developers of complex models/methods a layer of protection from public scrutiny, because the level of knowledge and infrastructure required to check the work is considerable and not many are called to take up the challenge. The prepaid method, however, allows any user with a basic grasp of statistics to check the consistency of the model and method, using data they have simulated themselves. In the future, we expect a natural evolution towards a situation where stakeholders in certain models (the developers and/or heavy users) will provide an estimation service or outsource this endeavor to a third party. The infrastructure required for hosting such a service is orders of magnitude lighter than what is required for the calculation of the database itself or a thorough simulation study for that matter. We are currently hosting the Ricker model on a very modest system (medium level desktop).</p>
<p>A first possible objection to the prepaid method is the considerable initial simulation cost (for the examples discussed, prepaid simulations took up to a couple of days on a 20-core processor). However, this overhead cost will dissipate entirely as increasingly more estimates are sourced from the same prepaid database. Moreover, the initial prepaid cost can be easily distributed across multiple interested parties. Further, because the database can be used for internal quality control, additional simulation studies investigating the recovery of parameters are made redundant. Indeed, whenever a new model and associated parameter estimation method are proposed, a recovery study is needed to study how well the parameters of the model can be estimated using the method. When such a simulation study is set up in a rigorous way, the prepaid grid will have been (partially or completely) constructed. For the first and the second example, the time to create the prepaid grid was of the same order as that of the parameter recovery study included for the estimation techniques the prepaid grid was compared with. Note however that the parameter recovery study of the traditional techniques was only partial, as data sets with more observations, for which the parameter estimation would take an excessively long time using only traditional methods, were excluded. If those would be included, a parameter recovery study would be at least 10 times slower than the creation of the prepaid grid. The fact that a parameter recovery study takes at least as much time as the creation of the prepaid grid makes sense. A recovery study should test the estimation of parameters in the whole realm of possible data sets. The prepaid grid exactly covers this realm.</p>
<p>The argumentation above shows that a parameter recovery study and a prepaid grid are very related. In fact, Jabot, saw the necessity of reusing ABC simulations to reduce computation time in his recovery study for the model of the second example [<xref ref-type="bibr" rid="pcbi.1007181.ref017">17</xref>]. More broadly, we are convinced that other researchers also have used similar tricks to avoid redundant simulation within their own research context. For example, a reviewer of this manuscript noted that s/he uses a prepaid grid (although not named so) when trying models in which the parameters change across trials. The main difference with prepaid estimation is that we propose to reuse these simulations to facilitate future estimations.</p>
<p>A second possible objection is that the prepaid grid, unsurprisingly, does not escape the curse of dimensionality: The grid size grows exponentially with the number of parameters. The prepaid method is most effective for highly nonlinear models with substantively meaningful parameters, as they appear in various computational modeling fields. For these models, all simulation based estimation techniques struggle with the curse of dimensionality. For the prepaid method, this limitation can be alleviated in a number of ways. First, the use of interpolation techniques allows for a substantial reduction of the number of prepaid points (by a factor of five for the same accuracy in the trait model example; see <xref ref-type="sec" rid="sec007">Methods</xref> section). Second, as is shown in the LCA example, it is possible to only partially apply the prepaid method and combine it with traditional estimation techniques. In this way, the less challenging parameters can be estimated conditionally on a prepaid grid of the more intricately connected ones. Third, as shown by tackling three challenging examples, current storage and/or memory technology can accommodate realistically sized prepaid databases.</p>
<p>A last possible objection is the risk, that once the prepaid grid is created for a certain model, researchers will be biased towards using this particular model. They may prefer the relatively easy prepaid estimation of this model over the use of other models without a prepaid grid. We hope however that also the creation of the prepaid grid is manageable enough for any model to prevent such scenarios.</p>
<p>A possible improvement of the prepaid method lies in a smarter construction of the prepaid grid. First, there is a straightforward theoretical angle: spreading the grid points out according to Jeffrey’s prior rather than a naïve parameter based prior, would lead to a more evenly distributed estimation accuracy, and therefore a smaller database size will suffice for a given minimum accuracy. Additionally, the database could be improved based on the actual queries of users. If the simulation grid proves a bit thin around the requested area (not a lot of unique grid points), more grid points can be added there. This way more detail is added where it matters.</p>
<p>Finally, the prepaid method also offers exciting opportunities for future research. First, another typical case where the same model has to be estimated multiple times, arises in a multilevel context (where several individual analyses are regularized by a set of hyperparameters defined on the group). Although extremely useful, multilevel analyses typically come with an additional computational burden. Because the synthetic likelihood, as any likelihood, can be extended to a multilevel context, the prepaid method should be too. Further research is needed to develop this idea.</p>
<p>Second, the prepaid philosophy can also be used to choose a good set of summary statistics, which are necessary for simulation based estimation techniques. During the creation of the prepaid grid many summary statistics can be saved, with no additional simulation cost. The effectiveness of combinations of summary statistics are then easily tested in parameter recovery studies as the prepaid estimation is so quick.</p>
<p>It is our strong belief that this method will massively democratize the use of many computationally expensive models, which are now reserved for people with access to specific high-end hardware (e.g., GPUs, HPC). Apart from such democratization, this approach could significantly impact the current work flow of scientific modeling, in which every part of the estimation is carried out locally by an individual researcher.</p>
</sec>
<sec id="sec007" sec-type="materials|methods">
<title>Methods</title>
<sec id="sec008">
<title>A toy example: Estimating the mean of a normal</title>
<p>For a very simple setting, we want to study the performance of the prepaid methods analytically.</p>
<p>Assume <italic>y</italic><sub><italic>i</italic></sub> ∼ <italic>N</italic>(<italic>μ</italic>, <italic>s</italic><sup>2</sup>) (<italic>i</italic> = 1, …, <italic>T</italic><sub>obs</sub>) with the mean <italic>μ</italic> unknown (and to be estimated and the standard deviation <italic>s</italic> known (so number of parameters <italic>K</italic> = 1). The observed mean is denoted as <inline-formula id="pcbi.1007181.e035"><alternatives><graphic id="pcbi.1007181.e035g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e035" xlink:type="simple"/><mml:math display="inline" id="M35"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. We will explore two situations. In the first situation, <inline-formula id="pcbi.1007181.e036"><alternatives><graphic id="pcbi.1007181.e036g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e036" xlink:type="simple"/><mml:math display="inline" id="M36"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> will be our summary statistic <italic>s</italic><sup>obs</sup> (hence number of summary statistics <italic>R</italic> = 1) to estimate <italic>μ</italic> (<inline-formula id="pcbi.1007181.e037"><alternatives><graphic id="pcbi.1007181.e037g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e037" xlink:type="simple"/><mml:math display="inline" id="M37"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> is also a sufficient statistic for <italic>μ</italic>). In the second situation, we will study what happens if <inline-formula id="pcbi.1007181.e038"><alternatives><graphic id="pcbi.1007181.e038g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e038" xlink:type="simple"/><mml:math display="inline" id="M38"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> is chosen to be the summary statistic.</p>
<sec id="sec009">
<title>Situation 1: <inline-formula id="pcbi.1007181.e039"><alternatives><graphic id="pcbi.1007181.e039g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e039" xlink:type="simple"/><mml:math display="inline" id="M39"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula></title>
<p>As a prepaid grid, we take <italic>N</italic><sub><italic>r</italic></sub> evenly spaced <italic>μ</italic>-values with spacing or gap size Δ = <italic>μ</italic><sub><italic>j</italic>+1</sub> − <italic>μ</italic><sub><italic>j</italic></sub> (see <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref>, left figure of panel A; in our case the parameter space is one dimensional). For each value <italic>μ</italic><sub><italic>j</italic></sub>, <italic>T</italic><sub>sim</sub> values of <italic>y</italic> are simulated and the sample average is computed (i.e., <inline-formula id="pcbi.1007181.e040"><alternatives><graphic id="pcbi.1007181.e040g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e040" xlink:type="simple"/><mml:math display="inline" id="M40"><mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>j</mml:mi> <mml:mtext>sim</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>) (see middle figure of panel A in <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref>). Typically, <italic>T</italic><sub>sim</sub> = 1000 or larger. Hence, every value of <italic>μ</italic><sub><italic>j</italic></sub> is paired with a particular <inline-formula id="pcbi.1007181.e041"><alternatives><graphic id="pcbi.1007181.e041g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e041" xlink:type="simple"/><mml:math display="inline" id="M41"><mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>j</mml:mi> <mml:mtext>sim</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>: <inline-formula id="pcbi.1007181.e042"><alternatives><graphic id="pcbi.1007181.e042g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e042" xlink:type="simple"/><mml:math display="inline" id="M42"><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>j</mml:mi> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>.</p>
<p>Given an observed <inline-formula id="pcbi.1007181.e043"><alternatives><graphic id="pcbi.1007181.e043g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e043" xlink:type="simple"/><mml:math display="inline" id="M43"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, the <italic>N</italic> nearest neighbors of simulated statistics <inline-formula id="pcbi.1007181.e044"><alternatives><graphic id="pcbi.1007181.e044g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e044" xlink:type="simple"/><mml:math display="inline" id="M44"><mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>j</mml:mi> <mml:mtext>sim</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> are selected: <inline-formula id="pcbi.1007181.e045"><alternatives><graphic id="pcbi.1007181.e045g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e045" xlink:type="simple"/><mml:math display="inline" id="M45"><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1007181.e046"><alternatives><graphic id="pcbi.1007181.e046g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e046" xlink:type="simple"/><mml:math display="inline" id="M46"><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> (see panel B1 of <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref>), such that <inline-formula id="pcbi.1007181.e047"><alternatives><graphic id="pcbi.1007181.e047g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e047" xlink:type="simple"/><mml:math display="inline" id="M47"><mml:mrow><mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>|</mml:mo> <mml:mo>≤</mml:mo> <mml:mo>|</mml:mo></mml:mrow> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>|</mml:mo> <mml:mo>≤</mml:mo> <mml:mo>⋯</mml:mo> <mml:mo>≤</mml:mo> <mml:mo>|</mml:mo></mml:mrow> <mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mrow><mml:mo>|</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. Typically, <italic>N</italic> = 100. In principle, the selected <italic>μ</italic>s depend on <inline-formula id="pcbi.1007181.e048"><alternatives><graphic id="pcbi.1007181.e048g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e048" xlink:type="simple"/><mml:math display="inline" id="M48"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, but for simplicity we suppress this dependence in the notation.</p>
<p>Because of the linearity of the problem, we can safely assume that if <italic>T</italic><sub>sim</sub> is large enough, the <italic>N</italic> selected <italic>μ</italic> values are all consecutive or nearly consecutive (because of noise in the prepaid simulation of <inline-formula id="pcbi.1007181.e049"><alternatives><graphic id="pcbi.1007181.e049g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e049" xlink:type="simple"/><mml:math display="inline" id="M49"><mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mtext>sim</mml:mtext></mml:msup></mml:math></alternatives></inline-formula>, it can happen that the <italic>N</italic> selected <italic>μ</italic> values are not consecutive). We denote the average of these <italic>N</italic> <italic>μ</italic>-values as <italic>M</italic><sub><italic>μ</italic></sub>. Ordering all values from smallest to largest (denoting the <italic>j</italic>th value as <italic>μ</italic><sub>[<italic>j</italic>]</sub> and assuming they are exactly consecutive, <italic>M</italic><sub><italic>μ</italic></sub> can be expressed as):
<disp-formula id="pcbi.1007181.e050"><alternatives><graphic id="pcbi.1007181.e050g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e050" xlink:type="simple"/><mml:math display="block" id="M50"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="left"><mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>N</mml:mi></mml:munderover> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>[</mml:mo> <mml:mi>j</mml:mi> <mml:mo>]</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo>]</mml:mo></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mi>j</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>Δ</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo>]</mml:mo></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mfrac><mml:mo>Δ</mml:mo> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="0.166667em"/><mml:mi>j</mml:mi></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo>]</mml:mo></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mo>Δ</mml:mo> <mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where we have defined <italic>μ</italic><sub>[1]</sub> as
<disp-formula id="pcbi.1007181.e051"><alternatives><graphic id="pcbi.1007181.e051g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e051" xlink:type="simple"/><mml:math display="block" id="M51"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo>]</mml:mo></mml:mrow></mml:msub> <mml:mo>≡</mml:mo> <mml:munder><mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mrow><mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn> <mml:mo>,</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>,</mml:mo> <mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:munder> <mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>[</mml:mo> <mml:mi>i</mml:mi> <mml:mo>]</mml:mo></mml:mrow></mml:msub> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>In addition (assuming that all values are exactly consecutive), their variance <italic>V</italic><sub><italic>μ</italic></sub> is given by
<disp-formula id="pcbi.1007181.e052"><alternatives><graphic id="pcbi.1007181.e052g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e052" xlink:type="simple"/><mml:math display="block" id="M52"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:msubsup><mml:mi>V</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>N</mml:mi></mml:mfrac> <mml:mo>(</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>N</mml:mi></mml:munderover> <mml:mspace width="0.166667em"/><mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>j</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="0.166667em"/><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:mi>j</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>Δ</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:mrow><mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>+</mml:mo> <mml:mn>2</mml:mn> <mml:mi>j</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>Δ</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msup><mml:mi>j</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>2</mml:mn> <mml:mspace width="0.166667em"/><mml:mo>Δ</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msub></mml:mrow> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="0.166667em"/><mml:mi>j</mml:mi> <mml:mo>)</mml:mo> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mi>N</mml:mi></mml:mfrac> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:munderover> <mml:mspace width="0.166667em"/><mml:msup><mml:mi>j</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>μ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msub> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>6</mml:mn></mml:mfrac> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>6</mml:mn></mml:mfrac> <mml:mo>-</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mn>4</mml:mn></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>N</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mn>12</mml:mn></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mfrac><mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:mspace width="0.166667em"/><mml:msup><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mn>12</mml:mn></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>Hence, their standard deviation is <inline-formula id="pcbi.1007181.e053"><alternatives><graphic id="pcbi.1007181.e053g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e053" xlink:type="simple"/><mml:math display="inline" id="M53"><mml:mrow><mml:msub><mml:mi>S</mml:mi> <mml:mi>μ</mml:mi></mml:msub> <mml:mo>≈</mml:mo> <mml:mfrac><mml:mrow><mml:mo>Δ</mml:mo> <mml:mi>N</mml:mi></mml:mrow> <mml:mrow><mml:mn>2</mml:mn> <mml:msqrt><mml:mn>3</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> and thus independent of <inline-formula id="pcbi.1007181.e054"><alternatives><graphic id="pcbi.1007181.e054g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e054" xlink:type="simple"/><mml:math display="inline" id="M54"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>.</p>
<p>Using the <italic>N</italic> nearest neighbour pairs, we assume as a linear interpolator (see panel B2 of <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref>) in this example a linear regression model that links the simulated statistics to the true underlying <italic>μ</italic>: <inline-formula id="pcbi.1007181.e055"><alternatives><graphic id="pcbi.1007181.e055g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e055" xlink:type="simple"/><mml:math display="inline" id="M55"><mml:mrow><mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>j</mml:mi> <mml:mtext>sim</mml:mtext></mml:msubsup> <mml:mo>=</mml:mo> <mml:msub><mml:mi>β</mml:mi> <mml:mn>0</mml:mn></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>β</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:msub><mml:mi>μ</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>ϵ</mml:mi> <mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>, with <inline-formula id="pcbi.1007181.e056"><alternatives><graphic id="pcbi.1007181.e056g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e056" xlink:type="simple"/><mml:math display="inline" id="M56"><mml:mrow><mml:msub><mml:mi>ϵ</mml:mi> <mml:mi>j</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:mi>N</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Obviously, <italic>β</italic><sub>0</sub> = 0 and <italic>β</italic><sub>1</sub> = 1.</p>
<p>Given <inline-formula id="pcbi.1007181.e057"><alternatives><graphic id="pcbi.1007181.e057g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e057" xlink:type="simple"/><mml:math display="inline" id="M57"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula>, <italic>N</italic> selected prepaid points and the fitted linear regression model, we know from linear regression theory that:
<disp-formula id="pcbi.1007181.e058"><alternatives><graphic id="pcbi.1007181.e058g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e058" xlink:type="simple"/><mml:math display="block" id="M58"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>(</mml:mo> <mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:mtd></mml:mtr></mml:mtable> <mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>∼</mml:mo> <mml:msub><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>(</mml:mo> <mml:mo>(</mml:mo> <mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo> <mml:mo>(</mml:mo> <mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>0</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mtd> <mml:mtd><mml:msub><mml:mi>σ</mml:mi> <mml:mn>01</mml:mn></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mi>σ</mml:mi> <mml:mn>01</mml:mn></mml:msub></mml:mtd> <mml:mtd><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mtd></mml:mtr></mml:mtable> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where 0 and 1 are the true <italic>β</italic><sub>0</sub> and <italic>β</italic><sub>1</sub> and
<disp-formula id="pcbi.1007181.e059"><alternatives><graphic id="pcbi.1007181.e059g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e059" xlink:type="simple"/><mml:math display="block" id="M59"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="left"><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>0</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mtext>Var</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≈</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mo>(</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mi>N</mml:mi></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mtext>Var</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≈</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mn>12</mml:mn> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>σ</mml:mi> <mml:mn>01</mml:mn></mml:msub></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mtext>Cov</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo>-</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mi>μ</mml:mi></mml:msub> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>≈</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>The distribution is assumed to hold for repeated simulations of the replicated statistics in the prepaid grid.</p>
<p>Because we work with linear regression, the optimization problem is simple. In this case, the optimal value of <italic>μ</italic> for a given <inline-formula id="pcbi.1007181.e060"><alternatives><graphic id="pcbi.1007181.e060g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e060" xlink:type="simple"/><mml:math display="inline" id="M60"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> can be found by inverting the regression line:
<disp-formula id="pcbi.1007181.e061"><alternatives><graphic id="pcbi.1007181.e061g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e061" xlink:type="simple"/><mml:math display="block" id="M61"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>In this simple example, the method of predicted moments from Panel B3 in <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref> yields an exact solution for the estimated mean, given the observed sample average.</p>
<p>Next, we can study the properties of <inline-formula id="pcbi.1007181.e062"><alternatives><graphic id="pcbi.1007181.e062g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e062" xlink:type="simple"/><mml:math display="inline" id="M62"><mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>. We begin by calculating the conditional mean <inline-formula id="pcbi.1007181.e063"><alternatives><graphic id="pcbi.1007181.e063g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e063" xlink:type="simple"/><mml:math display="inline" id="M63"><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and conditional variance <inline-formula id="pcbi.1007181.e064"><alternatives><graphic id="pcbi.1007181.e064g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e064" xlink:type="simple"/><mml:math display="inline" id="M64"><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Hence, we treat the observed data (or sample average) as given and fixed. These expectations are taken over different simulations of <inline-formula id="pcbi.1007181.e065"><alternatives><graphic id="pcbi.1007181.e065g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e065" xlink:type="simple"/><mml:math display="inline" id="M65"><mml:msubsup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mi>j</mml:mi> <mml:mtext>sim</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>’s in the prepaid grid. Before giving the expressions, it is useful to note that
<disp-formula id="pcbi.1007181.e066"><alternatives><graphic id="pcbi.1007181.e066g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e066" xlink:type="simple"/><mml:math display="block" id="M66"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo>(</mml:mo> <mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:mtd></mml:mtr></mml:mtable> <mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>∼</mml:mo> <mml:msub><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>(</mml:mo> <mml:mo>(</mml:mo> <mml:mtable><mml:mtr><mml:mtd><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo> <mml:mo>(</mml:mo> <mml:mtable><mml:mtr><mml:mtd><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>0</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mtd> <mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>σ</mml:mi> <mml:mn>01</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mrow><mml:mo>-</mml:mo> <mml:msub><mml:mi>σ</mml:mi> <mml:mn>01</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mtd></mml:mtr></mml:mtable> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>Now, using the approximations given in [<xref ref-type="bibr" rid="pcbi.1007181.ref025">25</xref>] for ratios of random variables, we find that:
<disp-formula id="pcbi.1007181.e067"><alternatives><graphic id="pcbi.1007181.e067g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e067" xlink:type="simple"/><mml:math display="block" id="M67"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:mfrac> <mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mfrac><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mfrac> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mrow><mml:mi>E</mml:mi> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mtext>Cov</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>E</mml:mi> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mtext>Var</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mfrac><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:mfrac> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:msup><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msup></mml:mfrac> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:msup><mml:mn>1</mml:mn> <mml:mn>3</mml:mn></mml:msup></mml:mfrac> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mn>12</mml:mn> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mn>12</mml:mn> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
and
<disp-formula id="pcbi.1007181.e068"><alternatives><graphic id="pcbi.1007181.e068g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e068" xlink:type="simple"/><mml:math display="block" id="M68"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub></mml:mrow> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub></mml:mfrac> <mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mfrac><mml:mrow><mml:mi>E</mml:mi> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:mi>E</mml:mi> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>E</mml:mi> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>E</mml:mi> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>-</mml:mo> <mml:mfrac><mml:mrow><mml:mn>2</mml:mn> <mml:mtext>Cov</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>0</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>β</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msup></mml:mfrac> <mml:mo>(</mml:mo> <mml:mfrac><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>0</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:msup><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msup></mml:mfrac> <mml:mo>-</mml:mo> <mml:mfrac><mml:mrow><mml:mn>2</mml:mn> <mml:mo>(</mml:mo> <mml:mo>-</mml:mo> <mml:msub><mml:mi>σ</mml:mi> <mml:mn>01</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>·</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>0</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>+</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:msubsup><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup> <mml:mo>+</mml:mo> <mml:mn>12</mml:mn> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup> <mml:mo>-</mml:mo> <mml:mn>24</mml:mn> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>Invoking the double expectation theorem to arrive at the unconditional expectations, we have:
<disp-formula id="pcbi.1007181.e069"><alternatives><graphic id="pcbi.1007181.e069g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e069" xlink:type="simple"/><mml:math display="block" id="M69"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>E</mml:mi> <mml:mo>[</mml:mo> <mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo> <mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mn>12</mml:mn> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>μ</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mn>12</mml:mn> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:mrow><mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>μ</mml:mi> <mml:mo>-</mml:mo> <mml:mfrac><mml:mi>α</mml:mi> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mfrac> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(2)</label></disp-formula>
where <inline-formula id="pcbi.1007181.e070"><alternatives><graphic id="pcbi.1007181.e070g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e070" xlink:type="simple"/><mml:math display="inline" id="M70"><mml:mrow><mml:mi>α</mml:mi> <mml:mo>=</mml:mo> <mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:mi>μ</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, that is, the difference between the expected value of the mean of the selected nearest neighbors <italic>μ</italic>’s and the true <italic>μ</italic>. Likewise, we can derive the marginal variance <inline-formula id="pcbi.1007181.e071"><alternatives><graphic id="pcbi.1007181.e071g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e071" xlink:type="simple"/><mml:math display="inline" id="M71"><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. We will assume that the variance in <inline-formula id="pcbi.1007181.e072"><alternatives><graphic id="pcbi.1007181.e072g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e072" xlink:type="simple"/><mml:math display="inline" id="M72"><mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:math></alternatives></inline-formula> is equal to <inline-formula id="pcbi.1007181.e073"><alternatives><graphic id="pcbi.1007181.e073g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e073" xlink:type="simple"/><mml:math display="inline" id="M73"><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>. In addition, we assume that <inline-formula id="pcbi.1007181.e074"><alternatives><graphic id="pcbi.1007181.e074g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e074" xlink:type="simple"/><mml:math display="inline" id="M74"><mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e075"><alternatives><graphic id="pcbi.1007181.e075g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e075" xlink:type="simple"/><mml:math display="inline" id="M75"><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> correlate perfectly, such that <inline-formula id="pcbi.1007181.e076"><alternatives><graphic id="pcbi.1007181.e076g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e076" xlink:type="simple"/><mml:math display="inline" id="M76"><mml:mrow><mml:mtext>Cov</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mtext>Var</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>. For this particular example, these assumptions make sense. Then we can derive that:
<disp-formula id="pcbi.1007181.e077"><alternatives><graphic id="pcbi.1007181.e077g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e077" xlink:type="simple"/><mml:math display="block" id="M77"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>E</mml:mi> <mml:mo>[</mml:mo> <mml:mtext>Var</mml:mtext> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo> <mml:mo>]</mml:mo> <mml:mo>+</mml:mo> <mml:mtext>Var</mml:mtext> <mml:mo>[</mml:mo> <mml:mi>E</mml:mi> <mml:mo>(</mml:mo> <mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>|</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>)</mml:mo> <mml:mo>]</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>≈</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:mrow><mml:mo>(</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>+</mml:mo> <mml:msup><mml:mi>μ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mn>12</mml:mn> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:mn>24</mml:mn> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>144</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>T</mml:mi> <mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>4</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>144</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub> <mml:msup><mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>4</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>+</mml:mo> <mml:msup><mml:mi>μ</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>+</mml:mo> <mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:mrow></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:mn>24</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>μ</mml:mi></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>144</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>T</mml:mi> <mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>4</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>(</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>+</mml:mo> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>μ</mml:mi> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd/><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>12</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:mi>E</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>μ</mml:mi> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>M</mml:mi> <mml:mrow><mml:mi>μ</mml:mi></mml:mrow> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>4</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>24</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>4</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mi>T</mml:mi> <mml:mtext>sim</mml:mtext></mml:msub> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>2</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>3</mml:mn></mml:msup></mml:mrow></mml:mfrac> <mml:mo>+</mml:mo> <mml:mfrac><mml:mrow><mml:mn>144</mml:mn> <mml:msup><mml:mi>s</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msubsup><mml:mi>T</mml:mi> <mml:mrow><mml:mtext>sim</mml:mtext></mml:mrow> <mml:mn>2</mml:mn></mml:msubsup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub> <mml:msup><mml:mo>Δ</mml:mo> <mml:mn>4</mml:mn></mml:msup> <mml:msup><mml:mi>N</mml:mi> <mml:mn>6</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(3)</label></disp-formula></p>
<p>From <xref ref-type="disp-formula" rid="pcbi.1007181.e069">Eq 2</xref>, we learn that if there is no systematic deviation in the selection of <italic>μ</italic>-grid points, the prepaid estimator is unbiased. In the other case, the bias decreases with <italic>T</italic><sub>sim</sub> but is proportional to <italic>s</italic><sup>2</sup>. In <xref ref-type="disp-formula" rid="pcbi.1007181.e077">Eq 3</xref>, the leading term of the variance is <inline-formula id="pcbi.1007181.e078"><alternatives><graphic id="pcbi.1007181.e078g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e078" xlink:type="simple"/><mml:math display="inline" id="M78"><mml:mfrac><mml:msup><mml:mi>s</mml:mi> <mml:mn>2</mml:mn></mml:msup> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac></mml:math></alternatives></inline-formula>, which is the same as in classical estimation theory. For the other terms, they all have <italic>T</italic><sub>sim</sub> (or a power of it) in the denominator. Because <italic>T</italic><sub>sim</sub> is usually quite large, these terms tend to be in general of lesser importance. However, some terms also have both <italic>N</italic> (the number of selected nearest neighbor grid points) and Δ (the gap size) in the denominator. It is worthwhile to note that increasing the resolution (i.e., decreasing Δ), while keeping <italic>N</italic> constant, will increase the additional terms and thus add to the error. The reason for this is that the interpolation is defined on a too small grid, leading to uncertainty in the estimated regression. This effect is illustrated in the left panel of <xref ref-type="fig" rid="pcbi.1007181.g005">Fig 5</xref> in which the root mean square error (RMSE) is shown for the estimation of <italic>μ</italic> for different values of <italic>N</italic> and Δ. The plot is constructed by means of a simulation study, but confirms our analytical results.</p>
<fig id="pcbi.1007181.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g005</object-id>
<label>Fig 5</label>
<caption>
<title>RMSE (based on a simulation study) of the toy example estimation as function of the gap size (Δ) and number of nearest neighbors selected to carry out the interpolation (<italic>N</italic>).</title>
<p>The left panel is called situation 1 in which <inline-formula id="pcbi.1007181.e079"><alternatives><graphic id="pcbi.1007181.e079g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e079" xlink:type="simple"/><mml:math display="inline" id="M79"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow></mml:math></alternatives></inline-formula> and the right panel is situation 2 (<inline-formula id="pcbi.1007181.e080"><alternatives><graphic id="pcbi.1007181.e080g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e080" xlink:type="simple"/><mml:math display="inline" id="M80"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula>). For the second situation, the trade-off between Δ and <italic>N</italic> is clearly visible.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g005" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec010">
<title>Situation 2: <inline-formula id="pcbi.1007181.e081"><alternatives><graphic id="pcbi.1007181.e081g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e081" xlink:type="simple"/><mml:math display="inline" id="M81"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula></title>
<p>In the second situation, we will again estimate <italic>μ</italic> (the unknown mean of a unit variance normal), but in this case <inline-formula id="pcbi.1007181.e082"><alternatives><graphic id="pcbi.1007181.e082g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e082" xlink:type="simple"/><mml:math display="inline" id="M82"><mml:mrow><mml:msup><mml:mi>s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:math></alternatives></inline-formula> is used as a statistic. Thus, the relation between the simulated statistics <inline-formula id="pcbi.1007181.e083"><alternatives><graphic id="pcbi.1007181.e083g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e083" xlink:type="simple"/><mml:math display="inline" id="M83"><mml:msup><mml:mover accent="true"><mml:mi>y</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:msup><mml:mtext>sim</mml:mtext> <mml:mn>2</mml:mn></mml:msup></mml:msup></mml:math></alternatives></inline-formula> and <italic>μ</italic> is quadratic (and thus nonlinear). Again we use a local linear approximation. Clearly, this approximation will only be approximately valid if we do not choose the area of approximation too large. However, unlike in the first situation, we do expect an additional effect of the approximation error.</p>
<p>No analytical derivations were made for this case, but we conducted a similar simulation study as in situation 1. The results (in terms of RMSE) are shown in the right panel of <xref ref-type="fig" rid="pcbi.1007181.g005">Fig 5</xref>. As can be seen, there is a clear optimality trade-off visible between Δ and <italic>N</italic>. This can be explained as follows: Fix <italic>N</italic> and then consider the gap size Δ. If Δ is too small, we get a similar phenomenon as in the left panel, that is a large RMSE. However, if we take Δ too large, then the approximation error will dominate (because the linear interpolation misfits the quadratic relation). The optimal point will be different for different <italic>N</italic>.</p>
<p>This toy example demonstrates the sound theoretical foundations of the prepaid method in well-behaved situations. However, the question is how well the method performs for real life examples.</p>
</sec>
</sec>
<sec id="sec011">
<title>Application 1: The Ricker model</title>
<p>The basic model equations of the Ricker model is given in <xref ref-type="disp-formula" rid="pcbi.1007181.e001">Eq 1</xref>.</p>
<sec id="sec012">
<title>Synthetic likelihood estimation</title>
<p>For the synthetic likelihood estimation (SL<sup>Orig</sup>), we made use of the <monospace>synlik</monospace> package [<xref ref-type="bibr" rid="pcbi.1007181.ref026">26</xref>]. The synthetic likelihood <italic>l</italic><sub><italic>s</italic></sub> for a data set with summary statistics <bold><italic>s</italic></bold><sup>obs</sup> and a certain parameter vector <bold><italic>θ</italic></bold> = (<italic>r</italic>, <italic>σ</italic>, <italic>ϕ</italic>) is given by
<disp-formula id="pcbi.1007181.e085"><alternatives><graphic id="pcbi.1007181.e085g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e085" xlink:type="simple"/><mml:math display="block" id="M85"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mi>s</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>θ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mtext>obs</mml:mtext></mml:mrow></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msubsup><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mo>(</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mtext>obs</mml:mtext></mml:mrow></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:mo form="prefix">log</mml:mo> <mml:mo>|</mml:mo> <mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub> <mml:mo>|</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(4)</label></disp-formula>
where <inline-formula id="pcbi.1007181.e086"><alternatives><graphic id="pcbi.1007181.e086g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e086" xlink:type="simple"/><mml:math display="inline" id="M86"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e087"><alternatives><graphic id="pcbi.1007181.e087g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e087" xlink:type="simple"/><mml:math display="inline" id="M87"><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub></mml:math></alternatives></inline-formula> are the estimated mean and covariance of the summary statistics when <xref ref-type="disp-formula" rid="pcbi.1007181.e001">Eq 1</xref> is simulated multiple times with parameter <bold><italic>θ</italic></bold>.</p>
<p>The statistics used by the synthetic likelihood function were the average population size, the number of zeros, the autocovariances up to lag 5, the coefficients of the quadratic linear autoregression of <inline-formula id="pcbi.1007181.e088"><alternatives><graphic id="pcbi.1007181.e088g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e088" xlink:type="simple"/><mml:math display="inline" id="M88"><mml:msubsup><mml:mi>y</mml:mi> <mml:mi>t</mml:mi> <mml:mrow><mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msubsup></mml:math></alternatives></inline-formula> and the coefficients of the cubic regression of the ordered differences <italic>y</italic><sub><italic>t</italic></sub> − <italic>y</italic><sub><italic>t</italic>−1</sub> on the observed values.</p>
<p>For each data set we used the synthetic likelihood Markov chain Monte Carlo (MCMC) method with 30000 iterations, a burn in of 3 time steps and 500 simulations to compute each <inline-formula id="pcbi.1007181.e089"><alternatives><graphic id="pcbi.1007181.e089g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e089" xlink:type="simple"/><mml:math display="inline" id="M89"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e090"><alternatives><graphic id="pcbi.1007181.e090g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e090" xlink:type="simple"/><mml:math display="inline" id="M90"><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub></mml:math></alternatives></inline-formula> [<xref ref-type="bibr" rid="pcbi.1007181.ref026">26</xref>]. We used the following prior:
<disp-formula id="pcbi.1007181.e091"><alternatives><graphic id="pcbi.1007181.e091g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e091" xlink:type="simple"/><mml:math display="block" id="M91"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mi>r</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>90</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>σ</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn> <mml:mo>,</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>7</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>ϕ</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mn>20</mml:mn> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(5)</label></disp-formula></p>
<p>The <monospace>synlik</monospace> package generates the MCMC chain on a logarithmic scale, we estimated the parameters as the exponential of the posterior mean. To ensure convergence, only the last half of the chain is used (the last 15000 iterations).</p>
</sec>
<sec id="sec013">
<title>Creation of the prepaid grid</title>
<p>For the prepaid estimation, we used the same summary statistics as for the traditional synthetic likelihood, except for two differences. First, the coefficients of the cubic regression of the ordered differences <italic>y</italic><sub><italic>t</italic></sub> − <italic>y</italic><sub><italic>t</italic>−1</sub> on the observed values could not be used, because the observed values are not available when creating the prepaid grid. Second, we changed the number of zeros to the percentage of zeros to make this statistic independent of <italic>T</italic><sub>obs</sub> (as this may change depending on the observation).</p>
<p>We filled the prepaid grid with 100000 parameter sets using the priors of <xref ref-type="disp-formula" rid="pcbi.1007181.e091">Eq 5</xref>. To cover this grid as evenly as possible (and avoiding too large gaps), the uniform distribution was approximated using Halton sequences [<xref ref-type="bibr" rid="pcbi.1007181.ref027">27</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref028">28</xref>]. For each parameter set in the prepaid grid, we simulated a time series of length 10<sup>7</sup> and used the summary statistics of this long time series as <inline-formula id="pcbi.1007181.e092"><alternatives><graphic id="pcbi.1007181.e092g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e092" xlink:type="simple"/><mml:math display="inline" id="M92"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub></mml:math></alternatives></inline-formula>.</p>
<p>Each time series was then split into series of length <italic>T</italic><sub><italic>prepaid</italic></sub> = 100, 1000 and 10000 which were used to compute the covariance <inline-formula id="pcbi.1007181.e093"><alternatives><graphic id="pcbi.1007181.e093g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e093" xlink:type="simple"/><mml:math display="inline" id="M93"><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">T</mml:mi><mml:mrow><mml:mstyle mathvariant="bold-italic"><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mstyle></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> for the statistics computed on data of these lengths. This means, for example, that we had 100000 series of length 100 to compute the covariance matrix for a certain parameter set for time series of length 100. If we need to estimate parameters of a time series with <italic>T</italic><sub>obs</sub> not equal to one of the <italic>T</italic><sub>prepaid</sub> lengths, we use the covariance matrix created with time series of length <italic>T</italic><sub><italic>prepaid</italic></sub> which is closest to <italic>T</italic><sub>obs</sub> in logarithmic scale and adapt the covariance matrix into
<disp-formula id="pcbi.1007181.e094"><alternatives><graphic id="pcbi.1007181.e094g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e094" xlink:type="simple"/><mml:math display="block" id="M94"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mfrac><mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(6)</label></disp-formula></p>
<p>The creation of the prepaid grid took approximately one day on a 3.4GHz 20-core processor.</p>
<p>To allow the estimation for a larger range of parameters for the online estimation at <ext-link ext-link-type="uri" xlink:href="http://www.prepaidestimation.org/" xlink:type="simple">http://www.prepaidestimation.org/</ext-link> we created a new and bigger prepaid grid using the following priors:
<disp-formula id="pcbi.1007181.e095"><alternatives><graphic id="pcbi.1007181.e095g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e095" xlink:type="simple"/><mml:math display="block" id="M95"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>log</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>r</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mtext>log</mml:mtext> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo> <mml:mi>l</mml:mi> <mml:mi>o</mml:mi> <mml:mi>g</mml:mi> <mml:mo>(</mml:mo> <mml:mn>200</mml:mn> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>σ</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn> <mml:mo>,</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>7</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>log</mml:mtext> <mml:mo>(</mml:mo> <mml:mi>ϕ</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mo>-</mml:mo> <mml:mn>2</mml:mn> <mml:mo>,</mml:mo> <mml:mn>7</mml:mn> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(7)</label></disp-formula></p>
<p>We filled to prepaid grid with 100000 parameter sets and used this prior for the real life data set on the Chilo partellus.</p>
</sec>
<sec id="sec014">
<title>Prepaid estimation</title>
<p>Four variants of prepaid estimation were implemented for this example. All use the negative synthetic likelihood as distance (<italic>d</italic>(<bold><italic>s</italic></bold><sup>sim</sup>, <bold><italic>s</italic></bold><sup>obs</sup>) as defined in the main text and <xref ref-type="fig" rid="pcbi.1007181.g001">Fig 1</xref>). First, we do a nearest neighbor estimation <inline-formula id="pcbi.1007181.e096"><alternatives><graphic id="pcbi.1007181.e096g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e096" xlink:type="simple"/><mml:math display="inline" id="M96"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, without using any interpolation between the grid points of the prepaid data set. We compute the synthetic likelihood of all the prepaid parameters for the summary statistics of the test data set. The parameter vector with the highest likelihood, the so-called nearest neighbor may already be a good estimation. For a low number of time points <italic>T</italic><sub>obs</sub>, it is to be expected that the error on the parameter estimate is much larger than the gaps in the prepaid grid, and in such a case, the <inline-formula id="pcbi.1007181.e097"><alternatives><graphic id="pcbi.1007181.e097g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e097" xlink:type="simple"/><mml:math display="inline" id="M97"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> estimation approach suffices.</p>
<p>Second, a more accurate estimation can be acquired by interpolating between the parameter values in the prepaid grid (<inline-formula id="pcbi.1007181.e098"><alternatives><graphic id="pcbi.1007181.e098g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e098" xlink:type="simple"/><mml:math display="inline" id="M98"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>). Therefore, we learn the relation between the parameters and the summary statistics: <inline-formula id="pcbi.1007181.e099"><alternatives><graphic id="pcbi.1007181.e099g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e099" xlink:type="simple"/><mml:math display="inline" id="M99"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi></mml:mrow></mml:msub> <mml:mo>:</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>↦</mml:mo> <mml:mi mathvariant="bold-italic">s</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. However, we only learn this relation in the region of interest, that is the 100 nearest neighbors according to the synthetic likelihood. For each summary statistic, we create, on the fly, a separate least squares support vector machine (LS-SVM) [<xref ref-type="bibr" rid="pcbi.1007181.ref012">12</xref>] using the 100 nearest neighbors. This machine learning technique is chosen as it is a fast non-linear method which generalizes well. We limit the predictions to the possible range of the summary statistics (e.g., to prevent a percentage of zeros, one of the statistics, larger than 1).</p>
<p>We then use the differential evolution global optimizer [<xref ref-type="bibr" rid="pcbi.1007181.ref014">14</xref>] to find the maximum of:
<disp-formula id="pcbi.1007181.e100"><alternatives><graphic id="pcbi.1007181.e100g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e100" xlink:type="simple"/><mml:math display="block" id="M100"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msubsup><mml:mi>l</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>θ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mtext>obs</mml:mtext></mml:mrow></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi></mml:mrow></mml:msub> <mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>T</mml:mi></mml:msup> <mml:msubsup><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mrow><mml:mi>o</mml:mi> <mml:mi>b</mml:mi> <mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mo>(</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mtext>obs</mml:mtext></mml:mrow></mml:msup> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi></mml:mrow></mml:msub> <mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>2</mml:mn></mml:mfrac> <mml:mo form="prefix">log</mml:mo> <mml:mo>|</mml:mo> <mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mrow><mml:mi>o</mml:mi> <mml:mi>b</mml:mi> <mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub> <mml:mo>|</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(8)</label></disp-formula>
where <inline-formula id="pcbi.1007181.e101"><alternatives><graphic id="pcbi.1007181.e101g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e101" xlink:type="simple"/><mml:math display="inline" id="M101"><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mrow><mml:mi>o</mml:mi> <mml:mi>b</mml:mi> <mml:mi>s</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> is the covariance matrix of the statistics of the nearest neighbor as defined in <xref ref-type="disp-formula" rid="pcbi.1007181.e094">Eq 6</xref>. The superscript “PP” is used to denote that we use the prepaid version of synthetic likelihood, and not the traditional version as used by [<xref ref-type="bibr" rid="pcbi.1007181.ref002">2</xref>] (see <xref ref-type="disp-formula" rid="pcbi.1007181.e085">Eq 4</xref>). The optimization process is constrained and we use the minima and maxima for each parameter of the 100 nearest neighbors as effective bounds.</p>
<p>The <inline-formula id="pcbi.1007181.e102"><alternatives><graphic id="pcbi.1007181.e102g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e102" xlink:type="simple"/><mml:math display="inline" id="M102"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach makes use of a non-linear black box interpolator. However, we may also consider using a much faster linear regression (see also the toy example in Section). Therefore, we will also compare the <inline-formula id="pcbi.1007181.e103"><alternatives><graphic id="pcbi.1007181.e103g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e103" xlink:type="simple"/><mml:math display="inline" id="M103"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> (and <inline-formula id="pcbi.1007181.e104"><alternatives><graphic id="pcbi.1007181.e104g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e104" xlink:type="simple"/><mml:math display="inline" id="M104"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>) approach to a third option where we predict the summary statistics using a linear regression (called the <inline-formula id="pcbi.1007181.e105"><alternatives><graphic id="pcbi.1007181.e105g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e105" xlink:type="simple"/><mml:math display="inline" id="M105"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Lin</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach).</p>
<p>Third, we can easily implement a prior for the likelihood in <xref ref-type="disp-formula" rid="pcbi.1007181.e085">Eq 4</xref>. This leads to a posterior given by
<disp-formula id="pcbi.1007181.e106"><alternatives><graphic id="pcbi.1007181.e106g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e106" xlink:type="simple"/><mml:math display="block" id="M106"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>|</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>∝</mml:mo> <mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msub><mml:mi>l</mml:mi> <mml:mi>s</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(9)</label></disp-formula></p>
<p>The parameters will be estimated as the maximum a posteriori (MAP), as comparison to maximum likelihood estimation which is a maximum a posteriori with a uniform prior. Here we will apply this extension to the nearest neighbor estimation: <inline-formula id="pcbi.1007181.e107"><alternatives><graphic id="pcbi.1007181.e107g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e107" xlink:type="simple"/><mml:math display="inline" id="M107"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>MAP</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>.</p>
<p>Lastly we will show that our prepaid method can also be used to cover an experimental set-up. In such a set-up, we want to estimate the same model over several experimental conditions. For example, we may be interested in the effect of light intensity on the population dynamics of a certain type of bacteria. In such an example we would vary the light intensity over several conditions and estimate the population dynamics again for each condition.</p>
<p>If, for this experimental set-up, the conditions <italic>c</italic> are independent, the likelihood of the whole experiment is
<disp-formula id="pcbi.1007181.e108"><alternatives><graphic id="pcbi.1007181.e108g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e108" xlink:type="simple"/><mml:math display="block" id="M108"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mrow><mml:mi>s</mml:mi> <mml:mo>,</mml:mo> <mml:mi>e</mml:mi> <mml:mi>x</mml:mi> <mml:mi>p</mml:mi> <mml:mi>e</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>m</mml:mi> <mml:mi>e</mml:mi> <mml:mi>n</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>C</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>c</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>C</mml:mi></mml:munderover> <mml:mrow><mml:msub><mml:mi>l</mml:mi> <mml:mrow><mml:mi>s</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>c</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(10)</label></disp-formula>
where <italic>l</italic><sub><italic>s</italic>,<italic>c</italic></sub>(<bold><italic>θ</italic></bold><sub><italic>c</italic></sub>) is the synthetic likelihood for condition <italic>c</italic>. This is equivalent to estimating each parameter set <bold><italic>θ</italic></bold><sub><italic>c</italic></sub> individually for each condition <italic>c</italic> poses no problem for the previously proposed prepaid method.</p>
<p>In many experimental set-ups, the conditions will however not be independent. In the case of our example, we may only be interested in the effect of light intensity on the scaling parameter <italic>ϕ</italic>, and expect the other parameters <italic>r</italic> and <italic>σ</italic> to be constant across conditions. Such a dependence between conditions can be mimicked using priors. In case of the experiment example, with two conditions, we propose the following prior:
<disp-formula id="pcbi.1007181.e109"><alternatives><graphic id="pcbi.1007181.e109g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e109" xlink:type="simple"/><mml:math display="block" id="M109"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mn mathvariant="bold">1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mn mathvariant="bold">2</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>r</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>r</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow> <mml:msub><mml:mi>σ</mml:mi> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mfrac> <mml:mo>)</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>r</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>r</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow> <mml:msub><mml:mi>σ</mml:mi> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mfrac> <mml:mo>)</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow> <mml:msub><mml:mi>σ</mml:mi> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mfrac> <mml:mo>)</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow> <mml:msub><mml:mi>σ</mml:mi> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(11)</label></disp-formula>
where <inline-formula id="pcbi.1007181.e110"><alternatives><graphic id="pcbi.1007181.e110g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e110" xlink:type="simple"/><mml:math display="inline" id="M110"><mml:mi mathvariant="script">N</mml:mi></mml:math></alternatives></inline-formula> is the standard normal distribution and <inline-formula id="pcbi.1007181.e111"><alternatives><graphic id="pcbi.1007181.e111g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e111" xlink:type="simple"/><mml:math display="inline" id="M111"><mml:mover accent="true"><mml:mi>r</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e112"><alternatives><graphic id="pcbi.1007181.e112g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e112" xlink:type="simple"/><mml:math display="inline" id="M112"><mml:mover accent="true"><mml:msub><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> are the averages of respectively <italic>r</italic> and <italic>σ</italic> across conditions (<inline-formula id="pcbi.1007181.e113"><alternatives><graphic id="pcbi.1007181.e113g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e113" xlink:type="simple"/><mml:math display="inline" id="M113"><mml:mrow><mml:mover accent="true"><mml:mi>r</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>r</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>r</mml:mi> <mml:mn>2</mml:mn></mml:msub></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e114"><alternatives><graphic id="pcbi.1007181.e114g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e114" xlink:type="simple"/><mml:math display="inline" id="M114"><mml:mrow><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>¯</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>σ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msub></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>). Using such a prior we can force <italic>r</italic><sub>1</sub> and <italic>σ</italic><sub>1</sub> to be similar to <italic>r</italic><sub>2</sub> and <italic>σ</italic><sub>2</sub> respectively. The smaller the tuning parameter <italic>σ</italic><sub><italic>prior</italic></sub>, the more all constrained parameters (<italic>r</italic> and <italic>σ</italic>) will be forced to be equal. If <italic>σ</italic><sub><italic>prior</italic></sub> is too large the estimation will not take into account the interdependence between the conditions. So at first, it seems that <italic>σ</italic><sub><italic>prior</italic></sub> needs to be as small as possible. However, if <italic>σ</italic><sub><italic>prior</italic></sub> is too small we run into trouble with the sparsity of the prepaid grid. In the limit, where <italic>σ</italic><sub><italic>prior</italic></sub> goes to zero, the estimation process will choose a parameter where <italic>r</italic><sub>1</sub> = <italic>r</italic><sub>2</sub> and <italic>σ</italic><sub>1</sub> = <italic>σ</italic><sub>2</sub> will hold exactly. Due to the nature of the prepaid grid, this will lead to the undesired result where exactly one prepaid point is chosen for both conditions, meaning that also <italic>ϕ</italic><sub>1</sub> = <italic>ϕ</italic><sub>2</sub>. Luckily, <italic>σ</italic><sub><italic>prior</italic></sub> can be easily tuned. Once the prepaid grid is created, we can estimate many test parameters using the the experimental set-up in combination with a certain tuning parameter. Subsequently, the tuning parameter which leads to the best estimates of these test parameters is chosen.</p>
<p>In practice, when <italic>σ</italic><sub><italic>prior</italic></sub> is tuned, we will first create a pool of eligible parameters for each condition individually using the nearest neighbor approach <inline-formula id="pcbi.1007181.e115"><alternatives><graphic id="pcbi.1007181.e115g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e115" xlink:type="simple"/><mml:math display="inline" id="M115"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>. In a second step we fill refine these pools by using the prior of <xref ref-type="disp-formula" rid="pcbi.1007181.e109">Eq 11</xref> and choose the best estimate for each condition. In a last step we replace <italic>r</italic><sub>1</sub> and <italic>r</italic><sub>2</sub> by <inline-formula id="pcbi.1007181.e116"><alternatives><graphic id="pcbi.1007181.e116g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e116" xlink:type="simple"/><mml:math display="inline" id="M116"><mml:mover accent="true"><mml:mi>r</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and <italic>σ</italic><sub>1</sub> and <italic>σ</italic><sub>2</sub> by <inline-formula id="pcbi.1007181.e117"><alternatives><graphic id="pcbi.1007181.e117g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e117" xlink:type="simple"/><mml:math display="inline" id="M117"><mml:mover accent="true"><mml:mi>σ</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:math></alternatives></inline-formula> to ensure that the constraints of the experimental set up are exactly satisfied.</p>
<p>More generally, for an experiment with several conditions where we want parameter <italic>θ</italic> to be constant over the conditions we get the following prior:
<disp-formula id="pcbi.1007181.e118"><alternatives><graphic id="pcbi.1007181.e118g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e118" xlink:type="simple"/><mml:math display="block" id="M118"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>θ</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>θ</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>.</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>θ</mml:mi> <mml:mn>3</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munderover><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>c</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>C</mml:mi></mml:munderover> <mml:mi mathvariant="script">N</mml:mi> <mml:mo>(</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mi>θ</mml:mi> <mml:mi>c</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi>θ</mml:mi> <mml:mo>¯</mml:mo></mml:mover></mml:mrow> <mml:msub><mml:mi>σ</mml:mi> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mfrac> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(12)</label></disp-formula></p>
</sec>
<sec id="sec015">
<title>Test set</title>
<p>As a test set we first used 100 random parameters created with the prior of <xref ref-type="disp-formula" rid="pcbi.1007181.e091">Eq 5</xref>. To avoid problems with the borders we deleted parameters that where within 1% range of the bounds. We simulated data sets for <italic>T</italic><sub>obs</sub> = {10<sup>2</sup>, 5⋅10<sup>2</sup>, 10<sup>3</sup>, 10<sup>4</sup>, 10<sup>5</sup>}. For each data set we estimated parameters using the nearest neighbor (<inline-formula id="pcbi.1007181.e119"><alternatives><graphic id="pcbi.1007181.e119g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e119" xlink:type="simple"/><mml:math display="inline" id="M119"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>) and the <inline-formula id="pcbi.1007181.e120"><alternatives><graphic id="pcbi.1007181.e120g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e120" xlink:type="simple"/><mml:math display="inline" id="M120"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach. For <italic>T</italic><sub>obs</sub> = 10<sup>5</sup>, we also estimated the parameters using the <inline-formula id="pcbi.1007181.e121"><alternatives><graphic id="pcbi.1007181.e121g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e121" xlink:type="simple"/><mml:math display="inline" id="M121"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Lin</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach. Due to time constraints, we only estimated parameters for the data with <italic>T</italic><sub>obs</sub> ≤ 10<sup>3</sup> using the traditional synthetic likelihood approach.</p>
<p>Next we also created test data sets from different priors for <italic>T</italic><sub>obs</sub> = 10<sup>2</sup>. Prior <italic>P</italic><sub>1</sub> from <xref ref-type="disp-formula" rid="pcbi.1007181.e091">Eq 5</xref> can also be written as
<disp-formula id="pcbi.1007181.e122"><alternatives><graphic id="pcbi.1007181.e122g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e122" xlink:type="simple"/><mml:math display="block" id="M122"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mn>90</mml:mn> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mi>e</mml:mi> <mml:mi>t</mml:mi> <mml:mi>a</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>σ</mml:mi> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow> <mml:mrow><mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>7</mml:mn> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mi>e</mml:mi> <mml:mi>t</mml:mi> <mml:mi>a</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mi>ϕ</mml:mi> <mml:mn>20</mml:mn></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mi>e</mml:mi> <mml:mi>t</mml:mi> <mml:mi>a</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(13)</label></disp-formula>
where <italic>Beta</italic> is a beta distribution with parameters <italic>α</italic> = 1 and <italic>β</italic> = 1. Similarly, we created a test set from prior <italic>P</italic><sub>2</sub> <disp-formula id="pcbi.1007181.e123"><alternatives><graphic id="pcbi.1007181.e123g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e123" xlink:type="simple"/><mml:math display="block" id="M123"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mn>90</mml:mn> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mn>10</mml:mn> <mml:mo>,</mml:mo> <mml:mn>10</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>σ</mml:mi> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow> <mml:mrow><mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>7</mml:mn> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mn>10</mml:mn> <mml:mo>,</mml:mo> <mml:mn>10</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mi>ϕ</mml:mi> <mml:mn>20</mml:mn></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mn>10</mml:mn> <mml:mo>,</mml:mo> <mml:mn>10</mml:mn> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(14)</label></disp-formula>
and prior <italic>P</italic><sub>3</sub> <disp-formula id="pcbi.1007181.e124"><alternatives><graphic id="pcbi.1007181.e124g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e124" xlink:type="simple"/><mml:math display="block" id="M124"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>r</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mrow><mml:mn>90</mml:mn> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mo>,</mml:mo> <mml:mn>10</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mrow><mml:mi>σ</mml:mi> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow> <mml:mrow><mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>7</mml:mn> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mn>10</mml:mn> <mml:mo>,</mml:mo> <mml:mn>2</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mfrac><mml:mi>ϕ</mml:mi> <mml:mn>20</mml:mn></mml:mfrac></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi>B</mml:mi> <mml:mo>(</mml:mo> <mml:mn>2</mml:mn> <mml:mo>,</mml:mo> <mml:mn>10</mml:mn> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(15)</label></disp-formula></p>
<p>We will test if <inline-formula id="pcbi.1007181.e125"><alternatives><graphic id="pcbi.1007181.e125g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e125" xlink:type="simple"/><mml:math display="inline" id="M125"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>MAP</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> performs best when the correct prior is used in the estimation process. Last we also created a test set for <italic>T</italic><sub>obs</sub> = 10<sup>2</sup> for an experimental set up with two conditions where <italic>r</italic> and <italic>σ</italic> are equal over the conditions.</p>
<p>In the subsequent sections, we will evaluate the methods on the following criteria: accuracy, speed and coverage.</p>
</sec>
<sec id="sec016">
<title>Results accuracy</title>
<p>To start off, we look at the recoveries for <italic>T</italic><sub>obs</sub> = 10<sup>3</sup> for all 100 simulated data sets and the three methods (SL<sup>Orig</sup>,<inline-formula id="pcbi.1007181.e126"><alternatives><graphic id="pcbi.1007181.e126g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e126" xlink:type="simple"/><mml:math display="inline" id="M126"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e127"><alternatives><graphic id="pcbi.1007181.e127g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e127" xlink:type="simple"/><mml:math display="inline" id="M127"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>). Scatter plots are shown in <xref ref-type="fig" rid="pcbi.1007181.g006">Fig 6</xref>. It can seen that the synthetic likelihood estimation leads to some clear outliers. One possible reason for the absence of outliers in the prepaid estimation is the fact that prepaid estimation from the start examines the whole grid and therefore has less problems with getting stuck in local optima.</p>
<fig id="pcbi.1007181.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Estimated versus true parameters of the Ricker model of 100 data sets with <italic>T</italic><sub>obs</sub> = 1000.</title>
<p>The SL<sup>Orig</sup> estimation has some problems with outliers.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g006" xlink:type="simple"/>
</fig>
<p>More generally, we plotted the accuracy of each of the methods as a function of time series length <italic>T</italic><sub>obs</sub> in <xref ref-type="fig" rid="pcbi.1007181.g007">Fig 7</xref>. The left panel shows the root mean square error (RMSE), while the right panel shows the median absolute error (MAE). We decided to look at the MAE because the few outliers for SL<sup>Orig</sup> (which were shown <xref ref-type="fig" rid="pcbi.1007181.g006">Fig 6</xref>) may inflate the RMSE of the synthetic likelihood disproportionally, which happens to a certain extent. However, very similar conclusions can be drawn for both performance measures. In general, accuracy increases when <italic>T</italic><sub>obs</sub> increases (i.e., both RMSE and MAE decreases). For RMSE, our SVM prepaid method clearly outperforms the traditional synthetic likelihood method SL<sup>Orig</sup> for every <italic>T</italic><sub>obs</sub> and every parameter. For <italic>T</italic><sub>obs</sub> = {5⋅10<sup>2</sup>, 10<sup>3</sup>}, also the <inline-formula id="pcbi.1007181.e128"><alternatives><graphic id="pcbi.1007181.e128g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e128" xlink:type="simple"/><mml:math display="inline" id="M128"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach leads for every parameter to a lower RMSE compared to the synthetic likelihood. For all <italic>T</italic><sub>obs</sub>, the <inline-formula id="pcbi.1007181.e129"><alternatives><graphic id="pcbi.1007181.e129g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e129" xlink:type="simple"/><mml:math display="inline" id="M129"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid leads to a higher accuracy compared to the <inline-formula id="pcbi.1007181.e130"><alternatives><graphic id="pcbi.1007181.e130g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e130" xlink:type="simple"/><mml:math display="inline" id="M130"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid and this difference becomes larger for a larger <italic>T</italic><sub>obs</sub>. For MAE, the <inline-formula id="pcbi.1007181.e131"><alternatives><graphic id="pcbi.1007181.e131g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e131" xlink:type="simple"/><mml:math display="inline" id="M131"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid method and the original synthetic likelihood SL<sup>Orig</sup> show a very similar accuracy (for <italic>T</italic><sub>obs</sub> ≤ 10<sup>3</sup>). Both outperform the <inline-formula id="pcbi.1007181.e132"><alternatives><graphic id="pcbi.1007181.e132g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e132" xlink:type="simple"/><mml:math display="inline" id="M132"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid.</p>
<fig id="pcbi.1007181.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g007</object-id>
<label>Fig 7</label>
<caption>
<title>The accuracy of all estimation methods versus the number of time points <italic>T</italic><sub>obs</sub>.</title>
<p>The left panel shows the mean squared error, while the right panel shows the median absolute error. The three colors represent the three parameters. Blue lines refer to the parameter <italic>r</italic>, red lines to the parameter <italic>σ</italic> and yellow lines to the parameter <italic>ϕ</italic>. The solid line represents the original synthetic likelihood approach SL<sup>Orig</sup> (stopping at <italic>T</italic><sub>obs</sub> = 10<sup>3</sup>), the dashed line the <inline-formula id="pcbi.1007181.e133"><alternatives><graphic id="pcbi.1007181.e133g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e133" xlink:type="simple"/><mml:math display="inline" id="M133"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach and the dotted line the <inline-formula id="pcbi.1007181.e134"><alternatives><graphic id="pcbi.1007181.e134g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e134" xlink:type="simple"/><mml:math display="inline" id="M134"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g007" xlink:type="simple"/>
</fig>
<p>The largest attainable accuracy for the <inline-formula id="pcbi.1007181.e135"><alternatives><graphic id="pcbi.1007181.e135g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e135" xlink:type="simple"/><mml:math display="inline" id="M135"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach is limited by the spacing of the prepaid grid. If we had created an equally spaced grid of <italic>T</italic><sub>obs</sub> = 10<sup>5</sup> points using the prior in <xref ref-type="disp-formula" rid="pcbi.1007181.e091">Eq 5</xref>, we would have the following gaps in each of the three parameter dimensions:
<disp-formula id="pcbi.1007181.e136"><alternatives><graphic id="pcbi.1007181.e136g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e136" xlink:type="simple"/><mml:math display="block" id="M136"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mo>Δ</mml:mo> <mml:mi>r</mml:mi></mml:msub></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mn>90</mml:mn> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mn>10</mml:mn> <mml:mn>5</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn> <mml:mo>.</mml:mo> <mml:mn>9</mml:mn></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mo>Δ</mml:mo> <mml:mi>σ</mml:mi></mml:msub></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>7</mml:mn> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn></mml:mrow> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mn>10</mml:mn> <mml:mn>5</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>01</mml:mn></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mo>Δ</mml:mo> <mml:mi>ϕ</mml:mi></mml:msub></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:mn>20</mml:mn> <mml:mo>-</mml:mo> <mml:mn>0</mml:mn></mml:mrow> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mn>10</mml:mn> <mml:mn>5</mml:mn></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>/</mml:mo> <mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>4</mml:mn> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(16)</label></disp-formula></p>
<p>We do not have an equally spaced grid, but it is expected that the quasi Monte Carlo distribution of points creates expected gaps close to the ones in <xref ref-type="disp-formula" rid="pcbi.1007181.e136">Eq 16</xref>. Therefore, it is no coincidence that the best possible RMSE using the <inline-formula id="pcbi.1007181.e137"><alternatives><graphic id="pcbi.1007181.e137g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e137" xlink:type="simple"/><mml:math display="inline" id="M137"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach has the same order of magnitude as the gap size Δ, as can be seen in <xref ref-type="table" rid="pcbi.1007181.t002">Table 2</xref> for the case of <italic>T</italic><sub>obs</sub> = 10<sup>5</sup>. However, <xref ref-type="table" rid="pcbi.1007181.t002">Table 2</xref> also show that the <inline-formula id="pcbi.1007181.e138"><alternatives><graphic id="pcbi.1007181.e138g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e138" xlink:type="simple"/><mml:math display="inline" id="M138"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach leads to a much lower RMSE. The difference between the <inline-formula id="pcbi.1007181.e139"><alternatives><graphic id="pcbi.1007181.e139g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e139" xlink:type="simple"/><mml:math display="inline" id="M139"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and the <inline-formula id="pcbi.1007181.e140"><alternatives><graphic id="pcbi.1007181.e140g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e140" xlink:type="simple"/><mml:math display="inline" id="M140"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid approach for <italic>T</italic><sub>obs</sub> = 10<sup>5</sup> is further visualized in <xref ref-type="fig" rid="pcbi.1007181.g008">Fig 8</xref>.</p>
<fig id="pcbi.1007181.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g008</object-id>
<label>Fig 8</label>
<caption>
<title>The estimation of the three parameters of the Ricker model of 100 data sets with <italic>T</italic><sub>obs</sub> = 10<sup>5</sup>.</title>
<p>The <inline-formula id="pcbi.1007181.e148"><alternatives><graphic id="pcbi.1007181.e148g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e148" xlink:type="simple"/><mml:math display="inline" id="M148"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> estimation clearly outperforms the <inline-formula id="pcbi.1007181.e149"><alternatives><graphic id="pcbi.1007181.e149g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e149" xlink:type="simple"/><mml:math display="inline" id="M149"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> estimation.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g008" xlink:type="simple"/>
</fig>
<table-wrap id="pcbi.1007181.t002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t002</object-id>
<label>Table 2</label>
<caption>
<title>RMSE for the estimation of the parameters of the Ricker model for <italic>T</italic> = 10<sup>5</sup> using the <inline-formula id="pcbi.1007181.e142"><alternatives><graphic id="pcbi.1007181.e142g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e142" xlink:type="simple"/><mml:math display="inline" id="M142"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1007181.e143"><alternatives><graphic id="pcbi.1007181.e143g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e143" xlink:type="simple"/><mml:math display="inline" id="M143"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e144"><alternatives><graphic id="pcbi.1007181.e144g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e144" xlink:type="simple"/><mml:math display="inline" id="M144"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Lin</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid methods.</title>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t002g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t002" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left"/>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e145">
<alternatives>
<graphic id="pcbi.1007181.e145g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e145" xlink:type="simple"/>
<mml:math display="inline" id="M145">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="char" char=".">1.2</td>
<td align="char" char=".">0.021</td>
<td align="char" char=".">0.14</td>
</tr>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e146">
<alternatives>
<graphic id="pcbi.1007181.e146g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e146" xlink:type="simple"/>
<mml:math display="inline" id="M146">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="char" char=".">0.43</td>
<td align="char" char=".">0.0044</td>
<td align="char" char=".">0.023</td>
</tr>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e147">
<alternatives>
<graphic id="pcbi.1007181.e147g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e147" xlink:type="simple"/>
<mml:math display="inline" id="M147">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>Lin</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="char" char=".">0.54</td>
<td align="char" char=".">0.013</td>
<td align="char" char=".">0.091</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>The results in <xref ref-type="table" rid="pcbi.1007181.t002">Table 2</xref> also show the need for a non-linear interpolator for the prepaid method. The RMSE of a linear regression interpolator (<inline-formula id="pcbi.1007181.e141"><alternatives><graphic id="pcbi.1007181.e141g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e141" xlink:type="simple"/><mml:math display="inline" id="M141"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Lin</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>) is much larger than that of the SVM prepaid.</p>
<p>In sum, we can conclude that the prepaid estimation methods lead to better, or at least similar, results as the traditional synthetic likelihood.</p>
</sec>
<sec id="sec017">
<title>Results speed</title>
<p>The largest improvement of the prepaid method over synthetic likelihood is in computational speed: The prepaid method is many times faster than synthetic likelihood. Consider <xref ref-type="fig" rid="pcbi.1007181.g002">Fig 2</xref> in the main text where it is shown that the <inline-formula id="pcbi.1007181.e150"><alternatives><graphic id="pcbi.1007181.e150g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e150" xlink:type="simple"/><mml:math display="inline" id="M150"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid method is finished before a single iteration of the 30000 iterations are done by the SL<sup>Orig</sup> method. While the <inline-formula id="pcbi.1007181.e151"><alternatives><graphic id="pcbi.1007181.e151g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e151" xlink:type="simple"/><mml:math display="inline" id="M151"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and the <inline-formula id="pcbi.1007181.e152"><alternatives><graphic id="pcbi.1007181.e152g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e152" xlink:type="simple"/><mml:math display="inline" id="M152"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid methods are finished in respectively 0.044 and 3.7 seconds, independent of the time series length <italic>T</italic><sub>obs</sub>, the SL<sup>Orig</sup> method grows slower with an order of magnitude of <italic>T</italic><sub>obs</sub>. In each SL<sup>Orig</sup> iteration one needs to simulate multiple time series with length <italic>T</italic><sub>obs</sub>. The larger <italic>T</italic><sub>obs</sub>, the slower the estimation. While the synthetic likelihood needs approximately one and a half hour to estimate the parameters for a time series with length <italic>T</italic><sub>obs</sub> = 10<sup>3</sup>. The <inline-formula id="pcbi.1007181.e153"><alternatives><graphic id="pcbi.1007181.e153g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e153" xlink:type="simple"/><mml:math display="inline" id="M153"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid estimation still finishes in 0.044 s, which is more than 10<sup>5</sup> times faster. The speed up factors are presented in <xref ref-type="table" rid="pcbi.1007181.t003">Table 3</xref> and as can be seen from <xref ref-type="fig" rid="pcbi.1007181.g007">Fig 7</xref>, there is not loss of accuracy. The speed up would reach millions, if we had the time to run the synthetic likelihood method for longer time series.</p>
<table-wrap id="pcbi.1007181.t003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t003</object-id>
<label>Table 3</label>
<caption>
<title>Average time in seconds needed for the SL<sup>Orig</sup> estimation for multiple <italic>T</italic><sub>obs</sub> and the speed up for the <inline-formula id="pcbi.1007181.e157"><alternatives><graphic id="pcbi.1007181.e157g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e157" xlink:type="simple"/><mml:math display="inline" id="M157"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e158"><alternatives><graphic id="pcbi.1007181.e158g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e158" xlink:type="simple"/><mml:math display="inline" id="M158"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> methods.</title>
<p>The time for <italic>T</italic><sub>obs</sub> = 10<sup>4</sup> and <italic>T</italic><sub>obs</sub> = 10<sup>5</sup> was not measured, so these values are estimated and between brackets. (<xref ref-type="fig" rid="pcbi.1007181.g007">Fig 7</xref> shows the corresponding accuracies).</p>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t003g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t003" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left"><italic>T</italic><sub>obs</sub></th>
<th align="right">10<sup>2</sup></th>
<th align="right">5 ⋅ 10<sup>2</sup></th>
<th align="right">10<sup>3</sup></th>
<th align="right">10<sup>4</sup></th>
<th align="right">10<sup>5</sup></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">time SL<sup>Orig</sup></td>
<td align="right">716 s</td>
<td align="right">3549 s</td>
<td align="right">5841 s</td>
<td align="right">(50000 s)</td>
<td align="right">(500000 s)</td>
</tr>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e159">
<alternatives>
<graphic id="pcbi.1007181.e159g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e159" xlink:type="simple"/>
<mml:math display="inline" id="M159">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>GRID</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula> times faster</td>
<td align="right">16273</td>
<td align="right">80659</td>
<td align="right">132750</td>
<td align="right">(1000000)</td>
<td align="right">(10000000)</td>
</tr>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e160">
<alternatives>
<graphic id="pcbi.1007181.e160g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e160" xlink:type="simple"/>
<mml:math display="inline" id="M160">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula> times faster</td>
<td align="right">194</td>
<td align="right">959</td>
<td align="right">1578</td>
<td align="right">(10000)</td>
<td align="right">(100000)</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec018">
<title>Results coverage</title>
<p>Next, we look at the coverage rates of the 95% confidence intervals as obtained with the bootstrap in combination with the prepaid method. To estimate a 95% confidence interval of the estimates for the prepaid method, a parametric bootstrap with <italic>B</italic> = 1000 bootstrap samples was used.</p>
<p>For the prepaid version the estimate for the observed data set was obtained using the <inline-formula id="pcbi.1007181.e154"><alternatives><graphic id="pcbi.1007181.e154g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e154" xlink:type="simple"/><mml:math display="inline" id="M154"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach and the bootstrap estimates were commonly obtained using the <inline-formula id="pcbi.1007181.e155"><alternatives><graphic id="pcbi.1007181.e155g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e155" xlink:type="simple"/><mml:math display="inline" id="M155"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> prepaid method applied to the bootstrap data sets. However, if in the first 100 bootstraps only half of the nearest neighbors where unique points, the bootstrap distribution could be considered questionable. This behavior is to be expected for larger sample sizes <italic>T</italic><sub>obs</sub>, because the true bootstrap distribution is very peaked so that every bootstrap sample will have the same nearest neighbor grid point. When this occurs, we would estimate the parameters of each bootstrap using differential evolution, using the SVM created by the original 100 nearest neighbors.</p>
<p>Alternatively, for the synthetic likelihood approach (using MCMC) we computed the 95% confidence interval by calculating the 0.025 and 0.975 quantiles of the last half of the posterior samples.</p>
<p>The coverage results for the test set of 100 parameters are shown for three different values of <italic>T</italic><sub>obs</sub> in <xref ref-type="table" rid="pcbi.1007181.t004">Table 4</xref>. It can be seen that for both methods, the coverage is close to the nominal level of 95%, but the coverage of the prepaid method is slightly better.</p>
<table-wrap id="pcbi.1007181.t004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t004</object-id>
<label>Table 4</label>
<caption>
<title>The effective coverages of the test set for different <italic>T</italic><sub>obs</sub>.</title>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t004g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t004" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left"/>
<th align="right"><italic>T</italic><sub>obs</sub></th>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" rowspan="3">SL<sup>Orig</sup></td>
<td align="right">10<sup>2</sup></td>
<td align="char" char=".">0.9</td>
<td align="char" char=".">0.89</td>
<td align="char" char=".">0.93</td>
</tr>
<tr>
<td align="right">5 ⋅ 10<sup>2</sup></td>
<td align="char" char=".">0.94</td>
<td align="char" char=".">0.92</td>
<td align="char" char=".">0.94</td>
</tr>
<tr>
<td align="right">10<sup>3</sup></td>
<td align="char" char=".">0.92</td>
<td align="char" char=".">0.91</td>
<td align="char" char=".">0.92</td>
</tr>
<tr>
<td align="left" rowspan="3">prepaid</td>
<td align="right">10<sup>2</sup></td>
<td align="char" char=".">0.95</td>
<td align="char" char=".">0.84</td>
<td align="char" char=".">0.97</td>
</tr>
<tr>
<td align="right">5 ⋅ 10<sup>2</sup></td>
<td align="char" char=".">0.96</td>
<td align="char" char=".">0.94</td>
<td align="char" char=".">0.96</td>
</tr>
<tr>
<td align="right">10<sup>3</sup></td>
<td align="char" char=".">0.97</td>
<td align="char" char=".">0.95</td>
<td align="char" char=".">0.97</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec019">
<title>Results prior</title>
<p>In this paragraph we show how we can benefit from using the correct prior. We estimate the parameters of the three testsets for <italic>T</italic><sub>obs</sub> = 100, created with uniform prior <italic>P</italic><sub>1</sub> from <xref ref-type="disp-formula" rid="pcbi.1007181.e106">Eq 9</xref> and beta distribution priors <italic>P</italic><sub>2</sub> and <italic>P</italic><sub>3</sub> from Eqs <xref ref-type="disp-formula" rid="pcbi.1007181.e123">14</xref> and <xref ref-type="disp-formula" rid="pcbi.1007181.e124">15</xref>. We estimated all three data sets using maximum a posteriori estimation <inline-formula id="pcbi.1007181.e156"><alternatives><graphic id="pcbi.1007181.e156g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e156" xlink:type="simple"/><mml:math display="inline" id="M156"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>MAP</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> using all three priors. The results are shown in <xref ref-type="table" rid="pcbi.1007181.t005">Table 5</xref>. Using the correct prior leads, as expected, to the best results.</p>
<table-wrap id="pcbi.1007181.t005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t005</object-id>
<label>Table 5</label>
<caption>
<title>RMSE of <inline-formula id="pcbi.1007181.e161"><alternatives><graphic id="pcbi.1007181.e161g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e161" xlink:type="simple"/><mml:math display="inline" id="M161"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>MAP</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> estimation of test sets with <italic>T</italic><sub>obs</sub> = 100 created with priors <italic>P</italic><sub>1</sub>, <italic>P</italic><sub>2</sub> and <italic>P</italic><sub>3</sub> and estimated by using priors <italic>P</italic><sub>1</sub>, <italic>P</italic><sub>2</sub> and <italic>P</italic><sub>3</sub>.</title>
<p>For each test set and parameter the best result is shown in bold.</p>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t005g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t005" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left"/>
<th align="center" colspan="3">estimated with <italic>P</italic><sub>1</sub></th>
<th align="center" colspan="3">estimated with <italic>P</italic><sub>2</sub></th>
<th align="center" colspan="3">estimated with <italic>P</italic><sub>3</sub></th>
</tr>
<tr>
<th align="left">parameter</th>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">test set created with <italic>P</italic><sub>1</sub></td>
<td align="right"><bold>8.2</bold></td>
<td align="char" char="."><bold>0.13</bold></td>
<td align="char" char="."><bold>0.53</bold></td>
<td align="right">10</td>
<td align="char" char=".">0.12</td>
<td align="char" char=".">0.82</td>
<td align="right">16</td>
<td align="char" char=".">0.17</td>
<td align="char" char=".">0.94</td>
</tr>
<tr>
<td align="left">test set created with <italic>P</italic><sub>1</sub></td>
<td align="right">10</td>
<td align="char" char=".">0.13</td>
<td align="char" char=".">0.55</td>
<td align="right"><bold>6.5</bold></td>
<td align="char" char="."><bold>0.072</bold></td>
<td align="char" char="."><bold>0.43</bold></td>
<td align="right">11</td>
<td align="char" char=".">0.12</td>
<td align="char" char=".">0.60</td>
</tr>
<tr>
<td align="left">test set created with <italic>P</italic><sub>1</sub></td>
<td align="right">4.4</td>
<td align="char" char=".">0.15</td>
<td align="char" char=".">0.33</td>
<td align="right">6.9</td>
<td align="char" char=".">0.19</td>
<td align="char" char=".">0.51</td>
<td align="right"><bold>3.5</bold></td>
<td align="char" char="."><bold>0.065</bold></td>
<td align="char" char="."><bold>0.28</bold></td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec020">
<title>Parameter constraints across conditions</title>
<p>We estimated the parameters for a two condition experimental set up with equal <italic>r</italic> and <italic>σ</italic>, with and without the prior from <xref ref-type="disp-formula" rid="pcbi.1007181.e109">Eq 11</xref> (parameter <italic>σ</italic><sub><italic>prior</italic></sub> was tuned on 100 similar simulated data sets). The results are shown in <xref ref-type="table" rid="pcbi.1007181.t006">Table 6</xref>. Using the prior from <xref ref-type="disp-formula" rid="pcbi.1007181.e109">Eq 11</xref>, which implements the parameter constraints of the experimental set up, leads, as expected, to better results for each parameter. Even for <italic>ϕ</italic>, which is absent in the prior, we find better results.</p>
<table-wrap id="pcbi.1007181.t006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t006</object-id>
<label>Table 6</label>
<caption>
<title>RMSE for Ricker model data where <italic>T</italic><sub>obs</sub> = 100 for an experimental set up with two conditions where <italic>r</italic> and <italic>σ</italic> are equal over the conditions.</title>
<p>Parameters are estimated by using <inline-formula id="pcbi.1007181.e162"><alternatives><graphic id="pcbi.1007181.e162g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e162" xlink:type="simple"/><mml:math display="inline" id="M162"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>MAP</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> with a flat prior (same as <inline-formula id="pcbi.1007181.e163"><alternatives><graphic id="pcbi.1007181.e163g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e163" xlink:type="simple"/><mml:math display="inline" id="M163"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>ML</mml:mtext> <mml:mtext>GRID</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>)and with a prior from <xref ref-type="disp-formula" rid="pcbi.1007181.e109">Eq 11</xref>.</p>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t006g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t006" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left">prior</th>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">flat prior</td>
<td align="right">88</td>
<td align="char" char=".">0.17</td>
<td align="char" char=".">0.42</td>
</tr>
<tr>
<td align="left">prior <xref ref-type="disp-formula" rid="pcbi.1007181.e109">Eq 11</xref></td>
<td align="right">61</td>
<td align="char" char=".">0.11</td>
<td align="char" char=".">0.36</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec021">
<title>Results real life data set</title>
<p>The results for the estimation of the population dynamics of the Chilo partellus [<xref ref-type="bibr" rid="pcbi.1007181.ref016">16</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref015">15</xref>], using the prior from <xref ref-type="disp-formula" rid="pcbi.1007181.e095">Eq 7</xref> can be found in <xref ref-type="table" rid="pcbi.1007181.t007">Table 7</xref>. For the prepaid, we estimated the parameters using the methods online at <ext-link ext-link-type="uri" xlink:href="http://www.prepaidestimation.org/" xlink:type="simple">http://www.prepaidestimation.org/</ext-link>. All estimations are similar and have overlapping confidence intervals. The prepaid estimation is however significantly faster.</p>
<table-wrap id="pcbi.1007181.t007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t007</object-id>
<label>Table 7</label>
<caption>
<title>Population dynamics of the Chilo partellus [<xref ref-type="bibr" rid="pcbi.1007181.ref016">16</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref015">15</xref>].</title>
<p>We show the estimates, the 95% confidence intervals and computation time of the prepaid and synthetic likelihood estimation techniques.</p>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t007g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t007" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="left"/>
<th align="right">r</th>
<th align="right"><italic>σ</italic></th>
<th align="right"><italic>ϕ</italic></th>
<th align="right">Time (in seconds)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">SL<sup>Orig</sup></td>
<td align="right">1.05 (1.01– 1.1)</td>
<td align="right">0.41 (0.31–0.51)</td>
<td align="right">248.17 (139.53–493.2)</td>
<td align="right">830</td>
</tr>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e164">
<alternatives>
<graphic id="pcbi.1007181.e164g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e164" xlink:type="simple"/>
<mml:math display="inline" id="M164">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>GRID</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="right">1.10 (1.06– 1.34)</td>
<td align="right">0.43 (0.30–0.54)</td>
<td align="right">140.60 (43.94–208.19)</td>
<td align="right">0.2</td>
</tr>
<tr>
<td align="left">
<inline-formula id="pcbi.1007181.e165">
<alternatives>
<graphic id="pcbi.1007181.e165g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e165" xlink:type="simple"/>
<mml:math display="inline" id="M165">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>ML</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="right">1.06 (1.01– 1.24)</td>
<td align="right">0.41 (0.21–0.56)</td>
<td align="right">176.15 (19.27–427.65)</td>
<td align="right">4</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
</sec>
<sec id="sec022">
<title>Application 2: A stochastic model of community dynamics</title>
<p>A second model we will apply our prepaid modeling technique to, is a stochastic dispersal-limited trait-based model of community dynamics [<xref ref-type="bibr" rid="pcbi.1007181.ref017">17</xref>]. The data that will be modeled, are the abundances of species (hence a vector of frequencies, in which each component is a different species). Each species in the local environment is assumed to have a competitive value dependent on its trait <italic>u</italic>, given by the filtering function
<disp-formula id="pcbi.1007181.e166"><alternatives><graphic id="pcbi.1007181.e166g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e166" xlink:type="simple"/><mml:math display="block" id="M166"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>F</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>u</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:mi>A</mml:mi> <mml:msup><mml:mi>e</mml:mi> <mml:mrow><mml:mo>-</mml:mo> <mml:mfrac><mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>u</mml:mi> <mml:mo>-</mml:mo> <mml:mi>h</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mrow><mml:mn>2</mml:mn> <mml:msup><mml:mi>σ</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac></mml:mrow></mml:msup> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(17)</label></disp-formula></p>
<p>Here <italic>A</italic> is the maximal competitive advantage, <italic>h</italic> is the optimal trait value in the local environment and <italic>σ</italic> describes the width of the filtering function. At each time step, one individual from the local community dies. It is then replaced with a probability <inline-formula id="pcbi.1007181.e167"><alternatives><graphic id="pcbi.1007181.e167g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e167" xlink:type="simple"/><mml:math display="inline" id="M167"><mml:mrow><mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mfrac><mml:mi>I</mml:mi> <mml:mrow><mml:mi>I</mml:mi> <mml:mo>+</mml:mo> <mml:mi>J</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula> by a random descendant from the local pool. Here, <italic>J</italic> is the size of the local community and <italic>I</italic> is the fourth parameter to estimate, related to the amount of immigration from the regional pool into the local community. The probability that this descendant comes from a certain individual in the local community, is proportional to the competitiveness of this individual. With a probability of <inline-formula id="pcbi.1007181.e168"><alternatives><graphic id="pcbi.1007181.e168g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e168" xlink:type="simple"/><mml:math display="inline" id="M168"><mml:mfrac><mml:mi>I</mml:mi> <mml:mrow><mml:mi>I</mml:mi> <mml:mo>+</mml:mo> <mml:mi>J</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:math></alternatives></inline-formula>, the dead individual is replaced by an immigrant from the regional pool. The distribution of traits <italic>u</italic> of the individuals in the regional pool is assumed to be uniform over <italic>u</italic>. It is noteworthy that Jabot saw the necessity of reusing ABC simulations to reduce computation time in his recovery study [<xref ref-type="bibr" rid="pcbi.1007181.ref017">17</xref>].</p>
<p>The model was simulated using the C++ code from the Easy ABC package [<xref ref-type="bibr" rid="pcbi.1007181.ref022">22</xref>] where a regional pool of <italic>S</italic> = 1000 species was defined evenly spaced on the trait axis (i.e., the resolution) and <italic>J</italic> = 500 was the size of the local community.</p>
<sec id="sec023">
<title>ABC estimation</title>
<p>We compare our prepaid method estimation with the Easy ABC package (ABC<sup>Orig</sup>) [<xref ref-type="bibr" rid="pcbi.1007181.ref029">29</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref022">22</xref>]. Because we work in a Bayesian framework, we first have to specify priors. As in Jabot et al. we use the following priors [<xref ref-type="bibr" rid="pcbi.1007181.ref022">22</xref>]:
<disp-formula id="pcbi.1007181.e169"><alternatives><graphic id="pcbi.1007181.e169g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e169" xlink:type="simple"/><mml:math display="block" id="M169"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mi>I</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>3</mml:mn> <mml:mo>,</mml:mo> <mml:mn>5</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mi>A</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mn>5</mml:mn> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>h</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mo>-</mml:mo> <mml:mn>25</mml:mn> <mml:mo>,</mml:mo> <mml:mn>125</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mi>σ</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>5</mml:mn> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mo>(</mml:mo> <mml:mn>25</mml:mn> <mml:mo>)</mml:mo> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(18)</label></disp-formula></p>
<p>In this application, the parameter vector <bold><italic>θ</italic></bold> is defined as follows: <bold><italic>θ</italic></bold> = (log(<italic>I</italic>), log(<italic>A</italic>), <italic>h</italic>, log(<italic>σ</italic>)). To get the ABC algorithm to work, we compute four summary statistics: the richness of the community (number of living species), Shannon’s index which measures the entropy of the community, and the mean and the skewness of the trait distribution of the community.</p>
<p>The ABC algorithm we use applies a sequential parameter sampling scheme [<xref ref-type="bibr" rid="pcbi.1007181.ref030">30</xref>]. The sequence of tolerance bounds is given by <italic>ρ</italic> = {8, 5, 3, 1, 0.5, 0.2, 0.1} and the algorithm proceeds to the next tolerance after 200 simulations which lead to summary statistics within the bounds. The last 200 simulations within the bounds represent the posterior, and the estimate of the parameter is given by the posterior mean.</p>
</sec>
<sec id="sec024">
<title>Creation of the prepaid grid</title>
<p>For the prepaid estimation, we used exactly the same summary statistics as the Easy ABC package. We filled the prepaid grid with 500, 000 parameter vectors using the priors of <xref ref-type="disp-formula" rid="pcbi.1007181.e169">Eq 18</xref>, but for most examples we will use a grid with only 100, 000 parameter vectors. To cover this grid as evenly as possible, the uniform distribution was approximated using Halton sequences [<xref ref-type="bibr" rid="pcbi.1007181.ref027">27</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref028">28</xref>] (in order to avoid gaps that may appear when Monte Carlo samples are used). The creation of the prepaid grid with 100, 000 parameter vectors took approximately 3 days on a 3.4GHz 20-core processor.</p>
<p>For the community dynamics models from Eqs <xref ref-type="disp-formula" rid="pcbi.1007181.e166">17</xref> and <xref ref-type="disp-formula" rid="pcbi.1007181.e169">18</xref>, there are several ways to simulate an almost infinitely large data set to achieve stable summary statistics. The first way is to increase the number of species <italic>S</italic> and the size of the local pool <italic>J</italic>. Unfortunately some summary statistics (the richness and the entropy) are in some unknown way dependent on these parameters. As a result, the summary statistics of a simulation with <italic>J</italic> = 5000 cannot be used to estimate the parameters for a setting where <italic>J</italic> = 500. Therefore, we chose to fix the size of the local pool <italic>J</italic> and the number of species <italic>S</italic>. It is very well possible that there are summary statistics which do not have this problem, making the prepaid grid much more universal. We chose however, for the sake of comparison with the easy ABC package to keep using these parameters.</p>
<p>A second way to simulate data with a very large sample size is by increasing the number of time steps. By estimating the summary statistics after each time step, when one individual from the local community dies and is replaced by another individual, we create a time series of summary statistics. Averaging the summary statistics over a sufficient large number of time points will lead to stable average values of these summary statistics. In our simulations, we applied some tinning by calculating the summary statistics every time after 500 species have died (the size of the community). The reasons is that there is not enough of variation in the summary statistics computed after the death of a single species. Next, we created time series of length <italic>T</italic> = 100, 000 (5 ⋅ 10<sup>7</sup> species will have been replaced) for the prepaid grid and used the average of these summary statistics as <inline-formula id="pcbi.1007181.e170"><alternatives><graphic id="pcbi.1007181.e170g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e170" xlink:type="simple"/><mml:math display="inline" id="M170"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi mathvariant="bold-italic">θ</mml:mi></mml:msub></mml:math></alternatives></inline-formula>. Using this time series we also computed <inline-formula id="pcbi.1007181.e171"><alternatives><graphic id="pcbi.1007181.e171g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e171" xlink:type="simple"/><mml:math display="inline" id="M171"><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> for <italic>T</italic><sub>prepaid</sub> = {1, 10, 1000, 10000}. <italic>T</italic><sub>prepaid</sub> = 1 is of course the setting for which the original trait model is described and for which the Easy ABC algorithm is tested. Additionally we also saved 1000 samples of time series of length <italic>T</italic><sub>prepaid</sub> = {1, 10, 1000, 10000}.</p>
</sec>
<sec id="sec025">
<title>Prepaid estimation</title>
<p>Contrary to the first application (the Ricker model), where we used a frequentist approach, for this community dynamics model we will follow a Bayesian approach. In Bayesian statistics, the focus is on the posterior distribution of the parameters <italic>p</italic>(<bold><italic>θ</italic></bold>|data), which is defined as follows:
<disp-formula id="pcbi.1007181.e172"><alternatives><graphic id="pcbi.1007181.e172g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e172" xlink:type="simple"/><mml:math display="block" id="M172"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>p</mml:mi> <mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>|</mml:mo> <mml:mtext>data</mml:mtext> <mml:mo>)</mml:mo> <mml:mo>∝</mml:mo> <mml:mi>p</mml:mi> <mml:mo>(</mml:mo> <mml:mtext>data</mml:mtext> <mml:mo>|</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo> <mml:mo>×</mml:mo> <mml:mi>p</mml:mi> <mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(19)</label></disp-formula>
where <italic>p</italic>(data|<bold><italic>θ</italic></bold>) is the likelihood and <italic>p</italic>(<bold><italic>θ</italic></bold>) the prior. As the likelihood, we will use the synthetic likelihood <italic>p</italic>(data|<bold><italic>θ</italic></bold>) ≈ <italic>L</italic><sub><italic>s</italic></sub>(<bold><italic>θ</italic></bold>) = exp(<italic>l</italic><sub><italic>s</italic></sub>(<bold><italic>θ</italic></bold>)), where <italic>l</italic><sub><italic>s</italic></sub>(<bold><italic>θ</italic></bold>) is the synthetic log-likelihood as defined in <xref ref-type="disp-formula" rid="pcbi.1007181.e085">Eq 4</xref> (based on the vector of summary statistics <bold><italic>s</italic></bold><sup>obs</sup>). Because we compress the data into summary statistics, the posterior we work with is actually an approximation to the true posterior: <italic>p</italic>(<bold><italic>θ</italic></bold>|<bold><italic>s</italic></bold><sup><italic>obs</italic></sup>) ≈ <italic>p</italic>(<bold><italic>θ</italic></bold>|data) (in case the summary statistics are sufficient statistics for <bold><italic>θ</italic></bold>, the approximation sign becomes an equality sign). The distributions from <xref ref-type="disp-formula" rid="pcbi.1007181.e169">Eq 18</xref> are the priors for the parameters.</p>
<p>We have studied three variants of a Bayesian version of the prepaid method. These three versions will be discussed here in increasing order of complexity. We will denote the three variants as follows: <inline-formula id="pcbi.1007181.e173"><alternatives><graphic id="pcbi.1007181.e173g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e173" xlink:type="simple"/><mml:math display="inline" id="M173"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1007181.e174"><alternatives><graphic id="pcbi.1007181.e174g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e174" xlink:type="simple"/><mml:math display="inline" id="M174"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, and <inline-formula id="pcbi.1007181.e175"><alternatives><graphic id="pcbi.1007181.e175g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e175" xlink:type="simple"/><mml:math display="inline" id="M175"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>.</p>
<p>First we will discuss <inline-formula id="pcbi.1007181.e176"><alternatives><graphic id="pcbi.1007181.e176g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e176" xlink:type="simple"/><mml:math display="inline" id="M176"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant. Because the priors are all uniform (and our prepaid grid is distributed following this prior), the posterior for a data set with summary statistic <bold><italic>s</italic></bold> at parameter <bold><italic>θ</italic></bold><sub><italic>p</italic></sub> of the prepaid grid is proportional to
<disp-formula id="pcbi.1007181.e177"><alternatives><graphic id="pcbi.1007181.e177g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e177" xlink:type="simple"/><mml:math display="block" id="M177"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>p</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>|</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>∝</mml:mo> <mml:msubsup><mml:mi>L</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(20)</label></disp-formula>
where <inline-formula id="pcbi.1007181.e178"><alternatives><graphic id="pcbi.1007181.e178g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e178" xlink:type="simple"/><mml:math display="inline" id="M178"><mml:mrow><mml:msubsup><mml:mi>L</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is the prepaid synthetic likelihood (i.e., with the mean statistics computed for a very large sample and a approximate covariance matrix given by <xref ref-type="disp-formula" rid="pcbi.1007181.e094">Eq 6</xref>). The posterior mean (PM), used in this variant, using prepaid synthetic likelihood can be estimated as:
<disp-formula id="pcbi.1007181.e179"><alternatives><graphic id="pcbi.1007181.e179g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e179" xlink:type="simple"/><mml:math display="block" id="M179"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mo>|</mml:mo></mml:mrow> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>=</mml:mo> <mml:mfrac><mml:mrow><mml:msub><mml:mo>∑</mml:mo> <mml:mi>p</mml:mi></mml:msub> <mml:mrow><mml:msubsup><mml:mi>L</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>p</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>×</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:mrow> <mml:mrow><mml:msub><mml:mo>∑</mml:mo> <mml:mi>p</mml:mi></mml:msub> <mml:mrow><mml:msubsup><mml:mi>L</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>p</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(21)</label></disp-formula></p>
<p>Second we will discuss the <inline-formula id="pcbi.1007181.e180"><alternatives><graphic id="pcbi.1007181.e180g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e180" xlink:type="simple"/><mml:math display="inline" id="M180"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant. The prepaid synthetic likelihood approach works best if the assumption of normally distributed summary statistics is not too far off. However, as can be seen in <xref ref-type="fig" rid="pcbi.1007181.g009">Fig 9</xref>, this is not always the case for the trait model defined in <xref ref-type="disp-formula" rid="pcbi.1007181.e166">Eq 17</xref>. Therefore, as an alternative procedure, we propose an Approximate Bayesian Computation (ABC) approach in this variant. First, we select a subset of nearest neighbors <inline-formula id="pcbi.1007181.e181"><alternatives><graphic id="pcbi.1007181.e181g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e181" xlink:type="simple"/><mml:math display="inline" id="M181"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula> from the prepaid set, such that for every <inline-formula id="pcbi.1007181.e182"><alternatives><graphic id="pcbi.1007181.e182g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e182" xlink:type="simple"/><mml:math display="inline" id="M182"><mml:mrow><mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>q</mml:mi></mml:msub> <mml:mo>∈</mml:mo> <mml:mi mathvariant="script">S</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>, the synthetic likelihood value <italic>L</italic><sub><italic>s</italic></sub>(<bold><italic>θ</italic></bold><sub><italic>q</italic></sub>) is highest and so that
<disp-formula id="pcbi.1007181.e183"><alternatives><graphic id="pcbi.1007181.e183g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e183" xlink:type="simple"/><mml:math display="block" id="M183"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mo>∑</mml:mo> <mml:mi>q</mml:mi></mml:msub> <mml:mrow><mml:msubsup><mml:mi>L</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>q</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow> <mml:mrow><mml:msub><mml:mo>∑</mml:mo> <mml:mi>p</mml:mi></mml:msub> <mml:mrow><mml:msubsup><mml:mi>L</mml:mi> <mml:mi>s</mml:mi> <mml:mtext>PP</mml:mtext></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mi>p</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow></mml:mfrac> <mml:mo>&lt;</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>999</mml:mn> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(22)</label></disp-formula>
where the sum in the denominator runs across all grid points. In a sense, these are all the prepaid points in the 99.9% expected coverage according to the posterior of <xref ref-type="disp-formula" rid="pcbi.1007181.e177">Eq 20</xref>. We denote the cardinality of <inline-formula id="pcbi.1007181.e184"><alternatives><graphic id="pcbi.1007181.e184g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e184" xlink:type="simple"/><mml:math display="inline" id="M184"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula> as <italic>Q</italic>.</p>
<fig id="pcbi.1007181.g009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g009</object-id>
<label>Fig 9</label>
<caption>
<title>Samples for <italic>T</italic><sub>obs</sub> = 1 of the summary statistics of the trait model for parameter set log(<italic>I</italic>) = 3.0621, log(<italic>A</italic>) = 0.8302, <italic>h</italic> = 86.8924 and log(<italic>σ</italic>) = −0.6899.</title>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g009" xlink:type="simple"/>
</fig>
<p>In a next step, we basically perform ABC with all the grid points belonging to the selected subset <inline-formula id="pcbi.1007181.e185"><alternatives><graphic id="pcbi.1007181.e185g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e185" xlink:type="simple"/><mml:math display="inline" id="M185"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula>. However, there is an important issue we cannot overlook. When doing ABC, for a given parameter vector new data are simulated of the same size as the observed data. Unfortunately, our prepaid grid has correspondingly only very large data sets. To rectify this problem, so that ABC can applied without problems, we simulated during the construction of the prepaid grid, a set of <italic>M</italic> = 1000 prepaid samples for several designated sample sizes (i.e., <italic>T</italic><sub>prepaid</sub> = {1, 10, 1000, 10000}). Let us denote with <inline-formula id="pcbi.1007181.e186"><alternatives><graphic id="pcbi.1007181.e186g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e186" xlink:type="simple"/><mml:math display="inline" id="M186"><mml:msub><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mi>q</mml:mi> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> the vector of statistics for prepaid grid point <italic>q</italic>, the <italic>i</italic>th simulation (with <italic>i</italic> = 1, …, <italic>M</italic>) and sample size <italic>T</italic><sub>prepaid</sub>.</p>
<p>Now, we can apply ABC to arrive at the posterior for <bold><italic>θ</italic></bold>; the method will be denoted as <inline-formula id="pcbi.1007181.e187"><alternatives><graphic id="pcbi.1007181.e187g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e187" xlink:type="simple"/><mml:math display="inline" id="M187"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>. For now we will assume that <italic>T</italic><sub>obs</sub> is equal to one of the <italic>T</italic><sub>prepaid</sub> lenghts. We select the 1000 samples from this <italic>Q</italic> × 1000 samples set that have the smallest Mahalonobis distance to the observed set of statistics <bold><italic>s</italic></bold><sup>obs</sup>:
<disp-formula id="pcbi.1007181.e188"><alternatives><graphic id="pcbi.1007181.e188g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e188" xlink:type="simple"/><mml:math display="block" id="M188"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mi>ϵ</mml:mi> <mml:mrow><mml:mi>q</mml:mi> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mi>q</mml:mi> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>ABC</mml:mtext></mml:msub></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:msubsup><mml:mi mathvariant="bold-italic">W</mml:mi> <mml:mrow><mml:mi>Q</mml:mi></mml:mrow> <mml:mrow><mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mrow><mml:mi>q</mml:mi> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>ABC</mml:mtext></mml:msub></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msup><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mtext>obs</mml:mtext></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(23)</label></disp-formula>
here <bold><italic>W</italic></bold><sub><italic>Q</italic></sub> is given by the covariance over all grid points in <inline-formula id="pcbi.1007181.e189"><alternatives><graphic id="pcbi.1007181.e189g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e189" xlink:type="simple"/><mml:math display="inline" id="M189"><mml:mi mathvariant="script">S</mml:mi></mml:math></alternatives></inline-formula> and over all 1000 replications (thus, <italic>Q</italic> × 1000). The finally selected 1000 samples are then considered as a sample from the posterior. Note that the <inline-formula id="pcbi.1007181.e190"><alternatives><graphic id="pcbi.1007181.e190g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e190" xlink:type="simple"/><mml:math display="inline" id="M190"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> method does not require us to progressively strengthen the tolerances, as in traditional ABC<sup>Orig</sup> (governed by the tolerance parameter <italic>ρ</italic>). If the observed sample size <italic>T</italic><sub>obs</sub> is not equal to one of the <italic>T</italic><sub>prepaid</sub> lengths, then one can use the samples for length <italic>T</italic><sub>prepaid</sub> which is closest to <italic>T</italic><sub>obs</sub> in logaritmic scale and later adjust the posterior samples such that the posterior mean stays the same, but the posterior covariance matrix changes to
<disp-formula id="pcbi.1007181.e191"><alternatives><graphic id="pcbi.1007181.e191g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e191" xlink:type="simple"/><mml:math display="block" id="M191"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>o</mml:mi> <mml:mi>s</mml:mi> <mml:mi>t</mml:mi> <mml:mi>e</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mfrac><mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>obs</mml:mtext></mml:msub></mml:mfrac> <mml:msub><mml:mover accent="true"><mml:mo>Σ</mml:mo> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>p</mml:mi> <mml:mi>o</mml:mi> <mml:mi>s</mml:mi> <mml:mi>t</mml:mi> <mml:mi>e</mml:mi> <mml:mi>r</mml:mi> <mml:mi>i</mml:mi> <mml:mi>o</mml:mi> <mml:mi>r</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>prepaid</mml:mtext></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(24)</label></disp-formula></p>
<p>We advise to save samples for enough different <italic>T</italic><sub>prepaid</sub> such that this correction is only marginal.</p>
<p>Lastly, we will discuss the <inline-formula id="pcbi.1007181.e192"><alternatives><graphic id="pcbi.1007181.e192g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e192" xlink:type="simple"/><mml:math display="inline" id="M192"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant. The <inline-formula id="pcbi.1007181.e193"><alternatives><graphic id="pcbi.1007181.e193g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e193" xlink:type="simple"/><mml:math display="inline" id="M193"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> is only based on the raw prepaid grid points. But again, a more accurate estimation can be found by interpolating between the parameters in the prepaid grid. Therefore, in this <inline-formula id="pcbi.1007181.e194"><alternatives><graphic id="pcbi.1007181.e194g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e194" xlink:type="simple"/><mml:math display="inline" id="M194"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant, we learn the relation between the parameters and the summary statistics using LS-SVM: <inline-formula id="pcbi.1007181.e195"><alternatives><graphic id="pcbi.1007181.e195g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e195" xlink:type="simple"/><mml:math display="inline" id="M195"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi></mml:mrow></mml:msub> <mml:mo>:</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>↦</mml:mo> <mml:mi mathvariant="bold-italic">s</mml:mi></mml:mrow></mml:math></alternatives></inline-formula>. We only learn this relation in the region of interest, that is, only the 100 nearest neighbors according to the <inline-formula id="pcbi.1007181.e196"><alternatives><graphic id="pcbi.1007181.e196g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e196" xlink:type="simple"/><mml:math display="inline" id="M196"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach or more specifically, the 100 prepaid points for which the most samples lead to a small enough <inline-formula id="pcbi.1007181.e197"><alternatives><graphic id="pcbi.1007181.e197g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e197" xlink:type="simple"/><mml:math display="inline" id="M197"><mml:msub><mml:mi>ϵ</mml:mi> <mml:mrow><mml:mi>q</mml:mi> <mml:mo>,</mml:mo> <mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mtext>ABC</mml:mtext></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.</p>
<p>Before we use machine learning to infer the relation <inline-formula id="pcbi.1007181.e198"><alternatives><graphic id="pcbi.1007181.e198g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e198" xlink:type="simple"/><mml:math display="inline" id="M198"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi></mml:mrow></mml:msub> <mml:mo>:</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>↦</mml:mo> <mml:mi mathvariant="bold-italic">s</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> we cluster these 100 nearest neighbors using hierarchical clustering such that no cluster has more than 50 prepaid points. This is necessary as these 100 nearest neighbors may come from totally different areas in the prepaid grid. This is illustrated in <xref ref-type="fig" rid="pcbi.1007181.g010">Fig 10</xref>.</p>
<fig id="pcbi.1007181.g010" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g010</object-id>
<label>Fig 10</label>
<caption>
<title>Scatter plot matrix of the clustering that occurs for the 100 nearest neighbors for the summary statistics for <italic>T</italic><sub>obs</sub> = 1000 of parameter log(<italic>I</italic>) = 3.9081, log(<italic>A</italic>) = −2.0343, <italic>h</italic> = 36.4150 and log(<italic>σ</italic>) = 2.9762.</title>
<p>The red cross shows the true value of this parameter.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g010" xlink:type="simple"/>
</fig>
<p>For each cluster, we first make sure that at least 20 points are included (if not, we add points from the prepaid grid which are closest). Then we estimate the <inline-formula id="pcbi.1007181.e199"><alternatives><graphic id="pcbi.1007181.e199g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e199" xlink:type="simple"/><mml:math display="inline" id="M199"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi></mml:mrow></mml:msub> <mml:mo>:</mml:mo> <mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mo>↦</mml:mo> <mml:mi mathvariant="bold-italic">s</mml:mi></mml:mrow></mml:math></alternatives></inline-formula> using LS-SVM for each cluster <italic>c</italic> separately, giving rise to <inline-formula id="pcbi.1007181.e200"><alternatives><graphic id="pcbi.1007181.e200g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e200" xlink:type="simple"/><mml:math display="inline" id="M200"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. Next, we find the minimum volume ellipse encompassing all the points in each cluster. These ellipses inform us about the areas for which the relation holds. Subsequently we resample parameters in each ellipse to zoom in more and more to the regions of interests. In detail, we do the following in every cluster <italic>c</italic>:</p>
<list list-type="order">
<list-item>
<p>Uniformly sample 1000 points <bold><italic>θ</italic></bold><sub><italic>j</italic>,<italic>c</italic></sub> in the minimum volume ellipse for cluster <italic>c</italic>. We create a finer grid for each elipse.</p>
</list-item>
<list-item>
<p>Find the summary statistics based on the LS-SVM in cluster <italic>c</italic>: <inline-formula id="pcbi.1007181.e201"><alternatives><graphic id="pcbi.1007181.e201g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e201" xlink:type="simple"/><mml:math display="inline" id="M201"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">f</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>s</mml:mi> <mml:mi>v</mml:mi> <mml:mi>m</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">θ</mml:mi> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
</list-item>
<list-item>
<p>Find for each point <bold><italic>θ</italic></bold><sub><italic>j</italic>,<italic>c</italic></sub> the nearest point <bold><italic>θ</italic></bold><sub><italic>p</italic></sub> from the prepaid points with which this particular cluster was created</p>
</list-item>
<list-item>
<p>Translate the 1000 samples from the nearest point <bold><italic>θ</italic></bold><sub><italic>p</italic></sub> to the newly sampled point <bold><italic>θ</italic></bold><sub><italic>j</italic>,<italic>c</italic></sub> and add to each sample the difference in summary statistics: <inline-formula id="pcbi.1007181.e202"><alternatives><graphic id="pcbi.1007181.e202g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e202" xlink:type="simple"/><mml:math display="inline" id="M202"><mml:mrow><mml:mi mathvariant="bold-italic">d</mml:mi> <mml:mo>=</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mi>p</mml:mi></mml:msub></mml:mrow></mml:math></alternatives></inline-formula>. In this step we aproximate a distribution of statistics for <bold><italic>θ</italic></bold><sub><italic>j</italic>,<italic>c</italic></sub> around <inline-formula id="pcbi.1007181.e203"><alternatives><graphic id="pcbi.1007181.e203g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e203" xlink:type="simple"/><mml:math display="inline" id="M203"><mml:msub><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>j</mml:mi> <mml:mo>,</mml:mo> <mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>.</p>
</list-item>
<list-item>
<p>Keep the points <bold><italic>θ</italic></bold><sub><italic>j</italic></sub> for which <italic>ϵ</italic><sub><italic>j</italic>,<italic>i</italic></sub> from <xref ref-type="disp-formula" rid="pcbi.1007181.e188">Eq 23</xref> is among the 5000 smallest distances and remove all others.</p>
</list-item>
<list-item>
<p>Recalculate the minimum volume ellipse with the new points.</p>
</list-item>
<list-item>
<p>Go back to step 1, until the worst <italic>ϵ</italic><sub><italic>j</italic>,<italic>i</italic></sub> does not decrease any more.</p>
</list-item>
</list>
<p>Broadly speaking, in step 1, we sample parameters <bold><italic>θ</italic></bold><sub><italic>j</italic>,<italic>c</italic></sub>, in step 2 to 4 we approximate the summary statistics distribution for each <bold><italic>θ</italic></bold><sub><italic>j</italic>,<italic>c</italic></sub> using LS-SVM and in step 5 to 7 we trim this set of parameters to only keep the parameters with a high posterior probability.</p>
<p>In the end we combine all the samples, we build the posterior with the parameters from the 1000 best samples over all clusters according to <xref ref-type="disp-formula" rid="pcbi.1007181.e188">Eq 23</xref>. Note that some parameters may show up several times in this posterior sample. To compute the posterior mean, we use a weighted version of these samples. The weights are given by the volume of the ellipse from the cluster where they were created. This is necessary to ensure the correct use of the equal prior for all clusters.</p>
</sec>
<sec id="sec026">
<title>Test set</title>
<p>To generate the test set, we follow the same logic as in [<xref ref-type="bibr" rid="pcbi.1007181.ref017">17</xref>]. We use the prior in <xref ref-type="disp-formula" rid="pcbi.1007181.e169">Eq 18</xref> to generate 1000 random parameter sets, except for <italic>h</italic>, where we changed the prior with the following generating distribution:
<disp-formula id="pcbi.1007181.e204"><alternatives><graphic id="pcbi.1007181.e204g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e204" xlink:type="simple"/><mml:math display="block" id="M204"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>h</mml:mi> <mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mn>100</mml:mn> <mml:mo>)</mml:mo> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(25)</label></disp-formula>
such that 0 and 100 are the true minimum and maximum optimal trait values for communities. By taking the prior for <italic>h</italic> as in <xref ref-type="disp-formula" rid="pcbi.1007181.e169">Eq 18</xref>, we avoid boundary effects. To exclude other problems at the borders of the parameter space, we deleted parameters which where within 1% range of the bounds. We simulated data sets for both <italic>T</italic><sub>obs</sub> = 1 and <italic>T</italic><sub>obs</sub> = 1000.</p>
</sec>
<sec id="sec027">
<title>Results accuracy</title>
<p>Let us first look at the results for <italic>T</italic><sub>obs</sub> = 1. We have used traditional ABC (ABC<sup>Orig</sup>), prepaid Bayes approach based on the synthetic likelihood (<inline-formula id="pcbi.1007181.e205"><alternatives><graphic id="pcbi.1007181.e205g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e205" xlink:type="simple"/><mml:math display="inline" id="M205"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>) and prepaid ABC based on separately generated samples at the grid points (<inline-formula id="pcbi.1007181.e206"><alternatives><graphic id="pcbi.1007181.e206g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e206" xlink:type="simple"/><mml:math display="inline" id="M206"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e207"><alternatives><graphic id="pcbi.1007181.e207g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e207" xlink:type="simple"/><mml:math display="inline" id="M207"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>). We have used 10<sup>5</sup> and 5 ⋅ 10<sup>5</sup> prepaid grid points. The RMSE and MAE can be found in Tables <xref ref-type="table" rid="pcbi.1007181.t001">1</xref> and <xref ref-type="table" rid="pcbi.1007181.t008">8</xref>. All methods result in accuracies that are equally large. For 3 out of 4 parameters (except for <italic>h</italic>), the prepaid method outperforms ABC<sup>Orig</sup> with respect to RMSE. For MAE, the prepaid method uniformly outperforms the Easy ABC package (ABC<sup>Orig</sup>). Overal, the difference between Ω = 10<sup>5</sup> and Ω = 5 ⋅ 10<sup>5</sup> prepaid grid point is very small for the prepaid methods.</p>
<table-wrap id="pcbi.1007181.t008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t008</object-id>
<label>Table 8</label>
<caption>
<title>The MAE of the estimations of the test set of the trait model.</title>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t008g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t008" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="center"><italic>T</italic><sub>obs</sub></th>
<th align="left">version</th>
<th align="left">Ω</th>
<th align="right">log(<italic>I</italic>)</th>
<th align="right">log(<italic>A</italic>)</th>
<th align="right"><italic>h</italic></th>
<th align="right">log(<italic>σ</italic>)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="left">ABC<sup>Orig</sup></td>
<td align="left">/</td>
<td align="char" char=".">0.11</td>
<td align="char" char=".">0.45</td>
<td align="right">1.4</td>
<td align="char" char=".">0.45</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e214">
<alternatives>
<graphic id="pcbi.1007181.e214g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e214" xlink:type="simple"/>
<mml:math display="inline" id="M214">
<mml:msubsup>
<mml:mtext>SL</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.1</td>
<td align="char" char=".">0.39</td>
<td align="right">0.96</td>
<td align="char" char=".">0.38</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e215">
<alternatives>
<graphic id="pcbi.1007181.e215g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e215" xlink:type="simple"/>
<mml:math display="inline" id="M215">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.1</td>
<td align="char" char=".">0.4</td>
<td align="right">1</td>
<td align="char" char=".">0.4</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e216">
<alternatives>
<graphic id="pcbi.1007181.e216g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e216" xlink:type="simple"/>
<mml:math display="inline" id="M216">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.1</td>
<td align="char" char=".">0.38</td>
<td align="right">1</td>
<td align="char" char=".">0.39</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e217">
<alternatives>
<graphic id="pcbi.1007181.e217g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e217" xlink:type="simple"/>
<mml:math display="inline" id="M217">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.03</td>
<td align="char" char=".">0.14</td>
<td align="right">0.39</td>
<td align="char" char=".">0.32</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e218">
<alternatives>
<graphic id="pcbi.1007181.e218g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e218" xlink:type="simple"/>
<mml:math display="inline" id="M218">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.02</td>
<td align="char" char=".">0.09</td>
<td align="right">0.27</td>
<td align="char" char=".">0.22</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e219">
<alternatives>
<graphic id="pcbi.1007181.e219g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e219" xlink:type="simple"/>
<mml:math display="inline" id="M219">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.02</td>
<td align="char" char=".">0.07</td>
<td align="right">0.18</td>
<td align="char" char=".">0.14</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e220">
<alternatives>
<graphic id="pcbi.1007181.e220g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e220" xlink:type="simple"/>
<mml:math display="inline" id="M220">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.01</td>
<td align="char" char=".">0.07</td>
<td align="right">0.17</td>
<td align="char" char=".">0.15</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
<p>We have refrained from interpolating with the LS-SVM because the 99.9% coverage includes on average more than 1000 points. This is perfectly logical because <italic>T</italic><sub>obs</sub> = 1 does not provide a lot of information, and, as a consequence, there is a lot of uncertainty (which translates itself into a large number of parameter points that have a reasonable large synthetic likelihood value). As a result, creating a posterior based on only 100 nearest neighbors (even after interpolation) would not suffice because too many parameter points with high posterior density would be missed.</p>
<p>For <italic>T</italic><sub>obs</sub> = 1000 (see again Tables <xref ref-type="table" rid="pcbi.1007181.t001">1</xref> and <xref ref-type="table" rid="pcbi.1007181.t008">8</xref>), the accuracy increases, as is expected (this can be seen both in the RMSE as in the MAE). In this case, both increasing the number of grid points Ω and using LS-SVM interpolation increases accuracy. No results are given for ABC<sup>Orig</sup>, because it is impossible to fit the model with this sample size in acceptable time.</p>
</sec>
<sec id="sec028">
<title>Results speed</title>
<p>For <italic>T</italic><sub>obs</sub> = 1, the estimation time of ABC<sup>Orig</sup> is 3865 s. In contrast, the estimation time of <inline-formula id="pcbi.1007181.e208"><alternatives><graphic id="pcbi.1007181.e208g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e208" xlink:type="simple"/><mml:math display="inline" id="M208"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> is 0.167 s. This means that the prepaid ABC method is approximately 23000 times faster than traditional ABC.</p>
</sec>
<sec id="sec029">
<title>Results coverage</title>
<p>For both the ABC<sup>Orig</sup> as well as the prepaid versions we end up with a posterior sample. We computed the coverage by calculating the 0.025 and 0.975 quantiles of the posterior samples. Next, we checked whether the true parameter was in this interval or not. Note that when we use clustering during <inline-formula id="pcbi.1007181.e209"><alternatives><graphic id="pcbi.1007181.e209g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e209" xlink:type="simple"/><mml:math display="inline" id="M209"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, we weigh each point proportional to the volume of its originating cluster. For the <inline-formula id="pcbi.1007181.e210"><alternatives><graphic id="pcbi.1007181.e210g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e210" xlink:type="simple"/><mml:math display="inline" id="M210"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> approach we use the whole prepaid set as posterior and us weights according to <xref ref-type="disp-formula" rid="pcbi.1007181.e177">Eq 20</xref>.</p>
<p>For <italic>T</italic><sub>obs</sub> = 1 and <italic>T</italic><sub>obs</sub> = 1000, coverage results can be found in <xref ref-type="table" rid="pcbi.1007181.t009">Table 9</xref>. For <italic>T</italic><sub>obs</sub> = 1, ABC<sup>Orig</sup> leads to better coverages than <inline-formula id="pcbi.1007181.e211"><alternatives><graphic id="pcbi.1007181.e211g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e211" xlink:type="simple"/><mml:math display="inline" id="M211"><mml:msubsup><mml:mtext>SL</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>. Also the <inline-formula id="pcbi.1007181.e212"><alternatives><graphic id="pcbi.1007181.e212g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e212" xlink:type="simple"/><mml:math display="inline" id="M212"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> method gives good coverages (around the nominal level of 0.95) for <italic>T</italic><sub>obs</sub> = 1, but these coverages deteriorate for <italic>T</italic><sub>obs</sub> = 1000 if no interpolation is used (coverage is a bit better for 5 ⋅ 10<sup>5</sup> grid points). When the LS-SVM interpolation is applied (i.e., <inline-formula id="pcbi.1007181.e213"><alternatives><graphic id="pcbi.1007181.e213g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e213" xlink:type="simple"/><mml:math display="inline" id="M213"><mml:msubsup><mml:mtext>ABC</mml:mtext> <mml:mtext>PM</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>), coverages become very good again, certainly for the largest number of grid points.</p>
<table-wrap id="pcbi.1007181.t009" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.t009</object-id>
<label>Table 9</label>
<caption>
<title>The effective 95% coverage of the estimations of the test set of the trait model.</title>
</caption>
<alternatives>
<graphic id="pcbi.1007181.t009g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.t009" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="center"><italic>T</italic><sub>obs</sub></th>
<th align="left">version</th>
<th align="left">Ω</th>
<th align="right">log(<italic>I</italic>)</th>
<th align="right">log(<italic>A</italic>)</th>
<th align="right"><italic>h</italic></th>
<th align="right">log(<italic>σ</italic>)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">1</td>
<td align="left">ABC<sup>Orig</sup></td>
<td align="left">/</td>
<td align="char" char=".">0.97</td>
<td align="char" char=".">0.97</td>
<td align="char" char=".">0.99</td>
<td align="char" char=".">0.96</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">ABC<sup>Orig</sup></td>
<td align="left">100000</td>
<td align="char" char=".">0.84</td>
<td align="char" char=".">0.87</td>
<td align="char" char=".">0.86</td>
<td align="char" char=".">0.86</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e221">
<alternatives>
<graphic id="pcbi.1007181.e221g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e221" xlink:type="simple"/>
<mml:math display="inline" id="M221">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.94</td>
<td align="char" char=".">0.95</td>
<td align="char" char=".">0.95</td>
<td align="char" char=".">0.94</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">
<inline-formula id="pcbi.1007181.e222">
<alternatives>
<graphic id="pcbi.1007181.e222g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e222" xlink:type="simple"/>
<mml:math display="inline" id="M222">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.94</td>
<td align="char" char=".">0.95</td>
<td align="char" char=".">0.94</td>
<td align="char" char=".">0.94</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e223">
<alternatives>
<graphic id="pcbi.1007181.e223g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e223" xlink:type="simple"/>
<mml:math display="inline" id="M223">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.27</td>
<td align="char" char=".">0.3</td>
<td align="char" char=".">0.29</td>
<td align="char" char=".">0.27</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e224">
<alternatives>
<graphic id="pcbi.1007181.e224g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e224" xlink:type="simple"/>
<mml:math display="inline" id="M224">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>Grid</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.47</td>
<td align="char" char=".">0.5</td>
<td align="char" char=".">0.48</td>
<td align="char" char=".">0.48</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e225">
<alternatives>
<graphic id="pcbi.1007181.e225g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e225" xlink:type="simple"/>
<mml:math display="inline" id="M225">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">100000</td>
<td align="char" char=".">0.93</td>
<td align="char" char=".">0.94</td>
<td align="char" char=".">0.96</td>
<td align="char" char=".">0.93</td>
</tr>
<tr>
<td align="center">1000</td>
<td align="left">
<inline-formula id="pcbi.1007181.e226">
<alternatives>
<graphic id="pcbi.1007181.e226g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e226" xlink:type="simple"/>
<mml:math display="inline" id="M226">
<mml:msubsup>
<mml:mtext>ABC</mml:mtext>
<mml:mtext>PM</mml:mtext>
<mml:mtext>SVM</mml:mtext>
</mml:msubsup>
</mml:math>
</alternatives>
</inline-formula>
</td>
<td align="left">500000</td>
<td align="char" char=".">0.96</td>
<td align="char" char=".">0.95</td>
<td align="char" char=".">0.96</td>
<td align="char" char=".">0.95</td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
</sec>
<sec id="sec030">
<title>Application 3: The Leaky Competing Accumulator</title>
<p>Elementary decision making has been studied intensively in humans and animals [<xref ref-type="bibr" rid="pcbi.1007181.ref031">31</xref>]. A common example of an experimental paradigm is the random-motion dot task: the participant has to decide whether a collection of dots (of which only a fraction moves coherently; the others move randomly) is moving to the left or to the right. The stimuli typically have varying levels of difficulty, determined by the fraction of dots moving coherently.</p>
<p>Assuming there are two response options (e.g., left and right), the Leaky Competing Accumulator consists of two evidence accumulators, <italic>x</italic><sub>1</sub>(<italic>t</italic>) and <italic>x</italic><sub>2</sub>(<italic>t</italic>) (where <italic>t</italic> denotes the time), each associated with one response option. The evolution of evidence across time for a single trial is then described by the following system of two stochastic differential equations:
<disp-formula id="pcbi.1007181.e227"><alternatives><graphic id="pcbi.1007181.e227g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e227" xlink:type="simple"/><mml:math display="block" id="M227"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>d</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>v</mml:mi> <mml:mo>+</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:mi>κ</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mi>c</mml:mi> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:msub><mml:mi>W</mml:mi> <mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>d</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>v</mml:mi> <mml:mo>-</mml:mo> <mml:mo>Δ</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mi>γ</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:mi>κ</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mi>c</mml:mi> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:msub><mml:mi>W</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(26)</label></disp-formula>
where <italic>dW</italic><sub>1</sub> and <italic>dW</italic><sub>2</sub> are uncorrelated white noise processes. To avoid negative values, the evidence is set to 0 whenever it becomes negative: <italic>x</italic><sub>1</sub> = max(<italic>x</italic><sub>1</sub>, 0) and <italic>x</italic><sub>2</sub> = max(<italic>x</italic><sub>2</sub>, 0). The initial values (at <italic>t</italic> = 0) are (<italic>x</italic><sub>1</sub>, <italic>x</italic><sub>2</sub>) = (0, 0).</p>
<p>The evidence accumulation process continues until one of the accumulators crosses a boundary <italic>a</italic> (with <italic>a</italic> &gt; 0). The coordinate that crosses its decision boundary first, determines the choice that is made and the time of crossing is seen as the decision time. The observed choice response time is seen as the sum of the decision time and a non-decision time <italic>T</italic><sub><italic>er</italic></sub>, to account for the time needed to encode the stimulus and emit the response.</p>
<p>
<xref ref-type="disp-formula" rid="pcbi.1007181.e227">Eq 26</xref> describes the evolution of information accumulation for a two-option choice RT task, given the presentation of a single stimulus. For all stimuli, the total evidence is equal to <italic>v</italic>, but the differential evidence for option 1 compared to 2 is 2Δ<italic>v</italic><sub><italic>i</italic></sub>, which is stimulus dependent and reflects the stimulus difficulty. In this example, we assume the stimuli can be categorized into four levels of difficulty, hence <italic>i</italic> = 1, …, 4.</p>
<p>The model gives rise to two separate choice response time probability densities, <italic>p</italic><sub>1<italic>i</italic></sub>(<italic>t</italic>) and <italic>p</italic><sub>2<italic>i</italic></sub>(<italic>t</italic>), each representing the response time conditional on the choice that was made. Integrating the densities over time will result in the probability of choosing the response options: <inline-formula id="pcbi.1007181.e228"><alternatives><graphic id="pcbi.1007181.e228g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e228" xlink:type="simple"/><mml:math display="inline" id="M228"><mml:mrow><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo> <mml:mn>0</mml:mn> <mml:mi>∞</mml:mi></mml:msubsup> <mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mrow><mml:mn>1</mml:mn> <mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:mi>t</mml:mi> <mml:mo stretchy="false">)</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>=</mml:mo><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo> <mml:mtext>option</mml:mtext><mml:mspace width="4pt"/><mml:mn>1</mml:mn><mml:mspace width="4pt"/><mml:mtext>for</mml:mtext><mml:mspace width="4pt"/><mml:mtext>stimulus</mml:mtext><mml:mspace width="4pt"/><mml:mi>i</mml:mi> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e229"><alternatives><graphic id="pcbi.1007181.e229g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e229" xlink:type="simple"/><mml:math display="inline" id="M229"><mml:mrow><mml:mstyle displaystyle="true"><mml:mrow><mml:msubsup><mml:mo>∫</mml:mo> <mml:mn>0</mml:mn> <mml:mi>∞</mml:mi></mml:msubsup> <mml:mrow><mml:msub><mml:mi>p</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:mi>t</mml:mi> <mml:mo stretchy="false">)</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>=</mml:mo><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo> <mml:mtext>option</mml:mtext><mml:mspace width="4pt"/><mml:mn>2</mml:mn><mml:mspace width="4pt"/><mml:mtext>for</mml:mtext><mml:mspace width="4pt"/><mml:mtext>stimulus</mml:mtext><mml:mspace width="4pt"/><mml:mi>i</mml:mi> <mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>. Obviously, when taken together, <italic>p</italic><sub>1<italic>i</italic></sub> and <italic>p</italic><sub>2<italic>i</italic></sub> sum to one.</p>
<p>All parameters in the parameter vector <bold><italic>θ</italic></bold> = (<italic>v</italic>, Δ<italic>v</italic><sub>1</sub>, …, Δ<italic>v</italic><sub>4</sub>, <italic>κ</italic>, <italic>γ</italic>, <italic>a</italic>, <italic>T</italic><sub><italic>er</italic></sub>) can take values from 0 to ∞. This parametrization is known to have one redundant parameter [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>], so we choose to fix <italic>c</italic> = 0.1.</p>
<sec id="sec031">
<title>The re-parametrization</title>
<p>The prepaid method will not be applied to the model as presented in <xref ref-type="disp-formula" rid="pcbi.1007181.e227">Eq 26</xref>, but rather on a re-parametrized formulation:
<disp-formula id="pcbi.1007181.e230"><alternatives><graphic id="pcbi.1007181.e230g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e230" xlink:type="simple"/><mml:math display="block" id="M230"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>d</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>D</mml:mi> <mml:mo>·</mml:mo> <mml:mo>(</mml:mo> <mml:msup><mml:mi>v</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>+</mml:mo> <mml:msub><mml:mi>C</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>·</mml:mo> <mml:msub><mml:mi>x</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msup><mml:mi>κ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>·</mml:mo> <mml:msub><mml:mi>x</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msqrt><mml:mi>D</mml:mi></mml:msqrt> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:msub><mml:mi>W</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>d</mml:mi> <mml:msub><mml:mi>x</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo> <mml:mi>D</mml:mi> <mml:mo>·</mml:mo> <mml:mo>(</mml:mo> <mml:msup><mml:mi>v</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:msub><mml:mi>C</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>·</mml:mo> <mml:msub><mml:mi>x</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msup><mml:mi>κ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>·</mml:mo> <mml:msub><mml:mi>x</mml:mi> <mml:mrow><mml:mn>1</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:msqrt><mml:mi>D</mml:mi></mml:msqrt> <mml:mo>·</mml:mo> <mml:mi>d</mml:mi> <mml:msub><mml:mi>W</mml:mi> <mml:mrow><mml:mn>2</mml:mn> <mml:mi>i</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(27)</label></disp-formula>
again with the additional restriction that <italic>x</italic><sub>1<italic>it</italic></sub> = max(<italic>x</italic><sub>1<italic>it</italic></sub>, 0) and <italic>x</italic><sub>2<italic>it</italic></sub> = max(<italic>x</italic><sub>2<italic>it</italic></sub>, 0). The new parameters are defined as follows in terms of the original ones:
<disp-formula id="pcbi.1007181.e231"><alternatives><graphic id="pcbi.1007181.e231g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e231" xlink:type="simple"/><mml:math display="block" id="M231"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mi>D</mml:mi></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:msup><mml:mi>c</mml:mi> <mml:mn>2</mml:mn></mml:msup></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msup><mml:mi>v</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mfrac><mml:mi>v</mml:mi> <mml:mi>D</mml:mi></mml:mfrac></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mi>C</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mfrac><mml:mrow><mml:mo>Δ</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mi>i</mml:mi></mml:msub></mml:mrow> <mml:mi>v</mml:mi></mml:mfrac></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msup><mml:mi>γ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mfrac><mml:mi>γ</mml:mi> <mml:mi>D</mml:mi></mml:mfrac></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msup><mml:mi>κ</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mi>κ</mml:mi> <mml:mi>D</mml:mi></mml:mfrac> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>This new parametrization has the advantage that <italic>D</italic> can be interpreted as an inverse time scalar because doubling <italic>D</italic> makes all choice response times twice as fast. This property will allow us to reduce the dimensionality of the prepaid grid (see below). The parameter <italic>v</italic>′ &gt; 0 denotes general stimulus strength scaled according to <italic>D</italic>, while parameter <italic>C</italic><sub><italic>i</italic></sub> (for coherence) denotes the amount of relative evidence encoded in the stimulus <italic>i</italic>: −1 &lt; <italic>C</italic><sub><italic>i</italic></sub> &lt; 1. It is commonly assumed for these evidence accumulator models that different stimuli should lead to different coherences <italic>C</italic><sub><italic>i</italic></sub>, but without affecting the other parameters. The nondecision time <italic>T</italic><sub><italic>er</italic></sub> is not transformed.</p>
</sec>
<sec id="sec032">
<title>Creation of the prepaid grid</title>
<p>For the delineation of the parameter space, we will follow the specifications of [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>]. Because this parameter space is rather restrictive (a consequence of the recommendation of [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>] to improve parameter recovery), we will extend it through the use of a time scale parameter. This extension will be further discussed when introducing the test set.</p>
<p>First, we create a prepaid grid on a four-dimensional space in the original parametrization by drawing from the following distribution:
<disp-formula id="pcbi.1007181.e232"><alternatives><graphic id="pcbi.1007181.e232g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e232" xlink:type="simple"/><mml:math display="block" id="M232"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mi>a</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>05</mml:mn> <mml:mo>,</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>25</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>v</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>.</mml:mo> <mml:mn>8</mml:mn> <mml:mo>,</mml:mo> <mml:mn>1</mml:mn> <mml:mo>.</mml:mo> <mml:mn>5</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>γ</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>8</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:mi>κ</mml:mi></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mo>∼</mml:mo> <mml:mi mathvariant="script">U</mml:mi> <mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mn>8</mml:mn> <mml:mo>)</mml:mo> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(28)</label></disp-formula></p>
<p>We select 10000 grid points from this distribution using Halton sequences [<xref ref-type="bibr" rid="pcbi.1007181.ref027">27</xref>, <xref ref-type="bibr" rid="pcbi.1007181.ref028">28</xref>]. When working in the reparametrized version, as defined in <xref ref-type="disp-formula" rid="pcbi.1007181.e230">Eq 27</xref>, this space can be transformed to a four dimensional space of <italic>v</italic>′, <italic>γ</italic>′, <italic>κ</italic>′ and <italic>D</italic>.</p>
<p>However, because <italic>D</italic> acts an inverse time scalar on the response time distributions, we may also consider the three dimensional space formed by <italic>v</italic>′, <italic>γ</italic>′, and <italic>κ</italic>′ and for each grid point, choose the parameter <italic>D</italic> in such a way that the RT distributions for options 1 and 2 are scaled to fit nicely between 0 and 3 seconds (with a resolution of 1ms and 3000 time points so that about 0.0001 of the tail mass is allowed to be clipped at 3 seconds when <italic>C</italic> = 0). Effectively, this brings all RT distributions to the same scale (denoted as <italic>s</italic> = 1). This process of scaling is illustrated in <xref ref-type="fig" rid="pcbi.1007181.g011">Fig 11</xref>. It reduces both the number of simulations and the storage load (without it we would have to simulate and store a separate set of distributions for each value of <italic>D</italic>). Note that the scaling is done jointly for all RT distributions associated with a particular <bold><italic>g</italic></bold>. The resulting diffusion constant corresponding to the rescaled distribution is denoted as <inline-formula id="pcbi.1007181.e233"><alternatives><graphic id="pcbi.1007181.e233g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e233" xlink:type="simple"/><mml:math display="inline" id="M233"><mml:msubsup><mml:mi>D</mml:mi> <mml:mn>0</mml:mn> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula>. In addition, the construction effectively removes one parameter from the prepaid grid, which is illustrated in <xref ref-type="fig" rid="pcbi.1007181.g012">Fig 12</xref>.</p>
<fig id="pcbi.1007181.g011" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g011</object-id>
<label>Fig 11</label>
<caption>
<title>Illustration of how different coherences are incorporated.</title>
<p>The gray plane is a simplified representation of the three dimensional (<italic>v</italic>′, <italic>γ</italic>′, <italic>κ</italic>′)-space. For each point <bold><italic>g</italic></bold>, 50 coherences are chosen. Corresponding to each coherence, there is a pair of RT distributions (which each integrate to the probability of selecting the corresponding option).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g011" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007181.g012" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g012</object-id>
<label>Fig 12</label>
<caption>
<title>Illustration of the transformation of the original parameter space (called <italic>A</italic>) to a new one (called <italic>B</italic>) in which <italic>D</italic> is one of the parameters.</title>
<p>The projections of the three parameter points on the red axis governing the width of the <italic>B</italic> area are denoted with open circle and these are the parameter points <bold><italic>g</italic></bold>. For each of these open circle points, the RT distribution scales are set to 1 (i.e., <italic>s</italic> = 1) by choosing an appropriate diffusion coefficient (denoted as <inline-formula id="pcbi.1007181.e236"><alternatives><graphic id="pcbi.1007181.e236g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e236" xlink:type="simple"/><mml:math display="inline" id="M236"><mml:msubsup><mml:mi>D</mml:mi> <mml:mn>0</mml:mn> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula>) and any parameter point in <italic>B</italic> can be reached by selecting an appropriate <bold><italic>g</italic></bold> and then adjusting the scale up- or downwards (this is indicated by the dotted lines in the length direction of the new parameter space <italic>B</italic>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g012" xlink:type="simple"/>
</fig>
<p>To include the coherence parameter, we extend each grid point with a set of predefined coherences. For each point <bold><italic>g</italic></bold> = (<italic>v</italic>′, <italic>γ</italic>′, <italic>κ</italic>′) in the grid, we take 50 equally spaced coherences <inline-formula id="pcbi.1007181.e234"><alternatives><graphic id="pcbi.1007181.e234g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e234" xlink:type="simple"/><mml:math display="inline" id="M234"><mml:msubsup><mml:mi>C</mml:mi> <mml:mi>k</mml:mi> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> (with <italic>k</italic> = 1, …, 50) from 0 to the maximum coherence that still has some non-zero chance of choice option 2 to be selected (we take 0.001). Finally, we simulate for each combination of <bold><italic>g</italic></bold> = (<italic>v</italic>′, <italic>γ</italic>′, <italic>κ</italic>′) and <inline-formula id="pcbi.1007181.e235"><alternatives><graphic id="pcbi.1007181.e235g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e235" xlink:type="simple"/><mml:math display="inline" id="M235"><mml:msubsup><mml:mi>C</mml:mi> <mml:mi>k</mml:mi> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> a large number of choice response time data (choices and response times). This is illustrated in <xref ref-type="fig" rid="pcbi.1007181.g011">Fig 11</xref>.</p>
<p>In a last step, grid points are eliminated from the prepaid grid, if the simulations result in too many simultaneous arrivals (i.e., trajectories that end at or very close to the intersection point of the two absorbing boundaries at the upper right corner, located at (<italic>a</italic>, <italic>a</italic>)). More specifically, we drop grid points with more than 0.1 percent simultaneous arrivals. Creating the prepaid database took less then a day on a NVIDIA GeForce GTX 780 GPU.</p>
</sec>
<sec id="sec033">
<title>Prepaid estimation</title>
<p>To explain how the prepaid estimation of the LCA works, let us start with a prototypical experimental design. Assume a choice RT experiment with four stimulus difficulty levels (e.g., four coherences in the random dot motion task). Each difficulty level is administered <italic>N</italic> times to a single participant. A particular trial in this experiment results in (<italic>c</italic><sub><italic>ij</italic></sub>, <italic>t</italic><sub><italic>ij</italic></sub>), where <italic>i</italic> is the stimulus difficulty level (<italic>i</italic> = 1, …, 4) and <italic>j</italic> is the sequence number within its difficulty level (<italic>j</italic> = 1, …, <italic>N</italic>). The data resulting from this experiment are responses <italic>c</italic><sub><italic>ij</italic></sub> (referring to choice 1 or choice 2) and response times <italic>t</italic><sub><italic>ij</italic></sub>. Each pair (<italic>c</italic><sub><italic>ij</italic></sub>, <italic>t</italic><sub><italic>ij</italic></sub>) is considered to originate from an unknown parameter set (<italic>v</italic>′, <italic>γ</italic>′, <italic>κ</italic>′, <italic>D</italic>, <italic>T</italic><sub><italic>er</italic></sub>) and coherences <italic>C</italic><sub><italic>i</italic></sub> (<italic>i</italic> = 1, …, 4).</p>
<p>Our first aim is to is to establish a local net of prepaid points that lead to data that are close to the observed dataset. If necessary, we can further zoom in with the help of support vector machines. Conditional on each prepaid parameter set <bold><italic>g</italic></bold> in the basic grid, a number of the remaining parameters can be integrated out beforehand. First, conditional on grid point <bold><italic>g</italic></bold>, we have for 50 predetermined coherences <inline-formula id="pcbi.1007181.e237"><alternatives><graphic id="pcbi.1007181.e237g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e237" xlink:type="simple"/><mml:math display="inline" id="M237"><mml:msubsup><mml:mi>C</mml:mi> <mml:mi>k</mml:mi> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> simulated accuracies and response time distributions (see <xref ref-type="fig" rid="pcbi.1007181.g011">Fig 11</xref>). The coherences of the observed data can be estimated solely using the observed accuracies using simple linear interpolation. The estimated coherence for stimulus (or condition) <italic>i</italic> is denoted as <inline-formula id="pcbi.1007181.e238"><alternatives><graphic id="pcbi.1007181.e238g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e238" xlink:type="simple"/><mml:math display="inline" id="M238"><mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>. Corresponding to each of the 50 coherences <inline-formula id="pcbi.1007181.e239"><alternatives><graphic id="pcbi.1007181.e239g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e239" xlink:type="simple"/><mml:math display="inline" id="M239"><mml:msubsup><mml:mi>C</mml:mi> <mml:mi>k</mml:mi> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> for grid point <bold><italic>g</italic></bold>, there is a pair of corresponding simulated RT densities <inline-formula id="pcbi.1007181.e240"><alternatives><graphic id="pcbi.1007181.e240g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e240" xlink:type="simple"/><mml:math display="inline" id="M240"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> (with <italic>c</italic> = 1, 2). As before, <inline-formula id="pcbi.1007181.e241"><alternatives><graphic id="pcbi.1007181.e241g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e241" xlink:type="simple"/><mml:math display="inline" id="M241"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> is scaled to the [0, 3] seconds window, and we can use a combination of translating (estimating <inline-formula id="pcbi.1007181.e242"><alternatives><graphic id="pcbi.1007181.e242g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e242" xlink:type="simple"/><mml:math display="inline" id="M242"><mml:msub><mml:mover accent="true"><mml:mi>T</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>e</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>), scaling (estimating <inline-formula id="pcbi.1007181.e243"><alternatives><graphic id="pcbi.1007181.e243g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e243" xlink:type="simple"/><mml:math display="inline" id="M243"><mml:mover accent="true"><mml:mi>D</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:math></alternatives></inline-formula>) and interpolating. Specifically, we first calculate <inline-formula id="pcbi.1007181.e244"><alternatives><graphic id="pcbi.1007181.e244g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e244" xlink:type="simple"/><mml:math display="inline" id="M244"><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> as the optimal time scalar to match data with the model on grid point <bold><italic>g</italic></bold>:
<disp-formula id="pcbi.1007181.e245"><alternatives><graphic id="pcbi.1007181.e245g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e245" xlink:type="simple"/><mml:math display="block" id="M245"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>=</mml:mo> <mml:msqrt><mml:mfrac><mml:mrow><mml:mfrac><mml:mn>1</mml:mn> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>4</mml:mn> <mml:mi>N</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:mfrac> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>j</mml:mi></mml:mrow></mml:msub> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>j</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>4</mml:mn></mml:mfrac> <mml:msub><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow></mml:msub> <mml:mo>∫</mml:mo> <mml:msubsup><mml:mi>p</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:mn>2</mml:mn></mml:msup> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:mfrac></mml:msqrt> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
in which
<disp-formula id="pcbi.1007181.e246"><alternatives><graphic id="pcbi.1007181.e246g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e246" xlink:type="simple"/><mml:math display="block" id="M246"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn> <mml:mrow><mml:mn>4</mml:mn> <mml:mi>N</mml:mi></mml:mrow></mml:mfrac> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>j</mml:mi></mml:mrow></mml:munder> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn> <mml:mn>4</mml:mn></mml:mfrac> <mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow></mml:munder> <mml:mo>∫</mml:mo> <mml:msubsup><mml:mi>p</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mi>t</mml:mi> <mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>This formula capitalizes on the fact that the variance of a distribution does not change when it is simply shifted to the right by a constant. Hence, the ratio of the model’s decision time variance (without <italic>T</italic><sub><italic>e</italic></sub><italic>r</italic>) and the observed total response time variance (presumably shifted with some <italic>T</italic><sub><italic>e</italic></sub><italic>r</italic>) is still an estimator of the squared scale factor between them. Using this information, we can estimate the optimal <inline-formula id="pcbi.1007181.e247"><alternatives><graphic id="pcbi.1007181.e247g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e247" xlink:type="simple"/><mml:math display="inline" id="M247"><mml:mover accent="true"><mml:mi>D</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e248"><alternatives><graphic id="pcbi.1007181.e248g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e248" xlink:type="simple"/><mml:math display="inline" id="M248"><mml:msub><mml:mover accent="true"><mml:mi>T</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>e</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> for grid point <bold><italic>g</italic></bold> as follows:
<disp-formula id="pcbi.1007181.e249"><alternatives><graphic id="pcbi.1007181.e249g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e249" xlink:type="simple"/><mml:math display="block" id="M249"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mover accent="true"><mml:mi>D</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mfrac><mml:msubsup><mml:mi>D</mml:mi> <mml:mrow><mml:mn>0</mml:mn></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:mfrac></mml:mtd></mml:mtr> <mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mover accent="true"><mml:mi>T</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>e</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>μ</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>t</mml:mi></mml:msub> <mml:mo>-</mml:mo> <mml:mover accent="true"><mml:mi mathvariant="bold-italic">s</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:msubsup><mml:mi>μ</mml:mi> <mml:mrow><mml:mi>t</mml:mi></mml:mrow> <mml:mi mathvariant="bold-italic">g</mml:mi></mml:msubsup> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
with <inline-formula id="pcbi.1007181.e250"><alternatives><graphic id="pcbi.1007181.e250g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e250" xlink:type="simple"/><mml:math display="inline" id="M250"><mml:msubsup><mml:mi>D</mml:mi> <mml:mrow><mml:mn>0</mml:mn></mml:mrow> <mml:mi>g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> being the optimal scaling diffusion constant used for optimal storage in the database. This gives us a final effective parameter vector of <inline-formula id="pcbi.1007181.e251"><alternatives><graphic id="pcbi.1007181.e251g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e251" xlink:type="simple"/><mml:math display="inline" id="M251"><mml:mo>(</mml:mo> <mml:msup><mml:mi>v</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:msup><mml:mi>γ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:msup><mml:mi>κ</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>3</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mn>4</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:mover accent="true"><mml:mi>D</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mo>,</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>T</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>e</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:math></alternatives></inline-formula>. Note that the last 6 elements of this vector are estimates conditional on the grid point <bold><italic>g</italic></bold> = (<italic>v</italic>′, <italic>γ</italic>′, <italic>κ</italic>′).</p>
<p>Next, we have to determine the single optimal parameter set (and thus also the optimal <italic>v</italic>′, <italic>γ</italic>′, and <italic>κ</italic>′). For this we need an objective function that compares the model based PDFs with those of the data. For this purpose, we use a (symmetrized) chi-square distance based on a set of bin statistics. For each stimulus’ observed set of choice RTs, <bold><italic>t</italic></bold><sub><italic>i</italic></sub> = (<bold><italic>t</italic></bold><sub><italic>i</italic>1</sub>, <bold><italic>t</italic></bold><sub><italic>i</italic>2</sub>) (with <bold><italic>t</italic></bold><sub><italic>i</italic>1</sub> the RTs for option 1 and <bold><italic>t</italic></bold><sub><italic>i</italic>2</sub> for option 2), we calculate 20 data quantiles <italic>q</italic><sub><italic>u</italic></sub> (with <italic>u</italic> = 1, …, 20) at probability masses <italic>m</italic><sub><italic>i</italic></sub> = 0.05 ⋅ <italic>i</italic>. The set of quantiles is appended with one extra quantile <italic>q</italic><sub>0</sub> at <italic>m</italic><sub>0</sub> = 0.01 to have a more detailed representation of the leading edge of the distribution. Based on binning edges (0, <italic>q</italic><sub>0</sub>, <italic>q</italic><sub>1</sub>, …, <italic>q</italic><sub>20</sub>, + ∞), we create 4 × 2 × 22 bin frequencies <inline-formula id="pcbi.1007181.e252"><alternatives><graphic id="pcbi.1007181.e252g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e252" xlink:type="simple"/><mml:math display="inline" id="M252"><mml:msub><mml:mover accent="true"><mml:mi>b</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> with <italic>w</italic> = 1, …, 22. The corresponding probability masses <inline-formula id="pcbi.1007181.e253"><alternatives><graphic id="pcbi.1007181.e253g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e253" xlink:type="simple"/><mml:math display="inline" id="M253"><mml:msubsup><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow> <mml:mi>g</mml:mi></mml:msubsup></mml:math></alternatives></inline-formula> can be easily extracted from the prepaid PDFs <inline-formula id="pcbi.1007181.e254"><alternatives><graphic id="pcbi.1007181.e254g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e254" xlink:type="simple"/><mml:math display="inline" id="M254"><mml:mrow><mml:msubsup><mml:mi>p</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi></mml:mrow> <mml:mi>g</mml:mi></mml:msubsup> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>t</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> as well. Observed and theoretical quantities can then be combined in the a symmetrized chi-square distance:
<disp-formula id="pcbi.1007181.e255"><alternatives><graphic id="pcbi.1007181.e255g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e255" xlink:type="simple"/><mml:math display="block" id="M255"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>d</mml:mi> <mml:mo>(</mml:mo> <mml:mi>g</mml:mi> <mml:mo>,</mml:mo> <mml:mrow><mml:mo>{</mml:mo> <mml:msub><mml:mi>c</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>j</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>t</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>j</mml:mi></mml:mrow></mml:msub> <mml:mo>}</mml:mo></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mtd> <mml:mtd><mml:mo>=</mml:mo></mml:mtd> <mml:mtd columnalign="left"><mml:mrow><mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow></mml:munder> <mml:mfrac><mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mover accent="true"><mml:mi>b</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow></mml:msub> <mml:mo>-</mml:mo> <mml:msubsup><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow> <mml:mi>g</mml:mi></mml:msubsup> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mrow/><mml:mn>2</mml:mn></mml:msup></mml:mrow> <mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>b</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow></mml:msub> <mml:mo>+</mml:mo> <mml:msubsup><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mi>c</mml:mi> <mml:mi>w</mml:mi></mml:mrow> <mml:mi>g</mml:mi></mml:msubsup></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(29)</label></disp-formula></p>
<p>This defines a distance between all grid points <italic>g</italic> in the database and any data set.</p>
<p>In the following paragraphs we will present three ways of using this distance to calculate LCA estimates, each a bit more complicated than the previous one (but also more accurate): <inline-formula id="pcbi.1007181.e256"><alternatives><graphic id="pcbi.1007181.e256g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e256" xlink:type="simple"/><mml:math display="inline" id="M256"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>NN</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1007181.e257"><alternatives><graphic id="pcbi.1007181.e257g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e257" xlink:type="simple"/><mml:math display="inline" id="M257"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1007181.e258"><alternatives><graphic id="pcbi.1007181.e258g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e258" xlink:type="simple"/><mml:math display="inline" id="M258"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula>.</p>
<p>First we will discuss the <inline-formula id="pcbi.1007181.e259"><alternatives><graphic id="pcbi.1007181.e259g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e259" xlink:type="simple"/><mml:math display="inline" id="M259"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>NN</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant. Here, the grid point closest to the data set (as measured by the symmetrized chi-square distance function) can be used as a first nearest neighbor estimate.</p>
<p>Second we discuss the <inline-formula id="pcbi.1007181.e260"><alternatives><graphic id="pcbi.1007181.e260g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e260" xlink:type="simple"/><mml:math display="inline" id="M260"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>Grid</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant. Not all parameters are treated equally in the estimation procedure. The parameters <italic>C</italic><sub><italic>i</italic></sub>, <italic>D</italic> and <italic>T</italic><sub><italic>er</italic></sub> are estimated conditionally on all grid points <bold><italic>g</italic></bold> and then the other parameters are estimated conditionally on <inline-formula id="pcbi.1007181.e261"><alternatives><graphic id="pcbi.1007181.e261g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e261" xlink:type="simple"/><mml:math display="inline" id="M261"><mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula>, <inline-formula id="pcbi.1007181.e262"><alternatives><graphic id="pcbi.1007181.e262g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e262" xlink:type="simple"/><mml:math display="inline" id="M262"><mml:mover accent="true"><mml:mi>D</mml:mi> <mml:mo>^</mml:mo></mml:mover></mml:math></alternatives></inline-formula> and <inline-formula id="pcbi.1007181.e263"><alternatives><graphic id="pcbi.1007181.e263g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e263" xlink:type="simple"/><mml:math display="inline" id="M263"><mml:msub><mml:mover accent="true"><mml:mi>T</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mrow><mml:mi>e</mml:mi> <mml:mi>r</mml:mi></mml:mrow></mml:msub></mml:math></alternatives></inline-formula>. Moreover, these parameters are chosen in such a way that a specific aspect of the data (e.g., proportion of choices for option 1) is fitted perfectly (i.e., the coherence is chosen to result in probabilities perfectly equal to the proportions observed in the data). This would be no problem for an infinite amount of data. However, for finite data, the major disadvantage of this way of working is that any errors induced in the precursor step are propagated through the estimation process for <italic>v</italic>′, <italic>γ</italic>′ and <italic>κ</italic>′. This is because for finite data, the observed accuracies will typically not exactly coincide with the accuracies provided by the best model estimates. As the estimates <inline-formula id="pcbi.1007181.e264"><alternatives><graphic id="pcbi.1007181.e264g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e264" xlink:type="simple"/><mml:math display="inline" id="M264"><mml:msub><mml:mover accent="true"><mml:mi>C</mml:mi> <mml:mo>^</mml:mo></mml:mover> <mml:mi>i</mml:mi></mml:msub></mml:math></alternatives></inline-formula> are (on each grid point) exactly fit to the observed accuracy and consequently, the effective grid points will all have this exact accuracy. In this variant, we tackle this estimator bias by non-parametrically bootstrapping the data and repeating the nearest neighbor estimate for every bootstrapped dataset. Taking the mean of this set of estimates (a method known as bagging; [<xref ref-type="bibr" rid="pcbi.1007181.ref032">32</xref>]), gives us a more accurate estimate. Additionally, we now have a standard error of the estimate (and confidence interval).</p>
<p>Lastly, we discuss the <inline-formula id="pcbi.1007181.e265"><alternatives><graphic id="pcbi.1007181.e265g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e265" xlink:type="simple"/><mml:math display="inline" id="M265"><mml:msubsup><mml:mtext>CHISQ</mml:mtext> <mml:mtext>BS</mml:mtext> <mml:mtext>SVM</mml:mtext></mml:msubsup></mml:math></alternatives></inline-formula> variant. If we apply the bootstrap procedure, it may turn out that the selected grid points as nearest neighbor are not very diverse (this may happen with large sample sizes). In such a situation, it can be worthwhile to use an interpolator. So we may learn a support vector machine based on the bin statistics of the few unique bootstraps grid points available, together with the best overall unique grid points. In this variant, we propose to use a training set of 100 grid points in total. The SVM can then be used as an approximation for the bin statistics in the space between the grid points and hence for the objective function. We subsequently minimize the approximative SVM based objective function for every bootstrap, using differential evolution (as has been outlined above for the other applications).</p>
<p>Obviously, the quality of the SVM based estimate is limited by the quality of the SVMs that are trained to learn the relation between parameters and statistics. In addition, the same SVMs are used for all bootstrap samples, which may introduce an unwanted distortion in the uncertainty assessment. To account for the systemic bias that might have been introduced by the SVMs, we will add some random noise to each bootstrap estimate. The amount of random deviation that is added equals the size of the prediction error of the SVM. In this way, low quality SVMs are prohibited of biasing all bootstraps in the same way. The uncertainty of the SVMs is now incorporated in the final bootstrapped results.</p>
</sec>
<sec id="sec034">
<title>Test set</title>
<p>The test set is created by uniformly sampling parameters according to <xref ref-type="disp-formula" rid="pcbi.1007181.e232">Eq 28</xref>. Input differences <inline-formula id="pcbi.1007181.e084"><alternatives><graphic id="pcbi.1007181.e084g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1007181.e084" xlink:type="simple"/><mml:math display="inline" id="M84"><mml:mfrac><mml:mrow><mml:msub><mml:mi>v</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>-</mml:mo> <mml:msub><mml:mi>v</mml:mi> <mml:mn>2</mml:mn></mml:msub></mml:mrow> <mml:mn>2</mml:mn></mml:mfrac></mml:math></alternatives></inline-formula> are chosen to produce typical accuracies of 0.6, 0.7, 0.8, and 0.9. As is done in [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>], excessively long PDFs (with a maximum RT larger than 5000ms) and excessively short PDFs (with a range below 400ms) are removed from the test set. Apart from the fact that these PDFs are deemed unrealistic [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>] for typical choice RT data, this part of the parameter space suffers from inherent poor parameter identifiability, with very large confidence intervals and less meaningful estimates as a consequence. Because the new parametrization analytically integrates out scale (i.e., <italic>D</italic>) (and also shift <italic>T</italic><sub><italic>er</italic></sub>), and is positively unbounded in these dimensions, we can expand the test set to cover a broader range of distributions than the ones covered in [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>]. To broaden the range of the test, the distributions are scaled with a random factor ranging from 0.2 to 5. We will use this broadened test set to determine the method’s accuracy and coverage.</p>
</sec>
<sec id="sec035">
<title>Results accuracy</title>
<p>The recoveries of the original LCA parameters are displayed in Figs <xref ref-type="fig" rid="pcbi.1007181.g004">4</xref>, <xref ref-type="fig" rid="pcbi.1007181.g013">13</xref> and <xref ref-type="fig" rid="pcbi.1007181.g014">14</xref>. It can be concluded that for all sample sizes, recovery is acceptable, but it improves a lot for larger sample sizes. In all cases, the recovery is dramatically better than that reported in [<xref ref-type="bibr" rid="pcbi.1007181.ref024">24</xref>]. Figs <xref ref-type="fig" rid="pcbi.1007181.g015">15</xref> and <xref ref-type="fig" rid="pcbi.1007181.g016">16</xref> shows RMSE and MAE, respectively, as a function of sample size for three methods (for all parameters). It can be seen that accuracy improves for all parameters for the single best nearest neighbor and for the bootstrap method, until some point, after which it stabilizes or deteriorates. However, for the SVM based estimation, there is still considerable improvement for higher sample sizes.</p>
<fig id="pcbi.1007181.g013" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g013</object-id>
<label>Fig 13</label>
<caption>
<title>Recovery for the original parameters of the LCA model with <italic>T</italic><sub>obs</sub> = 1000 observation per stimulus.</title>
<p>See <xref ref-type="fig" rid="pcbi.1007181.g004">Fig 4</xref> for detailed information.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g013" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007181.g014" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g014</object-id>
<label>Fig 14</label>
<caption>
<title>Recovery for the original parameters of the LCA model with <italic>T</italic><sub>obs</sub> = 10000 observation per stimulus.</title>
<p>See <xref ref-type="fig" rid="pcbi.1007181.g004">Fig 4</xref> for detailed information.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g014" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007181.g015" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g015</object-id>
<label>Fig 15</label>
<caption>
<title>The MAE of the estimates of the parameters of the LCA as a function of sample size (abscissa) and for different methods.</title>
<p>More details can be found in the caption of <xref ref-type="fig" rid="pcbi.1007181.g003">Fig 3</xref>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g015" xlink:type="simple"/>
</fig>
<fig id="pcbi.1007181.g016" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g016</object-id>
<label>Fig 16</label>
<caption>
<title>The RMSE of the estimates of the parameters of the LCA as a function of sample size (abscissa) and for different methods.</title>
<p>More details can be found in the caption of <xref ref-type="fig" rid="pcbi.1007181.g003">Fig 3</xref>.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g016" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec036">
<title>Results coverage</title>
<p>
<xref ref-type="fig" rid="pcbi.1007181.g017">Fig 17</xref> shows the coverages for different numbers of observations. Nearest neighbor bootstrap coverage seems to be adequate for sample sizes up to 10000; for higher sample sizes SVMs are needed to ensure good coverage.</p>
<fig id="pcbi.1007181.g017" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1007181.g017</object-id>
<label>Fig 17</label>
<caption>
<title>The coverage of LCA estimates for different number of observations <italic>T</italic><sub>obs</sub>.</title>
<p>Each line represents one of the nine LCA parameters and plots the fraction of estimates between the [<italic>α</italic>, 1 − <italic>α</italic>] quantiles of their bootstrapped confidence intervals. The closer the line to the second diagonal, the better the coverage. Black lines are the result of non-parametric bootstraps obtained through nearest neighbor estimates; red lines are the result of SVM enhanced estimates.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1007181.g017" xlink:type="simple"/>
</fig>
</sec>
</sec>
</sec>
</body>
<back>
<ref-list>
<title>References</title>
<ref id="pcbi.1007181.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Beaumont</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>Zhang</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Balding</surname> <given-names>DJ</given-names></name>. <article-title>Approximate Bayesian Computation in Population Genetics</article-title>. <source>Genetics</source>. <year>2002</year>;<volume>162</volume>(<issue>4</issue>):<fpage>2025</fpage>–<lpage>2035</lpage>. <object-id pub-id-type="pmid">12524368</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wood</surname> <given-names>SN</given-names></name>. <article-title>Statistical inference for noisy nonlinear ecological dynamic systems</article-title>. <source>Nature</source>. <year>2010</year>;<volume>466</volume>(<issue>7310</issue>):<fpage>1102</fpage>–<lpage>1104</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/nature09319" xlink:type="simple">10.1038/nature09319</ext-link></comment> <object-id pub-id-type="pmid">20703226</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Fasiolo</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Pya</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Wood</surname> <given-names>SN</given-names></name>. <article-title>A Comparison of Inferential Methods for Highly Nonlinear State Space Models in Ecology and Epidemiology</article-title>. <source>Statistical Science</source>. <year>2016</year>;<volume>31</volume>(<issue>1</issue>):<fpage>96</fpage>–<lpage>118</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1214/15-STS534" xlink:type="simple">10.1214/15-STS534</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>McFadden</surname> <given-names>D</given-names></name>. <article-title>A Method of Simulated Moments for Estimation of Discrete Response Models Without Numerical Integration</article-title>. <source>Econometrica</source>. <year>1989</year>;<volume>57</volume>(<issue>5</issue>):<fpage>995</fpage>–<lpage>1026</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.2307/1913621" xlink:type="simple">10.2307/1913621</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref005">
<label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Fermanian</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Salanié</surname> <given-names>B</given-names></name>. <article-title>A NONPARAMETRIC SIMULATED MAXIMUM LIKELIHOOD ESTIMATION METHOD</article-title>. <source>Econometric Theory</source>. <year>2004</year>;<volume>20</volume>(<issue>4</issue>):<fpage>701</fpage>–<lpage>734</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1017/S0266466604204054" xlink:type="simple">10.1017/S0266466604204054</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref006">
<label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Turner</surname> <given-names>BM</given-names></name>, <name name-style="western"><surname>Sederberg</surname> <given-names>PB</given-names></name>, <name name-style="western"><surname>McClelland</surname> <given-names>JL</given-names></name>. <article-title>Bayesian analysis of simulation-based models</article-title>. <source>Journal of Mathematical Psychology</source>. <year>2016</year>;<volume>72</volume>:<fpage>191</fpage>–<lpage>199</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.jmp.2014.10.001" xlink:type="simple">10.1016/j.jmp.2014.10.001</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref007">
<label>7</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Heard</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Dent</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Schifeling</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Banks</surname> <given-names>D</given-names></name>. <article-title>Agent-based models and microsimulation</article-title>. <source>Annual Review of Statistics and Its Application</source>. <year>2015</year>;<volume>2</volume>:<fpage>259</fpage>–<lpage>272</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1146/annurev-statistics-010814-020218" xlink:type="simple">10.1146/annurev-statistics-010814-020218</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref008">
<label>8</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Hall</surname> <given-names>AR</given-names></name>. <source>Generalized method of moments</source>. <publisher-name>Oxford University Press</publisher-name>; <year>2005</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref009">
<label>9</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Gourieroux</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Monfort</surname> <given-names>A</given-names></name>. <source>Simulation-based econometric methods</source>. <publisher-name>Oxford University Press</publisher-name>; <year>1996</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Gutmann</surname> <given-names>MU</given-names></name>, <name name-style="western"><surname>Corander</surname> <given-names>J</given-names></name>. <article-title>Bayesian Optimization for Likelihood-Free Inference of Simulator-Based Statistical Models</article-title>. <source>Journal of Machine Learning Research</source>. <year>2016</year>;<volume>17</volume>(<issue>125</issue>):<fpage>1</fpage>–<lpage>47</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Mestdagh</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Verdonck</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Duisters</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Tuerlinckx</surname> <given-names>F</given-names></name>. <article-title>Fingerprint resampling: A generic method for efficient resampling</article-title>. <source>Scientific Reports</source>. <year>2015</year>;<volume>5</volume>:<fpage>srep16970</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/srep16970" xlink:type="simple">10.1038/srep16970</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref012">
<label>12</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Suykens</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Gestel</surname> <given-names>TV</given-names></name>, <name name-style="western"><surname>Brabanter</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Moor</surname> <given-names>BD</given-names></name>, <name name-style="western"><surname>Vandewalle</surname> <given-names>J</given-names></name>. <source>Least Squares Support Vector Machines</source>. <publisher-loc>River Edge, NJ</publisher-loc>: <publisher-name>World Scientific Publishing Company</publisher-name>; <year>2002</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref013">
<label>13</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Turchin</surname> <given-names>P</given-names></name>. <source>Complex Population Dynamics</source>. <publisher-name>Princeton Univ. Press</publisher-name>; <year>2003</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Storn</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Price</surname> <given-names>K</given-names></name>. <article-title>Differential Evolution—A Simple and Efficient Heuristic for global Optimization over Continuous Spaces</article-title>. <source>Journal of Global Optimization</source>. <year>1997</year>;<volume>11</volume>(<issue>4</issue>):<fpage>341</fpage>–<lpage>359</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1023/A:1008202821328" xlink:type="simple">10.1023/A:1008202821328</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref015">
<label>15</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Taneja</surname> <given-names>SL</given-names></name>, <name name-style="western"><surname>Leuschner</surname> <given-names>K</given-names></name>. <source>Methods of rearing, infestations, and evaluation for Chilo partellus resistance in sorghum</source>. <publisher-name>ICRISAT</publisher-name>; <year>1985</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref016">
<label>16</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Yonow</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Kriticos</surname> <given-names>DJ</given-names></name>, <name name-style="western"><surname>Ota</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Van Den Berg</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Hutchison</surname> <given-names>WD</given-names></name>. <article-title>The potential global distribution of Chilo partellus, including consideration of irrigation and cropping patterns</article-title>. <source>Journal of Pest Science</source>. <year>2017</year>;<volume>90</volume>(<issue>2</issue>):<fpage>459</fpage>–<lpage>477</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1007/s10340-016-0801-4" xlink:type="simple">10.1007/s10340-016-0801-4</ext-link></comment> <object-id pub-id-type="pmid">28275325</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref017">
<label>17</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Jabot</surname> <given-names>F</given-names></name>. <article-title>A stochastic dispersal-limited trait-based model of community dynamics</article-title>. <source>Journal of Theoretical Biology</source>. <year>2010</year>;<volume>262</volume>(<issue>4</issue>):<fpage>650</fpage>–<lpage>661</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.jtbi.2009.11.004" xlink:type="simple">10.1016/j.jtbi.2009.11.004</ext-link></comment> <object-id pub-id-type="pmid">19913559</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref018">
<label>18</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Csilléry</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Blum</surname> <given-names>MGB</given-names></name>, <name name-style="western"><surname>Gaggiotti</surname> <given-names>OE</given-names></name>, <name name-style="western"><surname>François</surname> <given-names>O</given-names></name>. <article-title>Approximate Bayesian Computation (ABC) in practice</article-title>. <source>Trends in Ecology &amp; Evolution</source>. <year>2010</year>;<volume>25</volume>(<issue>7</issue>):<fpage>410</fpage>–<lpage>418</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.tree.2010.04.001" xlink:type="simple">10.1016/j.tree.2010.04.001</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref019">
<label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Voight</surname> <given-names>BF</given-names></name>, <name name-style="western"><surname>Wijmenga</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Wegmann</surname> <given-names>D</given-names></name>, Consortium DGRaMa, <name name-style="western"><surname>Stahl</surname> <given-names>EA</given-names></name>, <name name-style="western"><surname>Kurreeman</surname> <given-names>FAS</given-names></name>, <etal>et al</etal>. <article-title>Bayesian inference analyses of the polygenic architecture of rheumatoid arthritis</article-title>. <source>Nature Genetics</source>. <year>2012</year>;<volume>44</volume>(<issue>5</issue>):<fpage>483</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/ng.2232" xlink:type="simple">10.1038/ng.2232</ext-link></comment> <object-id pub-id-type="pmid">22446960</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref020">
<label>20</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Siepel</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Gulko</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Danko</surname> <given-names>CG</given-names></name>, <name name-style="western"><surname>Gronau</surname> <given-names>I</given-names></name>, <name name-style="western"><surname>Hubisz</surname> <given-names>MJ</given-names></name>. <article-title>Bayesian inference of ancient human demography from individual genome sequences</article-title>. <source>Nature Genetics</source>. <year>2011</year>;<volume>43</volume>(<issue>10</issue>):<fpage>1031</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/ng.937" xlink:type="simple">10.1038/ng.937</ext-link></comment> <object-id pub-id-type="pmid">21926973</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref021">
<label>21</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Beaumont</surname> <given-names>MA</given-names></name>. <article-title>Approximate Bayesian Computation in Evolution and Ecology</article-title>. <source>Annual Review of Ecology, Evolution, and Systematics</source>. <year>2010</year>;<volume>41</volume>(<issue>1</issue>):<fpage>379</fpage>–<lpage>406</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1146/annurev-ecolsys-102209-144621" xlink:type="simple">10.1146/annurev-ecolsys-102209-144621</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref022">
<label>22</label>
<mixed-citation publication-type="other" xlink:type="simple">Jabot F, Faure T, Dumoulin N, Albert C. EasyABC: Efficient Approximate Bayesian Computation Sampling Schemes; 2015.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref023">
<label>23</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Usher</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>McClelland</surname> <given-names>JL</given-names></name>. <article-title>The time course of perceptual choice: The leaky, competing accumulator model</article-title>. <source>Psychological Review</source>. <year>2001</year>;<volume>108</volume>(<issue>3</issue>):<fpage>550</fpage>–<lpage>592</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1037/0033-295X.108.3.550" xlink:type="simple">10.1037/0033-295X.108.3.550</ext-link></comment> <object-id pub-id-type="pmid">11488378</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref024">
<label>24</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Miletić</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Turner</surname> <given-names>BM</given-names></name>, <name name-style="western"><surname>Forstmann</surname> <given-names>BU</given-names></name>, <name name-style="western"><surname>van Maanen</surname> <given-names>L</given-names></name>. <article-title>Parameter recovery for the Leaky Competing Accumulator model</article-title>. <source>Journal of Mathematical Psychology</source>. <year>2017</year>;<volume>76</volume>:<fpage>25</fpage>–<lpage>50</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1016/j.jmp.2016.12.001" xlink:type="simple">10.1016/j.jmp.2016.12.001</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref025">
<label>25</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Mood</surname> <given-names>AM</given-names></name>, <name name-style="western"><surname>Graybill</surname> <given-names>FA</given-names></name>, <name name-style="western"><surname>Boes</surname> <given-names>DC</given-names></name>. <source>Introduction to the theory of statistics</source> (<edition>3rd ed</edition>). <publisher-loc>Signapore</publisher-loc>: <publisher-name>McGraw-Hill</publisher-name>; <year>1974</year>.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref026">
<label>26</label>
<mixed-citation publication-type="other" xlink:type="simple">Fasiolo M, Wood S. An introduction to synlik (2014). R package version 0.1.1.; 2014.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref027">
<label>27</label>
<mixed-citation publication-type="other" xlink:type="simple">MATLAB. version 9.1.0.441655 (R2016b). Natick, Massachusetts: The MathWorks Inc.; 2016.</mixed-citation>
</ref>
<ref id="pcbi.1007181.ref028">
<label>28</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kocis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Whiten</surname> <given-names>WJ</given-names></name>. <article-title>Computational Investigations of Low-discrepancy Sequences</article-title>. <source>ACM Trans Math Softw</source>. <year>1997</year>;<volume>23</volume>(<issue>2</issue>):<fpage>266</fpage>–<lpage>294</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1145/264029.264064" xlink:type="simple">10.1145/264029.264064</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref029">
<label>29</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Jabot</surname> <given-names>F</given-names></name>, <name name-style="western"><surname>Faure</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Dumoulin</surname> <given-names>N</given-names></name>. <article-title>EasyABC: performing efficient approximate Bayesian computation sampling schemes using R</article-title>. <source>Methods in Ecology and Evolution</source>. <year>2013</year>;<volume>4</volume>(<issue>7</issue>):<fpage>684</fpage>–<lpage>687</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1111/2041-210X.12050" xlink:type="simple">10.1111/2041-210X.12050</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref030">
<label>30</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>BEAUMONT</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>CORNUET</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>MARIN</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>ROBERT</surname> <given-names>CP</given-names></name>. <article-title>Adaptive approximate Bayesian computation</article-title>. <source>Biometrika</source>. <year>2009</year>;<volume>96</volume>(<issue>4</issue>):<fpage>983</fpage>–<lpage>990</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/biomet/asp052" xlink:type="simple">10.1093/biomet/asp052</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref031">
<label>31</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Huk</surname> <given-names>AC</given-names></name>, <name name-style="western"><surname>Katz</surname> <given-names>LN</given-names></name>, <name name-style="western"><surname>Yates</surname> <given-names>JL</given-names></name>. <article-title>The role of the lateral intraparietal area in (the study of) decision making</article-title>. <source>Annual review of neuroscience</source>. <year>2017</year>;<volume>40</volume>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1146/annurev-neuro-072116-031508" xlink:type="simple">10.1146/annurev-neuro-072116-031508</ext-link></comment> <object-id pub-id-type="pmid">28772104</object-id></mixed-citation>
</ref>
<ref id="pcbi.1007181.ref032">
<label>32</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Hastie</surname> <given-names>T</given-names></name>, <name name-style="western"><surname>Tibshirani</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Friedman</surname> <given-names>J</given-names></name>. <source>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</source>, <edition>Second Edition</edition>. <publisher-name>Springer Science &amp; Business Media</publisher-name>; <year>2009</year>.</mixed-citation>
</ref>
</ref-list>
</back>
</article>