<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN" "http://jats.nlm.nih.gov/publishing/1.1d3/JATS-journalpublishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.1d3" xml:lang="en">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-17-02144</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1006343</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Probability theory</subject><subj-group><subject>Probability distribution</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Systems science</subject><subj-group><subject>Dynamical systems</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Systems science</subject><subj-group><subject>Dynamical systems</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Optimization</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Information theory</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Software engineering</subject><subj-group><subject>Source code</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Engineering and technology</subject><subj-group><subject>Software engineering</subject><subj-group><subject>Source code</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Software engineering</subject><subj-group><subject>Software design</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Engineering and technology</subject><subj-group><subject>Software engineering</subject><subj-group><subject>Software design</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Calculus</subject></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>PyPhi: A toolbox for integrated information theory</article-title>
<alt-title alt-title-type="running-head">PyPhi: A toolbox for integrated information theory</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-9737-6260</contrib-id>
<name name-style="western">
<surname>Mayner</surname> <given-names>William G. P.</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Project administration</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Visualization</role>
<role content-type="http://credit.casrai.org/">Writing – original draft</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-4779-6734</contrib-id>
<name name-style="western">
<surname>Marshall</surname> <given-names>William</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Formal analysis</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Albantakis</surname> <given-names>Larissa</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Findlay</surname> <given-names>Graham</given-names></name>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Marchman</surname> <given-names>Robert</given-names></name>
<role content-type="http://credit.casrai.org/">Software</role>
<role content-type="http://credit.casrai.org/">Validation</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
</contrib>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-3892-4087</contrib-id>
<name name-style="western">
<surname>Tononi</surname> <given-names>Giulio</given-names></name>
<role content-type="http://credit.casrai.org/">Conceptualization</role>
<role content-type="http://credit.casrai.org/">Funding acquisition</role>
<role content-type="http://credit.casrai.org/">Supervision</role>
<role content-type="http://credit.casrai.org/">Writing – review &amp; editing</role>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
</contrib-group>
<aff id="aff001">
<label>1</label>
<addr-line>Neuroscience Training Program, University of Wisconsin–Madison, Madison, Wisconsin, United States of America</addr-line>
</aff>
<aff id="aff002">
<label>2</label>
<addr-line>Psychiatry Department, University of Wisconsin–Madison, Madison, Wisconsin, United States of America</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Blackwell</surname> <given-names>Kim T.</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>George Mason University, UNITED STATES</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">mayner@wisc.edu</email> (WGPM); <email xlink:type="simple">gtononi@wisc.edu</email> (GT)</corresp>
</author-notes>
<pub-date pub-type="collection">
<month>7</month>
<year>2018</year>
</pub-date>
<pub-date pub-type="epub">
<day>26</day>
<month>7</month>
<year>2018</year>
</pub-date>
<volume>14</volume>
<issue>7</issue>
<elocation-id>e1006343</elocation-id>
<history>
<date date-type="received">
<day>22</day>
<month>12</month>
<year>2017</year>
</date>
<date date-type="accepted">
<day>4</day>
<month>7</month>
<year>2018</year>
</date>
</history>
<permissions>
<copyright-year>2018</copyright-year>
<copyright-holder>Mayner et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1006343"/>
<abstract>
<p>Integrated information theory provides a mathematical framework to fully characterize the cause-effect structure of a physical system. Here, we introduce <italic>PyPhi</italic>, a Python software package that implements this framework for causal analysis and unfolds the full cause-effect structure of discrete dynamical systems of binary elements. The software allows users to easily study these structures, serves as an up-to-date reference implementation of the formalisms of integrated information theory, and has been applied in research on complexity, emergence, and certain biological questions. We first provide an overview of the main algorithm and demonstrate PyPhi’s functionality in the course of analyzing an example system, and then describe details of the algorithm’s design and implementation. PyPhi can be installed with Python’s package manager via the command ‘<monospace>pip install pyphi</monospace>’ on Linux and macOS systems equipped with Python 3.4 or higher. PyPhi is open-source and licensed under the GPLv3; the source code is hosted on GitHub at <ext-link ext-link-type="uri" xlink:href="https://github.com/wmayner/pyphi" xlink:type="simple">https://github.com/wmayner/pyphi</ext-link>. Comprehensive and continually-updated documentation is available at <ext-link ext-link-type="uri" xlink:href="https://pyphi.readthedocs.io" xlink:type="simple">https://pyphi.readthedocs.io</ext-link>. The <monospace>pyphi-users</monospace> mailing list can be joined at <ext-link ext-link-type="uri" xlink:href="https://groups.google.com/forum/#!forum/pyphi-users" xlink:type="simple">https://groups.google.com/forum/#!forum/pyphi-users</ext-link>. A web-based graphical interface to the software is available at <ext-link ext-link-type="uri" xlink:href="http://integratedinformationtheory.org/calculate.html" xlink:type="simple">http://integratedinformationtheory.org/calculate.html</ext-link>.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution>Templeton World Charities Foundation</institution>
</funding-source>
<award-id>0067/AB41</award-id>
<principal-award-recipient>
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0002-3892-4087</contrib-id>
<name name-style="western">
<surname>Tononi</surname> <given-names>Giulio</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award002">
<funding-source>
<institution>National Institutes of Health (US)</institution>
</funding-source>
<award-id>NRSA T32 GM007507</award-id>
</award-group>
<funding-statement>WGPM, WM, LA, GF, RM and GT received funding from the Templeton World Charity Foundation (Grant #TWCF 0067/AB41). WGPM and GF were also supported by National Research Service Award (NRSA) T32 GM007507. The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="4"/>
<table-count count="1"/>
<page-count count="21"/>
</counts>
<custom-meta-group>
<custom-meta>
<meta-name>PLOS Publication Stage</meta-name>
<meta-value>vor-update-to-uncorrected-proof</meta-value>
</custom-meta>
<custom-meta>
<meta-name>Publication Update</meta-name>
<meta-value>2018-08-07</meta-value>
</custom-meta>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>The source code for PyPhi is available on GitHub at <ext-link ext-link-type="uri" xlink:href="https://github.com/wmayner/pyphi" xlink:type="simple">https://github.com/wmayner/pyphi</ext-link> and on the Python Package Index at <ext-link ext-link-type="uri" xlink:href="https://pypi.python.org/pypi/pyphi" xlink:type="simple">https://pypi.python.org/pypi/pyphi</ext-link>.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<disp-quote>
<p>This is a <italic>PLOS Computational Biology</italic> Software paper.</p>
</disp-quote>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Integrated information theory (IIT) has been proposed as a theory of consciousness. The central hypothesis is that a physical system has to meet five requirements (‘postulates’) in order to be a physical substrate of subjective experience: (1) <italic>intrinsic existence</italic> (the system must be able to make a difference to itself); (2) <italic>composition</italic> (it must be composed of parts that have causal power within the whole); (3) <italic>information</italic> (its causal power must be specific); (4) <italic>integration</italic> (its causal power must not be reducible to that of its parts); and (5) <italic>exclusion</italic> (it must be maximally irreducible) [<xref ref-type="bibr" rid="pcbi.1006343.ref001">1</xref>–<xref ref-type="bibr" rid="pcbi.1006343.ref005">5</xref>].</p>
<p>From these postulates, IIT develops a mathematical framework to assess the cause-effect structure (CES) of a physical system that is applicable to discrete dynamical systems. This framework has proven useful not only for the study of consciousness but has also been applied in research on complexity [<xref ref-type="bibr" rid="pcbi.1006343.ref006">6</xref>–<xref ref-type="bibr" rid="pcbi.1006343.ref009">9</xref>], emergence [<xref ref-type="bibr" rid="pcbi.1006343.ref010">10</xref>–<xref ref-type="bibr" rid="pcbi.1006343.ref012">12</xref>], and certain biological questions [<xref ref-type="bibr" rid="pcbi.1006343.ref013">13</xref>].</p>
<p>The main measure of cause-effect power, <italic>integrated information</italic> (denoted Φ), quantifies how irreducible a system’s CES is to those of its parts. Φ also serves as a general measure of complexity that captures to what extent a system is both integrated [<xref ref-type="bibr" rid="pcbi.1006343.ref006">6</xref>] and differentiated (informative) [<xref ref-type="bibr" rid="pcbi.1006343.ref014">14</xref>].</p>
<p>Here we describe <italic>PyPhi</italic>, a Python software package that implements IIT’s framework for causal analysis and unfolds the full CES of discrete Markovian dynamical systems of binary elements. The software allows users to easily study these CESs and serves as an up-to-date reference implementation of the formalisms of IIT.</p>
<p>Details of the mathematical framework are published elsewhere [<xref ref-type="bibr" rid="pcbi.1006343.ref001">1</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>]; in § Results we describe the output and input of the software and give an overview of the main algorithm in the course of reproducing results obtained from an example system studied in [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>]. In § Design and implementation we discuss specific issues concerning the algorithm’s implementation. Finally in § Availability and future directions we describe how the software can be obtained and discuss new functionality planned for future versions.</p>
</sec>
<sec id="sec002" sec-type="results">
<title>Results</title>
<sec id="sec003">
<title>Output</title>
<p>The software has two primary functions: (1) to unfold the full CES of a discrete dynamical system of interacting elements and compute its Φ value, and (2) to compute the maximally-irreducible cause-effect repertoires of a particular set of elements within the system. The first is function is implemented by <monospace>pyphi.compute.major_complex()</monospace>, which returns a <monospace>SystemIrreducibilityAnalysis</monospace> object (<xref ref-type="fig" rid="pcbi.1006343.g001">Fig 1A</xref>). The system’s CES is contained in the ‘<monospace>ces</monospace>’ attribute and its Φ value is contained in ‘<monospace>phi</monospace>’. Other attributes are detailed in the <ext-link ext-link-type="uri" xlink:href="https://pyphi.readthedocs.io/page/api/models.subsystem.html#pyphi.models.subsystem.SystemIrreducibilityAnalysis" xlink:type="simple">online documentation</ext-link>.</p>
<fig id="pcbi.1006343.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006343.g001</object-id>
<label>Fig 1</label>
<caption>
<title>Output.</title>
<p><bold>(A)</bold> The <monospace>SystemIrreducibilityAnalysis</monospace> object is the main output of the software. It represents the results of the analysis of the system in question. It has several attributes (grey boxes): ‘<monospace>ces</monospace>’ is a <monospace>CauseEffectStructure</monospace> object containing all of the system’s <monospace>Concepts</monospace>; ‘<monospace>cut</monospace>’ is a <monospace>Cut</monospace> object that represents the minimum-information partition (MIP) of the system (the partition of the system that makes the least difference to its CES); ‘<monospace>partitioned_ces</monospace>’ is the <monospace>CauseEffectStructure</monospace> of <monospace>Concepts</monospace> specified by the system after applying the MIP; and ‘<monospace>phi</monospace>’ is the Φ value, which measures the difference between the unpartitioned and partitioned CES. <bold>(B)</bold> A <monospace>Concept</monospace> represents the maximally-irreducible cause (MIC) and maximally-irreducible effect (MIE) of a mechanism in a state. The ‘<monospace>mechanism</monospace>’ attribute contains the indices of the mechanism elements. The ‘<monospace>cause</monospace>’ and ‘<monospace>effect</monospace>’ attributes contain <monospace>MaximallyIrreducibleCause</monospace> and <monospace>MaximallyIrreducibleEffect</monospace> objects that describe the mechanism’s MIC and MIE, respectively; each of these contains a purview, repertoire, MIP, partitioned repertoire, and <italic>φ</italic> value. The ‘<monospace>phi</monospace>’ attribute contains the concept’s <italic>φ</italic> value, which is the minimum of the <italic>φ</italic> values of the MIC and MIE.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.g001" xlink:type="simple"/>
</fig>
<p>The CES is composed of <monospace>Concept</monospace> objects, which are the output of the second main function: <monospace>Subsystem.concept()</monospace> (<xref ref-type="fig" rid="pcbi.1006343.g001">Fig 1B</xref>). Each <monospace>Concept</monospace> is specified by a set of elements within the system (contained in its ‘<monospace>mechanism</monospace>’ attribute). A <monospace>Concept</monospace> contains a maximally-irreducible cause and effect repertoire (‘<monospace>cause_repertoire</monospace>’ and ‘<monospace>effect_repertoire</monospace>’), which are probability distributions that capture how the mechanism elements in their current state constrain the previous and next state of the system, respectively; a <italic>φ</italic> value (‘<monospace>phi</monospace>’), which measures the irreducibility of the repertoires; and several other attributes discussed below and detailed in the <ext-link ext-link-type="uri" xlink:href="https://pyphi.readthedocs.io/page/api/models.mechanism.html#pyphi.models.mechanism.Concept" xlink:type="simple">online documentation</ext-link>.</p>
</sec>
<sec id="sec004">
<title>Input</title>
<p>The starting point for the IIT analysis is a discrete Markovian dynamical system <italic>S</italic> composed of <italic>n</italic> interacting elements. Such a system can be represented by a directed graph of interconnected nodes, each equipped with a function that outputs the node’s state at the next timestep <italic>t</italic> + 1 given the state of its parents at the previous timestep <italic>t</italic> (<xref ref-type="fig" rid="pcbi.1006343.g002">Fig 2</xref>). At present, PyPhi can analyze both deterministic and stochastic discrete Markovian dynamical systems consisting of elements with two states.</p>
<fig id="pcbi.1006343.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006343.g002</object-id>
<label>Fig 2</label>
<caption>
<title>A network of nodes and its TPM.</title>
<p>Each node has its own TPM—in this case, the truth-table of a deterministic logic gate. Yellow signifies the “ON” state; white signifies “OFF”. The system’s TPM (right) is composed of the TPMs of its nodes (left), here shown in state-by-node form (see § Representation of the TPM and probability distributions). Note that in PyPhi’s TPM representation, the first node’s state varies the fastest, according to the little-endian convention (see § 2-dimensional state-by-node form).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.g002" xlink:type="simple"/>
</fig>
<p>Such a discrete dynamical system is completely specified by its transition probability matrix (TPM), which contains the probabilities of all state transitions from <italic>t</italic> to <italic>t</italic> + 1. It can be obtained from the graphical representation of the system by perturbing the system into each of its possible states and observing the following state at the next timestep (for stochastic systems, repeated trials of perturbation/observation will yield the probabilities of each state transition). In PyPhi, the TPM is the fundamental representation of the system.</p>
<p>Formally, if we let <italic>S</italic><sub><italic>t</italic></sub> be the random variable of the system state at <italic>t</italic>, the TPM specifies the conditional probability distribution over the next state <italic>S</italic><sub><italic>t</italic>+1</sub> given each current state <italic>s</italic><sub><italic>t</italic></sub>:
<disp-formula id="pcbi.1006343.e001"><alternatives><graphic id="pcbi.1006343.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e001" xlink:type="simple"/><mml:math display="block" id="M1"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:mspace width="1.em"/><mml:mo>∀</mml:mo> <mml:mspace width="0.277778em"/><mml:msub><mml:mi>s</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>∈</mml:mo> <mml:msub><mml:mo>Ω</mml:mo> <mml:mi>S</mml:mi></mml:msub> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where Ω<sub><italic>S</italic></sub> denotes the set of possible states. Furthermore, given a marginal distribution over the previous states of the system, the TPM fully specifies the joint distribution over state transitions. Here IIT imposes uniformity on the marginal distribution of the previous states because the aim of the analysis is to capture direct causal relationships across a single timestep without confounding factors, such as influences from system states before <italic>t</italic> − 1 [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref004">4</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref011">11</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref015">15</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref016">16</xref>]. The marginal distribution thus corresponds to an interventional (causal), not observed, state distribution.</p>
<p>Moreover, IIT assumes that there is no instantaneous causation; that is, it is assumed that the elements of the dynamical system influence one another only from one timestep to the next. Therefore we require that the system satisfies the following Markov condition, called the <italic>conditional independence property</italic>: each element’s state at <italic>t</italic> + 1 must be independent of the state of the others, given the state of the system at <italic>t</italic> [<xref ref-type="bibr" rid="pcbi.1006343.ref017">17</xref>],
<disp-formula id="pcbi.1006343.e002"><alternatives><graphic id="pcbi.1006343.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e002" xlink:type="simple"/><mml:math display="block" id="M2"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="0.277778em"/><mml:mo>=</mml:mo> <mml:munder><mml:mo>∏</mml:mo> <mml:mrow><mml:mi>N</mml:mi> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>S</mml:mi></mml:mrow></mml:munder> <mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>N</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>S</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>s</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="0.277778em"/><mml:mo>,</mml:mo> <mml:mspace width="1.em"/><mml:mo>∀</mml:mo> <mml:mspace width="0.277778em"/><mml:msub><mml:mi>s</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>∈</mml:mo> <mml:mi>S</mml:mi> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(1)</label></disp-formula>
For systems of binary elements, a TPM that satisfies <xref ref-type="disp-formula" rid="pcbi.1006343.e002">Eq (1)</xref> can be represented in state-by-node form (<xref ref-type="fig" rid="pcbi.1006343.g002">Fig 2</xref>, right), since we need only store each element’s marginal distribution rather than the full joint distribution.</p>
<p>In PyPhi, the system under analysis is represented by a <monospace>Network</monospace> object. A <monospace>Network</monospace> is created by passing its TPM as the first argument: <monospace>network = pyphi.Network(tpm)</monospace> (see § Setup). Optionally, a connectivity matrix (CM) can also be provided, where
<disp-formula id="pcbi.1006343.e003"><alternatives><graphic id="pcbi.1006343.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e003" xlink:type="simple"/><mml:math display="block" id="M3"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mrow><mml:mo>[</mml:mo> <mml:mrow><mml:mtext>CM</mml:mtext></mml:mrow> <mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>{</mml:mo><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mtext>if</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>there</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>is</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>an</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>edge</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>from</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>element</mml:mtext><mml:mspace width="4.pt"/><mml:mi>i</mml:mi><mml:mspace width="4.pt"/><mml:mtext>to</mml:mtext><mml:mspace width="4.pt"/><mml:mtext>element</mml:mtext><mml:mspace width="4.pt"/><mml:mi>j</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mtext>otherwise</mml:mtext><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></alternatives></disp-formula>
via the <monospace>cm</monospace> keyword argument: <monospace>network = pyphi.Network(tpm, cm=cm)</monospace>. Because the TPM completely specifies the system, providing a CM is not necessary; however, explicit connectivity information can be used to make computations more efficient, especially for sparse networks, because PyPhi can rule out certain causal influences <italic>a priori</italic> if there are missing connections (see § Connectivity optimizations). Note that this means providing an incorrect CM can result in inaccurate output. If no CM is given, PyPhi assumes full connectivity; <italic>i.e</italic>., it assumes each element may have an effect on any other, which guarantees correct results.</p>
<p>Once the <monospace>Network</monospace> is created, a subset of elements within the system (called a <italic>candidate system</italic>), together with a particular system state, can be selected for analysis by creating a <monospace>Subsystem</monospace> object. Hereafter we refer to a candidate system as a <italic>subsystem</italic>.</p>
</sec>
<sec id="sec005">
<title>Demonstration</title>
<p>The mathematical framework of IIT is typically formulated using graphical causal models as representations of physical systems of elements. The framework builds on the causal calculus of the <italic>do</italic>(⋅) operator introduced by Pearl [<xref ref-type="bibr" rid="pcbi.1006343.ref017">17</xref>]. In order to assess causal relationships among the elements, interventions (manipulations, perturbations) are used to actively set elements into a specific state, after which the resulting state transition is observed.</p>
<p>For reference, we define a set of graphical operations that are used during the IIT analysis. To <italic>fix</italic> an element is to use system interventions to keep it in the same state for every observation. To <italic>noise</italic> an element is to use system interventions to set it into a state chosen uniformly at random. Finally, to <italic>cut</italic> a connection from a source element to a target element is to make the source appear noised to the target, while the remaining, uncut connections from the source still correctly transmit its state.</p>
<p>In this section we demonstrate some of the capabilities of the software by unfolding the CES of a small deterministic system of logic gates as described in [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>] while describing how the algorithm is implemented in terms of TPM manipulations, which we link to the graphical operations defined above. A schematic of the algorithm is shown in Figs <xref ref-type="fig" rid="pcbi.1006343.g003">3</xref> and <xref ref-type="fig" rid="pcbi.1006343.g004">4</xref>, and a more detailed illustration is given in <xref ref-type="supplementary-material" rid="pcbi.1006343.s001">S1 Text</xref>.</p>
<fig id="pcbi.1006343.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006343.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Algorithm schematic at the mechanism level.</title>
<p>PyPhi functions are named in boxes, with arguments in grey. Arrows point from callee to caller. Functions are organized by the postulate they correspond to (left). ⊗ denotes the tensor product; <inline-formula id="pcbi.1006343.e004"><alternatives><graphic id="pcbi.1006343.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula> denotes the power set.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.g003" xlink:type="simple"/>
</fig>
<fig id="pcbi.1006343.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006343.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Algorithm schematic at the system level.</title>
<p>PyPhi functions are named in boxes, with arguments in grey. Arrows point from callee to caller. Functions are organized by the postulate they correspond to (left). <inline-formula id="pcbi.1006343.e005"><alternatives><graphic id="pcbi.1006343.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e005" xlink:type="simple"/><mml:math display="inline" id="M5"><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle></mml:math></alternatives></inline-formula> denotes the power set.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.g004" xlink:type="simple"/>
</fig>
<sec id="sec006">
<title>Setup</title>
<p>The first step is to create the <monospace>Network</monospace> object. Here we choose to provide the TPM in 2-dimensional state-by-node form (see § 2-dimensional state-by-node form). The TPM is the only required argument, but we provide the CM as well, since we know that there are no self-loops in the system and PyPhi will use this information to speed up the computation. We also label the nodes <italic>A</italic>, <italic>B</italic>, and <italic>C</italic> to make the output easier to read.
<disp-formula id="pcbi.1006343.e023"><graphic id="pcbi.1006343.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e023" xlink:type="simple"/></disp-formula></p>
<p>We select a subsystem and a system state for analysis by creating a <monospace>Subsystem</monospace> object. System states are represented by tuples of <monospace>1</monospace>s and <monospace>0</monospace>s, with <monospace>1</monospace> meaning “ON” and <monospace>0</monospace> meaning “OFF.” In this case we will analyze the entire system, so the subsystem will contain all three nodes. The nodes to include can be specified with either their labels or their indices (note that in other PyPhi functions, nodes must be specified with their indices).
<disp-formula id="pcbi.1006343.e024"><graphic id="pcbi.1006343.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e024" xlink:type="simple"/></disp-formula></p>
<p>If there are nodes outside the subsystem, they are considered as <italic>background conditions</italic> for the causal analysis [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>]. In the graphical representation of the system, the background conditions are <italic>fixed</italic> in their current state while the subsystem is perturbed and observed in order to derive its TPM. In the TPM representation, the equivalent operation is performed by <italic>conditioning</italic> the system TPM on the state at <italic>t</italic> of the nodes outside the subsystem and then <italic>marginalizing out</italic> those nodes at <italic>t</italic> + 1 (illustrated in <xref ref-type="supplementary-material" rid="pcbi.1006343.s001">S1 Text</xref>). In PyPhi, this is done when the subsystem is created; the subsystem TPM can be accessed with the <monospace>tpm</monospace> attribute, <italic>e.g</italic>. <monospace>subsystem.tpm</monospace>.</p>
</sec>
<sec id="sec007">
<title>Cause/Effect repertoires (mechanism-level information)</title>
<p>The lowest-level objects in the CES of a system are the <italic>cause repertoire</italic> and <italic>effect repertoire</italic> of a set of nodes within the subsystem, called a <italic>mechanism</italic>, over another set of nodes within the subsystem, called a <italic>purview</italic> of the mechanism. The cause (effect) repertoire is a probability distribution that captures the information specified by the mechanism about the purview by describing how the previous (next) state of the purview is constrained by the current state of the mechanism.</p>
<p>In terms of graphical operations, the effect repertoire is obtained by (1) <italic>fixing</italic> the mechanism nodes in their state at <italic>t</italic>; (2) <italic>noising</italic> the non-mechanism nodes at time <italic>t</italic>, so as to remove their causal influence on the purview; and (3) observing the resulting state transition from <italic>t</italic> to <italic>t</italic> + 1 while ignoring the state at <italic>t</italic> + 1 of non-purview nodes, in order to derive a distribution over purview states at <italic>t</italic> + 1.</p>
<p>The cause repertoire is obtained similarly, but in that case, the purview nodes at time <italic>t</italic> − 1 are noised, and the resulting state transition from <italic>t</italic> − 1 to <italic>t</italic> is observed while ignoring the state of non-mechanism nodes. Bayes’ rule is then applied, resulting in a distribution over purview states at <italic>t</italic> − 1. The corresponding operations on the TPM are detailed in § Calculation of cause/effect repertoires from the TPM and illustrated in <xref ref-type="supplementary-material" rid="pcbi.1006343.s001">S1 Text</xref>.</p>
<p>Note that, operationally, we enforce that each input from a noised node conveys <italic>independent</italic> noise during the perturbation/observation step. In this way, we avoid counting correlations from outside the mechanism-purview pair as constraints due to the current state of the mechanism. Graphically, this process would correspond to replacing each noised node that is a parent of multiple purview nodes (for the effect repertoire) or mechanism nodes (for the cause repertoire) with multiple, independent “virtual nodes” (as in [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>, Supplementary Methods]). However, the equivalent definition of repertoires in Eqs (<xref ref-type="disp-formula" rid="pcbi.1006343.e015">3</xref>) and (<xref ref-type="disp-formula" rid="pcbi.1006343.e019">5</xref>) obviates the need to actually implement virtual nodes in PyPhi.</p>
<p>With the <monospace>cause_repertoire()</monospace> method of the <monospace>Subsystem</monospace>, we can obtain the cause repertoire of, for example, mechanism <italic>A</italic> over the purview <italic>ABC</italic> depicted in Fig. 4 of [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>]:
<disp-formula id="pcbi.1006343.e025"><graphic id="pcbi.1006343.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e025" xlink:type="simple"/></disp-formula></p>
<p>We see that mechanism <italic>A</italic> in its current state, ON (<monospace>1</monospace>), specifies information by ruling out the previous states in which <italic>B</italic> and <italic>C</italic> are OFF (<monospace>0</monospace>). That is, the probability that either <monospace>(0, 0, 0)</monospace> or <monospace>(1, 0, 0)</monospace> was the previous state, given that <italic>A</italic> is currently ON, is zero:
<disp-formula id="pcbi.1006343.e026"><graphic id="pcbi.1006343.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e026" xlink:type="simple"/></disp-formula></p>
<p>Note that repertoires are returned in multidimensional form, so they can be indexed with state tuples as above. Repertoires can be reshaped to be 1-dimensional if needed, <italic>e.g</italic>. for plotting, but care must be taken that NumPy’s FORTRAN (column-major) ordering is used so that PyPhi’s little-endian convention for indexing states is respected (see § 2-dimensional state-by-node form). PyPhi provides the <monospace>pyphi.distribution.flatten()</monospace> function for this:
<disp-formula id="pcbi.1006343.e027"><graphic id="pcbi.1006343.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e027" xlink:type="simple"/></disp-formula></p>
</sec>
<sec id="sec008">
<title>Minimum-information partitions (mechanism-level integration)</title>
<p>Having assessed the information of a mechanism over a purview, the next step is to assess its <italic>integrated information</italic> (denoted <italic>φ</italic>) by quantifying the extent to which the cause and effect repertoires of the mechanism-purview pair cannot be reduced to the repertoires of its parts.</p>
<p>In terms of graphical operations, the irreducibility of a mechanism-purview pair is tested by partitioning it into parts and <italic>cutting</italic> the connections between them. By applying the perturbation/observation procedure after cutting the connections we obtain a <italic>partitioned repertoire</italic>. Since the partition renders the parts independent, in terms of TPM manipulations, the partitioned repertoire can be calculated as the product of the individual repertoires for each of the parts. If the partitioned repertoire is no different than the original unpartitioned repertoire, then the mechanism as a whole did not specify integrated information about the purview. By contrast, if a repertoire cannot be factored in this way, then some of its selectivity is due to the causal influence of the mechanism <italic>as an integrated whole</italic> on the purview, and the repertoire is said to be <italic>irreducible</italic>.</p>
<p>The amount of irreducibility of a mechanism over a purview with respect to a partition is quantified as the distance between the unpartitioned repertoire and the partitioned repertoire (calculated with <monospace>pyphi.distance.repertoire_distance()</monospace>). There are many ways to divide the mechanism and purview into parts, so the irreducibility is measured for every partition and the partition that yields the minimum irreducibility is called the <italic>minimum-information partition</italic> (MIP). The integrated information (<italic>φ</italic>) of a mechanism-purview pair is the distance between the unpartitioned repertoire and the partitioned repertoire associated with the MIP. PyPhi supports several distance measures and partitioning schemes (see § Configuration).</p>
<p>The MIP search procedure is implemented by the <monospace>Subsystem.cause_mip()</monospace> and <monospace>Subsystem.effect_mip()</monospace> methods. Each returns a <monospace>RepertoireIrreducibilityAnalysis</monospace> object that contains the MIP, as well as the <italic>φ</italic> value, mechanism, purview, temporal direction (cause or effect), unpartitioned repertoire, and partitioned repertoire. For example, we compute the effect MIP of mechanism <italic>ABC</italic> over purview <italic>ABC</italic> from Fig. 6 of [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>] as follows:
<disp-formula id="pcbi.1006343.e006"><graphic id="pcbi.1006343.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e006" xlink:type="simple"/></disp-formula></p>
<p>Here we can see that the MIP attempts to factor the repertoire of <italic>ABC</italic> over <italic>ABC</italic> into the product of the repertoire of <italic>ABC</italic> over <italic>AC</italic> and the repertoire of the empty mechanism ∅ over <italic>B</italic>. However, the repertoire cannot be factored in this way without information loss; the distance between the unpartitioned and partitioned repertoire is nonzero (<inline-formula id="pcbi.1006343.e007"><alternatives><graphic id="pcbi.1006343.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e007" xlink:type="simple"/><mml:math display="inline" id="M7"><mml:mrow><mml:mi>φ</mml:mi> <mml:mo>=</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:mn>4</mml:mn></mml:mfrac></mml:mrow></mml:math></alternatives></inline-formula>). Thus mechanism <italic>ABC</italic> over the purview <italic>ABC</italic> is irreducible.</p>
</sec>
<sec id="sec009">
<title>Maximally-irreducible cause-effect repertoires (mechanism-level exclusion)</title>
<p>Next, we apply IIT’s postulate of exclusion at the mechanism level by finding the <italic>maximally-irreducible cause</italic> (MIC) and <italic>maximally irreducible effect</italic> (MIE) specified by a mechanism. This is done by searching over all possible purviews for the <monospace>RepertoireIrreducibilityAnalysis</monospace> object with the maximal <italic>φ</italic> value. The <monospace>Subsystem.mic()</monospace> and <monospace>Subsystem.mie()</monospace> methods implement this search procedure; they return a <monospace>MaximallyIrreducibleCause</monospace> and a <monospace>MaximallyIrreducibleEffect</monospace> object, respectively. The MIC of mechanism <italic>BC</italic>, for example, is the purview <italic>AB</italic> (Fig. 8 of [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>]). This is computed like so:
<disp-formula id="pcbi.1006343.e008"><graphic id="pcbi.1006343.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e008" xlink:type="simple"/></disp-formula></p>
</sec>
<sec id="sec010">
<title>Concepts</title>
<p>If the mechanism’s MIC has <italic>φ</italic><sub>cause</sub> &gt; 0 and its MIE has <italic>φ</italic><sub>effect</sub> &gt; 0, then the mechanism is said to specify a <italic>concept</italic>. The <italic>φ</italic> value of the concept as a whole is the minimum of <italic>φ</italic><sub>cause</sub> and <italic>φ</italic><sub>effect</sub>.</p>
<p>We can compute the concept depicted in Fig. 9 of [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>] using the <monospace>Subsystem.concept()</monospace> method, which takes a <monospace>mechanism</monospace> and returns a <monospace>Concept</monospace> object containing the <italic>φ</italic> value, the MIC (in the ‘<monospace>cause</monospace>’ attribute), and the MIE (in the ‘<monospace>effect</monospace>’ attribute):
<disp-formula id="pcbi.1006343.e009"><graphic id="pcbi.1006343.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e009" xlink:type="simple"/></disp-formula></p>
<p>Note that in PyPhi, the repertoires are distributions over purview states, rather than system states. Occasionally it is more convenient to represent repertoires as distributions over the entire system. This can be done with the <monospace>expand_cause_repertoire()</monospace> and <monospace>expand_effect_repertoire()</monospace> methods of the <monospace>Concept</monospace> object, which assume the unconstrained (maximum-entropy) distribution over the states of non-purview nodes:
<disp-formula id="pcbi.1006343.e028"><graphic id="pcbi.1006343.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e028" xlink:type="simple"/></disp-formula></p>
<p>Also note that <monospace>Subsystem.concept()</monospace> will return a <monospace>Concept</monospace> object when <italic>φ</italic> = 0 even though these are not concepts, strictly speaking. For convenience, <monospace>bool(concept)</monospace> evaluates to <monospace>True</monospace> if <italic>φ</italic> &gt; 0 and <monospace>False</monospace> otherwise.</p>
</sec>
<sec id="sec011">
<title>Cause-effect structures (system-level information)</title>
<p>The next step is to compute the CES, the set of all concepts specified by the subsystem. The CES characterizes all of the causal constraints that are intrinsic to a physical system. This is implemented by the <monospace>pyphi.compute.ces()</monospace> function, which simply calls <monospace>Subsystem.concept()</monospace> for every mechanism <inline-formula id="pcbi.1006343.e010"><alternatives><graphic id="pcbi.1006343.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:mrow><mml:mi>M</mml:mi> <mml:mo>∈</mml:mo> <mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>S</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pcbi.1006343.e011"><alternatives><graphic id="pcbi.1006343.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:mrow><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>S</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> is the power set of subsystem nodes. It returns a <monospace>CauseEffectStructure</monospace> object containing those <monospace>Concepts</monospace> for which <italic>φ</italic> &gt; 0.</p>
<p>We see that every mechanism in <inline-formula id="pcbi.1006343.e012"><alternatives><graphic id="pcbi.1006343.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e012" xlink:type="simple"/><mml:math display="inline" id="M12"><mml:mrow><mml:mstyle mathvariant="script"><mml:mi>P</mml:mi></mml:mstyle> <mml:mo form="prefix" stretchy="false">(</mml:mo> <mml:mi>S</mml:mi> <mml:mo form="postfix" stretchy="false">)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> except for <italic>AC</italic> specifies a concept, as described in Fig. 10 of [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>]:
<disp-formula id="pcbi.1006343.e029"><graphic id="pcbi.1006343.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e029" xlink:type="simple"/></disp-formula></p>
</sec>
<sec id="sec012">
<title>Irreducible cause-effect structures (system-level integration)</title>
<p>At this point, the irreducibility of the subsystem’s CES is evaluated by applying the integration postulate at the system level. As with integration at the mechanism level, the idea is to measure the difference made by each partition and then take the minimal value as the irreducibility of the subsystem.</p>
<p>We begin by performing a <italic>system cut</italic>. Graphically, the subsystem is partitioned into two parts and the edges going from one part to the other are <italic>cut</italic>, rendering them causally ineffective. This is implemented as an operation on the TPM as follows: Let <italic>E</italic><sub>cut</sub> denote the set of directed edges in the subsystem that are to be cut, where each edge <italic>e</italic> ∈ <italic>E</italic><sub>cut</sub> has a source node <italic>a</italic> and a target node <italic>b</italic>. For each edge, we modify the individual TPM of node <italic>b</italic> (<xref ref-type="fig" rid="pcbi.1006343.g002">Fig 2</xref>) by marginalizing over the states of <italic>a</italic> at <italic>t</italic>. The resulting TPM specifies the function implemented by <italic>b</italic> with the causal influence of <italic>a</italic> removed. We then combine the modified node TPMs to recover the full TPM of the partitioned subsystem. Finally, we recalculate the CES of the subsystem with this modified TPM (the <italic>partitioned CES</italic>).</p>
<p>The irreducibility of a CES with respect to a partition is the distance between the unpartitioned and partitioned CESs (calculated with <monospace>pyphi.compute.ces_distance()</monospace>; several distances are supported; see § Configuration). This distance is evaluated for every partition, and the minimum value across all partitions is the subsystem’s integrated information Φ, which measures the extent to which the CES specified by the subsystem is irreducible to the CES under the minimal partition.</p>
<p>This procedure is implemented by the <monospace>pyphi.compute.sia()</monospace> function, which returns a <monospace>SystemIrreducibilityAnalysis</monospace> object (<xref ref-type="fig" rid="pcbi.1006343.g001">Fig 1</xref>). We can verify that the Φ value of the example system in [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>] is 1.92 and the minimal partition is that which removes the causal connections from <italic>AB</italic> to <italic>C</italic>:
<disp-formula id="pcbi.1006343.e030"><graphic id="pcbi.1006343.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e030" xlink:type="simple"/></disp-formula></p>
</sec>
<sec id="sec013">
<title>Complexes (system-level exclusion)</title>
<p>The final step in unfolding the CES of the system is to apply the postulate of exclusion at the system level. We compute the CES of each subset of the network, considered as a subsystem (that is, <italic>fixing</italic> the external nodes as background conditions), and find the CES with maximal Φ, called the <italic>maximally-irreducible cause-effect structure</italic> (MICS) of the system. The subsystem giving rise to it is called the <italic>major complex</italic>; any overlapping subsets with lower Φ are excluded. Non-overlapping subsets may be further analyzed to find additional complexes within the system.</p>
<p>In this example, we find that the whole system <italic>ABC</italic> is the system’s major complex, and all proper subsets are excluded:
<disp-formula id="pcbi.1006343.e031"><graphic id="pcbi.1006343.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e031" xlink:type="simple"/></disp-formula></p>
<p>Note that since <monospace>pyphi.compute.major_complex()</monospace> is a function of the <monospace>Network</monospace>, rather than a particular <monospace>Subsystem</monospace>, it is necessary to specify the state in which the system should be analyzed.</p>
</sec>
</sec>
</sec>
<sec id="sec014" sec-type="materials|methods">
<title>Design and implementation</title>
<p>PyPhi was designed to be easy to use in interactive, exploratory research settings while nonetheless remaining suitable for use in large-scale simulations or as a component in larger applications. It was also designed to be efficient, given the high computational complexity of the algorithms in IIT. Here we describe some implementation details and optimizations used in the software.</p>
<sec id="sec015">
<title>Representation of the TPM and probability distributions</title>
<p>PyPhi supports three different TPM representations: 2-<italic>dimensional state-by-node</italic>, <italic>multidimensional state-by-node</italic>, and <italic>state-by-state</italic>. The state-by-node form is the canonical representation in PyPhi, with the 2-dimensional form used for input and visualization and the multidimensional form used for internal computation. The state-by-state representation is given as an input option for those accustomed to this more general form. If the TPM is given in state-by-state form, PyPhi will raise an error if it does not satisfy <xref ref-type="disp-formula" rid="pcbi.1006343.e002">Eq (1)</xref> (conditional independence).</p>
<sec id="sec016">
<title>2-dimensional state-by-node form</title>
<p>A TPM in state-by-node form is a matrix where the entry (<italic>i</italic>, <italic>j</italic>) gives the probability that the <italic>j</italic><sup>th</sup> node will be ON at <italic>t</italic> + 1 if the system is in the <italic>i</italic><sup>th</sup> state at <italic>t</italic>. This representation has the advantage of being more compact than the state-by-state form, with 2<sup><italic>n</italic></sup> × <italic>n</italic> entries instead of 2<sup><italic>n</italic></sup> × 2<sup><italic>n</italic></sup>, where <italic>n</italic> is the number of nodes. Note that the TPM admits this representation because in PyPhi the nodes are binary; both Pr(<italic>N</italic><sub><italic>t</italic>+1</sub> = ON) and Pr(<italic>N</italic><sub><italic>t</italic>+1</sub> = OFF) can be specified by a single entry, in our case Pr(<italic>N</italic><sub><italic>t</italic>+1</sub> = ON), since the two probabilities must sum to 1.</p>
<p>Because the possible system states at <italic>t</italic> are represented implicitly as row indices in 2-dimensional TPMs, there must be an implicit mapping from states to indices. In PyPhi this mapping is achieved by listing the state tuples in lexicographical order and then interpreting them as binary numbers where the state of the first node corresponds to the least-significant bit, so that <italic>e.g</italic>. the state <monospace>(0, 0, 0, 1)</monospace> is mapped to the row with index 8 (the ninth row, since Python uses zero-based indexing [<xref ref-type="bibr" rid="pcbi.1006343.ref018">18</xref>]). Designating the first node’s state as the least-significant bit is analogous to choosing the little-endian convention in organizing computer memory. This convention is preferable because the mapping is stable under the inclusion of new nodes: including another node in a subsystem only requires concatenating new rows and a new column to its TPM rather than interleaving them. Note that this is opposite convention to that used in writing numbers in positional notation; care must be taken when converting between states and indices and between different TPM representations (the <monospace>pyphi.convert</monospace> module provides convenience functions for these purposes).</p>
</sec>
<sec id="sec017">
<title>Multidimensional state-by-node form</title>
<p>When a state-by-state TPM is provided to PyPhi by the user, it is converted to state-by-node form and the conditional independence property (<xref ref-type="disp-formula" rid="pcbi.1006343.e002">Eq (1)</xref>) is checked. Note that any TPM in state-by-node form necessarily satisfies <xref ref-type="disp-formula" rid="pcbi.1006343.e002">Eq (1)</xref>. For internal computations, the TPM is then reshaped so that it has <italic>n</italic> + 1 dimensions rather than two: the first <italic>n</italic> dimensions correspond to the states of each of the <italic>n</italic> nodes at <italic>t</italic>, while the last dimension corresponds to the probabilities of each node being ON at <italic>t</italic> + 1. In other words, the indices of the rows (current states) in the 2-dimensional TPM are “unraveled” into <italic>n</italic> dimensions, with the <italic>i</italic><sup>th</sup> dimension indexed by the <italic>i</italic><sup><italic>th</italic></sup> bit of the 2-dimensional row index according to the little-endian convention. Because the TPM is stored in a NumPy array, this multidimensional form allows us to take advantage of NumPy indexing [<xref ref-type="bibr" rid="pcbi.1006343.ref019">19</xref>] and use a state tuple as an index directly, without converting it to an integer index:
<disp-formula id="pcbi.1006343.e032"><graphic id="pcbi.1006343.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e032" xlink:type="simple"/></disp-formula></p>
<p>The first entry of this array signifies that if the state of the system is <monospace>(0, 1, 1)</monospace> at <italic>t</italic>, then the probability of the first node <italic>N</italic><sub>0</sub> being ON at <italic>t</italic> + 1 is Pr(<italic>N</italic><sub>0,<italic>t</italic>+1</sub> = ON) = 1. Similarly, the second entry means Pr(<italic>N</italic><sub>1,<italic>t</italic>+1</sub> = ON) = 0.25 and the third entry means Pr(<italic>N</italic><sub>2,<italic>t</italic>+1</sub> = ON) = 0.75.</p>
<p>Most importantly, the multidimensional representation simplifies the calculation of marginal and conditional distributions and cause/effect repertoires, because it allows efficient “broadcasting” [<xref ref-type="bibr" rid="pcbi.1006343.ref019">19</xref>] of probabilities when multiplying distributions. Specifically, the Python multiplication operator ‘<monospace>*</monospace>’ acts as the tensor product when the operands are NumPy arrays <monospace>A</monospace> and <monospace>B</monospace> of equal dimensionality such that for each dimension <monospace>d</monospace>, either <monospace>A.shape[d] == 1</monospace> or <monospace>B.shape[d] == 1</monospace>.</p>
</sec>
</sec>
<sec id="sec018">
<title>Calculation of cause/effect repertoires from the TPM</title>
<p>The cause and effect repertoires of a mechanism over a purview describe how the mechanism nodes in a particular state at <italic>t</italic> constrain the possible states of the purview nodes at <italic>t</italic> − 1 and <italic>t</italic> + 1, respectively. Here we describe how they are derived from the TPM in PyPhi.</p>
<sec id="sec019">
<title>The effect repertoire</title>
<p>We begin with the simplest case: calculating the effect repertoire of a mechanism <italic>M</italic> ⊆ <italic>S</italic> over a purview consisting of a single element <italic>P</italic><sub><italic>i</italic></sub> ∈ <italic>S</italic>. This is defined as a conditional probability distribution over states of the purview element at <italic>t</italic> + 1 given the current state of the mechanism,
<disp-formula id="pcbi.1006343.e013"><alternatives><graphic id="pcbi.1006343.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e013" xlink:type="simple"/><mml:math display="block" id="M13"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mtext mathvariant="monospace">effect</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext mathvariant="monospace">repertoire</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>M</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>P</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≔</mml:mo><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(2)</label></disp-formula>
It is derived from the TPM by conditioning on the state of the mechanism elements, marginalizing over the states of non-purview elements <italic>P</italic>′ = <italic>S</italic>\<italic>P</italic><sub><italic>i</italic></sub> (these states correspond to columns in the state-by-state TPM), and marginalizing over the states of non-mechanism elements <italic>M</italic>′ = <italic>S</italic>\<italic>M</italic> (these correspond to rows):
<disp-formula id="pcbi.1006343.e014"><alternatives><graphic id="pcbi.1006343.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e014" xlink:type="simple"/><mml:math display="block" id="M14"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mtext>Pr</mml:mtext> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mspace width="1pt"/> <mml:mo>=</mml:mo></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mspace width="1pt"/> <mml:mspace width="1pt"/> <mml:mspace width="1pt"/> <mml:mspace width="1pt"/> <mml:mfrac><mml:mn>1</mml:mn> <mml:mrow><mml:mo>|</mml:mo> <mml:msub><mml:mo>Ω</mml:mo> <mml:msup><mml:mi>M</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:msub> <mml:mo>|</mml:mo></mml:mrow></mml:mfrac> <mml:mspace width="1pt"/> <mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msubsup> <mml:mspace width="4pt"/> <mml:mo>∈</mml:mo> <mml:mspace width="4pt"/> <mml:msub><mml:mo>Ω</mml:mo> <mml:msup><mml:mi>M</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder> <mml:mspace width="1pt"/></mml:mstyle> <mml:mfrac><mml:mn>1</mml:mn> <mml:mrow><mml:mo>|</mml:mo> <mml:msub><mml:mo>Ω</mml:mo> <mml:msup><mml:mi>P</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:msub> <mml:mo>|</mml:mo></mml:mrow></mml:mfrac> <mml:mspace width="1pt"/> <mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup> <mml:mspace width="4pt"/> <mml:mo>∈</mml:mo> <mml:mspace width="4pt"/> <mml:msub><mml:mo>Ω</mml:mo> <mml:msup><mml:mi>P</mml:mi> <mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder> <mml:mspace width="1pt"/></mml:mstyle> <mml:mtext>Pr</mml:mtext> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup> <mml:mo>∣</mml:mo> <mml:mi>M</mml:mi> <mml:mo>=</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:msup><mml:mi>M</mml:mi> <mml:mo>′</mml:mo></mml:msup> <mml:mo>=</mml:mo> <mml:msubsup><mml:mi>m</mml:mi><mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo>′</mml:mo></mml:msubsup> <mml:mo stretchy="false">)</mml:mo> <mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula></p>
<p>This operation is implemented in PyPhi by several subroutines. First, in a pre-processing step performed when the <monospace>Subsystem</monospace> object is created, a <monospace>Node</monospace> object is created for each element in the subsystem. Each <monospace>Node</monospace> contains its own individual TPM, extracted from the subsystem’s TPM; this is a 2<sup><italic>s</italic></sup> × 2 matrix where <italic>s</italic> is the number of the node’s parents and the entry (<italic>i</italic>, <italic>j</italic>) gives the probability that the node is in state <italic>j</italic> (<monospace>0</monospace> or <monospace>1</monospace>) at <italic>t</italic> + 1 given that its parents are in state <italic>i</italic> at <italic>t</italic>. This node TPM is represented internally in multidimensional state-by-node form as usual, with singleton dimensions for those subsystem elements that are not parents of the node. The effect repertoire is then calculated by conditioning the purview node’s TPM on the state of the mechanism nodes that are also parents of the purview node, via the <monospace>pyphi.tpm.condition_tpm()</monospace> function, and marginalizing out non-mechanism nodes, with <monospace>pyphi.tpm.marginalize_out()</monospace>.</p>
<p>In cases where there are mechanism nodes that are not parents of the purview node, the resulting array is multiplied by an array of ones that has the desired shape (dimensions of size two for each mechanism node, and singleton dimensions for each non-mechanism node). Because of NumPy’s broadcasting feature, this step is equivalent to taking the tensor product of the array with the maximum-entropy distribution over mechanism nodes that are not parents, so that the final result is a distribution over all mechanism nodes, as desired.</p>
<p>The effect repertoire over a purview of more than one element is given by the tensor product of the effect repertories over each individual purview element,
<disp-formula id="pcbi.1006343.e015"><alternatives><graphic id="pcbi.1006343.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e015" xlink:type="simple"/><mml:math display="block" id="M15"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mtext mathvariant="monospace">effect</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext mathvariant="monospace">repertoire</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>M</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>P</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≔</mml:mo><mml:munder><mml:mo>⊗</mml:mo> <mml:mrow><mml:msub><mml:mi>P</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>P</mml:mi></mml:mrow></mml:munder> <mml:mrow><mml:mtext mathvariant="monospace">effect</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext mathvariant="monospace">repertoire</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>M</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mi>P</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(3)</label></disp-formula>
Again, because PyPhi TPMs and repertoires are represented as tensors (multidimensional arrays), with each dimension corresponding to a node, the NumPy multiplication operator between distributions over different nodes is equivalent to the tensor product. Thus the effect repertoire over an arbitrary purview is trivially implemented by taking the product of the effect repertoires over each purview node with <monospace>numpy.multiply()</monospace>.</p>
</sec>
<sec id="sec020">
<title>The cause repertoire</title>
<p>The cause repertoire of a single-element mechanism <italic>M</italic><sub><italic>i</italic></sub> ∈ <italic>S</italic> over a purview <italic>P</italic> ⊆ <italic>S</italic> is defined as a conditional probability distribution over the states of the purview at <italic>t</italic> − 1 given the current state of the mechanism,
<disp-formula id="pcbi.1006343.e016"><alternatives><graphic id="pcbi.1006343.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e016" xlink:type="simple"/><mml:math display="block" id="M16"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mtext mathvariant="monospace">cause</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext mathvariant="monospace">repertoire</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>P</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>≔</mml:mo><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(4)</label></disp-formula>
As with the effect repertoire, it is obtained by conditioning and marginalizing the TPM. However, because the TPM gives conditional probabilities of states at <italic>t</italic> + 1 given the state at <italic>t</italic>, Bayes’ rule is first applied to express the cause repertoire in terms of a conditional distribution over states at <italic>t</italic> − 1 given the state at <italic>t</italic>,
<disp-formula id="pcbi.1006343.e017"><alternatives><graphic id="pcbi.1006343.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e017" xlink:type="simple"/><mml:math display="block" id="M17"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="0.277778em"/><mml:mo>=</mml:mo> <mml:mspace width="0.277778em"/><mml:mstyle displaystyle="true" scriptlevel="0"><mml:mfrac><mml:mrow><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="0.277778em"/><mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mrow><mml:mtext>Pr</mml:mtext> <mml:mo>(</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mfrac></mml:mstyle> <mml:mo>.</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
where the marginal distribution Pr(<italic>P</italic><sub><italic>t</italic>−1</sub>) over previous states is the uniform distribution. In this way, the analysis captures how a mechanism in a state constrains a purview without being biased by whether certain states arise more frequently than others in the dynamical evolution of the system [<xref ref-type="bibr" rid="pcbi.1006343.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref004">4</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref011">11</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref016">16</xref>]. Then the cause repertoire can be calculated by marginalizing over the states of non-mechanism elements <italic>M</italic>′ = <italic>S</italic>\<italic>M</italic><sub><italic>i</italic></sub> (now corresponding to columns in the state-by-state TPM) and non-purview elements <italic>P</italic>′ = <italic>S</italic>\<italic>P</italic> (now corresponding to rows),
<disp-formula id="pcbi.1006343.e018"><alternatives><graphic id="pcbi.1006343.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e018" xlink:type="simple"/><mml:math display="block" id="M18"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mfrac><mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>∣</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mspace width="4pt"/><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="4pt"/><mml:mo>=</mml:mo><mml:mspace width="4pt"/><mml:mfrac><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mspace width="4pt"/><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:mspace width="4pt"/><mml:mo>∈</mml:mo><mml:mspace width="4pt"/><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder><mml:mspace width="4pt"/></mml:mstyle><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mspace width="4pt"/><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mspace width="4pt"/><mml:mo>∈</mml:mo><mml:mspace width="4pt"/><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder><mml:mspace width="4pt"/></mml:mstyle><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>∣</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mspace width="4pt"/><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mspace width="4pt"/><mml:mo>∈</mml:mo><mml:mspace width="4pt"/><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder><mml:mspace width="4pt"/></mml:mstyle><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="4pt"/><mml:mo>=</mml:mo><mml:mspace width="4pt"/><mml:mfrac><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mrow><mml:mo>|</mml:mo><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub><mml:mo>|</mml:mo></mml:mrow></mml:mfrac><mml:mspace width="4pt"/><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:mo>∈</mml:mo><mml:mspace width="4pt"/><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>P</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder><mml:mspace width="4pt"/></mml:mstyle><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mspace width="4pt"/><mml:mo>∈</mml:mo><mml:mspace width="4pt"/><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder><mml:mspace width="4pt"/></mml:mstyle><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mi>t</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo>∣</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:msubsup><mml:mi>p</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>P</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mo>−</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mstyle displaystyle="true"><mml:munder><mml:mo>∑</mml:mo><mml:mrow><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mspace width="4pt"/><mml:mo>∈</mml:mo><mml:mspace width="4pt"/><mml:msub><mml:mo>Ω</mml:mo><mml:msup><mml:mi>M</mml:mi><mml:mo>′</mml:mo></mml:msup></mml:msub></mml:mrow></mml:munder><mml:mspace width="4pt"/></mml:mstyle><mml:mtext>Pr</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>m</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mi>m</mml:mi><mml:mi>t</mml:mi><mml:mo>′</mml:mo></mml:msubsup><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable>
</mml:math>
</alternatives></disp-formula></p>
<p>In PyPhi, the “backward” conditional probabilities Pr(<italic>m</italic><sub><italic>i</italic>,<italic>t</italic></sub> | <italic>P</italic><sub><italic>t</italic>−1</sub>) for a single mechanism node are obtained by indexing into the last dimension of the node’s TPM with the state <italic>m</italic><sub><italic>i</italic>,<italic>t</italic></sub> and then marginalizing out non-purview nodes via <monospace>pyphi.tpm.marginalize_out()</monospace>. As with the effect repertoire, the resulting array is then multiplied by an array of ones with the desired shape in order to obtain a distribution over the entire purview. Finally, because in this case the probabilities were obtained from columns of the TPM, which do not necessarily sum to 1, the distribution is normalized with <monospace>pyphi.distribution.normalize()</monospace>.</p>
<p>The cause repertoire of a mechanism with multiple elements is the normalized tensor product of the cause repertoires of each individual mechanism element,
<disp-formula id="pcbi.1006343.e019"><alternatives><graphic id="pcbi.1006343.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e019" xlink:type="simple"/><mml:math display="block" id="M19"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mrow><mml:mtext mathvariant="monospace">cause</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext mathvariant="monospace">repertoire</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>M</mml:mi> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>P</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mspace width="0.277778em"/><mml:mo>=</mml:mo> <mml:mspace width="0.277778em"/><mml:mfrac><mml:mn>1</mml:mn> <mml:mi>K</mml:mi></mml:mfrac> <mml:mspace width="0.277778em"/><mml:munder><mml:mo>⊗</mml:mo> <mml:mrow><mml:msub><mml:mi>M</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>M</mml:mi></mml:mrow></mml:munder> <mml:mrow><mml:mtext mathvariant="monospace">cause</mml:mtext> <mml:mo>_</mml:mo> <mml:mtext mathvariant="monospace">repertoire</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mi>i</mml:mi></mml:msub> <mml:mo>,</mml:mo> <mml:mspace width="0.166667em"/><mml:mi>P</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives> <label>(5)</label></disp-formula>
where
<disp-formula id="pcbi.1006343.e020"><alternatives><graphic id="pcbi.1006343.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e020" xlink:type="simple"/><mml:math display="block" id="M20"><mml:mtable displaystyle="true"><mml:mtr><mml:mtd columnalign="right"><mml:mrow><mml:mi>K</mml:mi> <mml:mspace width="0.277778em"/><mml:mo>=</mml:mo> <mml:mspace width="0.277778em"/><mml:munder><mml:mo>∑</mml:mo> <mml:mrow><mml:msub><mml:mi>p</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mo>Ω</mml:mo> <mml:mi>P</mml:mi></mml:msub></mml:mrow></mml:munder> <mml:mspace width="0.277778em"/><mml:munder><mml:mo>∏</mml:mo> <mml:mrow><mml:msub><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mspace width="0.166667em"/><mml:mo>∈</mml:mo> <mml:mspace width="0.166667em"/><mml:msub><mml:mo>Ω</mml:mo> <mml:mi>M</mml:mi></mml:msub></mml:mrow></mml:munder> <mml:mtext>Pr</mml:mtext> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi>P</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>p</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>-</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>∣</mml:mo> <mml:msub><mml:mi>M</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi>m</mml:mi> <mml:mrow><mml:mi>i</mml:mi> <mml:mo>,</mml:mo> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
is a normalization factor that ensures that the distribution sums to 1. This is implemented in PyPhi via <monospace>numpy.multiply()</monospace> and <monospace>pyphi.distribution.normalize()</monospace>. For a more complete illustration of these procedures, see <xref ref-type="supplementary-material" rid="pcbi.1006343.s001">S1 Text</xref>.</p>
</sec>
</sec>
<sec id="sec021">
<title>Code organization and interface design</title>
<p>The postulates of IIT induce a natural hierarchy of computations [<xref ref-type="bibr" rid="pcbi.1006343.ref001">1</xref>, Supplementary Information S2], and PyPhi’s implementation mirrors this hierarchy by using object-oriented programming (<xref ref-type="table" rid="pcbi.1006343.t001">Table 1</xref>) and factoring the computations into compositions of separate functions where possible. One advantage of this approach is that each level of the computation can be performed independently of the higher levels; for example, if one were interested only in the MIE of certain mechanisms rather than the full MICS, then one could simply call <monospace>Subsystem.effect_mip()</monospace> on those mechanisms instead of calling <monospace>pyphi.compute.sia()</monospace> and extracting them from the resulting <monospace>SystemIrreducibilityAnalysis</monospace> object (this is especially important in the case of large systems where the full calculation is infeasible). Separating the calculation into many subroutines and exposing them to the user also has the advantage that they can be easily composed to implement functionality that is not already built-in.</p>
<table-wrap id="pcbi.1006343.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1006343.t001</object-id>
<label>Table 1</label>
<caption>
<title>Correspondence between theoretical objects and PyPhi objects.</title>
</caption>
<alternatives>
<graphic id="pcbi.1006343.t001g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.t001" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="right" style="border-bottom:thick">Theoretical object</th>
<th align="left" style="border-bottom:thick">PyPhi object</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right">Discrete dynamical system</td>
<td align="left">
<monospace>Network</monospace>
</td>
</tr>
<tr>
<td align="right">Candidate system</td>
<td align="left">
<monospace>Subsystem</monospace>
</td>
</tr>
<tr>
<td align="right">System element</td>
<td align="left">
<monospace>Node</monospace> in <monospace>Subsystem.nodes</monospace></td>
</tr>
<tr>
<td align="right">System state</td>
<td align="left">Python <monospace>tuple</monospace> containing a <monospace>0</monospace> or <monospace>1</monospace> for each node</td>
</tr>
<tr>
<td align="right">Mechanism</td>
<td align="left">Python <monospace>tuple</monospace> of node indices</td>
</tr>
<tr>
<td align="right">Purview</td>
<td align="left">Python <monospace>tuple</monospace> of node indices</td>
</tr>
<tr>
<td align="right">Repertoire over a purview <italic>P</italic></td>
<td align="left">NumPy array with |<italic>P</italic>| dimensions, each of size 2</td>
</tr>
<tr>
<td align="right">MIP</td>
<td align="left">The <monospace>partition</monospace> attribute of the <monospace>RepertoireIrreducibilityAnalysis</monospace> returned by <monospace>Subsystem.cause_mip()</monospace> or <monospace>Subsystem.effect_mip()</monospace></td>
</tr>
<tr>
<td align="right">MIC and MIE</td>
<td align="left">
<monospace>MaximallyIrreducibleCause</monospace> and <monospace>MaximallyIrreducibleEffect</monospace></td>
</tr>
<tr>
<td align="right">Concept</td>
<td align="left">
<monospace>Concept</monospace>
</td>
</tr>
<tr>
<td align="right"><italic>φ</italic></td>
<td align="left">The <monospace>phi</monospace> attribute of a <monospace>Concept</monospace></td>
</tr>
<tr>
<td align="right">CES</td>
<td align="left">
<monospace>CauseEffectStructure</monospace>
</td>
</tr>
<tr>
<td align="right">Φ</td>
<td align="left">The <monospace>phi</monospace> attribute of a <monospace>CauseEffectStructure</monospace></td>
</tr>
<tr>
<td align="right">MICS</td>
<td align="left">The <monospace>ces</monospace> attribute of the <monospace>SystemIrreducibilityAnalysis</monospace> returned by <monospace>pyphi.compute.major_complex()</monospace></td>
</tr>
<tr>
<td align="right">Complex</td>
<td align="left">The <monospace>subsystem</monospace> attribute of the <monospace>SystemIrreducibilityAnalysis</monospace> returned by <monospace>pyphi.compute.major_complex()</monospace></td>
</tr>
</tbody>
</table>
</alternatives>
</table-wrap>
</sec>
<sec id="sec022">
<title>Configuration</title>
<p>Many aspects of PyPhi’s behavior may be configured via the <monospace>pyphi.config</monospace> object. The configuration can be specified in a YAML file [<xref ref-type="bibr" rid="pcbi.1006343.ref020">20</xref>]; an <ext-link ext-link-type="uri" xlink:href="https://github.com/wmayner/pyphi/blob/master/pyphi_config.yml" xlink:type="simple">example</ext-link> is available in the GitHub repository. When PyPhi is imported, it checks the current directory for a file named <monospace>pyphi_config.yml</monospace> and automatically loads it if it exists. Configuration settings can also be loaded on the fly from an arbitrary file with the <monospace>pyphi.config.load_config_file()</monospace> function.</p>
<p>Alternatively, <monospace>pyphi.config.load_config_dict()</monospace> can load configuration settings from a Python dictionary. Many settings can also be changed by directly assigning them a new value.</p>
<p>Default settings are used if no configuration is provided. A full description of the available settings and their default values is available in the <ext-link ext-link-type="uri" xlink:href="https://pyphi.readthedocs.io/page/configuration" xlink:type="simple">“Configuration” section of the online documentation</ext-link>.</p>
</sec>
<sec id="sec023">
<title>Optimizations and approximations</title>
<p>Here we describe various optimizations and approximations used by the software to reduce the complexity of the calculations (see § Limitations). Memoization and caching optimizations are described in <xref ref-type="supplementary-material" rid="pcbi.1006343.s002">S2 Text</xref>.</p>
<sec id="sec024">
<title>Connectivity optimizations</title>
<p>As mentioned in § Input, providing connectivity information explicitly with a CM can greatly reduce the time complexity of the computations, because in certain cases missing connections imply reducibility <italic>a priori</italic>.</p>
<p>For example, at the system level, if the subsystem is not strongly connected then Φ is necessarily zero. This is because a unidirectional cut between one system part and the rest can always be found that will not actually remove any edges, so the CESs with and without the cut will be identical (see <xref ref-type="supplementary-material" rid="pcbi.1006343.s003">S3 Text</xref> for proof). Accordingly, PyPhi immediately excludes these subsystems when finding the major complex of a system.</p>
<p>Similarly, at the mechanism level, PyPhi uses the CM to exclude certain purviews from consideration when computing a MIC or MIE by efficiently determining that repertoires over those purviews are reducible without needing to explicitly compute them. Suppose there are two sets of nodes <italic>X</italic> and <italic>Y</italic> for which there exist partitions <italic>X</italic> = (<italic>X</italic><sub>1</sub>, <italic>X</italic><sub>2</sub>) and <italic>Y</italic> = (<italic>Y</italic><sub>1</sub>, <italic>Y</italic><sub>2</sub>) such that there are no edges from <italic>X</italic><sub>1</sub> to <italic>Y</italic><sub>2</sub> and no edges from <italic>X</italic><sub>2</sub> to <italic>Y</italic><sub>1</sub>. Then the effect repertoire of mechanism <italic>X</italic> over purview <italic>Y</italic> can be factored as
<disp-formula id="pcbi.1006343.e021"><alternatives><graphic id="pcbi.1006343.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e021" xlink:type="simple"/><mml:math display="block" id="M21"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle mathvariant="monospace"><mml:mtext>effect_repertoire</mml:mtext></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:mi>X</mml:mi> <mml:mo>,</mml:mo> <mml:mi>Y</mml:mi> <mml:mo stretchy="false">)</mml:mo> <mml:mspace width="1pt"/> <mml:mo>=</mml:mo> <mml:mspace width="1pt"/></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mspace width="1pt"/> <mml:mspace width="54pt"/><mml:mstyle mathvariant="monospace"><mml:mtext>effect_repertoire</mml:mtext></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>X</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>Y</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mspace width="1pt"/> <mml:mo>⊗</mml:mo> <mml:mspace width="1pt"/> <mml:mstyle mathvariant="monospace"><mml:mtext>effect_repertoire</mml:mtext></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>X</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>Y</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mo>,</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
and the cause repertoire of mechanism <italic>Y</italic> over purview <italic>X</italic> can be factored as
<disp-formula id="pcbi.1006343.e022"><alternatives><graphic id="pcbi.1006343.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1006343.e022" xlink:type="simple"/><mml:math display="block" id="M22"><mml:mtable columnalign="left"><mml:mtr><mml:mtd><mml:mstyle mathvariant="monospace"><mml:mtext>cause_repertoire</mml:mtext></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:mi>Y</mml:mi> <mml:mo>,</mml:mo> <mml:mi>X</mml:mi> <mml:mo stretchy="false">)</mml:mo> <mml:mspace width="1pt"/> <mml:mo>=</mml:mo> <mml:mspace width="1pt"/></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mspace width="54pt"/> <mml:mstyle mathvariant="monospace"><mml:mtext>cause_repertoire</mml:mtext></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>Y</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>X</mml:mi> <mml:mn>1</mml:mn></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mspace width="1pt"/> <mml:mo>⊗</mml:mo> <mml:mspace width="1pt"/> <mml:mstyle mathvariant="monospace"><mml:mtext>cause_repertoire</mml:mtext></mml:mstyle> <mml:mo stretchy="false">(</mml:mo> <mml:msub><mml:mi>Y</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi>X</mml:mi> <mml:mn>2</mml:mn></mml:msub> <mml:mo stretchy="false">)</mml:mo> <mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></alternatives></disp-formula>
Thus in these cases the mechanism is reducible for that purview and <italic>φ</italic> = 0 (see <xref ref-type="supplementary-material" rid="pcbi.1006343.s004">S4 Text</xref> for proof).</p>
</sec>
<sec id="sec025">
<title>Analytical solution to the earth mover’s distance</title>
<p>One of the repertoire distances available in PyPhi is the earth mover’s distance (EMD), with the Hamming distance as the ground metric. Computing the EMD between repertoires is a costly operation, with time complexity <italic>O</italic>(<italic>n</italic>2<sup>3<italic>n</italic></sup>) where <italic>n</italic> is the number of nodes in the purview [<xref ref-type="bibr" rid="pcbi.1006343.ref021">21</xref>]. However, when comparing effect repertoires, PyPhi exploits a theorem that states that the EMD between two distributions <italic>p</italic> and <italic>q</italic> over multiple nodes is the sum of the EMDs between the marginal distributions over each individual node, if <italic>p</italic> and <italic>q</italic> are independent. This analytical solution has time complexity <italic>O</italic>(<italic>n</italic>), a significant improvement over the general EMD algorithm (note that this estimate does not include the cost of computing the marginals, which already have been computed to obtain the repertoires). By the conditional independence property (<xref ref-type="disp-formula" rid="pcbi.1006343.e002">Eq 1</xref>), the conditions of the theorem hold for EMD calculations between effect repertoires, and thus the analytical solution can be used for half of all repertoire calculations performed in the analysis. The theorem is formally stated and proved in <xref ref-type="supplementary-material" rid="pcbi.1006343.s005">S5 Text</xref>.</p>
</sec>
<sec id="sec026">
<title>Approximations</title>
<p>Currently, two approximate methods of computing Φ are available. These can be used via settings in the PyPhi configuration file (they are disabled by default):</p>
<list list-type="order">
<list-item>
<p>
<monospace>pyphi.config.CUT_ONE_APPROXIMATION</monospace> (the “cut one” approximation), and</p>
</list-item>
<list-item>
<p>
<monospace>pyphi.config.ASSUME_CUTS_CANNOT_CREATE_NEW_CONCEPTS</monospace> (the “no new concepts” approximation).</p>
</list-item>
</list>
<p>In both cases, the complexity of the calculation is greatly reduced by replacing the optimal partitioned CES by an approximate solution. The system’s Φ value is then computed as usual as the difference between the unpartitioned CES and the approximate partitioned CES.</p>
</sec>
<sec id="sec027">
<title>Cut one</title>
<p>The “cut one” approximation reduces the scope of the search for the MIP over possible system cuts. Instead of evaluating the partitioned CES for each of the 2<sup><italic>n</italic></sup> unidirectional bipartitions of the system, only those 2<italic>n</italic> bipartitions are evaluated that sever the edges from a single node to the rest of the network or vice versa. Since the goal is to find the minimal Φ value across all possible partitions, the “cut one” approximation provides an upper bound on the exact Φ value of the system.</p>
</sec>
<sec id="sec028">
<title>No new concepts</title>
<p>For most choices of mechanism partitioning schemes and distance measures, it is possible that the CES of the partitioned system contains concepts that are reducible in the unpartitioned system and thus not part of the unpartitioned CES. For this reason, PyPhi by default computes the partitioned CES from scratch from the partitioned TPM. Under the “no new concepts” approximation, such new concepts are ignored. Instead of repeating the entire CES computation for each system partition, which requires reevaluating all possible candidate mechanisms for irreducibility, only those mechanisms are taken into account that already specify concepts in the unpartitioned CES. In many types of systems, new concepts due to the partition are rare. Approximations using the “no new concepts” option are thus often accurate. Note, however, that this approximation provides neither a theoretical upper nor lower bound on the exact Φ value of the system.</p>
</sec>
</sec>
<sec id="sec029">
<title>Limitations</title>
<p>PyPhi’s main limitation is that the algorithm is exponential time in the number of nodes, <italic>O</italic>(<italic>n</italic>53<sup><italic>n</italic></sup>). This is because the number of states, subsystems, mechanisms, purviews, and partitions that must be considered each grows exponentially in the size of the system. This limits the size of systems that can be practically analyzed to ~10–12 nodes. For example, calculating the major complex of systems of three, five, and seven stochastic majority gates, connected in a circular chain of bidirectional edges, takes ~1 s, ~16 s, and ~2.75 h respectively (parallel evaluation of system cuts, 32 × 3.1GHz CPU cores). Using the “cut one” approximation, these calculations take ~1 s, ~12 s, and ~0.63 h. In practice, actual execution times are substantially variable and depend on the specific network under analysis, because network structure determines the effectiveness of the optimizations discussed above.</p>
<p>Another limitation is that the analysis can only be meaningfully applied to a system that is Markovian and satisfies the conditional independence property. These are reasonable assumptions for the intended use case of the software: analyzing a causal TPM derived using the calculus of perturbations [<xref ref-type="bibr" rid="pcbi.1006343.ref017">17</xref>]. However, there is no guarantee that these assumptions will be valid in other circumstances, such as TPMs derived from observed time series (<italic>e.g</italic>., EEG recordings). Whether a system has the Markov property and conditional independence property should be carefully checked before applying the software in novel contexts.</p>
</sec>
</sec>
<sec id="sec030">
<title>Availability and future directions</title>
<p>PyPhi can be installed with Python’s package manager via the command ‘<monospace>pip install pyphi</monospace>’ on Linux and macOS systems equipped with Python 3.4 or higher. It is open-source and licensed under the GNU General Public License v3.0. The source code is version-controlled with <monospace>git</monospace> and hosted in a public repository on GitHub at <ext-link ext-link-type="uri" xlink:href="https://github.com/wmayner/pyphi" xlink:type="simple">https://github.com/wmayner/pyphi</ext-link>. Comprehensive and continually-updated documentation is available online at <ext-link ext-link-type="uri" xlink:href="https://pyphi.readthedocs.io" xlink:type="simple">https://pyphi.readthedocs.io</ext-link>. The <monospace>pyphi-users</monospace> mailing list can be joined at <ext-link ext-link-type="uri" xlink:href="https://groups.google.com/forum/#!forum/pyphi-users" xlink:type="simple">https://groups.google.com/forum/#!forum/pyphi-users</ext-link>. A web-based graphical interface to the software is available at <ext-link ext-link-type="uri" xlink:href="http://integratedinformationtheory.org/calculate.html" xlink:type="simple">http://integratedinformationtheory.org/calculate.html</ext-link>.</p>
<p>Several additional features are in development and will be released in future versions. These include a module for calculating Φ over multiple spatial and temporal scales, as theoretically required by the exclusion postulate (in the current version, the <monospace>Network</monospace> is assumed to represent the system at the spatiotemporal timescale at which Φ is maximized [<xref ref-type="bibr" rid="pcbi.1006343.ref010">10</xref>, <xref ref-type="bibr" rid="pcbi.1006343.ref012">12</xref>]), and a module implementing a calculus for “actual causation” as formulated in [<xref ref-type="bibr" rid="pcbi.1006343.ref015">15</xref>] (preliminary versions of these modules are available in the current release). The software will also be updated to reflect developments in IIT and further optimizations in the algorithm.</p>
</sec>
<sec id="sec031">
<title>Supporting information</title>
<supplementary-material id="pcbi.1006343.s001" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s001" xlink:type="simple">
<label>S1 Text</label>
<caption>
<title>Calculating Φ.</title>
<p>Illustration of the algorithm.</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1006343.s002" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s002" xlink:type="simple">
<label>S2 Text</label>
<caption>
<title>Memoization and caching optimizations.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1006343.s003" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s003" xlink:type="simple">
<label>S3 Text</label>
<caption>
<title>Proof of the strong connectivity optimization.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1006343.s004" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s004" xlink:type="simple">
<label>S4 Text</label>
<caption>
<title>Proof of the block-factorable optimization.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1006343.s005" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s005" xlink:type="simple">
<label>S5 Text</label>
<caption>
<title>Proof of an analytical solution to the EMD between effect repertoires.</title>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1006343.s006" mimetype="application/zip" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s006" xlink:type="simple">
<label>S1 File</label>
<caption>
<title>PyPhi v1.1.0 source code.</title>
<p>Note that installing PyPhi via ‘<monospace>pip</monospace>’ or downloading the source code from GitHub is recommended in order to obtain the most up-to-date version of the software.</p>
<p>(ZIP)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1006343.s007" mimetype="application/zip" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1006343.s007" xlink:type="simple">
<label>S2 File</label>
<caption>
<title>PyPhi v1.1.0 documentation.</title>
<p>Note that accessing the documentation online at <ext-link ext-link-type="uri" xlink:href="https://pyphi.readthedocs.io" xlink:type="simple">https://pyphi.readthedocs.io</ext-link> is recommended, as it is updated for each new version of the software.</p>
<p>(ZIP)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ack>
<p>We thank Andrew Haun, Leonardo Barbosa, Sabrina Streipert, and Erik Hoel for their valuable feedback as early users of the software.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1006343.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Boly</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Massimini</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Koch</surname> <given-names>C</given-names></name>. <article-title>Integrated information theory: from consciousness to its physical substrate</article-title>. <source>Nature Reviews Neuroscience</source>. <year>2016</year>;<volume>17</volume>(<issue>7</issue>):<fpage>450</fpage>–<lpage>461</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1038/nrn.2016.44" xlink:type="simple">10.1038/nrn.2016.44</ext-link></comment> <object-id pub-id-type="pmid">27225071</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Integrated information theory</article-title>. <source>Scholarpedia</source>. <year>2015</year>;<volume>10</volume>(<issue>1</issue>):<fpage>4164</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.4249/scholarpedia.4164" xlink:type="simple">10.4249/scholarpedia.4164</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Oizumi</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>From the Phenomenology to the Mechanisms of Consciousness: Integrated Information Theory 3.0</article-title>. <source>PLoS computational biology</source>. <year>2014</year>;<volume>10</volume>(<issue>5</issue>):<fpage>e1003588</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1003588" xlink:type="simple">10.1371/journal.pcbi.1003588</ext-link></comment> <object-id pub-id-type="pmid">24811198</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Balduzzi</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Integrated information in discrete dynamical systems: motivation and theoretical framework</article-title>. <source>PLoS computational biology</source>. <year>2008</year>;<volume>4</volume>(<issue>6</issue>):<fpage>e1000091</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1000091" xlink:type="simple">10.1371/journal.pcbi.1000091</ext-link></comment> <object-id pub-id-type="pmid">18551165</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref005">
<label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>An information integration theory of consciousness</article-title>. <source>BMC neuroscience</source>. <year>2004</year>;<volume>5</volume>(<issue>1</issue>):<fpage>42</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1186/1471-2202-5-42" xlink:type="simple">10.1186/1471-2202-5-42</ext-link></comment> <object-id pub-id-type="pmid">15522121</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref006">
<label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>The Intrinsic Cause-Effect Power of Discrete Dynamical Systems—From Elementary Cellular Automata to Adapting Animats</article-title>. <source>Entropy</source>. <year>2015</year>;<volume>17</volume>(<issue>8</issue>):<fpage>5472</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.3390/e17085472" xlink:type="simple">10.3390/e17085472</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref007">
<label>7</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Hintze</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Koch</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Adami</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Evolution of Integrated Causal Structures in Animats Exposed to Environments of Increasing Complexity</article-title>. <source>PLoS computational biology</source>. <year>2014</year>;<volume>10</volume>(<issue>12</issue>):<fpage>e1003966</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1003966" xlink:type="simple">10.1371/journal.pcbi.1003966</ext-link></comment> <object-id pub-id-type="pmid">25521484</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref008">
<label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Oizumi</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Tsuchiya</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Amari</surname> <given-names>S</given-names></name>. <article-title>Unified framework for information integration based on information geometry</article-title>. <source>Proceedings of the National Academy of Sciences</source>. <year>2016</year>;<volume>113</volume>(<issue>51</issue>):<fpage>14817</fpage>–<lpage>14822</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1073/pnas.1603583113" xlink:type="simple">10.1073/pnas.1603583113</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref009">
<label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Chapter 14: Automata and Animats</article-title>. <source>From Matter to Life: Information and Causality</source>. <year>2017</year>; p. <fpage>334</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1017/9781316584200.014" xlink:type="simple">10.1017/9781316584200.014</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hoel</surname> <given-names>EP</given-names></name>, <name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Marshall</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Can the macro beat the micro? Integrated information across spatiotemporal scales</article-title>. <source>Neuroscience of Consciousness</source>. <year>2016</year>;<volume>2016</volume>(<issue>1</issue>):<fpage>niw012</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1093/nc/niw012" xlink:type="simple">10.1093/nc/niw012</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hoel</surname> <given-names>EP</given-names></name>, <name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Quantifying causal emergence shows that macro can beat micro</article-title>. <source>PNAS</source>. <year>2013</year>;<volume>110</volume>(<issue>49</issue>):<fpage>19790</fpage>–<lpage>19795</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1073/pnas.1314922110" xlink:type="simple">10.1073/pnas.1314922110</ext-link></comment> <object-id pub-id-type="pmid">24248356</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref012">
<label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Marshall</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Black-boxing and cause-effect power</article-title>. <source>PLoS computational biology</source>. <year>2018</year>;<volume>14</volume>(<issue>4</issue>):<fpage>e1006114</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1371/journal.pcbi.1006114" xlink:type="simple">10.1371/journal.pcbi.1006114</ext-link></comment> <object-id pub-id-type="pmid">29684020</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref013">
<label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Marshall</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Kim</surname> <given-names>H</given-names></name>, <name name-style="western"><surname>Walker</surname> <given-names>SI</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>, <name name-style="western"><surname>Albantakis</surname> <given-names>L</given-names></name>. <article-title>How causal analysis can reveal autonomy in models of biological systems</article-title>. <source>Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences</source>. <year>2017</year>;<volume>375</volume> (<issue>2109</issue>). <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1098/rsta.2016.0358" xlink:type="simple">10.1098/rsta.2016.0358</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Marshall</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Gomez-Ramirez</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Tononi</surname> <given-names>G</given-names></name>. <article-title>Integrated Information and State Differentiation</article-title>. <source>Frontiers in Psychology</source>. <year>2016</year>;<volume>7</volume>:<fpage>926</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.3389/fpsyg.2016.00926" xlink:type="simple">10.3389/fpsyg.2016.00926</ext-link></comment> <object-id pub-id-type="pmid">27445896</object-id></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref015">
<label>15</label>
<mixed-citation publication-type="other" xlink:type="simple">Albantakis L, Marshall W, Tononi G. What caused what? An irreducible account of actual causation. arXiv:170806716 [csAI]. 2017.</mixed-citation>
</ref>
<ref id="pcbi.1006343.ref016">
<label>16</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Ay</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Polani</surname> <given-names>D</given-names></name>. <article-title>Information flows in causal networks</article-title>. <source>Advances in complex systems</source>. <year>2008</year>;<volume>11</volume>(<issue>01</issue>):<fpage>17</fpage>–<lpage>41</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1142/S0219525908001465" xlink:type="simple">10.1142/S0219525908001465</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref017">
<label>17</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Pearl</surname> <given-names>J</given-names></name>. <source>Causality</source>. <publisher-name>Cambridge university press</publisher-name>; <year>2009</year>.</mixed-citation>
</ref>
<ref id="pcbi.1006343.ref018">
<label>18</label>
<mixed-citation publication-type="other" xlink:type="simple">Dijkstra EW. Why numbering should start at zero (EWD 831); 1982. Available from: <ext-link ext-link-type="uri" xlink:href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" xlink:type="simple">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006343.ref019">
<label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Walt</surname> <given-names>Svd</given-names></name>, <name name-style="western"><surname>Colbert</surname> <given-names>SC</given-names></name>, <name name-style="western"><surname>Varoquaux</surname> <given-names>G</given-names></name>. <article-title>The NumPy array: a structure for efficient numerical computation</article-title>. <source>Computing in Science &amp; Engineering</source>. <year>2011</year>;<volume>13</volume>(<issue>2</issue>):<fpage>22</fpage>–<lpage>30</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1109/MCSE.2011.37" xlink:type="simple">10.1109/MCSE.2011.37</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1006343.ref020">
<label>20</label>
<mixed-citation publication-type="other" xlink:type="simple">Ben-Kiki O, Evans C, Net Id. YAML specification; 2009. Available from: <ext-link ext-link-type="uri" xlink:href="http://yaml.org/spec/" xlink:type="simple">http://yaml.org/spec/</ext-link>.</mixed-citation>
</ref>
<ref id="pcbi.1006343.ref021">
<label>21</label>
<mixed-citation publication-type="other" xlink:type="simple">Pele O, Werman M. Fast and robust earth mover’s distances. In: 2009 IEEE 12th International Conference on Computer Vision. IEEE; 2009. p. 460–467. Available from: <ext-link ext-link-type="uri" xlink:href="https://doi.org/10.1109/ICCV.2009.5459199" xlink:type="simple">https://doi.org/10.1109/ICCV.2009.5459199</ext-link>.</mixed-citation>
</ref>
</ref-list>
</back>
</article>