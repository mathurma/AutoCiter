<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1d3 20150301//EN" "http://jats.nlm.nih.gov/publishing/1.1d3/JATS-journalpublishing1.dtd">
<article article-type="research-article" dtd-version="1.1d3" xml:lang="en" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink">
<front>
<journal-meta>
<journal-id journal-id-type="nlm-ta">PLoS Comput Biol</journal-id>
<journal-id journal-id-type="publisher-id">plos</journal-id>
<journal-id journal-id-type="pmc">ploscomp</journal-id>
<journal-title-group>
<journal-title>PLOS Computational Biology</journal-title>
</journal-title-group>
<issn pub-type="ppub">1553-734X</issn>
<issn pub-type="epub">1553-7358</issn>
<publisher>
<publisher-name>Public Library of Science</publisher-name>
<publisher-loc>San Francisco, CA USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">PCOMPBIOL-D-15-01907</article-id>
<article-id pub-id-type="doi">10.1371/journal.pcbi.1004948</article-id>
<article-categories>
<subj-group subj-group-type="heading">
<subject>Research Article</subject>
</subj-group>
<subj-group subj-group-type="Discipline-v3"><subject>Engineering and technology</subject><subj-group><subject>Electronics</subject><subj-group><subject>Signal decoders</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Behavior</subject><subj-group><subject>Animal behavior</subject><subj-group><subject>Imitation</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Zoology</subject><subj-group><subject>Animal behavior</subject><subj-group><subject>Imitation</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive science</subject><subj-group><subject>Cognitive psychology</subject><subj-group><subject>Learning</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive psychology</subject><subj-group><subject>Learning</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Social sciences</subject><subj-group><subject>Psychology</subject><subj-group><subject>Cognitive psychology</subject><subj-group><subject>Learning</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Learning and memory</subject><subj-group><subject>Learning</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Engineering and technology</subject><subj-group><subject>Human factors engineering</subject><subj-group><subject>Man-computer interface</subject></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject><subj-group><subject>Kalman filter</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject><subj-group><subject>Kalman filter</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Physical sciences</subject><subj-group><subject>Mathematics</subject><subj-group><subject>Applied mathematics</subject><subj-group><subject>Algorithms</subject><subj-group><subject>Machine learning algorithms</subject></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Research and analysis methods</subject><subj-group><subject>Simulation and modeling</subject><subj-group><subject>Algorithms</subject><subj-group><subject>Machine learning algorithms</subject></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Biology and life sciences</subject><subj-group><subject>Neuroscience</subject><subj-group><subject>Cognitive science</subject><subj-group><subject>Artificial intelligence</subject><subj-group><subject>Machine learning</subject><subj-group><subject>Machine learning algorithms</subject></subj-group></subj-group></subj-group></subj-group></subj-group></subj-group><subj-group subj-group-type="Discipline-v3"><subject>Computer and information sciences</subject><subj-group><subject>Artificial intelligence</subject><subj-group><subject>Machine learning</subject><subj-group><subject>Machine learning algorithms</subject></subj-group></subj-group></subj-group></subj-group></article-categories>
<title-group>
<article-title>Neuroprosthetic Decoder Training as Imitation Learning</article-title>
<alt-title alt-title-type="running-head">Neuroprosthetic Decoder Training as Imitation Learning</alt-title>
</title-group>
<contrib-group>
<contrib contrib-type="author" corresp="yes" xlink:type="simple">
<name name-style="western">
<surname>Merel</surname> <given-names>Josh</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="corresp" rid="cor001">*</xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<contrib-id authenticated="true" contrib-id-type="orcid">http://orcid.org/0000-0003-1005-6385</contrib-id>
<name name-style="western">
<surname>Carlson</surname> <given-names>David</given-names></name>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
<xref ref-type="aff" rid="aff004"><sup>4</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
<xref ref-type="aff" rid="aff004"><sup>4</sup></xref>
</contrib>
<contrib contrib-type="author" xlink:type="simple">
<name name-style="western">
<surname>Cunningham</surname> <given-names>John P.</given-names></name>
<xref ref-type="aff" rid="aff001"><sup>1</sup></xref>
<xref ref-type="aff" rid="aff002"><sup>2</sup></xref>
<xref ref-type="aff" rid="aff003"><sup>3</sup></xref>
<xref ref-type="aff" rid="aff004"><sup>4</sup></xref>
</contrib>
</contrib-group>
<aff id="aff001">
<label>1</label>
<addr-line>Neurobiology and Behavior program, Columbia University, New York, New York, United States of America</addr-line>
</aff>
<aff id="aff002">
<label>2</label>
<addr-line>Center for Theoretical Neuroscience, Columbia University, New York, New York, United States of America</addr-line>
</aff>
<aff id="aff003">
<label>3</label>
<addr-line>Department of Statistics, Columbia University, New York, New York, United States of America</addr-line>
</aff>
<aff id="aff004">
<label>4</label>
<addr-line>Grossman Center for the Statistics of Mind, Columbia University, New York, New York, United States of America</addr-line>
</aff>
<contrib-group>
<contrib contrib-type="editor" xlink:type="simple">
<name name-style="western">
<surname>Chase</surname> <given-names>Steven M</given-names></name>
<role>Editor</role>
<xref ref-type="aff" rid="edit1"/>
</contrib>
</contrib-group>
<aff id="edit1">
<addr-line>Carnegie Mellon University, UNITED STATES</addr-line>
</aff>
<author-notes>
<fn fn-type="conflict" id="coi001">
<p>The authors have declared that no competing interests exist.</p>
</fn>
<fn fn-type="con" id="contrib001">
<p>Conceived and designed the experiments: JM LP JPC. Performed the experiments: JM. Analyzed the data: JM. Contributed reagents/materials/analysis tools: JM DC LP JPC. Wrote the paper: JM DC LP JPC.</p>
</fn>
<corresp id="cor001">* E-mail: <email xlink:type="simple">jsmerel@gmail.com</email></corresp>
</author-notes>
<pub-date pub-type="collection">
<month>5</month>
<year>2016</year>
</pub-date>
<pub-date pub-type="epub">
<day>18</day>
<month>5</month>
<year>2016</year>
</pub-date>
<volume>12</volume>
<issue>5</issue>
<elocation-id>e1004948</elocation-id>
<history>
<date date-type="received">
<day>11</day>
<month>11</month>
<year>2015</year>
</date>
<date date-type="accepted">
<day>26</day>
<month>4</month>
<year>2016</year>
</date>
</history>
<permissions>
<copyright-year>2016</copyright-year>
<copyright-holder>Merel et al</copyright-holder>
<license xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.</license-p>
</license>
</permissions>
<self-uri content-type="pdf" xlink:href="info:doi/10.1371/journal.pcbi.1004948"/>
<abstract>
<p>Neuroprosthetic brain-computer interfaces function via an algorithm which decodes neural activity of the user into movements of an end effector, such as a cursor or robotic arm. In practice, the decoder is often learned by updating its parameters while the user performs a task. When the user’s intention is not directly observable, recent methods have demonstrated value in training the decoder against a surrogate for the user’s intended movement. Here we show that training a decoder in this way is a novel variant of an <italic>imitation learning</italic> problem, where an oracle or expert is employed for supervised training in lieu of direct observations, which are not available. Specifically, we describe how a generic imitation learning meta-algorithm, dataset aggregation (DA<sc>gger</sc>), can be adapted to train a generic brain-computer interface. By deriving existing learning algorithms for brain-computer interfaces in this framework, we provide a novel analysis of <italic>regret</italic> (an important metric of learning efficacy) for brain-computer interfaces. This analysis allows us to characterize the space of algorithmic variants and bounds on their regret rates. Existing approaches for decoder learning have been performed in the cursor control setting, but the available design principles for these decoders are such that it has been impossible to scale them to naturalistic settings. Leveraging our findings, we then offer an algorithm that combines imitation learning with optimal control, which should allow for training of arbitrary effectors for which optimal control can generate goal-oriented control. We demonstrate this novel and general BCI algorithm with simulated neuroprosthetic control of a 26 degree-of-freedom model of an arm, a sophisticated and realistic end effector.</p>
</abstract>
<abstract abstract-type="summary">
<title>Author Summary</title>
<p>There are various existing methods for rapidly learning a decoder during closed-loop brain computer interface (BCI) tasks. While many of these methods work well in practice, there is no clear theoretical foundation for parameter learning. We offer a unification of closed-loop decoder learning setting as an imitation learning problem. This has two major consequences: first, our approach clarifies how to derive “intention-based” algorithms for any BCI setting, most notably more complex settings like control of an arm; and second, this framework allows us to provide theoretical results, building from an existing literature on the regret of related algorithms. After first demonstrating algorithmic performance in simulation on the well-studied setting of a user trying to reach targets by controlling a cursor on a screen, we then simulate a user controlling an arm with many degrees of freedom in order to grasp a wand. Finally, we describe how extensions in the online-imitation learning literature can improve BCI in additional settings.</p>
</abstract>
<funding-group>
<award-group id="award001">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100007297</institution-id>
<institution>Office of Naval Research Global</institution>
</institution-wrap>
</funding-source>
<award-id>ONR N00014-16-1-2176</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award002">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100006785</institution-id>
<institution>Google</institution>
</institution-wrap>
</funding-source>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award003">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000893</institution-id>
<institution>Simons Foundation</institution>
</institution-wrap>
</funding-source>
<award-id>325233</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award004">
<funding-source>
<institution-wrap>
<institution-id institution-id-type="funder-id">http://dx.doi.org/10.13039/100000893</institution-id>
<institution>Simons Foundation</institution>
</institution-wrap>
</funding-source>
<award-id>325233</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Cunningham</surname> <given-names>John P.</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award005">
<funding-source>
<institution>Simons Foundation (US)</institution>
</funding-source>
<award-id>325171</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Paninski</surname> <given-names>Liam</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award006">
<funding-source>
<institution>Simons Foundation (US)</institution>
</funding-source>
<award-id>325171</award-id>
<principal-award-recipient>
<name name-style="western">
<surname>Cunningham</surname> <given-names>John P.</given-names></name>
</principal-award-recipient>
</award-group>
<award-group id="award007">
<funding-source>
<institution>Alfred P. Sloan Foundation (US)</institution>
</funding-source>
<principal-award-recipient>
<name name-style="western">
<surname>Cunningham</surname> <given-names>John P.</given-names></name>
</principal-award-recipient>
</award-group>
<funding-statement>This work was supported by ONR N00014-16-1-2176 (<ext-link ext-link-type="uri" xlink:href="http://www.onr.navy.mil/" xlink:type="simple">http://www.onr.navy.mil/</ext-link>) and a Google Research Award (<ext-link ext-link-type="uri" xlink:href="http://research.google.com/university/relations/" xlink:type="simple">http://research.google.com/university/relations/</ext-link>) to LP. Simons Global Brain Research Awards SCGB#325171 and SCGB#325233 (<ext-link ext-link-type="uri" xlink:href="https://www.simonsfoundation.org/" xlink:type="simple">https://www.simonsfoundation.org/</ext-link>) supported LP and JPC. JPC is supported by a Sloan Research Fellowship (<ext-link ext-link-type="uri" xlink:href="http://www.sloan.org/sloan-research-fellowships/" xlink:type="simple">http://www.sloan.org/sloan-research-fellowships/</ext-link>). All authors receive support from the Grossman Center at Columbia University (<ext-link ext-link-type="uri" xlink:href="http://grossmancenter.columbia.edu/" xlink:type="simple">http://grossmancenter.columbia.edu/</ext-link>), and the Gatsby Charitable Trust (<ext-link ext-link-type="uri" xlink:href="http://www.gatsby.org.uk/" xlink:type="simple">http://www.gatsby.org.uk/</ext-link>). The funders had no role in study design, data collection and analysis, decision to publish, or preparation of the manuscript.</funding-statement>
</funding-group>
<counts>
<fig-count count="8"/>
<table-count count="1"/>
<page-count count="24"/>
</counts>
<custom-meta-group>
<custom-meta id="data-availability">
<meta-name>Data Availability</meta-name>
<meta-value>All relevant data are within the paper and its Supporting Information files. There is a public github repository associated with this project at <ext-link ext-link-type="uri" xlink:href="https://github.com/jsmerel/BCI_imitation_learning/" xlink:type="simple">https://github.com/jsmerel/BCI_imitation_learning/</ext-link>.</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<sec id="sec001" sec-type="intro">
<title>Introduction</title>
<p>Brain-computer interfaces (BCI, or brain-machine interfaces) translate noisy neural activity into commands for controlling an effector via a decoding algorithm [<xref ref-type="bibr" rid="pcbi.1004948.ref001">1</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref004">4</xref>]. While there are various proposed and debated encoding mechanisms describing how motor-relevant variables actually relate to neural activity [<xref ref-type="bibr" rid="pcbi.1004948.ref005">5</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref009">9</xref>], in practice decoders are successful at leveraging the statistical relationship between the intended movements of the user and firing rates of recorded neural signals. Under the operational assumption that some key variables of interest (e.g. effector kinematics) are linearly encoded by neural activity, the Kalman filter (KF) is a reasonable decoding approach [<xref ref-type="bibr" rid="pcbi.1004948.ref010">10</xref>], and empirically it yields state-of-the-art decoding performance [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>] (see [<xref ref-type="bibr" rid="pcbi.1004948.ref012">12</xref>] for review). Once a decoder family (e.g. KF) is specified, a core objective in decoder design is to obtain good performance by learning specific parameter values during a training phase. For a healthy user who is capable of making overt movements (as in a laboratory setup with non-human primates [<xref ref-type="bibr" rid="pcbi.1004948.ref001">1</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref003">3</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>]), it is possible to observe neural activity and overt movements simultaneously in order to directly learn the statistical mapping—implicitly, we assume the overt movements reflect <italic>intention</italic>, so this mapping provides a relationship between neural activity and intended movement.</p>
<p>However, in many cases of interest the user is not able to make overt movements, so intended movements must be inferred or otherwise determined. This insight that better decoder parameters can be learned by training against some form of assumed intention appears in [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>], and extensions have been explored in [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref014">14</xref>]. In these works, it is assumed that the user intends to move towards the current goal or target in a cursor task, resulting in parameter training algorithms that result in dramatically improved decoder performance on a cursor task.</p>
<p>Specifically, in the <italic>recalibrated feedback intention-trained Kalman filter</italic> formulation (ReFIT, [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>]), the decoder is trained in two stages. First, the subject makes some number of reaches using its real arm. The hand kinematics and neural data are used to train a Kalman filter decoder. Next, the subject engages in the reach-task in an online setting using the fixed Kalman filter decoder. The decoder could be updated naively with the data from this second stage (gathered via closed loop control of the cursor). However, the key parameter-fitting insight of ReFIT is that a demonstrably better decoder is learned by first modifying this closed-loop data to reflect the assumption that the user intended at each timestep to move towards the target (rather than the movement that the decoder actually produced). Specifically, the modification is that the instantaneous velocity from the closed-loop cursor control is <italic>rotated</italic> to point towards the goal to create a goal-oriented dataset. The decoder is then trained on this modified dataset. ReFIT additionally proposes a modified decoding algorithm. However, we emphasize the distinction between the problem of learning parameters and selection of the decoding algorithm—this paper focuses on the problem of learning parameters (for discussion concerning decoding algorithm selection, see [<xref ref-type="bibr" rid="pcbi.1004948.ref012">12</xref>]).</p>
<p>Shortcomings of ReFIT include both a lack of understanding the conditions necessary for successful application of its parameter-fitting innovation, as well as the inability for the user to perform overt movements required for the initial data collection when the user is paralyzed (as would be the norm for clinical settings [<xref ref-type="bibr" rid="pcbi.1004948.ref004">4</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref015">15</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref016">16</xref>]). But even more critical an issue is that ReFIT is exclusively suited to the cursor setting by requiring the intuitively-defined, goal-rotated velocities. The <italic>closed-loop decoder adaptation</italic> (CLDA) framework has made steps towards generalizing the ReFIT parameter-fitting innovation [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>]. The CLDA approach built on ReFIT, effectively proposing to update the decoder online as new data streamed in using an adaptive scheme [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref014">14</xref>]. While these developments significantly improve the range of applicability, they still rely on rotated velocities and do not address the key issue of extending these insights to more complex tasks, such as control with a realistic multi-joint arm effector. In the present work, we provide a clear approach which generalizes this problem to arbitrary effectors and contextualizes the style of parameter fitting employed in both ReFIT and CLDA approaches as special cases of a more general online learning problem, called “imitation learning.”</p>
<p>In imitation learning (or “apprenticeship learning”), an agent must learn what action to take when in a particular situation (or state) via access to an expert or oracle which provides the agent with a good action at each timestep. The agent can thereby gradually learn a policy for determining which action to select in various settings. This setting is related to online learning [<xref ref-type="bibr" rid="pcbi.1004948.ref017">17</xref>], wherein an agent makes sequential actions and receives feedback from the environment regarding the quality of the action. We propose that, in the BCI setting, instead of a policy that asserts which action to take in a given state, we have a decoder that determines the effector update in response to the current kinematic state and neural activity. Formally, the decoder serves the role of the policy; the neural activity and the current kinematic pose of the effector comprise the state; and the incremental updates to the effector pose correspond to actions. We also formalize knowledge of the user’s instantaneous “true” intention as an <italic>intention-oracle</italic>. With this oracle, we can train the decoder in an online-imitation data collection process using update rules that follow from supervised learning.</p>
<p>Our work helps to resolve core issues in the application of intention-based parameter fitting methods. (1) By explicitly deriving intention-based parameter fitting from an imitation learning perspective, we can describe a family of algorithms, provide general guarantees for the closed-loop training process, and provide specific guarantees for standard choices of parameter update rules. (2) We generalize intention-based parameter fitting to more general effectors through the use of an optimal control solver to generate an intention-oracle. We provide a concrete approach to derive goal-directed intention signals for a model monkey arm in a reaching task. Simulations of the arm movement task demonstrate the feasibility of leveraging intention-based parameter fitting in higher dimensional tasks—something fundamentally ambiguous given existing work, because it was not possible to infer intention for high-dimensional tasks or arbitrary effector DOF representations.</p>
<p>In the next section, we formulate the learning problem. We then present a family of CLDA-like algorithms which encompasses existing approaches. By relating BCI learning algorithms to their general online learning counterparts in this way, we can leverage the results from the larger online learning literature. We theoretically characterize the algorithms in terms of bounds on “regret.” Regret is a measure of the performance of a learning algorithm relative to the performance if that algorithm were set to its optimal parameters. However, while bounds are highly informative about dominant terms, they are often ambiguous up to proportionality constants. Therefore, we employ simulations to give a concrete sense of how well these algorithms can perform and provide a demonstration that even learning to control a full arm is now feasible using this approach.</p>
</sec>
<sec id="sec002" sec-type="results">
<title>Results</title>
<sec id="sec003">
<title>Components of the imitation learning approach for BCI</title>
<p>The problem that arises in BCI parameter fitting is to learn the parameters of the model in an online fashion. In an ideal world, this could be performed by supervised learning, where we observe both the neural activity and overt movements, which reflect user intention. In a closed-loop setting, we would then simply use supervised online learning methods. However, for supervised learning we need labelled movement data. Neither overt movements nor user intent are actually observable in a real-world prosthetic setting. Imitation learning, through the usage of an oracle or expert, helps us circumvent this issue. To begin, we describe the core components of BCI algorithms that follow the imitation learning paradigm—effector, task objective, oracle, decoding algorithm, and update rule (<xref ref-type="fig" rid="pcbi.1004948.g001">Fig 1</xref>).</p>
<fig id="pcbi.1004948.g001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g001</object-id>
<label>Fig 1</label>
<caption>
<title>A BCI has an <italic>effector</italic>, such as a robotic arm, with predefined degrees of freedom.</title>
<p>Given a <italic>task objective</italic> (e.g. an objective function corresponding to reaching and grasping a target), an <italic>intention-oracle</italic> can be computed to provide the intended updates to the arm kinematics. The actual trajectory of the arm is evaluated deterministically from the neural activity via the <italic>decoder</italic>. In practice, the oracle update would be recomputed at each timestep to reflect the instantaneous best movement in the direction of the goal.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g001" xlink:type="simple"/>
</fig>
<p>The <italic>effector</italic> for a BCI is the part of the system that is controlled in order to interact with the environment (e.g. a cursor on a computer screen [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>] or a robotic arm [<xref ref-type="bibr" rid="pcbi.1004948.ref015">15</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref018">18</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref019">19</xref>]). Minimally, the degrees of freedom (DOF) that are able to be controlled must be selected. For example, when controlling a robotic arm, it might be decided that the user only controls the hand position of the robotic arm (e.g. as if it were a cursor in 3D) and the updates to the arm joint angles are computed by the algorithm to accommodate that movement. A model of effector dynamics provides a probabilistic state transition model, which permits the use of filtering techniques as the decoding algorithm. The default assumption for dynamics is that the effector does not move discontinuously, which yields smoothed trajectories.</p>
<p>The <italic>task objective</italic> refers to the performance measure of the task. For example, in a cursor task, the objective could be for the cursor to be as close as possible to the goal as rapidly as possible, or it may be for the cursor to acquire as many targets as possible in some time interval. Other objectives related to holding the cursor at the target with a required amount of stability have also been proposed (e.g. “dial-in-time” as in [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>]). The objective may include be additional components related to minimizing exertion (i.e. energy) or having smooth/naturalistic movements. Insofar as this task has been communicated to the user (verbally in the human case or via training in the case of non-human subjects), the user’s intention should be consistent with this objective, so it is appropriate to consider the task objective to correspond to the user’s intended objective.</p>
<p>Imitation learning requires an <italic>oracle</italic> or expert to provide the labelled data. When overt movements are available, we use overt movements as a proxy for the intended movements. Retrospectively, we re-interpret the parameter-fitting innovation of ReFIT in the imitation learning framework—specifically, the choice to train using goal-directed velocity vectors [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>] was an implicit selection of intention-oracle (a model of the user’s intention). Indeed this is a reasonable choice of oracle as it is goal-directed, presumably reflects user intent, and provides a sensible heuristic for the magnitude of the instantaneous oracle velocities. More generally, the oracle should be selected to match the user’s intention as closely as possible (for example by compensating for sensory delays as in [<xref ref-type="bibr" rid="pcbi.1004948.ref020">20</xref>]). When the task objective is well-specified and there exists a dynamics model for the effector, routine optimal control theory can be used to produce the oracle (along the lines of [<xref ref-type="bibr" rid="pcbi.1004948.ref021">21</xref>]). That is, from the current position, the incremental update to the effector state in the direction of the task objective can be computed. For a cursor, a simple mean-squared error (MSE) objective will result in optimal velocities directed towards the goal/target, with extra assumptions governing the magnitudes of those velocities.</p>
<p>Different BCI algorithms also differ in their choice of <italic>decoder</italic> family and <italic>update rule</italic>. We can abstract these decoders as learned functions mapping neural activity and current effector state to kinematic updates (e.g. this is straightforward for the steady-state Kalman filter, see <xref ref-type="sec" rid="sec011">methods</xref>). The parameters of the model will be adapted by an update rule, which makes use of the observed pairs of data (i.e the intention-oracle and the neural activity). We note two complementary perspectives—we can use our data to directly update decoder parameters or alternatively we can update the encoding model parameters and compute the corresponding updated optimal decoder (i.e. using Bayes rule to combine the encoding model and the effector dynamics model to decode via Bayesian filtering). In principle, either of these approaches work, but in this work we will directly adapt decoder parameters because it is simpler and closer to the convention in online learning.</p>
<p>In very general decision process settings, a function mapping from states to actions is called a <italic>policy</italic> [<xref ref-type="bibr" rid="pcbi.1004948.ref022">22</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref023">23</xref>]—in BCI settings, this is the decoder. The details of this mapping can be specified in a few essentially equivalent ways. Most consistent with the state-action mapping is for the policy to produce an action corresponding to an update to the state of the effector. If the effector state consists of positions, then these updates are velocities; but the effector state could also be instantaneous velocities, forces, or other variables, in which case the actions correspond to updates to these state variables and imply updates to the pose of the effector.</p>
<p>Relatively more familiar in BCI research is the use of a policy as decoder when reinforcement learning (RL) is being used (see [<xref ref-type="bibr" rid="pcbi.1004948.ref024">24</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref027">27</xref>], or even with error feedback derived from neural activity in other brain regions [<xref ref-type="bibr" rid="pcbi.1004948.ref028">28</xref>]). Reinforcement learning and imitation learning involve similar formalisms. However, the most suitable learning framework depends on the available information. Conventional RL only provides information when feedback is available (e.g. when the task is successful), whereas use of an oracle in imitation learning allows for training informed by every state. This will yield considerably more rapid learning than RL. There are various ways to learn a policy using frameworks between these extremes. In an actor-critic RL framework [<xref ref-type="bibr" rid="pcbi.1004948.ref029">29</xref>], the policy (a.k.a. actor) is trained from a learned value function (a.k.a. critic)—readers familiar with this framework may see this as a conceptual bridge between imitation learning and RL, where imitation learning uses oracle examples rather than a learned value function. It is also possible to learn an expert’s reward function from examples and directly train the policy [<xref ref-type="bibr" rid="pcbi.1004948.ref030">30</xref>]. Perhaps most usefully, a policy could also be learned from hybrid RL and imitation updates, and this would be well-advised if the oracle is noisy or of otherwise low quality (see <xref ref-type="sec" rid="sec010">Discussion</xref>).</p>
</sec>
<sec id="sec004">
<title>Parameter updating through imitation learning</title>
<p>We next present a BCI meta-algorithm which formalizes closed-loop data collection and online parameter updating as a variant of imitation learning. This perspective is consistent with the CLDA framework [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>], but by formalizing the entire approach as a meta-algorithm, we gain additional theoretical leverage. BCI training as described in this meta-algorithm amounts to a non-standard imitation learning setting insofar as the oracle comes from a task-constrained model of user intention, and the decoder is a policy that is conditioned on noisy neural activity. The imitation learning formalization of this BCI learning procedure is consistent with the online-imitation learning framework and meta-algorithm <italic>dataset aggregation</italic> (DA<sc>gger</sc>) [<xref ref-type="bibr" rid="pcbi.1004948.ref017">17</xref>]. We will subsequently show the online-imitation learning framework encompasses a range of reasonable closed-loop BCI approaches.</p>
<p>We set up the process such that the data is split into reach <italic>trajectories</italic> <italic>k</italic> = 1, …, <italic>K</italic> that each contain a sequence of <italic>T</italic><sub><italic>k</italic></sub> &lt; <italic>T</italic> discretized time points, and <italic>K</italic> is not necessarily known <italic>a priori</italic>. Each <italic>T</italic><sub><italic>k</italic></sub> corresponds to the time it takes for a single successful reach. The <italic>k</italic><sup><italic>th</italic></sup> reach is successful when some task objective, such as the distance between the cursor position and a goal position <bold>g</bold><sub><italic>kt</italic></sub>, is satisfied to within some <italic>ϵ</italic> (more generally, the goal <bold>g</bold><sub><italic>kt</italic></sub> corresponds to any sort of target upon which the objective depends). At each time point within a reach, <italic>t</italic>, we assume that we have the current state of the effector <bold>x</bold><sub><italic>kt</italic></sub>, as well as a vector <bold>n</bold><sub><italic>kt</italic></sub> that corresponds to neural activity (e.g. spike counts). Bold lower-case letters (<bold>x</bold>, <bold>n</bold>, <bold>g</bold>, …) denote column vectors. The decoder will update the state of the effector based on the combined neural state and previous effector state, {<bold>n</bold><sub><italic>kt</italic></sub>, <bold>x</bold><sub><italic>kt</italic></sub>} (in a limiting case, the decoder may only rely on neural activity, but inclusion of previous effector states allows for smoothing of effector trajectories).</p>
<p>Formally, we want a decoder <italic>π</italic> ∈ Π (i.e., a <italic>policy</italic> <italic>π</italic> within the space of policies Π) that transforms the state information (<bold>x</bold>, <bold>n</bold>) into an action that matches the intention of the user. An imitation learning algorithm trains the policy to mimic as closely as possible the oracle policy <italic>π</italic>*, which gives the oracle actions <bold>o</bold><sub><italic>kt</italic></sub> = <italic>π</italic>*(<bold>x</bold><sub><italic>kt</italic></sub>, <bold>n</bold><sub><italic>kt</italic></sub>, <bold>g</bold><sub><italic>kt</italic></sub>). Note that the oracle policy is not a member of Π (i.e. <italic>π</italic>* ∉ Π): this distinction is important as the learnable policies <italic>π</italic> ∈ Π do not have access to goal information. Because we have finite samples, we use an instantaneous loss <italic>ℓ</italic>(<italic>π</italic>(<bold>x</bold><sub><italic>kt</italic></sub>, <bold>n</bold><sub><italic>kt</italic></sub>), <bold>o</bold><sub><italic>kt</italic></sub>) (note this is a surrogate loss because it depends only on the available decoded and oracle variables, and not the unavailable “true” user intention). In the cursor control case, this loss could be the squared error between the oracle velocity and the decoder/policy velocity. We write <inline-formula id="pcbi.1004948.e001"><alternatives><graphic id="pcbi.1004948.e001g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e001" xlink:type="simple"/><mml:math display="inline" id="M1"><mml:mrow><mml:mi mathvariant="script">L</mml:mi> <mml:mo>(</mml:mo> <mml:mi>π</mml:mi> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> as shorthand for <inline-formula id="pcbi.1004948.e002"><alternatives><graphic id="pcbi.1004948.e002g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e002" xlink:type="simple"/><mml:math display="inline" id="M2"><mml:mrow><mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>K</mml:mi></mml:msubsup> <mml:msubsup><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:msub><mml:mi>T</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:msubsup> <mml:mi>ℓ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold">x</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold">o</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula>, where <inline-formula id="pcbi.1004948.e003"><alternatives><graphic id="pcbi.1004948.e003g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e003" xlink:type="simple"/><mml:math display="inline" id="M3"><mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> refers to the set of data <inline-formula id="pcbi.1004948.e004"><alternatives><graphic id="pcbi.1004948.e004g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e004" xlink:type="simple"/><mml:math display="inline" id="M4"><mml:msub><mml:mrow><mml:mo>{</mml:mo> <mml:mrow><mml:msub><mml:mtext mathvariant="bold">x</mml:mtext><mml:mrow><mml:mi>k</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mtext mathvariant="bold">n</mml:mtext><mml:mrow><mml:mi>k</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mtext mathvariant="bold">o</mml:mtext><mml:mrow><mml:mi>k</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow> <mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> from just the <italic>k</italic><sup><italic>th</italic></sup> reach, and <inline-formula id="pcbi.1004948.e005"><alternatives><graphic id="pcbi.1004948.e005g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e005" xlink:type="simple"/><mml:math display="inline" id="M5"><mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> refers to the combined set of data <inline-formula id="pcbi.1004948.e006"><alternatives><graphic id="pcbi.1004948.e006g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e006" xlink:type="simple"/><mml:math display="inline" id="M6"><mml:msub><mml:mrow><mml:mo>{</mml:mo> <mml:mrow><mml:msub><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>x</mml:mi></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>n</mml:mi></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>o</mml:mi></mml:mstyle><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow> <mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo><mml:mo>∈</mml:mo><mml:mtext> </mml:mtext><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:msub><mml:msub><mml:mrow/><mml:mrow><mml:mi>t</mml:mi><mml:mo>∈</mml:mo><mml:mn>1</mml:mn><mml:mo>…</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>′</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math></alternatives></inline-formula> from reaches up to <italic>k</italic>.</p>
<p specific-use="line"><bold>Algorithm 1:</bold> Imitation learning perspective of decoder training</p>
<p specific-use="line">Initialize dataset <inline-formula id="pcbi.1004948.e007"><alternatives><graphic id="pcbi.1004948.e007g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e007" xlink:type="simple"/><mml:math display="inline" id="M7"><mml:mrow><mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>←</mml:mo> <mml:mi>∅</mml:mi></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line">Initialize decoder <italic>π</italic><sup>(0)</sup></p>
<p specific-use="line">Input/select <italic>β</italic><sub>1</sub>, …, <italic>β</italic><sub><italic>K</italic></sub></p>
<p specific-use="line"><bold>for</bold> <italic>k</italic> = 1 <bold>to</bold> <italic>K</italic> <italic>trajectories</italic> <bold>do</bold></p>
<p specific-use="line"> Initialize effector state, <bold>x</bold><sub><italic>k</italic>1</sub> ← <bold>x</bold><sub>0</sub>, (or continue from end of previous trajectory)</p>
<p specific-use="line"> Randomly select goal state, <bold>g</bold><sub><italic>kt</italic></sub> from set of valid goals</p>
<p specific-use="line"> Initialize <italic>t</italic> ← 1</p>
<p specific-use="line"> <bold>while</bold> <italic>distance</italic>(<bold>x</bold><sub><italic>kt</italic></sub>,<bold>g</bold><sub><italic>kt</italic></sub>) &gt; <italic>ϵ</italic> <bold><italic>and</italic></bold> <italic>t</italic> &lt; <italic>T</italic> <bold>do</bold></p>
<p specific-use="line">  Acquire neural data <bold>n</bold><sub><italic>kt</italic></sub></p>
<p specific-use="line">  Query oracle update <bold>o</bold><sub><italic>kt</italic></sub> = <italic>π</italic>*(<bold>x</bold><sub><italic>kt</italic></sub>,<bold>n</bold><sub><italic>kt</italic></sub>,<bold>g</bold><sub><italic>kt</italic></sub>)</p>
<p specific-use="line">  Update state via assisted decoder:</p>
<p specific-use="line">   <bold>x</bold><sub><italic>k</italic>, <italic>t</italic>+1</sub> ← <italic>β</italic><sub><italic>k</italic></sub> <italic>π</italic>*(<bold>x</bold><sub><italic>kt</italic></sub>,<bold>n</bold><sub><italic>kt</italic></sub>,<bold>g</bold><sub><italic>kt</italic></sub>) + (1 − <italic>β</italic><sub><italic>k</italic></sub>)<italic>π</italic><sup>(<italic>k</italic>)</sup>(<bold>x</bold><sub><italic>kt</italic></sub>,<bold>n</bold><sub><italic>kt</italic></sub>)</p>
<p specific-use="line">  <italic>t</italic> ← <italic>t</italic> + 1</p>
<p specific-use="line"> <bold>end</bold></p>
<p specific-use="line"> Aggregate <inline-formula id="pcbi.1004948.e008"><alternatives><graphic id="pcbi.1004948.e008g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e008" xlink:type="simple"/><mml:math display="inline" id="M8"><mml:mrow><mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup> <mml:mo>←</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:msup> <mml:msup><mml:mstyle displaystyle="true" mathsize="140%"><mml:mo>∪</mml:mo></mml:mstyle> <mml:mtext>​</mml:mtext></mml:msup> <mml:msub><mml:mrow><mml:mrow><mml:mo>{</mml:mo> <mml:mrow><mml:mrow><mml:mo>(</mml:mo> <mml:mrow><mml:msub><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>x</mml:mi></mml:mstyle> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>n</mml:mi></mml:mstyle> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mstyle mathsize="normal" mathvariant="bold"><mml:mi>o</mml:mi></mml:mstyle> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mo>}</mml:mo></mml:mrow></mml:mrow> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn> <mml:mo>,</mml:mo> <mml:mo>…</mml:mo> <mml:mo>,</mml:mo> <mml:msub><mml:mi>T</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line"> <inline-formula id="pcbi.1004948.e009"><alternatives><graphic id="pcbi.1004948.e009g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e009" xlink:type="simple"/><mml:math display="inline" id="M9"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>←</mml:mo> <mml:mrow><mml:mtext>UPDATE</mml:mtext></mml:mrow> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula> (See Alg. 2)</p>
<p specific-use="line"><bold>end</bold></p>
<p specific-use="line"><bold>return</bold> <italic>best or last π</italic></p>
<p>The core imitation learning <italic>meta</italic>-algorithm is presented in Alg 1. This meta-algorithm describes the general structure for different learning algorithms, and the <sc>update</sc> line is distinct for alternative learning methods (each <sc>update</sc> takes the current decoder and dataset and produces the new decoder). We emphasize that this meta-algorithm is specified only once the effector, task objective, oracle, decoding algorithm, and parameter update rule are determined. The DA<sc>gger</sc> process gradually aggregates a dataset <inline-formula id="pcbi.1004948.e010"><alternatives><graphic id="pcbi.1004948.e010g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e010" xlink:type="simple"/><mml:math display="inline" id="M10"><mml:mi mathvariant="script">D</mml:mi></mml:math></alternatives></inline-formula> with pairs of state information and oracle actions at each time point. The dataset is used to train a stationary, deterministic decoder, which is defined as the deterministic optimal action (lowest average loss) based on the state information, which includes both the neural activity (<bold>n</bold>) and the effector state (<bold>x</bold>) in the BCI setting.</p>
<p>The meta-algorithm begins with an initial decoder (i.e. stable, albeit poorly performing) and uses this decoder, possibly blended with the oracle, to explore states. Specifically, the effective decoder is given by <italic>β</italic><sub><italic>i</italic></sub> <italic>π</italic>* + (1 − <italic>β</italic><sub><italic>i</italic></sub>)<italic>π</italic><sup>(<italic>k</italic>)</sup>, where <italic>π</italic>* is the oracle policy and <italic>π</italic><sup>(<italic>k</italic>)</sup> is the current decoder. When this mixing is interpreted as a weighted linear sum, this approach is equivalent to <italic>assisted decoding</italic> in the BCI literature (as in [<xref ref-type="bibr" rid="pcbi.1004948.ref031">31</xref>] or [<xref ref-type="bibr" rid="pcbi.1004948.ref032">32</xref>]), where the effective decoder during training is a mixture of the oracle policy and the decoder driven by the neural activity —in [<xref ref-type="bibr" rid="pcbi.1004948.ref017">17</xref>], the policy blending is probabilistic (see <xref ref-type="supplementary-material" rid="pcbi.1004948.s001">S1 Text</xref> for detailed distinction). The assisted decoder may reduce user frustration from poor initial decoding, and helps provide more task-relevant sampling of states. As training proceeds, the effective decoder relies less on the oracle and is ultimately governed only by the decoder. For example, <italic>β</italic><sub><italic>i</italic></sub> may be set to decrease according to a particular schedule with iterations, or as an abrupt example, <italic>β</italic><sub>1</sub> = 1 and <italic>β</italic><sub><italic>i</italic> &gt; 1</sub> = 0.</p>
<p>For each time point in each trajectory, the state information and oracle pair are incorporated into the stored dataset. The decoder is updated by a chosen rule at the end of each trajectory (or alternatively after each time step). We note that computational and memory requirements are less for updates that only require data from the most recent stage (<inline-formula id="pcbi.1004948.e011"><alternatives><graphic id="pcbi.1004948.e011g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e011" xlink:type="simple"/><mml:math display="inline" id="M11"><mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></alternatives></inline-formula>); however, using the whole dataset is more general, may improve performance, and can stabilize updates.</p>
</sec>
<sec id="sec005">
<title>Relating BCI and online learning</title>
<p>Imitation learning with an intention-oracle is a natural framework to reinterpret and understand the parameter fitting insights that were proposed in the ReFIT algorithm [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>]. In the ReFIT work, the authors used modified velocity vectors in order to update parameters in a fashion which incorporated the user’s presumed goal-directed intention, and this approach was empirically justified. We can re-interpret the rotated vectors as an <italic>ad hoc</italic> oracle, with these vectors and the single batch re-update being specific choices, hand-tailored for the task.</p>
<p>The CLDA framework extracted the core parameter-fitting principle from ReFIT, allowing for the updates to occur multiple times and take different forms [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>]. The simplest update consistent with this framework is <italic>gradient-based decoder adaptation</italic>. Under this scheme the decoder is repeatedly updated and the updates correspond to <italic>online gradient descent</italic> (OGD). This general class of BCI algorithms take observations in an online fashion, perform updates to the parameters using the gradient, and do not pass over the “old” data again. This <sc>update</sc> takes the form:
<disp-formula id="pcbi.1004948.e012"><alternatives><graphic id="pcbi.1004948.e012g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e012" xlink:type="simple"/><mml:math display="block" id="M12"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:msub><mml:mi>η</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mfrac> <mml:msub><mml:mo>∇</mml:mo> <mml:mi>π</mml:mi></mml:msub> <mml:mi mathvariant="script">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo></mml:mrow></mml:math></alternatives> <label>(1)</label></disp-formula>
which simply means that decoder parameters are updated by taking a step in the direction of the negative gradient of the loss with respect to those parameters. <inline-formula id="pcbi.1004948.e013"><alternatives><graphic id="pcbi.1004948.e013g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e013" xlink:type="simple"/><mml:math display="inline" id="M13"><mml:mfrac><mml:mn>1</mml:mn> <mml:msub><mml:mi>η</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mfrac></mml:math></alternatives></inline-formula> corresponds to the learning rate.</p>
<p>A second option for parameter updating is to smoothly average previous parameter estimates with recent (temporally localized) estimates of those parameters computed from a mini-batch—that is, to perform a <italic>moving average</italic> (MA) over recent optimal parameters. This <sc>update</sc> takes the form:
<disp-formula id="pcbi.1004948.e014"><alternatives><graphic id="pcbi.1004948.e014g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e014" xlink:type="simple"/><mml:math display="block" id="M14"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>λ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>+</mml:mo> <mml:mi>λ</mml:mi> <mml:mo form="prefix">arg</mml:mo> <mml:munder><mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mi>π</mml:mi></mml:munder> <mml:mi mathvariant="script">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>π</mml:mi> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives> <label>(2)</label></disp-formula>
for <italic>λ</italic> ∈ [0, 1]. In practice, the second term here corresponds to maximum likelihood estimation of the parameters. An update of this sort is presented as part of the CLDA framework as <italic>smoothBatch</italic> [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>].</p>
<p>A third parameter update option in the BCI setting is to peform a full re-estimation of the parameters given all of the observed data at every update stage. This can be interpreted as a <italic>follow-the-leader</italic> (FTL) update [<xref ref-type="bibr" rid="pcbi.1004948.ref033">33</xref>]. This <sc>update</sc> takes the form:
<disp-formula id="pcbi.1004948.e015"><alternatives><graphic id="pcbi.1004948.e015g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e015" xlink:type="simple"/><mml:math display="block" id="M15"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:mo form="prefix">arg</mml:mo> <mml:munder><mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mi>π</mml:mi></mml:munder> <mml:mi mathvariant="script">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>π</mml:mi> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(3)</label></disp-formula>
Here all data pairs are used as part of the training of the next set of parameters. We will show in the next section that this update can provide especially good guarantees on performance. DA<sc>gger</sc> was originally presented using this FTL update, utilizing the aggregated dataset [<xref ref-type="bibr" rid="pcbi.1004948.ref017">17</xref>]. We note that this sort of batch maximum likelihood update is discussed as a CLDA option in [<xref ref-type="bibr" rid="pcbi.1004948.ref014">14</xref>], where a computationally simpler, exponentially weighted variant is explored, termed <italic>recursive maximum likelihood</italic> (RML). For BCI settings, data is costly relative to the memory requirements, so it makes sense to aggregate the whole dataset without discarding old samples. For all of these updates, especially early on, it can be useful to include regularization, and we also incorporate this into the definition of the loss. We summarize the parameter update procedures in Alg 2.</p>
<p specific-use="line"><bold>Algorithm 2:</bold> Selected direct decoder <sc>update</sc> options</p>
<p specific-use="line"><bold>Switch:</bold></p>
<p specific-use="line"> <bold>Case—Online gradient descent (OGD)</bold>, <xref ref-type="disp-formula" rid="pcbi.1004948.e012">Eq 1</xref> :</p>
<p specific-use="line">  <inline-formula id="pcbi.1004948.e016"><alternatives><graphic id="pcbi.1004948.e016g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e016" xlink:type="simple"/><mml:math display="inline" id="M16"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>-</mml:mo> <mml:mfrac><mml:mn>1</mml:mn> <mml:msub><mml:mi>η</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:mfrac> <mml:msub><mml:mo>∇</mml:mo> <mml:mi>π</mml:mi></mml:msub> <mml:mi mathvariant="script">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line"> <bold>Case—Moving average (MA)</bold>, <xref ref-type="disp-formula" rid="pcbi.1004948.e014">Eq 2</xref> :</p>
<p specific-use="line">  <inline-formula id="pcbi.1004948.e017"><alternatives><graphic id="pcbi.1004948.e017g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e017" xlink:type="simple"/><mml:math display="inline" id="M17"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>-</mml:mo> <mml:mi>λ</mml:mi> <mml:mo>)</mml:mo></mml:mrow> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>+</mml:mo> <mml:mi>λ</mml:mi> <mml:mo form="prefix">arg</mml:mo> <mml:msub><mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mi>π</mml:mi></mml:msub> <mml:mi mathvariant="script">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>π</mml:mi> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line"> <bold>Case—Follow the (regularized) leader (FTL)</bold>, <xref ref-type="disp-formula" rid="pcbi.1004948.e015">Eq 3</xref> :</p>
<p specific-use="line">  <inline-formula id="pcbi.1004948.e018"><alternatives><graphic id="pcbi.1004948.e018g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e018" xlink:type="simple"/><mml:math display="inline" id="M18"><mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>=</mml:mo> <mml:mo form="prefix">arg</mml:mo> <mml:msub><mml:mo form="prefix" movablelimits="true">min</mml:mo> <mml:mi>π</mml:mi></mml:msub> <mml:mi mathvariant="script">L</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>π</mml:mi> <mml:mo>,</mml:mo> <mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></alternatives></inline-formula></p>
<p specific-use="line"><bold>return</bold> <italic>π</italic><sup>(<italic>k</italic>+1)</sup></p>
<p>Adaptive filtering techniques in engineering are closely related to the online machine learning updates we consider in this work. OGD is a generic update rule. In the special case of linear models with a mean square error cost, the solution that has a long history in engineering is called the least mean square (LMS) algorithm [<xref ref-type="bibr" rid="pcbi.1004948.ref034">34</xref>]. Also, in the same setting, when FTL corresponds to a batch LS optimization, its solution could be computed exactly in an online fashion using recursive least squares (RLS) [<xref ref-type="bibr" rid="pcbi.1004948.ref035">35</xref>] (for more background on LMS or RLS see [<xref ref-type="bibr" rid="pcbi.1004948.ref036">36</xref>]) or by keeping a running total of sufficient statistics and recomputing the LS solution.</p>
<p>We will more concretely discuss the guarantees of these algorithms in the subsequent section. We remark that all of the algorithms described so far make use of our generalization of the key parameter-fitting innovation from ReFIT, but they differ in parameter update rule. Additionally, algorithms can differ in the selection of the decoding algorithm, effector, task objective, and oracle. For example, if some objective other than mean squared error (MSE) were prioritized (e.g. rapid cursor stopping) and it was believed that user intention should reflect this priority, then the task objective and oracle could be designed accordingly.</p>
</sec>
<sec id="sec006">
<title>Algorithm regret bounds</title>
<p>In this section we provide theoretical guarantees for the BCI learning algorithms introduced above. Our formalization of the BCI setting allows us to provide new theory for closed-loop BCI learning by combining core theory for DA<sc>gger</sc> [<xref ref-type="bibr" rid="pcbi.1004948.ref017">17</xref>] with adaptations of results from the online learning literature. We provide specific terms and rates for the representative choices of parameter update rules (discussed in previous sections, summarized in <xref ref-type="table" rid="pcbi.1004948.t001">Table 1</xref>).</p>
<table-wrap id="pcbi.1004948.t001" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.t001</object-id>
<label>Table 1</label>
<caption>
<title>Summary of regret for selected algorithms.</title>
</caption>
<alternatives>
<graphic id="pcbi.1004948.t001g" mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.t001" xlink:type="simple"/>
<table border="0" frame="box" rules="all">
<colgroup>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
<col align="left" valign="middle"/>
</colgroup>
<thead>
<tr>
<th align="center">Online Learning Algorithm</th>
<th align="center">Closest BCI Algorithm</th>
<th align="center">Regret</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Online Gradient Descent</td>
<td align="center">Gradient-based decoder adaptation</td>
<td align="center">
<inline-formula id="pcbi.1004948.e019">
<alternatives>
<graphic id="pcbi.1004948.e019g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e019" xlink:type="simple"/>
<mml:math display="inline" id="M19">
<mml:mrow>
<mml:mi mathvariant="script">O</mml:mi>
<mml:mo>(</mml:mo>
<mml:msqrt>
<mml:mi>K</mml:mi>
</mml:msqrt>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula> [<xref ref-type="bibr" rid="pcbi.1004948.ref037">37</xref>]<break/>
<inline-formula id="pcbi.1004948.e020">
<alternatives>
<graphic id="pcbi.1004948.e020g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e020" xlink:type="simple"/>
<mml:math display="inline" id="M20">
<mml:mrow>
<mml:mi mathvariant="script">O</mml:mi>
<mml:mrow>
<mml:mo>(</mml:mo>
<mml:mtext>log</mml:mtext>
<mml:mi>K</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula> <xref ref-type="table-fn" rid="t001fn001">*</xref>[<xref ref-type="bibr" rid="pcbi.1004948.ref038">38</xref>]
</td>
</tr>
<tr>
<td align="center">Moving Average</td>
<td align="center">SmoothBatch [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>]</td>
<td align="center">
<inline-formula id="pcbi.1004948.e021">
<alternatives>
<graphic id="pcbi.1004948.e021g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e021" xlink:type="simple"/>
<mml:math display="inline" id="M21">
<mml:mrow>
<mml:mi mathvariant="script">O</mml:mi>
<mml:mo>(</mml:mo>
<mml:mi>K</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula>
</td>
</tr>
<tr>
<td align="center">Follow-the-leader</td>
<td align="center">CLDA-style maximum likelihood [<xref ref-type="bibr" rid="pcbi.1004948.ref014">14</xref>]</td>
<td align="center">
<inline-formula id="pcbi.1004948.e022">
<alternatives>
<graphic id="pcbi.1004948.e022g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e022" xlink:type="simple"/>
<mml:math display="inline" id="M22">
<mml:mrow>
<mml:mi mathvariant="script">O</mml:mi>
<mml:mo>(</mml:mo>
<mml:mo form="prefix">log</mml:mo>
<mml:mi>K</mml:mi>
<mml:mo>)</mml:mo>
</mml:mrow>
</mml:math>
</alternatives>
</inline-formula> [<xref ref-type="bibr" rid="pcbi.1004948.ref038">38</xref>]</td>
</tr>
</tbody>
</table>
</alternatives>
<table-wrap-foot>
<fn id="t001fn001">
<p>* Bound obtained only under restrictive conditions (see main text).</p>
</fn>
</table-wrap-foot>
</table-wrap>
<p>The standard way of assessing the quality of an online learning algorithm is through a <italic>regret</italic> bound [<xref ref-type="bibr" rid="pcbi.1004948.ref033">33</xref>], which calculates the excess loss after <italic>K</italic> trajectories relative to having used an optimal, static decoder from the set of possible decoders Π:
<disp-formula id="pcbi.1004948.e023"><alternatives><graphic id="pcbi.1004948.e023g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e023" xlink:type="simple"/><mml:math display="block" id="M23"><mml:mrow><mml:msub><mml:mtext>Regret</mml:mtext> <mml:mi>K</mml:mi></mml:msub> <mml:mrow><mml:mo>(</mml:mo> <mml:mo>Π</mml:mo> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>=</mml:mo> <mml:munder><mml:mo form="prefix" movablelimits="true">max</mml:mo> <mml:mrow><mml:msup><mml:mi>π</mml:mi> <mml:mo>♭</mml:mo></mml:msup> <mml:mo>∈</mml:mo> <mml:mo>Π</mml:mo></mml:mrow></mml:munder> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>k</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:mi>K</mml:mi></mml:munderover> <mml:munderover><mml:mo>∑</mml:mo> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>=</mml:mo> <mml:mn>1</mml:mn></mml:mrow> <mml:msub><mml:mi>T</mml:mi> <mml:mi>k</mml:mi></mml:msub></mml:munderover> <mml:mfenced close=")" open="(" separators=""><mml:mi>ℓ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold">x</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold">o</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>-</mml:mo> <mml:mi>ℓ</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:msup><mml:mi>π</mml:mi> <mml:mo>♭</mml:mo></mml:msup> <mml:mrow><mml:mo>(</mml:mo> <mml:msub><mml:mi mathvariant="bold">x</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow> <mml:mo>,</mml:mo> <mml:msub><mml:mi mathvariant="bold">o</mml:mi> <mml:mrow><mml:mi>k</mml:mi> <mml:mi>t</mml:mi></mml:mrow></mml:msub> <mml:mo>)</mml:mo></mml:mrow></mml:mfenced> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(4)</label></disp-formula></p>
<p>A smaller regret bound or a regret bound that decays more quickly is indicative of an algorithm with better worst-case performance. Note that <italic>π</italic><sup>♭</sup> is the best realizable decoder (Π is the set of feasible decoders, which may have a specific parameterization and will not depend on the goal), so <italic>π</italic><sup>♭</sup> is not equivalent to the oracle. Since <italic>π</italic><sup>♭</sup> will need to make use of noisy neural activity, the term <italic>ℓ</italic>(<italic>π</italic><sup>♭</sup>(<bold>x</bold><sub><italic>kt</italic></sub>, <bold>n</bold><sub><italic>kt</italic></sub>), <bold>o</bold><sub><italic>kt</italic></sub>) is not likely to be zero.</p>
<p>Because we have been able to formulate closed-loop BCI learning as imitation learning, we inherit a variant of the core theorem of [<xref ref-type="bibr" rid="pcbi.1004948.ref017">17</xref>] (see <xref ref-type="supplementary-material" rid="pcbi.1004948.s001">S1 Text</xref> for our restatement), which can be paraphrased as stating: <italic>Alg 1 will result in a policy (i.e. decoder) that has an expected total loss bounded by the sum of three terms: (1) a term corresponding to the loss if the best obtainable decoder had been used for the whole duration; (2) a term that compensates for the assisted training terms (β</italic><sub><italic>k</italic></sub> <italic>); (3) a term that corresponds to the regret of the online learning parameter update rule used</italic>.</p>
<p>We emphasize that the power of this theorem is that it allows analysis of imitation learning through regret bounds for well-established online optimization methods. Regret that accumulates sublinearly with respect to observations implies that the trial-averaged loss can be expected to converge. We usually want the regret accumulation to occur as slowly as possible. A goal of online learning is to provide <italic>no-regret</italic> algorithms, which refers to the property that lim<sub><italic>K</italic> → ∞</sub> Regret<sub><italic>K</italic></sub>(Π)/<italic>K</italic> = 0.</p>
<p>In this work, we have introduced three update methods that serve as a representative survey of the simple, intuitive space of algorithms proposed for the BCI setting (see <xref ref-type="table" rid="pcbi.1004948.t001">Table 1</xref>). We provide regret bounds for the imitation learning variants, here specifically assuming linear decoding and a quadratic loss (see <xref ref-type="supplementary-material" rid="pcbi.1004948.s001">S1 Text</xref> for full details). This analysis is based on the <italic>steady-state Kalman filter</italic> (SSKF) (see <xref ref-type="sec" rid="sec011">methods</xref>), but could be generalized to other settings.</p>
<p>OGD is a classical online optimization algorithm, and is well-studied both generally and in the linear regression case. The regret scales as <inline-formula id="pcbi.1004948.e024"><alternatives><graphic id="pcbi.1004948.e024g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e024" xlink:type="simple"/><mml:math display="inline" id="M24"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:msqrt><mml:mi>K</mml:mi></mml:msqrt> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> [<xref ref-type="bibr" rid="pcbi.1004948.ref037">37</xref>] (recall <italic>k</italic> indexes the reach trajectory). We note that in order to saturate the performance of OGD, the learning rate must be selected carefully, and the optimal learning rate essentially requires knowledge of the scaling of the parameters. Each parameter may require a distinct learning rate for optimal performance [<xref ref-type="bibr" rid="pcbi.1004948.ref039">39</xref>]. OGD is most useful in an environment where data is cheap because the updates have very low computational overhead—this is relevant for many modern large-data problems. In BCI applications, data is costly due to practical limits on collecting data from a single subject, so a more computationally intensive update may be preferable if it outperforms OGD.</p>
<p>Under certain conditions, OGD can achieve a regret rate of <inline-formula id="pcbi.1004948.e025"><alternatives><graphic id="pcbi.1004948.e025g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e025" xlink:type="simple"/><mml:math display="inline" id="M25"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mi>K</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> [<xref ref-type="bibr" rid="pcbi.1004948.ref038">38</xref>], which is an improved rate (and the same order as the more computationally-intensive FTL strategy we discuss below). This rate requires additional assumptions that are realistic only for certain practical settings. Asymptotically, any learning rate <italic>η</italic><sub><italic>k</italic></sub> that scales as <inline-formula id="pcbi.1004948.e026"><alternatives><graphic id="pcbi.1004948.e026g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e026" xlink:type="simple"/><mml:math display="inline" id="M26"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> will achieve this logarithmic rate, but choosing the wrong scale will dramatically negatively impact performance, especially during the crucial, initial learning period. For this reason, we may desire methods without step-size tuning.</p>
<p>We next provide guarantees available for the <italic>moving average</italic> update. This algorithm suffers from regret that is <italic>O</italic>(<italic>K</italic>), so it is not a no-regret algorithm (see analysis presented in [<xref ref-type="bibr" rid="pcbi.1004948.ref013">13</xref>] where there is an additional steady-state error). Conceptually this is because old data has decaying weight, so there is estimation error due to prioritization of a recent subset of the data. While this method has poor regret when analyzed for a <italic>static model</italic> (i.e. neural tuning is stable), it may be useful when some of the data is meaningless (i.e. a distracted user who is temporarily not paying attention), or when the parameters of the model may change over time. Also, in practice, if <italic>λ</italic> is large enough, the algorithm may be close “enough” to an optimal solution.</p>
<p>Motivated by findings from online learning, we also expect that <italic>Follow-the-leader</italic> (FTL) (or if regularization is used, <italic>Follow-the-regularized-leader</italic> (FTRL, a.k.a. FoReL)) may improve regret rates relative to OGD, generally at the expense of additional computational cost [<xref ref-type="bibr" rid="pcbi.1004948.ref033">33</xref>] (though without much computational burden if RLS can be used). We derive that under mild conditions that hold for the SSKF learned with mild regularization, FTL obtains a regret rate of <inline-formula id="pcbi.1004948.e027"><alternatives><graphic id="pcbi.1004948.e027g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e027" xlink:type="simple"/><mml:math display="inline" id="M27"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:mo form="prefix">log</mml:mo> <mml:mi>K</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> [<xref ref-type="bibr" rid="pcbi.1004948.ref038">38</xref>] (see <xref ref-type="supplementary-material" rid="pcbi.1004948.s001">S1 Text</xref> for details and discussion of constants). Thus, keeping in mind these bounds are worst-case, we expect that using <italic>FTL</italic> updates will provide improved performance relative to OGD or MA. We validate our theoretical results in simulations in the next section. We note that BCI datasets remain small enough that FTL updates for sets of reaches should be tractable, at least for initial decoder learning in closed-loop settings.</p>
<p>While the focus here is on static models, we note that there is additional literature concerning online optimization for <italic>dynamic</italic> models. Here dynamic refers to situations where the neural tuning drifts in a random fashion over time. Intuitively, something more like OGD is reasonable, and specific variants have been well characterized [<xref ref-type="bibr" rid="pcbi.1004948.ref040">40</xref>]. If the absolute total deviation of the time-varying parameters is constrained, these approaches can have regret of order <inline-formula id="pcbi.1004948.e028"><alternatives><graphic id="pcbi.1004948.e028g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e028" xlink:type="simple"/><mml:math display="inline" id="M28"><mml:mrow><mml:mi mathvariant="script">O</mml:mi> <mml:mo>(</mml:mo> <mml:msqrt><mml:mi>K</mml:mi></mml:msqrt> <mml:mo>)</mml:mo></mml:mrow></mml:math></alternatives></inline-formula> [<xref ref-type="bibr" rid="pcbi.1004948.ref040">40</xref>]. A dynamic model may provide better fit and therefore provide lower MSE despite potential for additional regret.</p>
</sec>
<sec id="sec007">
<title>Simulated cursor experiments</title>
<p>The first set of simulations concerns decoding from a set of neurons that are responsive to intended movement velocity (see <xref ref-type="sec" rid="sec011">methods</xref> for full details). In these simulations, there is a cursor that the user intends to move towards a target, and we wish to learn the parameters of the decoder to enable this. The cursor task (leftside panel of <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref>) is relatively simple, but the range of results we obtain for well-tuned algorithm variants is consistent with our theoretically-motivated expectations. Indeed, in the right panel of <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref>, we see that the OGD algorithm, which takes only a single gradient step after each reach, performs less well than the FTL algorithm that performs batch-style learning using all data acquired to the current time. MA performs least well, though for large values of <italic>λ</italic> (i.e. .9 in this simulation), the performance can become reasonable.</p>
<fig id="pcbi.1004948.g002" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g002</object-id>
<label>Fig 2</label>
<caption>
<title>Left panel is a cartoon of the cursor task.</title>
<p>The blue cursor is under user control and the user intends to move it towards the green target. On a given reach trajectory, the cursor is decoded according to the current decoder yielding the path made up of red arrows. At each state, the oracle intention is computed (green arrows) to be aggregated as part of <inline-formula id="pcbi.1004948.e029"><alternatives><graphic id="pcbi.1004948.e029g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e029" xlink:type="simple"/><mml:math display="inline" id="M29"><mml:mi mathvariant="script">D</mml:mi></mml:math></alternatives></inline-formula> and incorporated into the update to the decoder. In the right panel, we compare the performance of the algorithms on a simulation of the cursor task (loss incurred during each trial <italic>k</italic>). We use Alg 1 with the three update rules discussed (Alg. 1 and <xref ref-type="table" rid="pcbi.1004948.t001">Table 1</xref>). Intuitively, OGD makes less efficient use of the data and should be dominated by FTL. Moreover OGD has additional parameters corresponding to learning rate which were tuned by hand. MA performs least well, though we selected <italic>λ</italic> to be sufficiently close to 1 as to permit performance to gradually improve (smaller lambda leads to more unstable learning). Each update index corresponds to the inclusion of 1 additional reach. The entire learning procedure is simulated 100 times for each algorithm and errorbars are 2 standard errors across the simulations.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g002" xlink:type="simple"/>
</fig>
<p>We also note that updates may require regularization to be stable, so we provide all algorithms with equal magnitude <italic>ℓ</italic><sub>2</sub> regularization (the regularization coefficient per OGD update was equal to 1/<italic>K</italic> times the regularization coefficient of the other algorithms). After fewer than 10 reaches the OGD and FTL appear to plateau—this task is sufficiently simple that good performance is quickly obtained when SNR is adequate. We note that we have opted to show sum squared error (SSE) rather than MSE (in <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref> and elsewhere), because it reflects the aggregated single timestep error combined with differences in acquisition time—MSE normalizes for the different lengths of reach trajectories, thereby only providing a sense of single timestep error (compare to <xref ref-type="supplementary-material" rid="pcbi.1004948.s002">S1 Fig</xref>).</p>
<p>To get a sense of the magnitude of the performance improvements (i.e. the scale of the error in <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref>), we can visualize poorly-performed reaches from early in training and compare these against well-performed reaches from a later decoder (<xref ref-type="fig" rid="pcbi.1004948.g003">Fig 3</xref>). While the early decoder performs essentially randomly, the learned decoder performs quite well, with trajectories that move rapidly towards the target location. See <xref ref-type="supplementary-material" rid="pcbi.1004948.s003">S1 Movie</xref> for an example movie of cursor movements during the learning process.</p>
<fig id="pcbi.1004948.g003" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g003</object-id>
<label>Fig 3</label>
<caption>
<title>Left panel is a visualization of 100 3D reach trajectories for a poorly-performing initial decoder (trained on 1 reach).</title>
<p>Right panel visualizes 100 trajectories for a well-performing decoder fit from 20 reaches (approximately at performance saturation for this level of noise). Each trajectory is depicted with yellow corresponding to initial trial time and blue corresponding to end of trial (time normalized to take into account different reach durations). The goals were in random locations, so to superimpose the set of traces, all positions have been shifted relative to the goal such that goal is always centered. Observe that the initial decoder is essentially random and the learned decoder permits the performance of reaches which mostly proceed directly towards the goal (modulo variability inherited from the neural noise). Units here relate to those in <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref>—here referring to position as compared with MSE of corresponding velocity units.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g003" xlink:type="simple"/>
</fig>
<p>We emphasize that FTL essentially has no learning-related parameters (aside from the optional <italic>ℓ</italic><sub>2</sub>-regularization coefficient). On the other hand, OGD and MA have additional learning parameters that must be set, which may require tuning in practical settings. The OGD experiments presented here are the result of having run the experiment for multiple learning rates and we reported only the results of a well-performing learning rate (since this requires tuning, it may be non-trivial to immediately achieve this rate of improvement in a practical setting where the learning rate is likely to be set more conservatively). Too large a learning rate leads to divergence during learning, and too small a learning rate leads to needlessly slow improvement.</p>
</sec>
<sec id="sec008">
<title>Simulated arm-reaching experiments</title>
<p>In this section we introduce a new opportunity, moving beyond BCI settings where intention-based algorithmic capabilities have yet been explored. We validate the imitation learning framework through simulation results on a high dimensional task—BCI control of a simulated robotic/virtual-arm (<xref ref-type="fig" rid="pcbi.1004948.g004">Fig 4</xref>). Whereas existing algorithms cannot be generalized to more complicated tasks, our results allow for generalization to an arm effector. The simple ReFIT-style oracle of rotating instantaneous velocities towards the “goal” is ill-posed in general cases—the goal position could be non-unique and the different degrees of freedom (DOF) may interact nonlinearly in producing the end-effector position (both of these issues are present for an arm). Instead, we introduce an optimal control derived intention-oracle. As our proof of concept, we present a set of simulated demonstrations of reaches of an arm towards a target-wand. We envision this being incorporated into a BCI setting such as that described in [<xref ref-type="bibr" rid="pcbi.1004948.ref019">19</xref>], where a user controls a virtual arm in a virtual environment. Extension to a robotic arm is also conceptually straightforward, if a model of the robotic arm is available.</p>
<fig id="pcbi.1004948.g004" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g004</object-id>
<label>Fig 4</label>
<caption>
<title>Left panel depicts arm model in MuJoCo software and a trajectory of the arm during a simulated closed-loop experiment, after the decoder has learned to imitate the optimal policy (for illustration).</title>
<p>This particular trajectory consists mostly of movement of an elbow joint, followed by slight movements of the middle finger and thumb when near the target. Right panel depicts a comparison of loss (here SSE of decoded joint angular velocities relative to oracle) as a function of reach index for the different update rules (similar to Right panel in <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref>). In this plot, we consider only the loss for the shoulder, elbow, and wrist DOF as these are the dominant DOF (curves are similar when other critical joints are included). We see that FTL again gives good performance both in terms of rate of convergence and resulting solution (see <xref ref-type="fig" rid="pcbi.1004948.g006">Fig 6</xref> or <xref ref-type="supplementary-material" rid="pcbi.1004948.s004">S2 Mov</xref> for a sense of the quality of the performance). The entire learning procedure is simulated 50 times for each algorithm and errorbars are 2 standard errors across the simulations.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g004" xlink:type="simple"/>
</fig>
<p>For these simulations, we implement the reach task using a model of a rhesus macaque arm in MuJoCo, a software that provides a physics engine and optimal control solver [<xref ref-type="bibr" rid="pcbi.1004948.ref041">41</xref>]. The monkey arm has 26 DOF, corresponding to all joint-angles at the shoulder, elbow, wrist, and fingers. The task objective we specified corresponds to the arm reaching towards a target “wand,” placed in a random location for each reach, and touching the wand with two fingers. Following from the task objective, at each timestep the optimal control solver receives the current position of the arm and the position of the goal (i.e. wand position), from which it computes incremental updates to the joint angles. These incremental updates to the joint angles correspond to oracle angular velocities and we wish to learn a decoder that can reproduce these updates via Alg 1. See <xref ref-type="sec" rid="sec011">methods</xref> for complete details of the simulations.</p>
<p>Given that this arm task is ostensibly more complicated than cursor control, it may be initially surprising that we see that task performance rapidly improves with a small number of reaches (Right panel <xref ref-type="fig" rid="pcbi.1004948.g004">Fig 4</xref>, and see <xref ref-type="supplementary-material" rid="pcbi.1004948.s004">S2 Movie</xref> for an example movie of arm reaches during the learning process). However, this relatively rapid improvement makes sense when we consider that the data is not collected independently, rather there is a closed-loop sequential process (see Alg 1). Consequently we expect that early improvement should occur by leveraging the most widely used DOF (i.e. shoulder, elbow, and to a lesser extent wrist). More gradually, the other degrees of freedom should improve (i.e. finger and less-relevant wrist DOF).</p>
<p>To empirically examine the rate at which we can learn about distinct DOF, we conduct an analysis to see how well we can characterize the mapping between intention (per DOF) and neural activity. At each stage of the learning process (<italic>k</italic> = 1…<italic>K</italic>), we use the aggregated dataset <inline-formula id="pcbi.1004948.e030"><alternatives><graphic id="pcbi.1004948.e030g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e030" xlink:type="simple"/><mml:math display="inline" id="M30"><mml:msup><mml:mi mathvariant="script">D</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>1</mml:mn> <mml:mo>:</mml:mo> <mml:mi>k</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:msup></mml:math></alternatives></inline-formula> to estimate the encoding model by regression (see <xref ref-type="sec" rid="sec011">methods</xref>, <xref ref-type="disp-formula" rid="pcbi.1004948.e031">Eq 5</xref>). The encoding model corresponds to the mapping from intention to neural activity and our ability to recover this (per DOF) reflects the amount of data we have about the various DOF. To quantify this, we compute correlation coeffcients (per DOF, across neurons) between the true encoding model parameters (known in simulation) and the encoding model parameters estimated from data aggregated up through a given reach. We expect this correlation to generally improve with increasing dataset size; however, regret bounds do not provide direct guarantees on this parameter convergence. The key empirical observation is that DOF more integral to task performance are learned rapidly, whereas certain finger DOF which are less critical are learned more gradually (<xref ref-type="fig" rid="pcbi.1004948.g005">Fig 5</xref>).</p>
<fig id="pcbi.1004948.g005" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g005</object-id>
<label>Fig 5</label>
<caption>
<title>Panels depict correlation between “true” encoding model and estimated encoding model parameters as a function of index over reach trajectories (for a single trial).</title>
<p>Each curve corresponds to the correlation for a different DOF. The encoding model parameters are not directly guaranteed to converge. We see, as expected, that the encoding model will improve for specific DOF in proportion to the extent to which those dimensions are relied on to perform the task. Shoulder DOF are crucial for the task, being implicated in most reaches, so are learned rapidly. Wrist and finger joints are relatively less critical for task performance, so are learned more gradually. In the thumb and middle finger panels above, the least well-learned DOF (thumb DOF 3 and mid DOF 3) can be interpreted as the “distal inter-phalangeal joint” (i.e. the small joint near tip of the finger), which is not heavily relied upon in this reach task.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g005" xlink:type="simple"/>
</fig>
<p>Similarly to the cursor tasks, we want to examine the magnitude of the performance improvements. For this case, it is difficult to statically visualize whole reaches. Instead, we look at an example shoulder DOF and depict the trajectory of that joint during a reach (<xref ref-type="fig" rid="pcbi.1004948.g006">Fig 6</xref>). Branching off of the actual trajectory, we show local, short-term oracle trajectories which depict the intended movement. Note that the oracle update takes into account other DOF and optimizes the end-effector cost, so it may change over time as other DOF evolve. We see that the early decoder does not yield trajectories consistent with the intention—the decoded pose does not move rapidly, nor does it always move in the direction indicated by the oracle. The late decoder is more responsive, moving more rapidly in a direction consistent with the the oracle. In the four examples using the late decoder, the arm successfully reaches the target, so the reach concludes before the maximum reach time.</p>
<fig id="pcbi.1004948.g006" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g006</object-id>
<label>Fig 6</label>
<caption>
<title>Plots depict reach trajectories of a representative shoulder DOF for 4 paired examples of reaches, from separate re-initializations of the decoder (i.e. different trials).</title>
<p>Left panels show a poorly-performing early decoder (k = 2), and right panels show a well-performing decoder (k = 30). Rows correspond to matched pairs of reaches for different repeats of the experiment. Blue curves correspond to the actual decoded pose of the DOF over time, and red arrows depict the local oracle update (only visualized for a subsampling of timesteps). For the early reaches, observe that the decoder does not always proceed in the intended direction. For the late reaches, observe that actual pose updates are quite consistent with the oracle and trajectories are shorter because the targets are acquired more frequently and more rapidly.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g006" xlink:type="simple"/>
</fig>
</sec>
<sec id="sec009">
<title>Model mismatch</title>
<p>An important potential class of model mismatch arises when there is a discrepancy between the “oracle” policy and the true intention of the user (in such cases the oracle is not a proper oracle and is better thought of as an attempt at approximating an oracle). We can consider this setting to suffer from “intention mismatch” (see [<xref ref-type="bibr" rid="pcbi.1004948.ref042">42</xref>] for a distinct, but related concept of discrepant “internal models”).</p>
<p>In our results thus far, we have assumed we have a true intention oracle. When such an oracle is available, we are in the ideal statistical setting, and our simulations provide a sense of quality of algorithmic variants in this setting. In order to characterize the robustness of this approach, we consider the realism of this assumption and the consequences when it is violated. This point concerning mismatch is not restricted to a specific oracle. Rather, it arises when comparing the degree of discrepancy between actual user intention and any particular oracle. There are a few classes of deviations we might expect between a true user’s intention and the intention oracle.</p>
<p>A simple class of intention mismatch corresponds to random noise applied to the user intention. This would be a simple model of single timebin variability arising from sensory feedback noise, inherent variability in biological control, or inconsistent task engagement. For such a case, we perform simulations identical to those performed previously, but we model the actual user intention (that drives the simulated neural activity) as a combination of a random intention and the oracle intention. The magnitude of the intention noise here corresponds to the magnitude of the random intention relative to the oracle (i.e. 100% noise indicates that actual user intention is a linear combination of the oracle intention and a randomly directed vector of equal magnitude norm). We emphasize that here the oracle is not correct and there is additional noise in the system that is from the random intention. We can verify empirically that performance decreases with noise level at a reasonable rate for this intention noise variant of model mismatch (see <xref ref-type="fig" rid="pcbi.1004948.g007">Fig 7</xref>). While naturally performance (i.e. loss between noise-free oracle and decoded intention) decreases when there is additional noise, we see gradual rather than catastrophic decline in performance.</p>
<fig id="pcbi.1004948.g007" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g007</object-id>
<label>Fig 7</label>
<caption>
<title>Plots depict decline in performance (i.e. loss between noise-free oracle and decoded intention) with intention noise model mismatch using sum square error (SSE) over the duration of a reach for (left) cursor task and (right) arm reaching task trajectories, comparable to performance curves in Figs <xref ref-type="fig" rid="pcbi.1004948.g002">2</xref> and <xref ref-type="fig" rid="pcbi.1004948.g004">4</xref> respectively.</title>
<p>In each task, noise performance curves are obtained when the user’s intent is a noisy version of the oracle, captured by a linear combination of intention oracle and a random vector. The noise level is indicated by a noise percentage, corresponding to the magnitude of the noise relative to the intention oracle signal. The effects of the relative noise are not directly comparable across tasks because the noise is distributed over more dimensions in the arm task.</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g007" xlink:type="simple"/>
</fig>
<p>Although intention noise mismatch is realistic under certain assumptions, we may have concerns regarding more systematically structured model mismatch. We next consider a class of intention mismatch where the user intention is consistently biased by a fixed linear operator with respect to the oracle (i.e. user intention arises from a gain and/or rotation applied to the oracle). If this linear mismatch is always present, then—crucially—the performance of the resulting decoder will be equivalent under our loss, which compares the decoder output against the oracle. This is because the algorithm would learn a decoder that undoes this consistent linear transform between the user intent and the oracle, resulting in good task performance. Note that after training, there would remain a persistent discrepancy between the decoder output and the actual user intention. Also note that changes in gain should only affect decoding performance if such changes modulated the SNR of the neural activity.</p>
<p>While linear intention mismatch does not affect the ability to imitate the oracle, it is not entirely realistic. For example, if the oracle and the user intention differ by a rotation that is consistent over time, either the oracle or the user intention would not efficiently complete the task (e.g. the intended cursor trajectory won’t be directed towards the target). Therefore, efficient completion of the task serves to constrain plausible intention trajectories. This motivates us to characterize a remaining class of nonlinear intention mismatch—wherein user intention and the oracle both solve the task but do so in ways that are discrepant. While there may be many satisfactory trajectories from the beginning of the task, as the effector nears goal acquisition, the discrepancy amongst efficient oracle solutions reduces. This means that the while the oracle is systematically and reliably wrong, the discrepancy differs in a way that depends upon the current pose and objective.</p>
<p>For the cursor task, we designed a conceptually illustrative second oracle that solves the task and is not simply a linear transform of the first oracle (i.e. not gain mismatch). We consider trajectories that arc towards the goal—this oracle can be generated by having a distance dependent linear transform, where a sigmoid function of distance determines whether the actual user intention is offset by zero up to some maximal <italic>ϕ</italic> from the standard straight-line oracle (see <xref ref-type="fig" rid="pcbi.1004948.g008">Fig 8</xref>). At far distances, this model of user intention and the straight-line oracle differ by a moderate rotation, and as the cursor nears the goal, the discrepancy decreases. It would be impossible for a simple decoder to compensate for this kind of mismatch because the decoder will not generally have access to distance between cursor and the goal. Instead, we expect the decoder will partly compensate for this arc-shape intention by learning to “undo” a rotation relative to the straight-line oracle. Since the correct rotation-compensation varies, the decoder will (at most distances) be incorrectly undercompensating or overcompensating (see <xref ref-type="fig" rid="pcbi.1004948.g008">Fig 8</xref>).</p>
<fig id="pcbi.1004948.g008" position="float">
<object-id pub-id-type="doi">10.1371/journal.pcbi.1004948.g008</object-id>
<label>Fig 8</label>
<caption>
<title>Left panel depicts a cartoon for a 2D projection of the arc-trajectory intention mismatch setting for the cursor task.</title>
<p>Contrary to the assumption that the intention is directly towards the goal (black arrow), the user intention actually is such that it would have induced an arc with initial angle <italic>ϕ</italic> (green arrow). After training, the decoder partly compensates for the arc-offset, undercompensating initially and overcompensating near the goal (red arrows). Center panel visualizes single trials from trained decoders from the 45° setting (each trace is from a different realization of neural encoding and training). All decoded trajectories have been projected from 3D into 2D and rotated to match the center panel orientation, and trials have a diversity of initial distances from the goal. Time during the trial is depicted from yellow to blue as in <xref ref-type="fig" rid="pcbi.1004948.g003">Fig 3</xref>. Right panel shows performance curves under increasing levels of nonlinear mismatch for the cursor task, trained using FTL (axes comparable to left panel of <xref ref-type="fig" rid="pcbi.1004948.g007">Fig 7</xref>).</p>
</caption>
<graphic mimetype="image" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.g008" xlink:type="simple"/>
</fig>
<p>We show empirical performance curves for the cursor arc-trajectory user intention and see that for increasing levels of arc-angle, learned performance only gradually declines. Note that these simulations were for a 3D cursor, so rotation corresponds to a rotation in all 3 planes of the same magnitude. For minor discrepancy, the resulting performance is very robust. At the largest level (45° angle), performance is noticeably worse but still suffices to perform the task. The center panel of <xref ref-type="fig" rid="pcbi.1004948.g008">Fig 8</xref> depicts many example single trial reach trajectories (projected into 2D and rotated to align with the cartoon in the middle panel).</p>
<p>While it is not feasible for us to test all forms of model mismatch here, the simulation framework we presented allows for empirical investigation of any specific class or mismatch details of interest that may arise. The representative classes of mismatch explored in this section illustrate the reasonable robustness of this framework.</p>
</sec>
</sec>
<sec id="sec010" sec-type="conclusions">
<title>Discussion</title>
<p>In this work, we have unified closed-loop decoder training approaches by providing a meta-algorithm for BCI training, rooted in imitation learning. Specifically, we have focused on the parameter learning problem, complementing other research that focuses on the problem of selecting a good decoder family [<xref ref-type="bibr" rid="pcbi.1004948.ref012">12</xref>]. Our approach allows the parameter learning problem to be established on a firmer footing within online learning, for which theoretical guarantees can be made. This is crucial since ReFIT-based approaches are being translated to human clinical applications where performance is of paramount concern [<xref ref-type="bibr" rid="pcbi.1004948.ref016">16</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref043">43</xref>]. Moreover, we have demonstrated that this approach now permits straightforward extension to higher dimensional settings, enabling rapid learning even in the higher dimensional case. In scaling existing algorithms to an arm-control task, we have provided generic approaches to solve two issues. First, imitation learning (using data aggregation) serves as the generic framework for updating parameters. Second, we have employed a generic, optimal control approach, which can be used to compute intention-oracle kinematics in a broad range of BCI settings.</p>
<p>For simulations in this work, we employ linear encoding of kinematic variables because, in addition to having a history in the BCI literature [<xref ref-type="bibr" rid="pcbi.1004948.ref010">10</xref>], this corresponds to an operationally useful encoding model employed in recent, well-performing applications in the closed-loop BCI [<xref ref-type="bibr" rid="pcbi.1004948.ref011">11</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref016">16</xref>]. We do not intend to claim that simple, linear encoding models as assumed when employing Kalman filter decoders correspond to the reality of innate neural computation in motor cortex. Nonlinear filtering approaches that make more realistic assumptions about neural encoding have been explored offline [<xref ref-type="bibr" rid="pcbi.1004948.ref044">44</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref046">46</xref>]. However, it is not clear that offline results employing more realistic encoding models always translate performance gains to closed-loop settings [<xref ref-type="bibr" rid="pcbi.1004948.ref047">47</xref>]. Nevertheless, there have been successes using more complicated decoding algorithms in closed-loop experiments [<xref ref-type="bibr" rid="pcbi.1004948.ref048">48</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref050">50</xref>]. Following on recent scientific work that has sought to understand a role of intrinsic dynamics in motor cortices [<xref ref-type="bibr" rid="pcbi.1004948.ref009">9</xref>], dynamics-aware decoders are also being developed [<xref ref-type="bibr" rid="pcbi.1004948.ref051">51</xref>–<xref ref-type="bibr" rid="pcbi.1004948.ref053">53</xref>]. While many decoder forms may be considered, in line with the variety of theories about the motor cortex, the precise choice is orthogonal to the work here. Intention-based parameter fitting does not depend, in any general way, on the encoding model assumed by the decoding algorithm. Consequently, a key benefit of the theoretical statements we present are that the algorithm performance guarantees hold for general classes of decoders, and the meta-algorithm we describe is largely agnostic to the details of the encoding.</p>
<p>It is a key point that Alg 1 results in preferential acquisition of data that enables learning of the most task-relevant DOF. This follows from the fact that the sampling of states in closed-loop is non-uniform, since the current decoder induces the distribution of states visited during the next reach. Exploration is not explicitly optimized, but more time is spent in relevant sets of states as a consequence of preferential sampling of certain parts of what can be a high dimensional movement space. This clarifies the potential utility of assisted decoding, which may serve to facilitate initial data collection in positions in the movement space that are especially task-relevant. This non-uniform exploration of the movement space provides intuition for the generality of the theoretical guarantees for DA<sc>gger</sc>-like learning. The decoder used in this work is of a relatively simple form (<italic>steady-state velocity Kalman filter</italic>, described in <xref ref-type="sec" rid="sec011">methods</xref>), but the theoretical results hold for general stationary, deterministic decoders.</p>
<p>While we have focused on a simple, parametric decoder, the parameter learning approach presented in this paper extends to more complicated decoders. For example, we may wish to allow the neural activity to be decoded differently depending on the current state of the effector. In conventional imitation learning, policies are trained to yield sequences of actions (without user input), so this general problem is extremely state-dependent. By building into the decoder an expressive mapping that captures state-transition probabilities, we could design a policy-decoder hybrid to exploit regularities in the dynamics of intended movements and heavily regularize trajectories based on their plausibility. Additionally, we could augment the state with extra information (e.g. extra data from sensors on the physical effector could be added to the current kinematics and neural activity) such that decoding relies on autonomous graceful execution of trajectories in addition to neural activity (see [<xref ref-type="bibr" rid="pcbi.1004948.ref054">54</xref>]). Similarly, this framework accommodates decoders which operate in more abstract spaces (such as if the available neural activity sent action-intention commands rather than low-level velocity signals).</p>
<p>A particularly interesting opportunity that corresponds to an augmentation of <italic>follow-the-leader</italic> (FTL, <xref ref-type="disp-formula" rid="pcbi.1004948.e015">Eq 3</xref>) would be to enrich the decoder family as the dataset grows. We can imagine a system with decoders of increasing complexity (more parameters or decreasing regularization) as the aggregated dataset of increasing size becomes available. While we focused on a simple decoder (i.e. the Kalman filter) which makes sense for small-to-moderate datasets, some work suggests that complicated decoders trained on huge datasets can perform well (e.g. using neural networks [<xref ref-type="bibr" rid="pcbi.1004948.ref050">50</xref>]). We anticipate that data aggregation would allow us to start with a simple decoder, and we could increase the expressive power of the decoder parameterization as more data streams in.</p>
<p>Our formalization of BCI learning most closely resembles the DA<sc>gger</sc> setting, but novel extensions to the BCI learning setting follow from related imitation learning formulations. Some particularly relevant opportunities are surveyed here. When starting from an initial condition of an unknown decoder-policy, it may be hard to directly train towards an optimal decoder-policy. Training incrementally towards the optimal policy via intermediate policies has been proposed [<xref ref-type="bibr" rid="pcbi.1004948.ref055">55</xref>]. Under such a strategy, a “coach” replaces the oracle, and the coach provides demonstration actions which are not much worse than the oracle but are easier to achieve. For example, in BCI, it may be hard to learn to control all DOF simultaneously, so a coach could provide intention-trajectories that use fewer DOF. It has also been observed that DA<sc>gger</sc> explores using partially optimized policies, and these might cause harm to the agent/system. Especially early in training, the policies may produce trajectories which take the agent through states which may be dangerous to the agent or the environment. An appropriate modification to solve this is to execute the oracle/expert action at timesteps when a second-system suspects there may be an issue carrying out the policy action, thereby promoting safer exploration [<xref ref-type="bibr" rid="pcbi.1004948.ref056">56</xref>].</p>
<p>As touched upon in the results, we also want to be aware of the performance impact of model mismatch and mitigate this problem. While we expect performance will erode with increasing intention mismatch, our results indicated robustness to small levels of mismatch (see Figs <xref ref-type="fig" rid="pcbi.1004948.g007">7</xref> &amp; <xref ref-type="fig" rid="pcbi.1004948.g008">8</xref>). In settings where, even after carefully designing the intention oracle there is persistent mismatch, a combined imitation learning and reinforcement learning approach may produce better results [<xref ref-type="bibr" rid="pcbi.1004948.ref057">57</xref>]. This amounts to a hybrid optimization that combines the error-ridden expert signals with RL signals obtained by successful goal acquisitions.</p>
<p>Finally, in this work we have assumed there is not gradual “drift” in the neural encoding model—it is probably a fair assumption that neural encoding drift is not a dominant issue during rapid training [<xref ref-type="bibr" rid="pcbi.1004948.ref058">58</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref059">59</xref>]. We highlight a distinction between general closed-loop adaptation (where the decoder should adapt as fast as possible), versus settings designed for the user to productively learn, termed co-adaptive (for a review of co-adaptation, see [<xref ref-type="bibr" rid="pcbi.1004948.ref060">60</xref>]). We have focused on the setting with user learning in other work [<xref ref-type="bibr" rid="pcbi.1004948.ref061">61</xref>, <xref ref-type="bibr" rid="pcbi.1004948.ref062">62</xref>], but we here focused on optimizing parameter learning under the assumption that the user’s neural tuning is fixed, allowing us to rigorously compare algorithms. In future work, it may prove fruitful to attempt to unify this analysis with co-adaptation. We also anticipate future developments that couple the sort formalization of decoder learning explored in this work with more expressive decoders. We are optimistic that progress in these directions will enable robust, high-dimensional brain-computer interface technology.</p>
</sec>
<sec id="sec011" sec-type="materials|methods">
<title>Methods</title>
<sec id="sec012">
<title>Simulated experiments</title>
<p>In this work we present two sets of simulations. The first set of simulations consist of simulated closed-loop experiments of 3D cursor control. In these simulations, the cursor serves as the <italic>effector</italic>, and this cursor is maneuverable in all three dimensions. Goals are placed at random locations and the <italic>task objective</italic> is to minimize the squared error loss between the cursor and the current goal. Goals are acquired when the cursor is moved to within a small radius of the target. The <italic>oracle</italic> for this task is determined from optimal control. When there is a quadratic penalty on instantaneous movement velocity, the optimal trajectory from the cursor towards the goal will be equal-length vectors directed towards the target. So at each timestep, we take the oracle to correspond to a goal-directed vector from the current cursor position.</p>
<p>The second set of simulations are similar, but involve controlling an arm to reach towards a “wand”. As the <italic>effector</italic>, we use an arm model with dimensions corresponding to those of a rhesus macaque monkey used for BCI research (from Pesaran Lab, Center for Neural Science, New York University, <ext-link ext-link-type="uri" xlink:href="http://www.pesaranlab.org" xlink:type="simple">http://www.pesaranlab.org</ext-link>, as in [<xref ref-type="bibr" rid="pcbi.1004948.ref019">19</xref>]). For simplicity we treat each joint as a degree of freedom (DOF) yielding 26 joint angles and 26 corresponding angular velocities. We specify the <italic>task objective</italic> to be a spring-like penalty between the wrist position (3D spatial coordinates) and the wand position. Specifically, in addition to the 26 joint-angle DOF, there are also identifiers corresponding to the x-y-z coordinates of the wrist and select fingertips, as well as points on the wand. Objective functions in terms of the x-y-z coordinates of these markers can be specified, and the MuJoCo solver computes trajectories (in terms of the specified joint angles) in order to optimize the objective. We defined the initial objective in terms of the Euclidean distance between the wrist and the wand. Once the wrist is within a radius <italic>δ</italic> of the wand, a new sping-like penalty is placed on the distance between tip of the middle finger and a point on the wand and also between the tip of the thumb and a point on the wand—this causes the fingertips to touch two points of the wand (a simple “grasp”). This explicit task objective allows us to compute the <italic>oracle</italic> solution for the reach trajectory, and this oracle is computed via an iterative optimal control solver on all joint angles in the model. The model, simulation, and optimal control solver are implemented in an early release of the software simulation package MuJoCo [<xref ref-type="bibr" rid="pcbi.1004948.ref041">41</xref>]. At each timestep, given the wand position and current arm position, the optimal control solver produces an incremental update to all (26) of the joint angles of the arm, and this goal-directed angular velocity vector is taken as the oracle. As an alternative to explicitly posing the objective function and computing the oracle, one can imagine using increasingly naturalistic optimal-control-based oracles that use more elaborate motor models trained on real data [<xref ref-type="bibr" rid="pcbi.1004948.ref063">63</xref>].</p>
<p>We produce synthetic neural activity similarly in both sets of simulations. In the cursor task, we want the neurons to be tuned to intended cursor velocity. In the arm task, neurons should encode velocities of the joint angles. To produce simulated neural data that reflects the “user’s” intention, we have a convenient choice—the oracle itself. The simulation cycle entails: (1) computing the intention-oracle (given the current state, goal, and task objective), (2) simulating the linear-Gaussian neural activity from the intention-oracle (<xref ref-type="disp-formula" rid="pcbi.1004948.e031">Eq 5</xref>), (3) using the current decoder to update the effector, and (4) updating the decoder between reaches. We note that the oracle is used twice, first to produce the neural activity and subsequently in the imitation learning decoder updates.</p>
<p>Specifically, we simulate neural activity via the neural encoding matrix <italic>A</italic> that maps intended velocity to neural activity:
<disp-formula id="pcbi.1004948.e031"><alternatives><graphic id="pcbi.1004948.e031g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e031" xlink:type="simple"/><mml:math display="block" id="M31"><mml:mrow><mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>=</mml:mo> <mml:mi>A</mml:mi> <mml:msub><mml:mi mathvariant="bold">o</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi mathvariant="bold">c</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mspace width="4.pt"/><mml:mtext>(with</mml:mtext> <mml:mspace width="4.pt"/><mml:mrow><mml:msub><mml:mi mathvariant="bold">c</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>∼</mml:mo> <mml:mi mathvariant="script">N</mml:mi> <mml:mrow><mml:mo>(</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> <mml:mi mathvariant="bold">C</mml:mi> <mml:mo>)</mml:mo></mml:mrow></mml:mrow> <mml:mtext>)</mml:mtext> <mml:mo>.</mml:mo></mml:mrow></mml:math></alternatives> <label>(5)</label></disp-formula>
where the noise covariance <italic>C</italic> was taken to be a scaled identity matrix, such that the signal-to-noise ratio (SNR) was ≈1 per neuron (i.e. noise magnitude set to be roughly equal in magnitude to signal magnitude per neuron, which we considered reasonable for single unit recordings). In real settings this neural activity might be driven by some intended movement <inline-formula id="pcbi.1004948.e032"><alternatives><graphic id="pcbi.1004948.e032g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e032" xlink:type="simple"/><mml:math display="inline" id="M32"><mml:msubsup><mml:mi mathvariant="bold">x</mml:mi> <mml:mi>t</mml:mi> <mml:mo>*</mml:mo></mml:msubsup></mml:math></alternatives></inline-formula> (where here the star denotes intention as in [<xref ref-type="bibr" rid="pcbi.1004948.ref012">12</xref>]).</p>
<p>These simulations assume the intention-oracle is “correct”. As such, a feature of all ReFIT-inspired algorithms is that there is model mismatch if the user is not engaged in the task or has a meaningfully different intention than these algorithms presume. This problem affects any algorithm that trains in closed-loop and makes assumptions about the user’s intention (see <xref ref-type="sec" rid="sec010">discussion</xref> for extensions to handle the case when the oracle is known to be imperfect). For the model mismatch section of the results, we perform simulations with “intention mismatch” by perturbing the oracle signal that drives the neural activity (i.e. by operating on <bold>o</bold><sub><italic>t</italic></sub> before applying the neural encoding matrix <italic>A</italic>).</p>
<p>For the simulations, <italic>A</italic> was selected to consist of independently drawn random values. For both tasks, we randomly sampled a new matrix <italic>A</italic> for each repeat of the simulated learning process. For the cursor simulations, we simply sampled entries of <italic>A</italic> independently from a normal distribution. For the higher dimensional arm simulations, we wanted to have neurons which did not encode all DOFs, so for the results presented here we similarly sampled <italic>A</italic> from a normal distribution, but then set any negative entries of <italic>A</italic> to zero (results were essentially the same if negative entries were included).</p>
<p>Assisted decoding (see Alg 1) was not heavily used. To provide stable initialization, <italic>β</italic><sub>0</sub> was set to 1 (and noise was injected into the oracle for numerical stability), and all subsequent <italic>β</italic><sub><italic>k</italic></sub> were set to 0. For the cursor simulations, we used 10 neurons and the maximum reach time <italic>T</italic> was set to 200 timesteps. For arm simulations, we used 75 neurons and the maximum reach time <italic>T</italic> was set to 150 timesteps. We consider simulated timesteps to correspond to real timesteps of order 10–50ms.</p>
<p>For both sets of simulated experiments the <italic>decoding algorithm</italic> was chosen to be the <italic>steady-state velocity Kalman Filter</italic> (SSVKF), which is a simple decoder and representative of decoders used in similar settings (i.e. it corresponds to a 2nd order physical system according to the interpretation in [<xref ref-type="bibr" rid="pcbi.1004948.ref012">12</xref>]). The SSVKF has a fixed parametrization as a decoder, but it also has a Bayesian interpretation. When the encoding model of the neural activity is linear-Gaussian with respect to intended velocity, the velocity Kalman filter is Bayes-optimal, and the steady state form is a close approximation for BCI applications.</p>
<p>The <italic>steady state Kalman Filter</italic> (SSKF) generally has the form:
<disp-formula id="pcbi.1004948.e033"><alternatives><graphic id="pcbi.1004948.e033g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e033" xlink:type="simple"/><mml:math display="block" id="M33"><mml:mrow><mml:msub><mml:mi mathvariant="bold">x</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:mi mathvariant="bold">F</mml:mi> <mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:mi mathvariant="bold">G</mml:mi> <mml:msub><mml:mi mathvariant="bold">x</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></alternatives> <label>(6)</label></disp-formula>
Here <bold>G</bold> can be interpreted as a prior dynamics model and <bold>F</bold> can be interpreted as the function mediating the update to the state from the current neural data. In practice, a bias term can be included in the neural activity to compensate for non-zero offset in the neural signals. The generic SSKF equation can be expanded into a specific SSVKF equation, where the state consists of both position and velocity. At the same time we will constrain the position to be physically governed by the velocity, and we will only permit neural activity to relate to velocity.
<disp-formula id="pcbi.1004948.e034"><alternatives><graphic id="pcbi.1004948.e034g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e034" xlink:type="simple"/><mml:math display="block" id="M34"><mml:mrow><mml:mfenced close="]" open=" ["><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="bold">p</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="bold">v</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mo>=</mml:mo> <mml:mfenced close="]" open=" ["><mml:mtable><mml:mtr><mml:mtd><mml:mn mathvariant="bold">0</mml:mn></mml:mtd> <mml:mtd><mml:mn mathvariant="bold">0</mml:mn></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="bold">F</mml:mi> <mml:mi>v</mml:mi></mml:msub></mml:mtd> <mml:mtd><mml:msub><mml:mi mathvariant="bold">b</mml:mi> <mml:mi>v</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mfenced close="]" open=" ["><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn mathvariant="bold">1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mo>+</mml:mo> <mml:mfenced close="]" open=" ["><mml:mtable><mml:mtr><mml:mtd><mml:mi mathvariant="bold">I</mml:mi></mml:mtd> <mml:mtd><mml:mrow><mml:mi>d</mml:mi> <mml:mi>t</mml:mi> <mml:mo>×</mml:mo> <mml:mi mathvariant="bold">I</mml:mi></mml:mrow></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:mn mathvariant="bold">0</mml:mn></mml:mtd> <mml:mtd><mml:msub><mml:mi mathvariant="bold">G</mml:mi> <mml:mi>v</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced> <mml:mfenced close="]" open=" ["><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="bold">p</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mtd></mml:mtr> <mml:mtr><mml:mtd><mml:msub><mml:mi mathvariant="bold">v</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mtd></mml:mtr></mml:mtable></mml:mfenced></mml:mrow></mml:math></alternatives> <label>(7)</label></disp-formula></p>
<p>It is straightforward to augment the decoder to include past lags of neural activity or state. A very straightforward training scheme that is apparent for this specific decoder is to simply perform regression to fit {<bold>F</bold><sub><italic>v</italic></sub>, <bold>b</bold><sub><italic>v</italic></sub>, <bold>G</bold><sub><italic>v</italic></sub>}, from the function:
<disp-formula id="pcbi.1004948.e035"><alternatives><graphic id="pcbi.1004948.e035g" mimetype="image" position="anchor" xlink:href="info:doi/10.1371/journal.pcbi.1004948.e035" xlink:type="simple"/><mml:math display="block" id="M35"><mml:mrow><mml:msub><mml:mi mathvariant="bold">v</mml:mi> <mml:mrow><mml:mi>t</mml:mi> <mml:mo>+</mml:mo> <mml:mn>1</mml:mn></mml:mrow></mml:msub> <mml:mo>=</mml:mo> <mml:msub><mml:mi mathvariant="bold">F</mml:mi> <mml:mi>v</mml:mi></mml:msub> <mml:msub><mml:mi mathvariant="bold">n</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi mathvariant="bold">b</mml:mi> <mml:mi>v</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi mathvariant="bold">G</mml:mi> <mml:mi>v</mml:mi></mml:msub> <mml:msub><mml:mi mathvariant="bold">v</mml:mi> <mml:mi>t</mml:mi></mml:msub> <mml:mo>+</mml:mo> <mml:msub><mml:mi mathvariant="bold">e</mml:mi> <mml:mi>t</mml:mi></mml:msub></mml:mrow></mml:math></alternatives> <label>(8)</label></disp-formula>
where <bold>e</bold><sub><italic>t</italic></sub> denotes an additive Gaussian noise term.</p>
</sec>
</sec>
<sec id="sec013">
<title>Supporting Information</title>
<supplementary-material id="pcbi.1004948.s001" mimetype="application/pdf" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.s001" xlink:type="simple">
<label>S1 Text</label>
<caption>
<title>Restatement of theoretical results for DA<sc>gger</sc> and presentation of regret bounds in linear-quadratic case.</title>
<p>We restate and interpret the theoretical results for DA<sc>gger</sc>. We also describe specific bounds on regret for selected BCI update rules under a quadratic loss and linear decoder.</p>
<p>(PDF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1004948.s002" mimetype="image/tiff" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.s002" xlink:type="simple">
<label>S1 Fig</label>
<caption>
<title>Comparison of MSE and acquisition time.</title>
<p>This figure compares MSE and time to acquisition for the cursor task, and motivates the use of SSE in the figures in the main text. Left panel depicts MSE for cursor task (for same trials as SSE curves in <xref ref-type="fig" rid="pcbi.1004948.g002">Fig 2</xref>). Right panel depicts time to acquisition for the same set of trials. While we might hope that MSE would give a complete indication of performance, this is not the case. This is because the quality of the different algorithms are differentially reflected when considering trial duration. Low MSE can be achieved multiple different ways—essentially mapping to the bias-variance tradeoff. In the trials considered here, the slow acquisition for the MA decoder arises from bias towards decoder outputs with smaller magnitude.</p>
<p>(TIFF)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1004948.s003" mimetype="video/quicktime" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.s003" xlink:type="simple">
<label>S1 Movie</label>
<caption>
<title>Example cursor trials.</title>
<p>Video of cursor task during learning via DA<sc>gger</sc>. Blue dot corresponds to controlled cursor. Green dot corresponds to target. Green line from blue cursor points towards the target. Red line from cursor corresponds to actual direction of motion.</p>
<p>(MOV)</p>
</caption>
</supplementary-material>
<supplementary-material id="pcbi.1004948.s004" mimetype="video/quicktime" position="float" xlink:href="info:doi/10.1371/journal.pcbi.1004948.s004" xlink:type="simple">
<label>S2 Movie</label>
<caption>
<title>Example full-arm trials.</title>
<p>Video of full arm task during learning via DA<sc>gger</sc>. Arm is controlled to reach towards the wand. Initial arm pose is reset between reaches.</p>
<p>(MOV)</p>
</caption>
</supplementary-material>
</sec>
</body>
<back>
<ack>
<p>We’d like to thank the Pesaran Lab, especially Adam Weiss and Yan Wong, who provided assistance related to using an arm model of one of their monkeys. Chris Cueva helped with MATLAB scripts to interact with MuJoCo. Grace Lindsay contributed the illustration in <xref ref-type="fig" rid="pcbi.1004948.g001">Fig 1</xref>.</p>
</ack>
<ref-list>
<title>References</title>
<ref id="pcbi.1004948.ref001">
<label>1</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Serruya</surname> <given-names>MD</given-names></name>, <name name-style="western"><surname>Hatsopoulos</surname> <given-names>NG</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Fellows</surname> <given-names>MR</given-names></name>, <name name-style="western"><surname>Donoghue</surname> <given-names>JP</given-names></name>. <article-title>Brain-machine interface: Instant neural control of a movement signal</article-title>. <source>Nature</source>. <year>2002</year>;<volume>416</volume>(<issue>6877</issue>):<fpage>141</fpage>–<lpage>142</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref002">
<label>2</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Taylor</surname> <given-names>DM</given-names></name>, <name name-style="western"><surname>Tillery</surname> <given-names>SIH</given-names></name>, <name name-style="western"><surname>Schwartz</surname> <given-names>AB</given-names></name>. <article-title>Direct cortical control of 3D neuroprosthetic devices</article-title>. <source>Science</source>. <year>2002</year>;<volume>296</volume>(<issue>5574</issue>):<fpage>1829</fpage>–<lpage>1832</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1126/science.1070291" xlink:type="simple">10.1126/science.1070291</ext-link></comment> <object-id pub-id-type="pmid">12052948</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref003">
<label>3</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Carmena</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Lebedev</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>Crist</surname> <given-names>RE</given-names></name>, <name name-style="western"><surname>O’doherty</surname> <given-names>JE</given-names></name>, <name name-style="western"><surname>Santucci</surname> <given-names>DM</given-names></name>, <name name-style="western"><surname>Dimitrov</surname> <given-names>DF</given-names></name>, <etal>et al</etal>. <article-title>Learning to control a brain-machine interface for reaching and grasping by primates</article-title>. <source>PLoS Biology</source>. <year>2003</year>;<volume>1</volume>(<issue>2</issue>):<fpage>E42</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pbio.0000042" xlink:type="simple">10.1371/journal.pbio.0000042</ext-link></comment> <object-id pub-id-type="pmid">14624244</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref004">
<label>4</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hochberg</surname> <given-names>LR</given-names></name>, <name name-style="western"><surname>Serruya</surname> <given-names>MD</given-names></name>, <name name-style="western"><surname>Friehs</surname> <given-names>GM</given-names></name>, <name name-style="western"><surname>Mukand</surname> <given-names>JA</given-names></name>, <name name-style="western"><surname>Saleh</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Caplan</surname> <given-names>AH</given-names></name>, <etal>et al</etal>. <article-title>Neuronal ensemble control of prosthetic devices by a human with tetraplegia</article-title>. <source>Nature</source>. <year>2006</year>;<volume>442</volume>(<issue>7099</issue>):<fpage>164</fpage>–<lpage>171</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature04970" xlink:type="simple">10.1038/nature04970</ext-link></comment> <object-id pub-id-type="pmid">16838014</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref005">
<label>5</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Georgopoulos</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Caminiti</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Kalaska</surname> <given-names>J</given-names></name>. <article-title>Static spatial effects in motor cortex and area 5: quantitative relations in a two-dimensional space</article-title>. <source>Experimental Brain Research</source>. <year>1984</year>;<volume>54</volume>(<issue>3</issue>):<fpage>446</fpage>–<lpage>454</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/BF00235470" xlink:type="simple">10.1007/BF00235470</ext-link></comment> <object-id pub-id-type="pmid">6723864</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref006">
<label>6</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Moran</surname> <given-names>DW</given-names></name>, <name name-style="western"><surname>Schwartz</surname> <given-names>AB</given-names></name>. <article-title>Motor cortical activity during drawing movements: population representation during spiral tracing</article-title>. <source>Journal of Neurophysiology</source>. <year>1999</year>;<volume>82</volume>(<issue>5</issue>):<fpage>2693</fpage>–<lpage>2704</lpage>. <object-id pub-id-type="pmid">10561438</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref007">
<label>7</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Todorov</surname> <given-names>E</given-names></name>. <article-title>Direct cortical control of muscle activation in voluntary arm movements: a model</article-title>. <source>Nature Neuroscience</source>. <year>2000</year>;<volume>3</volume>(<issue>4</issue>):<fpage>391</fpage>–<lpage>398</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/73964" xlink:type="simple">10.1038/73964</ext-link></comment> <object-id pub-id-type="pmid">10725930</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref008">
<label>8</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Moran</surname> <given-names>DW</given-names></name>, <name name-style="western"><surname>Schwartz</surname> <given-names>AB</given-names></name>, <name name-style="western"><surname>Georgopoulos</surname> <given-names>AP</given-names></name>, <name name-style="western"><surname>Ashe</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Todorov</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Scott</surname> <given-names>SH</given-names></name>. <article-title>One motor cortex, two different views</article-title>. <source>Nature Neuroscience (letters to the editor)</source>. <year>2000</year>;<volume>3</volume>(<issue>963</issue>):<fpage>963</fpage>–<lpage>5</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/79880" xlink:type="simple">10.1038/79880</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref009">
<label>9</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Churchland</surname> <given-names>MM</given-names></name>, <name name-style="western"><surname>Cunningham</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Kaufman</surname> <given-names>MT</given-names></name>, <name name-style="western"><surname>Foster</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Nuyujukian</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Ryu</surname> <given-names>SI</given-names></name>, <etal>et al</etal>. <article-title>Neural population dynamics during reaching</article-title>. <source>Nature</source>. <year>2012</year>;<volume>487</volume>(<issue>7405</issue>):<fpage>51</fpage>–<lpage>56</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature11129" xlink:type="simple">10.1038/nature11129</ext-link></comment> <object-id pub-id-type="pmid">22722855</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref010">
<label>10</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wu</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Gao</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Bienenstock</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Donoghue</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Black</surname> <given-names>MJ</given-names></name>. <article-title>Bayesian population decoding of motor cortical activity using a Kalman filter</article-title>. <source>Neural Computation</source>. <year>2006</year>;<volume>18</volume>(<issue>1</issue>):<fpage>80</fpage>–<lpage>118</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1162/089976606774841585" xlink:type="simple">10.1162/089976606774841585</ext-link></comment> <object-id pub-id-type="pmid">16354382</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref011">
<label>11</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Gilja</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Nuyujukian</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Chestek</surname> <given-names>CA</given-names></name>, <name name-style="western"><surname>Cunningham</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Byron</surname> <given-names>MY</given-names></name>, <name name-style="western"><surname>Fan</surname> <given-names>JM</given-names></name>, <etal>et al</etal>. <article-title>A high-performance neural prosthesis enabled by control algorithm design</article-title>. <source>Nature Neuroscience</source>. <year>2012</year>;<volume>15</volume>(<issue>12</issue>):<fpage>1752</fpage>–<lpage>1757</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nn.3265" xlink:type="simple">10.1038/nn.3265</ext-link></comment> <object-id pub-id-type="pmid">23160043</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref012">
<label>12</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Zhang</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Chase</surname> <given-names>SM</given-names></name>. <article-title>Recasting brain-machine interface design from a physical control system perspective</article-title>. <source>Journal of Computational Neuroscience</source>. <year>2015</year>;<volume>39</volume>(<issue>2</issue>):<fpage>107</fpage>–<lpage>118</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/s10827-015-0566-4" xlink:type="simple">10.1007/s10827-015-0566-4</ext-link></comment> <object-id pub-id-type="pmid">26142906</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref013">
<label>13</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Dangi</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Orsborn</surname> <given-names>AL</given-names></name>, <name name-style="western"><surname>Moorman</surname> <given-names>HG</given-names></name>, <name name-style="western"><surname>Carmena</surname> <given-names>JM</given-names></name>. <article-title>Design and analysis of closed-loop decoder adaptation algorithms for brain-machine interfaces</article-title>. <source>Neural Computation</source>. <year>2013</year>;<volume>25</volume>(<issue>7</issue>):<fpage>1693</fpage>–<lpage>1731</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1162/NECO_a_00460" xlink:type="simple">10.1162/NECO_a_00460</ext-link></comment> <object-id pub-id-type="pmid">23607558</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref014">
<label>14</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Dangi</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Gowda</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Moorman</surname> <given-names>HG</given-names></name>, <name name-style="western"><surname>Orsborn</surname> <given-names>AL</given-names></name>, <name name-style="western"><surname>So</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Shanechi</surname> <given-names>M</given-names></name>, <etal>et al</etal>. <article-title>Continuous closed-loop decoder adaptation with a recursive maximum likelihood algorithm allows for rapid performance acquisition in brain-machine interfaces</article-title>. <source>Neural Computation</source>. <year>2014</year>;<volume>26</volume>(<issue>9</issue>):<fpage>1811</fpage>–<lpage>1839</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1162/NECO_a_00632" xlink:type="simple">10.1162/NECO_a_00632</ext-link></comment> <object-id pub-id-type="pmid">24922501</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref015">
<label>15</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hochberg</surname> <given-names>LR</given-names></name>, <name name-style="western"><surname>Bacher</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Jarosiewicz</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Masse</surname> <given-names>NY</given-names></name>, <name name-style="western"><surname>Simeral</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Vogel</surname> <given-names>J</given-names></name>, <etal>et al</etal>. <article-title>Reach and grasp by people with tetraplegia using a neurally controlled robotic arm</article-title>. <source>Nature</source>. <year>2012</year>;<volume>485</volume>(<issue>7398</issue>):<fpage>372</fpage>–<lpage>375</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature11076" xlink:type="simple">10.1038/nature11076</ext-link></comment> <object-id pub-id-type="pmid">22596161</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref016">
<label>16</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Gilja</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Pandarinath</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Blabe</surname> <given-names>CH</given-names></name>, <name name-style="western"><surname>Nuyujukian</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Simeral</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Sarma</surname> <given-names>AA</given-names></name>, <etal>et al</etal>. <article-title>Clinical translation of a high-performance neural prosthesis</article-title>. <source>Nature Medicine</source>. <year>2015</year>;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref017">
<label>17</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Ross</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Gordon</surname> <given-names>GJ</given-names></name>, <name name-style="western"><surname>Bagnell</surname> <given-names>JA</given-names></name>. <article-title>A Reduction of Imitation Learning and Structured Prediction to No-Regret Online Learning</article-title>. <source>Artificial Intelligence and Statistics (AISTATS)</source>. <year>2011</year>;<volume>15</volume>.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref018">
<label>18</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wodlinger</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Downey</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Tyler-Kabara</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Schwartz</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Boninger</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Collinger</surname> <given-names>J</given-names></name>. <article-title>Ten-dimensional anthropomorphic arm control in a human brain- machine interface: difficulties, solutions, and limitations</article-title>. <source>Journal of Neural Engineering</source>. <year>2014</year>;<volume>12</volume>(<issue>1</issue>):<fpage>016011</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1088/1741-2560/12/1/016011" xlink:type="simple">10.1088/1741-2560/12/1/016011</ext-link></comment> <object-id pub-id-type="pmid">25514320</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref019">
<label>19</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Putrino</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Wong</surname> <given-names>YT</given-names></name>, <name name-style="western"><surname>Weiss</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Pesaran</surname> <given-names>B</given-names></name>. <article-title>A training platform for many-dimensional prosthetic devices using a virtual reality environment</article-title>. <source>Journal of Neuroscience Methods</source>. <year>2015</year>;<volume>244</volume>:<fpage>68</fpage>–<lpage>77</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.jneumeth.2014.03.010" xlink:type="simple">10.1016/j.jneumeth.2014.03.010</ext-link></comment> <object-id pub-id-type="pmid">24726625</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref020">
<label>20</label>
<mixed-citation publication-type="other" xlink:type="simple">Golub MD, Chase SM, Byron MY. Learning an internal dynamics model from control demonstration. International Conference on Machine Learning (ICML). 2013;p. 606.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref021">
<label>21</label>
<mixed-citation publication-type="other" xlink:type="simple">Ross S, Bagnell JA. Agnostic system identification for model-based reinforcement learning. International Conference on Machine Learning (ICML). 2012;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref022">
<label>22</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Bellman</surname> <given-names>R</given-names></name>. <article-title>A Markovian Decision Process</article-title>. <source>Indiana University Mathematics Journal</source>. <year>1957</year>;<volume>6</volume>:<fpage>679</fpage>–<lpage>684</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1512/iumj.1957.6.56038" xlink:type="simple">10.1512/iumj.1957.6.56038</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref023">
<label>23</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>LaValle</surname> <given-names>SM</given-names></name>. <source>Planning algorithms</source>. <publisher-name>Cambridge university press</publisher-name>; <year>2006</year>.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref024">
<label>24</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>DiGiovanna</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Mahmoudi</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Fortes</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Principe</surname> <given-names>JC</given-names></name>, <name name-style="western"><surname>Sanchez</surname> <given-names>JC</given-names></name>. <article-title>Coadaptive brain–machine interface via reinforcement learning</article-title>. <source>IEEE Transactions on Biomedical Engineering</source>. <year>2009</year>;<volume>56</volume>(<issue>1</issue>):<fpage>54</fpage>–<lpage>64</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TBME.2008.926699" xlink:type="simple">10.1109/TBME.2008.926699</ext-link></comment> <object-id pub-id-type="pmid">19224719</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref025">
<label>25</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Mahmoudi</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Pohlmeyer</surname> <given-names>EA</given-names></name>, <name name-style="western"><surname>Prins</surname> <given-names>NW</given-names></name>, <name name-style="western"><surname>Geng</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Sanchez</surname> <given-names>JC</given-names></name>. <article-title>Towards autonomous neuroprosthetic control using Hebbian reinforcement learning</article-title>. <source>Journal of Neural Engineering</source>. <year>2013</year>;<volume>10</volume>(<issue>6</issue>):<fpage>066005</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1088/1741-2560/10/6/066005" xlink:type="simple">10.1088/1741-2560/10/6/066005</ext-link></comment> <object-id pub-id-type="pmid">24100047</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref026">
<label>26</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Bryan</surname> <given-names>MJ</given-names></name>, <name name-style="western"><surname>Martin</surname> <given-names>SA</given-names></name>, <name name-style="western"><surname>Cheung</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Rao</surname> <given-names>RP</given-names></name>. <article-title>Probabilistic co-adaptive brain-computer interfacing</article-title>. <source>Journal of Neural Engineering</source>. <year>2013</year>;<volume>10</volume>(<issue>6</issue>):<fpage>066008</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1088/1741-2560/10/6/066008" xlink:type="simple">10.1088/1741-2560/10/6/066008</ext-link></comment> <object-id pub-id-type="pmid">24140680</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref027">
<label>27</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Pohlmeyer</surname> <given-names>EA</given-names></name>, <name name-style="western"><surname>Mahmoudi</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Geng</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Prins</surname> <given-names>NW</given-names></name>, <name name-style="western"><surname>Sanchez</surname> <given-names>JC</given-names></name>. <article-title>Using reinforcement learning to provide stable brain-machine interface control despite neural input reorganization</article-title>. <source>PloS One</source>. <year>2014</year>;<volume>9</volume>(<issue>1</issue>). <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0087253" xlink:type="simple">10.1371/journal.pone.0087253</ext-link></comment> <object-id pub-id-type="pmid">24498055</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref028">
<label>28</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Iturrate</surname> <given-names>I</given-names></name>, <name name-style="western"><surname>Chavarriaga</surname> <given-names>R</given-names></name>, <name name-style="western"><surname>Montesano</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Minguez</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Millán</surname> <given-names>JdR</given-names></name>. <article-title>Teaching brain-machine interfaces as an alternative paradigm to neuroprosthetics control</article-title>. <source>Scientific Reports</source>. <year>2015</year>;<volume>5</volume>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/srep13893" xlink:type="simple">10.1038/srep13893</ext-link></comment> <object-id pub-id-type="pmid">26354145</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref029">
<label>29</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Sutton</surname> <given-names>RS</given-names></name>, <name name-style="western"><surname>Barto</surname> <given-names>AG</given-names></name>. <source>Reinforcement learning: An introduction</source>. <publisher-name>MIT press</publisher-name>; <year>1998</year>.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref030">
<label>30</label>
<mixed-citation publication-type="other" xlink:type="simple">Abbeel P, Ng AY. Apprenticeship learning via inverse reinforcement learning. International Conference on Machine Learning (ICML). 2004;p. 1.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref031">
<label>31</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Velliste</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Perel</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Spalding</surname> <given-names>MC</given-names></name>, <name name-style="western"><surname>Whitford</surname> <given-names>AS</given-names></name>, <name name-style="western"><surname>Schwartz</surname> <given-names>AB</given-names></name>. <article-title>Cortical control of a prosthetic arm for self-feeding</article-title>. <source>Nature</source>. <year>2008</year>;<volume>453</volume>(<issue>7198</issue>):<fpage>1098</fpage>–<lpage>1101</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/nature06996" xlink:type="simple">10.1038/nature06996</ext-link></comment> <object-id pub-id-type="pmid">18509337</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref032">
<label>32</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>So</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Dangi</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Orsborn</surname> <given-names>AL</given-names></name>, <name name-style="western"><surname>Gastpar</surname> <given-names>MC</given-names></name>, <name name-style="western"><surname>Carmena</surname> <given-names>JM</given-names></name>. <article-title>Subject-specific modulation of local field potential spectral power during brain–machine interface control in primates</article-title>. <source>Journal of Neural Engineering</source>. <year>2014</year>;<volume>11</volume>(<issue>2</issue>):<fpage>026002</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1088/1741-2560/11/2/026002" xlink:type="simple">10.1088/1741-2560/11/2/026002</ext-link></comment> <object-id pub-id-type="pmid">24503623</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref033">
<label>33</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Shalev-Shwartz</surname> <given-names>S</given-names></name>. <article-title>Online Learning and Online Convex Optimization</article-title>. <source>Foundations and Trends in Machine Learning</source>. <year>2011</year>;<volume>4</volume>(<issue>2</issue>):<fpage>107</fpage>–<lpage>194</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1561/2200000018" xlink:type="simple">10.1561/2200000018</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref034">
<label>34</label>
<mixed-citation publication-type="other" xlink:type="simple">Widrow B, Stearns SD. Adaptive signal processing. Englewood Cliffs. 1985;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref035">
<label>35</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Plackett</surname> <given-names>RL</given-names></name>. <article-title>Some theorems in least squares</article-title>. <source>Biometrika</source>. <year>1950</year>;<volume>37</volume>(<issue>1–2</issue>):<fpage>149</fpage>–<lpage>157</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.2307/2332158" xlink:type="simple">10.2307/2332158</ext-link></comment> <object-id pub-id-type="pmid">15420260</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref036">
<label>36</label>
<mixed-citation publication-type="book" xlink:type="simple">
<name name-style="western"><surname>Sayed</surname> <given-names>AH</given-names></name>. <source>Fundamentals of adaptive filtering</source>. <publisher-name>John Wiley &amp; Sons</publisher-name>; <year>2003</year>.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref037">
<label>37</label>
<mixed-citation publication-type="other" xlink:type="simple">Kivinen J, Warmuth MK. Additive Versus Exponentiated Gradient Updates for Linear Prediction. In: Proceedings of the Twenty-seventh Annual ACM Symposium on Theory of Computing. STOC’95. New York, NY, USA: ACM; 1995. p. 209–218.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref038">
<label>38</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Hazan</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Agarwal</surname> <given-names>A</given-names></name>, <name name-style="western"><surname>Kale</surname> <given-names>S</given-names></name>. <article-title>Logarithmic regret algorithms for online convex optimization</article-title>. <source>Machine Learning</source>. <year>2007</year>;<volume>69</volume>(<issue>2–3</issue>):<fpage>169</fpage>–<lpage>192</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/s10994-007-5016-8" xlink:type="simple">10.1007/s10994-007-5016-8</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref039">
<label>39</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Duchi</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Hazan</surname> <given-names>E</given-names></name>, <name name-style="western"><surname>Singer</surname> <given-names>Y</given-names></name>. <article-title>Adaptive subgradient methods for online learning and stochastic optimization</article-title>. <source>The Journal of Machine Learning Research</source>. <year>2011</year>;<volume>12</volume>:<fpage>2121</fpage>–<lpage>2159</lpage>.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref040">
<label>40</label>
<mixed-citation publication-type="other" xlink:type="simple">Hall EC, Willett RM. Online Convex Optimization in Dynamic Environments. 2015;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref041">
<label>41</label>
<mixed-citation publication-type="other" xlink:type="simple">Todorov E, Erez T, Tassa Y. MuJoCo: A physics engine for model-based control. Intelligent Robots and Systems (IROS). 2012;p. 5026–5033.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref042">
<label>42</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Golub</surname> <given-names>MD</given-names></name>, <name name-style="western"><surname>Byron</surname> <given-names>MY</given-names></name>, <name name-style="western"><surname>Chase</surname> <given-names>SM</given-names></name>. <article-title>Internal models for interpreting neural population activity during sensorimotor control</article-title>. <source>eLife</source>. <year>2015</year>;p. <fpage>e10015</fpage>. <object-id pub-id-type="pmid">26646183</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref043">
<label>43</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Jarosiewicz</surname> <given-names>B</given-names></name>, <name name-style="western"><surname>Sarma</surname> <given-names>AA</given-names></name>, <name name-style="western"><surname>Bacher</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Masse</surname> <given-names>NY</given-names></name>, <name name-style="western"><surname>Simeral</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Sorice</surname> <given-names>B</given-names></name>, <etal>et al</etal>. <article-title>Virtual typing by people with tetraplegia using a self-calibrating intracortical brain-computer interface</article-title>. <source>Science Translational Medicine</source>. <year>2015</year>;<volume>7</volume>(<issue>313</issue>):<fpage>313ra179</fpage>–<lpage>313ra179</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1126/scitranslmed.aac7328" xlink:type="simple">10.1126/scitranslmed.aac7328</ext-link></comment> <object-id pub-id-type="pmid">26560357</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref044">
<label>44</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Shoham</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>LM</given-names></name>, <name name-style="western"><surname>Fellows</surname> <given-names>MR</given-names></name>, <name name-style="western"><surname>Hatsopoulos</surname> <given-names>NG</given-names></name>, <name name-style="western"><surname>Donoghue</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Normann</surname> <given-names>R</given-names></name>, <etal>et al</etal>. <article-title>Statistical encoding model for a primary motor cortical brain-machine interface</article-title>. <source>IEEE Transactions on Biomedical Engineering</source>. <year>2005</year>;<volume>52</volume>(<issue>7</issue>):<fpage>1312</fpage>–<lpage>1322</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TBME.2005.847542" xlink:type="simple">10.1109/TBME.2005.847542</ext-link></comment> <object-id pub-id-type="pmid">16041995</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref045">
<label>45</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wang</surname> <given-names>Y</given-names></name>, <name name-style="western"><surname>Paiva</surname> <given-names>AR</given-names></name>, <name name-style="western"><surname>Príncipe</surname> <given-names>JC</given-names></name>, <name name-style="western"><surname>Sanchez</surname> <given-names>JC</given-names></name>. <article-title>Sequential Monte Carlo point-process estimation of kinematics from neural spiking activity for brain-machine interfaces</article-title>. <source>Neural Computation</source>. <year>2009</year>;<volume>21</volume>(<issue>10</issue>):<fpage>2894</fpage>–<lpage>2930</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1162/neco.2009.01-08-699" xlink:type="simple">10.1162/neco.2009.01-08-699</ext-link></comment> <object-id pub-id-type="pmid">19548797</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref046">
<label>46</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Nazarpour</surname> <given-names>K</given-names></name>, <name name-style="western"><surname>Ethier</surname> <given-names>C</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>, <name name-style="western"><surname>Rebesco</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Miall</surname> <given-names>RC</given-names></name>, <name name-style="western"><surname>Miller</surname> <given-names>LE</given-names></name>. <article-title>EMG prediction from motor cortical recordings via a nonnegative point-process filter</article-title>. <source>IEEE Transactions on Biomedical Engineering</source>. <year>2012</year>;<volume>59</volume>(<issue>7</issue>):<fpage>1829</fpage>–<lpage>1838</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TBME.2011.2159115" xlink:type="simple">10.1109/TBME.2011.2159115</ext-link></comment> <object-id pub-id-type="pmid">21659018</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref047">
<label>47</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Koyama</surname> <given-names>S</given-names></name>, <name name-style="western"><surname>Chase</surname> <given-names>SM</given-names></name>, <name name-style="western"><surname>Whitford</surname> <given-names>AS</given-names></name>, <name name-style="western"><surname>Velliste</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Schwartz</surname> <given-names>AB</given-names></name>, <name name-style="western"><surname>Kass</surname> <given-names>RE</given-names></name>. <article-title>Comparison of brain–computer interface decoding algorithms in open-loop and closed-loop control</article-title>. <source>Journal of Computational Neuroscience</source>. <year>2010</year>;<volume>29</volume>(<issue>1–2</issue>):<fpage>73</fpage>–<lpage>87</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1007/s10827-009-0196-9" xlink:type="simple">10.1007/s10827-009-0196-9</ext-link></comment> <object-id pub-id-type="pmid">19904595</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref048">
<label>48</label>
<mixed-citation publication-type="other" xlink:type="simple">Shpigelman L, Lalazar H, Vaadia E. Kernel-ARMA for Hand Tracking and Brain-Machine interfacing During 3D Motor Control. Advances in Neural Information Processing Systems (NIPS). 2009;p. 1489–1496.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref049">
<label>49</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Li</surname> <given-names>Z</given-names></name>, <name name-style="western"><surname>O’doherty</surname> <given-names>JE</given-names></name>, <name name-style="western"><surname>Hanson</surname> <given-names>TL</given-names></name>, <name name-style="western"><surname>Lebedev</surname> <given-names>MA</given-names></name>, <name name-style="western"><surname>Henriquez</surname> <given-names>CS</given-names></name>, <name name-style="western"><surname>Nicolelis</surname> <given-names>MA</given-names></name>. <article-title>Unscented Kalman filter for brain-machine interfaces</article-title>. <source>PloS One</source>. <year>2009</year>;<volume>4</volume>(<issue>7</issue>):<fpage>e6243</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pone.0006243" xlink:type="simple">10.1371/journal.pone.0006243</ext-link></comment> <object-id pub-id-type="pmid">19603074</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref050">
<label>50</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Sussillo</surname> <given-names>D</given-names></name>, <name name-style="western"><surname>Nuyujukian</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Fan</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Kao</surname> <given-names>JC</given-names></name>, <name name-style="western"><surname>Stavisky</surname> <given-names>SD</given-names></name>, <name name-style="western"><surname>Ryu</surname> <given-names>S</given-names></name>, <etal>et al</etal>. <article-title>A recurrent neural network for closed-loop intracortical brain–machine interface decoders</article-title>. <source>Journal of Neural Engineering</source>. <year>2012</year>;<volume>9</volume>(<issue>2</issue>):<fpage>026027</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1088/1741-2560/9/2/026027" xlink:type="simple">10.1088/1741-2560/9/2/026027</ext-link></comment> <object-id pub-id-type="pmid">22427488</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref051">
<label>51</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Wu</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Kulkarni</surname> <given-names>JE</given-names></name>, <name name-style="western"><surname>Hatsopoulos</surname> <given-names>NG</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Neural decoding of hand motion using a linear state-space model with hidden states</article-title>. <source>IEEE transactions on Neural Systems and Rehabilitation Engineering</source>. <year>2009</year>;<volume>17</volume>(<issue>4</issue>):<fpage>370</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1109/TNSRE.2009.2023307" xlink:type="simple">10.1109/TNSRE.2009.2023307</ext-link></comment> <object-id pub-id-type="pmid">19497822</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref052">
<label>52</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Lawhern</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Wu</surname> <given-names>W</given-names></name>, <name name-style="western"><surname>Hatsopoulos</surname> <given-names>N</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Population decoding of motor cortical activity using a generalized linear model with hidden states</article-title>. <source>Journal of Neuroscience Methods</source>. <year>2010</year>;<volume>189</volume>(<issue>2</issue>):<fpage>267</fpage>–<lpage>280</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.jneumeth.2010.03.024" xlink:type="simple">10.1016/j.jneumeth.2010.03.024</ext-link></comment> <object-id pub-id-type="pmid">20359500</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref053">
<label>53</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kao</surname> <given-names>JC</given-names></name>, <name name-style="western"><surname>Nuyujukian</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Ryu</surname> <given-names>SI</given-names></name>, <name name-style="western"><surname>Churchland</surname> <given-names>MM</given-names></name>, <name name-style="western"><surname>Cunningham</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Shenoy</surname> <given-names>KV</given-names></name>. <article-title>Single-trial dynamics of motor cortex and their applications to brain-machine interfaces</article-title>. <source>Nature Communications</source>. <year>2015</year>;<volume>6</volume>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1038/ncomms8759" xlink:type="simple">10.1038/ncomms8759</ext-link></comment></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref054">
<label>54</label>
<mixed-citation publication-type="other" xlink:type="simple">Muelling K, Venkatraman A, Valois JS, Downey J, Weiss J, Javdani S, et al. Autonomy infused teleoperation with application to BCI manipulation. arXiv preprint arXiv:150305451. 2015;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref055">
<label>55</label>
<mixed-citation publication-type="other" xlink:type="simple">He H, Eisner J, Daume H. Imitation learning by coaching. Advances in Neural Information Processing Systems (NIPS). 2012;p. 3149–3157.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref056">
<label>56</label>
<mixed-citation publication-type="other" xlink:type="simple">Kim B, Pineau J. Maximum Mean Discrepancy Imitation Learning. Robotics: Science and Systems. 2013;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref057">
<label>57</label>
<mixed-citation publication-type="other" xlink:type="simple">Kim B, Massoud Farahmand A, Pineau J, Precup D. Learning from limited demonstrations. Advances in Neural Information Processing Systems (NIPS). 2013;p. 2859–2867.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref058">
<label>58</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Chestek</surname> <given-names>CA</given-names></name>, <name name-style="western"><surname>Gilja</surname> <given-names>V</given-names></name>, <name name-style="western"><surname>Nuyujukian</surname> <given-names>P</given-names></name>, <name name-style="western"><surname>Foster</surname> <given-names>JD</given-names></name>, <name name-style="western"><surname>Fan</surname> <given-names>JM</given-names></name>, <name name-style="western"><surname>Kaufman</surname> <given-names>MT</given-names></name>, <etal>et al</etal>. <article-title>Long-term stability of neural prosthetic control signals from silicon cortical arrays in rhesus macaque motor cortex</article-title>. <source>Journal of Neural Engineering</source>. <year>2011</year>;<volume>8</volume>(<issue>4</issue>):<fpage>045005</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1088/1741-2560/8/4/045005" xlink:type="simple">10.1088/1741-2560/8/4/045005</ext-link></comment> <object-id pub-id-type="pmid">21775782</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref059">
<label>59</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Kowalski</surname> <given-names>KC</given-names></name>, <name name-style="western"><surname>He</surname> <given-names>BD</given-names></name>, <name name-style="western"><surname>Srinivasan</surname> <given-names>L</given-names></name>. <article-title>Dynamic analysis of naive adaptive brain-machine interfaces</article-title>. <source>Neural Computation</source>. <year>2013</year>;<volume>25</volume>(<issue>9</issue>):<fpage>2373</fpage>–<lpage>2420</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1162/NECO_a_00484" xlink:type="simple">10.1162/NECO_a_00484</ext-link></comment> <object-id pub-id-type="pmid">23777523</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref060">
<label>60</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Shenoy</surname> <given-names>KV</given-names></name>, <name name-style="western"><surname>Carmena</surname> <given-names>JM</given-names></name>. <article-title>Combining Decoder Design and Neural Adaptation in Brain-Machine Interfaces</article-title>. <source>Neuron</source>. <year>2014</year>;<volume>84</volume>(<issue>4</issue>):<fpage>665</fpage>–<lpage>680</lpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.neuron.2014.08.038" xlink:type="simple">10.1016/j.neuron.2014.08.038</ext-link></comment> <object-id pub-id-type="pmid">25459407</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref061">
<label>61</label>
<mixed-citation publication-type="other" xlink:type="simple">Merel, J, Fox, R, Jebara, T, Paninski, L. A multi-agent control framework for co-adaptation in brain-computer interfaces. Advances in Neural Information Processing Systems (NIPS). 2013;.</mixed-citation>
</ref>
<ref id="pcbi.1004948.ref062">
<label>62</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Merel</surname> <given-names>J</given-names></name>, <name name-style="western"><surname>Pianto</surname> <given-names>DM</given-names></name>, <name name-style="western"><surname>Cunningham</surname> <given-names>JP</given-names></name>, <name name-style="western"><surname>Paninski</surname> <given-names>L</given-names></name>. <article-title>Encoder-Decoder Optimization for Brain-Computer Interfaces</article-title>. <source>PLoS Computational Biology</source>. <year>2015</year>;<volume>11</volume>(<issue>6</issue>):<fpage>e1004288</fpage>. <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1371/journal.pcbi.1004288" xlink:type="simple">10.1371/journal.pcbi.1004288</ext-link></comment> <object-id pub-id-type="pmid">26029919</object-id></mixed-citation>
</ref>
<ref id="pcbi.1004948.ref063">
<label>63</label>
<mixed-citation publication-type="journal" xlink:type="simple">
<name name-style="western"><surname>Berniker</surname> <given-names>M</given-names></name>, <name name-style="western"><surname>Koerding</surname> <given-names>KP</given-names></name>. <article-title>Deep networks for motor control functions</article-title>. <source>Frontiers in Computational Neuroscience</source>. <year>2015</year>;<volume>9</volume>(<issue>32</issue>). <comment>doi: <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.3389/fncom.2015.00032" xlink:type="simple">10.3389/fncom.2015.00032</ext-link></comment> <object-id pub-id-type="pmid">25852530</object-id></mixed-citation>
</ref>
</ref-list>
</back>
</article>